{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 4,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "f1b018037f5a44df2b2cee78bafc19e6eedd4cf9"
    },

    "projects": {
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (R x); auto with algebra.\napply Trans with (R y); auto with algebra.\napply Trans with (R y); auto with algebra.\napply Trans with (R y); auto with algebra.\napply Trans with (R y); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros H' H'0; try assumption.\napply Trans with (R x); auto with algebra.\napply Trans with (R y); auto with algebra.\napply Trans with (G x); auto with algebra.\napply Trans with (G x); auto with algebra.\napply Trans with (G x); auto with algebra.\napply Trans with (G x); auto with algebra.\napply Trans with (G x); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H with (x := S x) (y := S x) (y := S x) (y := S y).\napply Trans with (Ap (sgroup_law R (sgroup_law R (ring_mult x y)) (ring_mult y x)).\napply Trans with (Ap (sgroup_law R (ring_mult x y)) (ring_mult y (group_inverse R x))).\napply Trans with (Ap (sgroup_law R (ring_mult y x)) (ring_mult y (group_inverse R x))).\napply Trans with (Ap (sgroup_law R (ring_mult y x)) (ring_mult y x)).\napply Trans with (Ap (sgroup_law R (ring_mult y x)) (ring_mult y (group_inverse R x))).\napply Trans with (Ap (sgroup_law R (ring_mult y x)) (ring_mult y (group_inverse R x))).\napply Trans with (Ap (sgroup_law R (ring_mult y x)) (ring_mult y (group_inverse R x))).\napply Trans with (Ap (sgroup_law R (ring_mult y x)) (ringQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (G (G x) (G y)); auto with algebra.\napply Trans with (G (G x) (G y)); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (G x) (G y)); auto with algebra.\napply Trans with (G x) (G y); auto with algebra.\napply Trans with (G y) (G y); auto with algebra.\napply Trans with (G x) (G y); auto with algebra.\napply Trans with (G y); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply (BUILD_HOM_GROUP (G:=G) (G:=G) (G:=G) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g) (ff:=g)Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (monoid_unit G); auto with algebra.\napply Trans with (monoid_unit G); auto with algebra.\napply Trans with (monoid_unit G); auto with algebra.\napply Trans with (monoid_unit G); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (R (R (R x))); auto with sets.\napply Trans with (R (R x)); auto with sets.\napply Trans with (R (R x)); auto with sets.\napply Trans with (R (R x)); auto with sets.\napply Trans with (R (R x)); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (R:=R)); auto with algebra.\napply Trans with (ring_mult (R:=Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (G (S y)); auto with algebra.\napply Trans with (G (S y)); auto with algebra.\napply Trans with (G (S y)); auto with algebra.\napply Trans with (G (S y)); auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H4; intros; elim H5; intros; elim H6;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* use of neutral *)\nelim (H0 y H0); intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7;\n clear H7 H8 H9 H10 H11.\n(* on neutral *)\nelim (H1 y0 H1); intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on one *)\nelim (H0 y H1); intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on the left *)\nelim (H0 y0 H1); intros; elim H6; intros; elim H7; intros; elim H7; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H;\n clear H H0 H1; rewrite H1; rewrite H2; rewrite H1;\n rewrite H1; rewrite H2; rewrite H2; rewrite H2;\n assumption.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H x y H); intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9.\n(* use of neutral *)\nelim (H0 y0 H1); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H14.\n(* use of neutral *)\nelim (H0 y0 H1); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H14Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9.\n(* use of neutral *)\nelim (H8 x0 y0); intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8;\n clear H8 H9 H10 H11.\n(* use of neutral *)\nelim (H9 x0 y0); intros; elim H5; intros; elim H6; intros; elim H8; intros; elim H8;\n clear H9 H10 H11.\n(* on the left *)\nelim (H9 x0 y0); intros; elim H5; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10;\n clear H9 H10 H11.\n(* on the right *)\nelim (H10 x0 y1); intros; elim H10; intros; elim H10; intros; elim H10; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H8; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H5;\n clear H4 H5 H6 H7 H8.\n(* use of zero *)\nelim (H0 (IN (IN (Add x1 y2) x0)); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on zero *)\nelim (H0 (IN (Add x1 y2) x0)); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on zero *)\nelim (H0 (IN (Add x1 y2) x1)); intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on zero *)\nelim (H0 (Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H2 H3 H4 H5 H6.\n(* use of neutral *)\nelim (H6 (add x1) (add x2) (add x2) (add x1 x2)).\nelim H3; reflexivity.\n\n(* of elements of a sequence *)\nelim (H1 x0); intros; elim H1; intros; elim H1; intros; elim H2;\n clear H2 H3 H4 H5 H6 H7 H8.\n(* use of neutral *)\nelim (H7 x0); intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n clear H2 H3 H4 H5 H6 H7 H8 H9 H10 H11.\n(* on the inverse *)\nelim (H8 x0); intros; elim H1; intros; elim H2; intros; elim H2;\n clear H2 H3 HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x1); intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 x1); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H2 H3 H4.\nelim (H2 y1); intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* use of single one *)\nelim (H0 x1); intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5;\n clear H2 H6 H7 H8 H9 H10 H11.\n(* use of zero *)\nelim (lin_right x1); intros; elim H1; intros; elim H1; intros; elim H1; intros; elim H3;\n clear H1 H3 H4 H5 H6 H7 H8 H9 H10 H11.\n(* a = 0 *)\nelim (lin_right x1); intros; elim H1; intros; elim H1; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n [ clear H4 H5 | clear H5 ]\n | clear H3 ]; auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    clear H5 H6 H7 H8 H9 H10 H11.\n(* use of neutral *)\nelim (H1 x1); intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n    clear H5 H6 H7 H8 H9 H10 H11.\n(* on neutral *)\nelim (H1 x2); intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n    clear H5 H6 H7 H8 H9 H10 H11.\n(* on zero *)\nelim (H1 x2); intros; elim H2; intros; elim H2; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    clear H5 H6 H7 HQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x y); intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n auto with sets.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (star x y) (op y)).\nelim H; reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (Add x y) (Add y x)); intros; elim H0; intros; elim H1; intros; elim H2;\n clear H2 H3 H4 H5.\nrewrite <- H1; rewrite <- H2; rewrite <- H4; rewrite <- H5;\n assumption.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (inv_op (inv_op E x) (inv_op x y)) (inv_op x y)); trivial.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x y); intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* of zero *)\nelim (lem_opp_propertie x x0); intros; rewrite <- H0; auto with zfc.\n\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (mult_comm x y); intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n clear H1 H2 H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10; intros; elim H5; intros; elim H6; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* use of neutral *)\nelim\n  (axs_comprehension\n    (fun c : E =>\n     exists x : E, c = couple x y /\\ c = couple x y))\n    (cartesien a a) v2); intros; generalize (H0 H); \n clear H H0 H1 H2 H3 H4; intros; elim H; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* of proof of lem_rel_and_sym                                      *)\nelim\n (axs_comprehension\n    (funQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite <- (opp_involutive x); reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x); reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold alt, opp in |- *; simpl in |- *.\nintuition.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite <-opp_involutive; trivial.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_opp x); trivial.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros; unfold Opp, opp in |- *.\nelim (H x); intros; elim H0; intros; elim H0; intros; clear H0 H1 H2;\n elim H2; intros; clear H2 H3 H4; rewrite <- H; rewrite <- H0; rewrite <- H1;\n rewrite <- H1; rewrite <- H2; rewrite <- H2; rewrite <- H3;\n rewrite <- H1; rewrite <- H1; rewrite <- H2; rewrite <- H2;\n rewrite <- H1; rewrite <- H1; rewrite <- H2; rewrite <- H2;\n rewrite <- H1; rewrite <- H2; rewrite <- H2; rewrite <- H3;\n rewrite <- H1; rewrite <- H3; rewrite <- H2; rewrite <- H3;\n rewrite <- H1; rewrite <- H0; rewrite <- H1; rewrite <- H1;\n rewrite <- H1; rewrite <- H2; rewrite <- H3; rewrite <- H4;\n rewrite <- H1; rewrite <- H1; rewrite <- H2; rewrite <- H2;\n rewrite <- H1; rewrite <- H2; rewrite <- H2; rewrite HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold not in |- *; intro; rewrite H; rewrite H; clear H H0 H1.\n(* [x+y] *)\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H5; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite opp_involutive; trivial.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold alt, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp;\n rewrite <- opp_opp; rewrite opp_opp; rewrite opp_opp;\n rewrite opp_opp; rewrite opp_opp; rewrite opp_involutive;\n rewrite opp_opp; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x).\nrewrite (opp_involutive x); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": ". \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite <- (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive y).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive y).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive xQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (Opp x)) (opp_inj (Opp x)) (opp_inj (opp_inj (opp_inj (opp_inj x))) (opp_inj (opp_inj (opp_inj (opp_inj x)))) (opp_inj (opp_inj (opp_inj x))) (opp_inj (opp_inj (opp_inj (opp_inj x))) (opp_inj (opp_inj (opp_inj x))) (opp_inj (opp_inj x)))).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive x); trivial.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold Rdiv in |- *.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x); trivial.\napply opp_opp.\napply opp_opp.\napply opp_add.\napply opp_opp.\napply opp_opp.\napply opp_opp.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y); rewrite (opp_involutive y); rewrite (opp_involutive y);\n rewrite (opp_involutive y);Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite <- (opp_Ropp (opp x)) at 1.\nrewrite <- (opp_involutive x); trivial.\nrewrite <- H1; trivial.\nrewrite <- H1; trivial.\nrewrite <- H2; trivial.\nrewrite <- H2; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nrewrite <- (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp x)).\nrewrite (opp_involutive (opp xQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; symmetry  in |- *;\n apply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; reflexivity.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; rewrite H; rewrite H; rewrite H0; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintro H; elim H; intros; rewrite H; clear H H; intros; elim H; intros; elim H0; intros; elim H0;\n intros; elim H1; intros; clear H1 H2 H3; rewrite H; clear H0 H2 H3.\nunfold Opp in |- *; rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) inQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold Opp, Opp, respectful in |- *; intros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; red in |- *; intros; discriminate.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H H'.\nrewrite H'; elim H'; intros; elim H'; intros; clear H'.\nunfold Opp in |- *; simpl in |- *.\nrewrite <- (opp_involutive x).\nrewrite H'.\napply opp_eq; auto with algebra.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nrewrite (opp_involutive (opp_involutive (opp x)) H).\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp x)) in H.\nrewrite <- (opp_involutive (opp xQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n",
                "context_tokens": 44,
                "proof_start_offset": 215,
                "proof_end_offset": 725,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hd Hd Hd Hd H_eq H_eq.\n rewrite Z.gcd_eq in Hd.\n assert (H_sign_pos : (a + b + c + d)%Z <> (Z.sgn a + b + c + d)%Z).\n apply Zgt_not_eq.\n apply Zgt_not_eq.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n apply Zgt_lt.\n applyQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n   intros.\n   elim (Z_div_mod_eq_0 a b c d H).\n   intros.\n   rewrite H0 in H.\n   rewrite (Zplus_comm a b c) in H.\n   rewrite (Zplus_comm a c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_comm a c) in H.\n   rewrite (Zplus_comm a c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_comm b c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_comm b c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_comm b c) in H.\n   rewrite (Zplus_comm b c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_assoc b c) in H.\n   rewrite (Zplus_comm b c) in H.\n   rewrite (Zplus_assoc_reverse b c) in H.\n   rewrite (Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d a b c d H.\n unfold Bezout in |- *.\n case (Z_dec a 0).\n intro.\n rewrite e0 in H.\n discriminate H.\n intro.\n apply H.\n intro.\n apply H.\n assumption.\n intro.\n apply H.\n assumption.\n intro.\n apply H.\n assumption.\n intro.\n apply H.\n assumption.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H.\n case (Z_zerop b); intros.\n case (Z_zerop b); intros.\n apply False_ind; apply H; trivial.\n case (Z_zerop b); intros.\n apply False_ind; apply H; trivial.\n apply False_ind; apply H; trivial.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d c d e f g h.\n functional induction (Z_le_dec 0 a).\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\n intros; discriminate.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hb Hc H.\n destruct (Z_div_eucl_sign a b c d H) as (g,(g,(g,(g,(g,(g,(g,h))),H))).\n destruct (Z_div_eucl_sign a b c d H) as (g,(g,(g,(g,(g,(g,h))),H)).\n exists g.\n split.\n apply Z.lt_trans with (Z.pow_pos 1 g).\n apply Z.pow_pos_nonneg.\n apply Zmult_gt_0_lt_compat; assumption.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.pow_pos_nonneg.\n apply Z.powQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros.\n destruct (Z_div_eucl_aux a b c d) as [G|G];\n  [ elim G; intros H1| idtac];\n    [ right; reflexivity | left; apply Z.le_refl | right; assumption ]\n  | left; left; apply Z.le_refl | left; assumption ]\n  | left; apply Z.le_refl | right; assumption ]\n  | right; left; apply Z.le_refl | right; assumption ]\n  | right; left; apply Z.le_refl | left; assumption ]\n  | right; left; apply Z.le_refl ].\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hb Hd Hd.\n case (Z_lt_ge_dec 0 a).\n intro Hb.\n apply False_ind.\n case (Z_lt_ge_dec 0 b).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_ge_dec 0 c).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_ge_dec 0 c).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_ge_dec 0 c).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_ge_dec 0 c).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_ge_dec 0 c).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_eq_dec 0 c).\n intro Hd.\n apply H.\n discriminate.\n intro Hd.\n case (Z_lt_ge_dec 0 c).\n intro Hd.\n apply H.\n discriminate.Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d H H0.\n case (Z_le_gt_dec 0 a); intros.\n  case (Z_le_gt_dec 0 a).\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate H0.\n  intro; discriminate HQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b c d : Z, is_gcd Z IdZ Zmult 0%Z a b c -> is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\n intros a b c d Hb Hd Hd.\n case (Z_zerop b).\n intro.\n apply H.\n intro.\n assert (H0 := H0).\n assert (H1 := H1).\n apply H1.\n rewrite H1.\n assumption.\n intro.\n apply H.\n rewrite H1.\n assumption.\n intro.\n apply H.\n rewrite H1.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Require Export misc.\nRequire Export Zstruct.\nRequire Export ZArith.\nRequire Import Omega.\nRequire Import ZArithRing.\nRequire Import Zcomplements.\nRequire Import Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\nLemma gcd_unicity_apart_sign :\n forall a b c d : Z,\n is_gcd Z IdZ Zmult 0%Z a b c ->\n is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\n",
                "context_tokens": 238,
                "proof_start_offset": 727,
                "proof_end_offset": 1860,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim (Z_le_gt_dec 0 b); intros.\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nintros; exact H0.\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nright.\nsplit; auto with zarith.\nexists (-1)%Z; split.\nexact I.\nauto with zarith.\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (- x)%Z.\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nrewrite <- (Zabs_eq b).\nrewrite Zabs_eq; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim H; intros.\n case H0; intros.\n left. elim H1; intros; elim H2; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nunfold is_gcd in |- *.\nelim (Zabs_dec b 0); intros.\nleft. elim H0; intros; elim H4; intros.\nleft. elim H1; intros; elim H4; intros; elim H4; intros; elim H5; intros.\nright. elim H3; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H9; intros; \n elim H8; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim H; intros.\n rewrite <- H0.\n apply gcd_absorb; auto with zarith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n case (Z_le_gt_dec 0 a).\n intro.\n case (Z_le_gt_dec 0 a).\n intro.\n left.\n rewrite e.\n rewrite e.\n unfold Zminus at 1.\n rewrite Zmult_0_r.\n rewrite Zmult_comm.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n apply Z.lt_gt.\n assumption.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n rewrite H.\n apply gcd_lincomb_absZ; assumption.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n elim (Zabs_non_zero_pos a); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b); intros.\n elim (Zabs_non_zero_pos b);Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H4; intros;\n generalize (Zabs_Zsgn_unfolded_pos a); intro; \n elim H3; intros; elim H5; intros; clear H5 H6;\n intros; elim H5; intros; clear H5 H6;\n intros; elim H5; intros; clear H5 H6; \n intros; elim H5; intros; clear H5 H6; \n intros; elim H6; intros; clear H6; \n intros; elim H6; intros; clear H6; \n intros; clear H6; intros; elim H6; intros; clear H6; \n intros; clear H6; intros; clear H6; intros; clear H6; \n intros; elim H6; intros; clear H6; intros; clear H6; \n intros; clear H6; intros; clear H6; intros; clear H6; \n intros; clear H6; intros; clear H6; intros; clear H6; \n intros; clear H6; intros; clear H6; intros; clear H6; \n intros; clear H6; intros;Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros.\nunfold is_gcd.\nrewrite Zabs_eq_bool_rev.\napply Zabs_eq; auto.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\n intros.\n apply (gcd_divide_compat a b (Zabs b)); auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " is_gcd Z IdZ Zmult 0%Z a b d -> d = c \\/ d = (- c)%Z.\nProof.\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ Zplus Zmult 0%Z 1%Z Zopp\n    Z_unitary_commutative_ring integrityZ a b c d H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2; auto with zarith.\nelim H1; intros; exact H2.\nQed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 2271,
                "proof_end_offset": 2745,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros.\ncase (Z_zerop n); intro.\nunfold P in |- *.\nintro.\nsplit with (Zabs b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (Zdiv_eucl_extended n0 b).\nintro p; elim p; intros q r H0; elim H0; clear p H0; intros.\ncut (Zabs r < Zabs n)%Z; intros.\nelim (H r H2 n).\nintros.\nsplit with x.\napply gcd_mod with q r; trivial.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n H' H'0; elim H'; intros H'1.\napply (Zle_lt_trans 0%Z); auto with zarith.\nrewrite H'1; rewrite Zabs_non_eq; auto with zarith.\napply (Zle_lt_trans 0%Z); auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n H H0.\n case (non_zero_dec n); intros.\nleft; apply H.\n right; apply H0.\n right; apply H.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n; elim n; auto.\nintros m Hrec n Hrec p H H0.\nrewrite <- (Zabs_eq n); auto with zarith.\nintros p H1; apply prime_intro; apply H0; apply prime_intro; apply H0; auto.\nintros m Hrec p H H0.\napply le_trans with (m := Zabs_nat n).\nrewrite <- (Zabs_eq n); auto with zarith.\nrewrite <- (Zabs_eq n); auto with zarith.\napply is_gcd_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid.\napply Zis_gcd_for_euclid_for_euclid_for_euclid_for_euclid.\napply Zis_gcd_for_euclid_for_euclid_for_euclid_for_euclid.\napply Zis_gcd_for_euclid_for_euclid_for_euclid.\napply Zis_gcd_for_euclid_for_euclid_for_euclid.\napply Zis_gcd_for_euclid_for_euclid.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n H; elim (Z_le_lt_or_eq _ _ H); intros H1;\n elim H1; intros; auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros [| p| p] H; try discriminate H.\n intros m H1.\n destruct (Zle_or_lt p m) as [H|H].\n(* |p|p| *)\n(* |p|p|p| *)\n(* |p|p|p|p| *)\n(* |p|p|p|p| *)\n(* |p|p|p|p| *)\n(* |p|p|p|p|p| *)\n(* |p|p|p|p|p| *)\n(* |p|p|p|p|p|p| *)\n(* |p|p|p|p|p| *)\n(* |p|p|p|p|p| *)\n (* p|p|p|p|p|p| *)\n(* |p|p|p|p|p|p| *)\n (* |p|p|p|p|p|p| *)\n (* p|p|p|p|p|p|p|*)\n (* p|p|p|p|p|p| *)\n (* p|p|p|p|p|Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n H; elim H; auto with zarith.\nintros m Hrec p Hrec p.\nrewrite <- (abs_abs (Zabs_nat n)).\nrewrite Zabs_Zmult.\napply le_lt_trans with (Zabs_nat n); auto with zarith.\nrewrite <- (abs_abs (Zabs_nat n)).\napply Zlt_le_trans with (Zabs_nat n); auto with zarith.\nrewrite <- (abs_abs (Zabs_nat n)).\napply Zabs_eq; auto with zarith.\napply le_trans with (Zabs_nat n); auto with zarith.\napply Zle_lt_trans with (Zabs_nat n); auto with zarith.\nrewrite <- (abs_abs (Zabs_nat n)).\napply Zabs_eq; auto with zarith.\napply Zle_lt_trans with (Zabs_nat n); auto with zarith.\nrewrite <- (abs_abs (Zabs_nat n)).\napply Zabs_eq; auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n.\napply is_finite_gcd_for_euclid with (1 := H).\nintros m H1 H2.\napply is_finite_gcd_for_euclid with (1 := H2).\nintros m H3.\napply is_finite_gcd_for_euclid with (1 := H3).\nintros m H3.\napply is_finite_gcd_for_euclid with (1 := H3).\nintros m H4.\napply is_finite_gcd_for_euclid with (1 := H4).\nintros m H5.\napply is_finite_gcd_for_euclid with (1 := H5).\nintros m H5.\napply is_finite_gcd_for_euclid with (1 := H5).\nintros m H5.\napply is_finite_gcd_for_euclid with (1 := H5).\nintros m H5.\napply is_finite_gcd_for_euclid with (1 := H5).\nintros m H5.\napply is_finite_gcd_for_euclid with (1 := H5).\nintros m H5.\napply is_finite_gcd_Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros; apply is_gcd_for_euclid2 with 0%Z; auto with zarith.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n intros n H H1 H2.\n apply is_finite_P.\n apply is_finite_P.\n intros m H1 H2.\n apply is_finite_P.\n intros m H1 m H2.\n apply is_finite_P.\n intros m H1 H2.\n apply is_finite_P.\n intros m H H3.\n apply is_finite_P.\n intros m H1 m H3.\n apply is_finite_not_is_finite_P.\n intros m H1 m H3.\n apply is_finite_is_finite_P.\n intros m H1 m H3.\n apply is_finite_is_finite_P.\n intros m H1 H2.\n apply is_finite_P.\n intros m H1 m H3.\n apply is_finite_P.\n intros m H1 H2.\n apply is_finite_is_finite_P.\n intros m H1 m H3.\n apply is_finite_is_finite_is_finite_P.\n intros m H1 m H3.\n apply is_finite_P.\n intros m HQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\nintros n; elim n.\nintros m Hrec; case m.\nintros m Hrec; case m.\nintros m Hrec; case m.\nintros m Hrec; case m.\nintros m Hrec; case m.\nintros m Hm.\nintros m Hm H1; case m.\nintros m Hm H2; case m.\nintros m Hm.\napply le_trans with (m := Zabs_nat m).\napply Hrec; auto.\napply (fun m : Z => (Zabs m <= Zabs_nat m)%Z).\napply Hrec; auto with arith.\nintros m Hm; case m.\nintros m Hm.\nintros m Hm H1; case m.\nintros m Hm.\napply le_trans with (Zabs m - Zabs_nat m)%Z.\napply Hrec; auto with arith.\napply Hrec; auto.\napply (fun m : Z => (Zabs m <= Zabs_nat m)%Z).\napply Hrec; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "Qed.\n\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).\nProof.\nintros. \nelim (Z_le_gt_dec 0 b); intros.\n(* |b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2747,
                "proof_end_offset": 2841,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\n  unfold P in |- *; intros.\n  elim (Z_le_gt_dec 0 a); intro.\n  unfold P in |- *; intro.\n  elim (Zdiv_eucl_extended n0 b).\n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  apply (Zmod_lt_cancel_r _ _ _ H0).\n  apply (Zmod_lt_cancel_r _ _ _ H1).\n  apply (Zmod_lt_cancel_r _ _ _ H1).\n  apply (Zmod_lt_cancel_r _ _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ _ H2).\n  apply (Zmod_lt_cancel_r _ _ H2).\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  cut (forall m : Z, (Zabs m > 0)%Z -> P m) -> P n.\n  intros.\n  assert (H := even_odd_Z a b).\n  apply even_intro; assumption.\n  apply (gcd_bezout_absZ a b).\n  unfold P in |- *; intros.\n  elim (Zabs_dec a b).\n  intro p; elim p; intros q r H0; elim H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  apply (Zabs_eq q r H1).\n  apply (gcd_greatest_absZ a b).\n  unfold P in |- *; intros.\n  elim (Zle_lt_or_eq _ _ H2).\n  apply (dvd_abs_Z b).\n  apply (Zabs_eq q r H2).\n  apply (gcd_greatest_absZ a b).\n  unfold Q in |- *; intros.\n  elim (Zle_lt_or_eq _ _ H2).\n  apply (gcd_greatest_absZ a b).\n  unfold Q in |- *; intros.\n  elim (Zlt_le_or_eq _ _ H2).\n  apply (gcd_Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros a b.\n  unfold P in |- *.\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  apply Zis_gcd_for_euclid with (q := q).\n  applyQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  elim (Z_div_mod_eq_dec a b); intros.\n  apply Zis_gcd_for_euclid with (a:=a) (q:=b) (q:=c) (r:=c) (r:=c) (r:=c) (r:=c) (r:=c) (r:=c) (r:=c) (r:=d).\n  rewrite H; auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  unfold Zgcd_bound in |- *.\n  elim (Zgcd_bound_bound_z a b).\n  intros p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r > 0)%Z; intros.\n  elim (H r H0). intros.\n  apply gcd_divide_r with q r; trivial.\n  apply (gcd_divide_r q r H0).\n  apply Zis_gcd_for_euclid with q r; trivial.\n  apply Zis_gcd_for_euclid with q r; trivial.\n  apply Zis_gcd_for_euclid with p r; trivial.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  exists (Zabs b).\n  split.\n  apply Zis_gcd_for_euclid with (Z := (1 * a)%Z) (Z := (1 * a)%Z) (Z := (1 * b)%Z).\n  unfold Z, Z, Z, Z in |- *; apply Zis_gcd_for_euclid with (Z := (Z.abs a) * (Z.abs b)).\n  unfold Z, Z, Z.abs at 1 in |- *; apply Zis_gcd_for_euclid with (Z := (Z.abs b)).\n  unfold Z, Z.abs at 1 in |- *; apply Zis_gcd_for_euclid with (Z := (Z.abs b)).\n  unfold Z, Z.abs at 1 in |- *; apply Zis_gcd_for_euclid with (Z := (Z.abs b)).\n  change (Z.abs b < Z.abs b)%Z in |- *; apply Zis_gcd_for_euclid with (Z := (Z.abs b)).\n  apply Z.abs_inj.\n  apply Z.abs_inj.\n  apply Z.abs_inj.\n  apply Z.abs_inj.\n  apply Z.absQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n intros a b. unfold P in |- *. intros.\n case (Z_zerop b); intro.\n unfold P in |- *. intro.\n elim (gcd_lincomb_eq a b).\n intro p; elim p; intros q r H0; elim H0; intros; clear p H0; intros; elim H0; intros; clear H0;\n intros q r H0; elim H0; intros; clear H0; intros; elim H0; intros; clear H0;\n intros q r H0; elim H0; intros; clear H0; intros; \n elim H1; intros; clear H1; intros; elim H1; intros; clear H1;\n intros q r H0; elim H1; intros; clear H1; intros; \n elim H1; intros; clear H1; intros; \n elim H1; intros; clear H1; intros; \n elim H1; intros; clear H1; intros; \n elim H1; intros; clear H1; intros; \n elim H1; intros; clear H1; intros; \n elim H1; intros; clear H1; intros; \n elim H1; intros; clearQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\n  intros.\n  unfold gcdZ_i in |- *.\n  apply gcd_for_euclid with (Z := Z); auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros; elim H1; intros; auto with zarith.\n  intros.\n  generalize (Zabs_non_eq_bool b); intros; auto with zarith.\n  intros; elim H1; intros; auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  unfold BezoutZ in |- *.\n  apply (Build_gcd_for_euclid (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\n  intros.\n  apply (Build_gcd_for_euclid (Z_of_nat n) (Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros.\n  apply Zis_gcd_for_euclid with (Z := Z.gcd a b).\n  unfold Z.gcd in |- *; unfold Z.gcd in |- *.\n  apply Zis_gcd_for_euclid with (Z := Z.gcd a b).\n  red in |- *; unfold Z.gcd in |- *; unfold Z.gcd in |- *;\n  split.\n  unfold Z.gcd in |- *; unfold Z.gcd in |- *; unfold Z.gcd in |- *.\n  apply Z.gcd_0_l.\n  apply Zis_gcd_for_euclid with (Z := Z.gcd a b).\n  red in |- *; unfold Z.gcd in |- *.\n  apply Zis_gcd_for_euclid with (Z := Z.gcd b b).\n  red in |- *; unfold Z.gcd in |- *.\n  apply Zis_gcd_for_euclid with (Z := Z.gcd a b).\n  red in |- *; unfold Z.gcd in |- *; unfold Z.gcd in |- *.\n  apply Zis_gcd_for_euclid with (Z := Z.gcd b b).\n  red in |- *; unfold Z.gcd in |- *; unfold Z.gcd in |- *; \n  split.\n  unfoldQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "b|=b *)\nrewrite Zabs_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (Z_zerop b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists 1%Z. split. exact I. auto with zarith.\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite Zabs_non_eq; auto with zarith.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nright. split; auto with zarith.\nexists (-1)%Z; split. exact I.\nauto with zarith.\nexact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (- x)%Z. split. exact I. elim H8; intros; rewrite H10.\nrewrite <- Zopp_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2843,
                "proof_end_offset": 3586,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros.\nelim H.\nintros.\napply (gcd_OZ_absZ b0).\nclear H a b d; intros.\nunfold is_gcd in |- *.\nelim H3; clear H3; intros.\nelim H4; clear H4; intros.\nsplit.\nexact H4.\nsplit.\nrewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4.\nexact I.\nexact H3.\nintros.\napply (H5 q0).\ncut (r = (a - b * q)%Z); intros.\nrewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  unfold gcdZ in |- *.\n  apply Z_div_mult_l with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_for_euclid2 with d; auto with zarith.\n  apply gcd_sym.\n  apply gcd_forQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro.\n  unfold P in |- *. intro. elim (Zle_or_lt 0 a); intro.\n  unfold P in |- *. intro. elim (Zle_or_lt 0 a); intro.\n  unfold P in |- *. intro. elim (Zle_or_lt 0 a); intro.\n  unfold P in |- *. intro. elim (Zle_or_lt 0 a); intro.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  unfold Z in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 1 in |- *; apply Zle_ge.\n  unfold Zabs at 2 in |- *; apply Zle_ge.Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop b); intro.\n  unfold Z.abs in |- *.\n  apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n    apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n    apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n      apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n      apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n      apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n      apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n      apply Zis_gcd_for_euclid with (1 := H).\n  intros q H0; elim H0; intros;\n      apply Zis_gcd_for_euclid with (1 := H).\n  introsQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros a b d Hb H.\n  unfold gcdZ in |- *.\n  apply (Z_lt_abs_rec _ _ (Zabs_nat_nat_nat_nat_of_P n)).\n  apply Zis_gcd_for_euclid with (p:=gcd_greatest b).\n  unfold P in |- *; intros.\n  elim (Zle_bool_spec b d).\n  intro p; elim p; intros q r H0; elim H0; clear p; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  apply (Zgt_irrefl (Zabs_nat_of_P q)).\n  apply Zis_gcd_for_euclid with (p:=gcd_greatest b).\n  unfold P in |- *; intros.\n  elim (Zle_bool_spec b d).\n  intro p; elim p; intros q r H0; elim H0; clear p; intros.\n  cut (Zabs r > Zabs n)%Z; intros.\n  apply (Zlt_irrefl (Zabs_nat_of_P q)).\n  apply Zis_gcd_for_euclid with (p:=gcd_greatest b).\n  unfold P in |- *; intros.\n  elim (Zle_bool_specQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  exact (Z_div_mod b (Z_of_nat_of_nat_of_nat_of_P d)).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros a b d.\n  exact (Z_lt_abs_aux b d).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  exact (Z_divide_abs_rec _ _ d).\nQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros. case (Z_zerop d); intro. unfold Z in |- *.\n  unfold Z in |- *; unfold Z in |- *; unfold Z in |- *; simpl in |- *.\n  unfold Z in |- *; simpl in |- *.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarith.\n  intros.\n  apply Z_div_pos; auto with zarithQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros a b d.\n  apply (Z_lt_abs_rec _ _ (Zabs_nat a) (Zabs_nat b)).\n  unfold P in |- *; intro. elim (Zabs_nat b); intros; unfold P in |- *.\n  rewrite H; apply (Zabs_eq b); apply (Zabs_eq b); apply (Zabs_eq b); apply (Zabs_eq b);\n    apply (Zabs_eq b); apply (Zabs_eq b); apply (Zabs_eq b);\n    apply (Zabs_eq b); apply (Zabs_eq b); apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b); apply (Zabs_eq b);\n    apply (Zabs_eq b); apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b); apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);\n    apply (Zabs_eq b);Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\n  intros.\n  elim (Z_zerop b); intro. unfold P in |- *. intro.\n  elim (Zle_lt_or_eq _ _ H).\n  intros; apply H1.\n  apply gcd_comm; apply gcd_0_l; trivial.\n  unfold gcd in |- *; intros.\n  elim (Zle_lt_or_eq _ _ H).\n  intros; apply H1.\n  apply gcd_comm; apply gcd_opp; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "_mult_distr_r; auto.\nQed.\n\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3657,
                "proof_end_offset": 3793,
                "proof": "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (Z_div_mult_div_div_mod_eq a b).\napply Zle_trans with (Zabs b).\napply Zle_Zmult_comp_l.\napply Zmult_gt_0_lt_0_compat.\nnow apply Zlt_gt.\nnow apply Zlt_gt.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nunfold gcdZ in |- *.\nelim H; intros.\napply H.\napply (gcd_greatest a b).\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.\napply Zis_gcd_for_euclid with a; trivial.Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\n  intros. unfold gcdZ in |- *.\n  case (Z_zerop b); intro.\n  unfold Z.gcd in |- *.\n  apply gcd_sym.\n  split.\n  apply (gcd_sym a).\n  apply (gcd_sym a).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_comm b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n  apply (gcd_sym b).\n Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\n  intros. apply (Z_le_lt_eq 0%Z); apply gcd_0_l.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros a b.\nunfold gcdZ in |- *.\nelim (Z_zerop b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Zabs_eq b); intro.\nunfold gcdZ in |- *.\nelim (Qed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\napply (Z_div_mod_eq (Zabs_non_gcdZ a b)).\nunfold gcdZ in |- *.\nelim H; clear H; intros.\nunfold gcdZ in |- *.\nelim H; clear H; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdZ in |- *.\nelim H0; clear H0; intros.\nunfold gcdQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros a b.\nunfold gcdZ in |- *.\nelim H; intros.\napply (gcd_bezout_absZ a b).\nunfold gcdZ in |- *; intros.\nelim H0; intros.\napply (gcd_bezout_absZ a b).\nunfold gcdZ in |- *; intros.\nelim H1; intros.\nelim H2; intros.\napply (gcd_bezout_oppZ b).\nunfold gcdZ in |- *; intros.\nelim H4; intros.\nelim H5; intros.\napply (gcd_greatest_oppZ b).\nunfold gcdZ in |- *; intros.\nelim H5; intros.\nelim H5; intros.\napply (gcd_greatest_oppZ b).\nunfold gcdZ in |- *; intros.\nelim H5; intros.\napply (gcd_greatest_oppZ b).\nunfold gcdZ in |- *; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\napply (gcd_greatest_oppZ b).\nunfold gcdZ in |- *; intros.\nelim H5; intros.\nelim H5; intros.\napplyQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nrewrite <- (Z_eq_Z_eq a).\nrewrite <- (Z_eq_Z_eq b).\nrewrite <- (Z_eq_Z_eq b).\nrewrite (Zmult_comm a).\nrewrite (Zmult_comm a).\nrewrite Zmult_comm.\nrewrite Zmult_assoc.\nrewrite Zmult_comm.\nrewrite Zmult_assoc.\napply Zmult_1_l.\nQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nunfold gcdZ in |- *.\nunfold gcdZ in |- *.\napply gcd_comm.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_opp.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_opp.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_opp.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napply gcd_sym.\napplyQed.",
                    "Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nintros.\nunfold gcdZ in |- *.\napply gcd_for_euclid with (Z_of_nat a) (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_of_nat b).\napply gcd_for_euclid with (Z_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": ",\n      b <> 0%Z ->\n      (0 <= r < Zabs b)%Z ->\n      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.\n\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3795,
                "proof_end_offset": 3912,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H H0.\napply Z_div_pos_for_euclid2; auto with zarith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d; case (Z_zerop a); intro.\nunfold gcd in |- *.\nunfold Zminus in |- *.\napply (Build_Z_pos a (Zpos d)).\napply (fun a b : Z => Zabs_nat (Zpos d)).\napply Zabs_ind; intros; simpl in |- *.\nrewrite Zabs_eq; auto with zarith.\napply Zabs_ind; intros; simpl in |- *; red in |- *; intros; discriminate.\nunfold Zabs at 1 in |- *.\napply (Build_Z_pos a (Zpos d)).\napply (fun a b : Z => Zabs_nat (Zpos d)).\napply Zabs_ind; intros; simpl in |- *.\nrewrite Zabs_eq; auto with zarith.\napply Zabs_ind; intros; simpl in |- *; red in |- *; intros; discriminate.\nunfold Zabs at 1 in |- *.\napply (Build_Z_pos a (Zpos d)).\napply Zabs_ind; intros; simpl in |- *; red in |- *; intros; discriminate.\nunfold Zabs at 1 in |- *.\napply (Build_Z_pos a (Zpos d)).\napply Zabs_ind; intros; simpl in |- *; red inQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H; unfold gcdZ in |- *.\ncase (Z_zerop b); intro.\napply (euclid_for_euclid_aux a b d).\nexact H.\nintros; apply H.\napply (euclid_for_euclid_aux a b d).\nexact H.\nintros; apply H.\napply (euclid_for_euclid_aux a b d).\nexact H.\nintros; apply H.\napply (euclid_for_euclid_aux a b d).\nexact H.\nintros; apply H.\napply (euclid_for_euclid_aux a b d).\nexact H.\nintros; apply H.\napply (euclid_for_euclid_aux a b d).\nexact H.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply Z_div_is_gcd.\napply Zabs_non_gcd_for_euclid.\napply Z_div_exact; auto with zarith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\napply (is_gcd_for_euclid (Z_div_eucl a b)).\nexact (fun a b d : Z => (a * b)%Z = (a * b)%Z).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros.\nunfold Z.lt in |- *.\napply (Build_Z_eq_abs_nat (Zabs_nat a) (Zabs_nat d)).\napply Zabs_ind; intros.\nunfold Zabs_nat in |- *.\nsimpl in |- *.\napply le_trans with (Zabs_nat d).\napply Zabs_ind; intros.\napply le_trans with (Zabs_nat d).\nrewrite Zabs_eq; auto with zarith.\napply Zabs_ind; intros.\napply le_trans with (Zabs_nat d).\napply Zabs_ind; intros.\nunfold Zabs_nat in |- *.\nsimpl in |- *.\napply le_trans with (Zabs_nat d).\nrewrite Zabs_eq; auto with zarith.\napply Zabs_ind; intros.\napply le_trans with (Zabs_nat d).\napply Zabs_ind; intros.\nunfold Zabs_nat in |- *.\nsimpl in |- *.\napply le_trans with (Zabs_nat d).\napply Zabs_ind; intros.\nunfold Zabs_nat in |- *.\nsimpl in |- *.\napply le_trans with (Zabs_nat d).\napply Zabs_ind;Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H H0.\napply (gcd_greatest a b d H H0).\napply (gcd_greatest a b d H H0).\nexact H.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\n intros a b d H H0.\n case (Z_zerop b); intro.\n unfold Z.lt in |- *.\n apply Zmult_integral_l with d; auto with zarith.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewriteQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d; case (Z_zerop b); intros.\nunfold Z.gt in H0.\nreplace (Zabs b * Z_of_nat (Zabs_nat d)) with (Zabs_nat d).\napply (fun m n => Zabs_eq (Zabs_nat m) (Zabs_nat d)); auto with zarith.\napply Zabs_non_gcd_Z; auto with zarith.\nintros; apply (Zabs_non_gcd_Z a b n).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros a b d H H0.\napply (euclid_gcd_for_euclid a b d); trivial.\nunfold rel_primeZ.\napply Zis_gcd_for_euclid with (1 := 1%Z).\nexact (gcd_for_euclid a b d).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.\nProof.\n  intros. case (Z_zerop n); intro. unfold P in |- *. intro.\n  split with (Zabs b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (Zdiv_eucl_extended n0 b). \n  intro p; elim p; intros q r H0; elim H0; clear p H0; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 3914,
                "proof_end_offset": 4352,
                "proof": "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\n intros.\n case (Z_zerop a); intros; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0 H1.\napply H1; apply Zis_gcd_for_euclid; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nrewrite (Z_div_mod a b d H H0); auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0.\napply is_gcd_sym; apply divide_sym; apply divide_opp_r; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0; rewrite H0; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0.\napply Z.divide_is_gcd_l with (1 := H).\napply Z.divide_is_gcd_r with (1 := H).\napply Z.divide_is_gcd_r with (1 := H).\napply Z.divide_is_gcd_l with (1 := H).\napply Z.divide_mul_r.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H H0 H1.\nrewrite <- (Z_div_mod a b c d H H0).\napply Z_div_mod; auto.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros a b c d H1 H2.\napply (is_gcd_for_euclid a b c d); trivial.\napply (is_gcd_for_euclid a b c d); trivial.\napply (is_gcd_for_euclid a b c d); trivial.\napply (is_gcd_for_euclid a b c d); trivial.\napply (is_gcd_for_euclid a b c d); trivial.\napply (is_gcd_for_euclid a b c d); trivial.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros; elim H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "; intros.\n  cut (Zabs r < Zabs n)%Z; intros.\n  elim (H r H2 n). intros. split with x.\n  apply gcd_mod with q r; trivial. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 4354,
                "proof_end_offset": 4506,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply gcd_uniqueness with (1 := H).\napply gcd_sym; auto with zarith.\nrewrite H1; ring.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nunfold gcdZ in |- *.\nreplace (d_pos) with (d_pos).\napply gcd_for_euclid2; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nunfold gcdZ in |- *.\nrewrite <- (Zabs_eq_bool_eq a b); auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcdZ_is_gcdZ a b d H).\nintros; rewrite H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nrewrite <- (gcd_abs_Z a b d H).\napply gcdZ_is_gcd.\nrewrite <- (gcd_comm a b d H).\nrewrite <- (gcd_comm b d H).\napply gcd_divide_l.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_r.\nrewrite <- (gcd_comm a b d H).\napply gcd_divide_r.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_l.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_r.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_r.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_r.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_r.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_l.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_l.\nrewrite <- (gcd_comm b d H).\napply gcd_divide_r.\nrewrite <- (gcdQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d H; elim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (gcd_for_euclid_aux_correct a b d (gcdZ_is_gcd a b d H) (gcdZ_is_gcd b d H)).\napply rel_prime_divide; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim (gcd_bezout_zero a b d (gcdZ_is_gcd a b d H)).\nintros; rewrite H0; auto with zarith.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " _ acc_P).\nQed.\n\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.\nProof.\nintros. elim H. intros. apply (gcd_OZ_absZ b0). \nclear H a b d; intros. unfold is_gcd in |- *.\nelim H3; clear H3; intros. elim H4; clear H4; intros. split. exact H4.\nsplit. rewrite H1.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z r d).\napply (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 4508,
                "proof_end_offset": 4744,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H H0 H1 H2; rewrite H2.\nreplace (Zabs (Zabs b)) with (Zabs (Zabs b)).\napply Zabs_eq; apply Zabs_eq; apply Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply Zis_gcd_Zabs_pos; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply Zis_gcd_Zabs_pos; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply Zis_gcd_Zabs_pos; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply Zis_gcd_Zabs_pos; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply Zis_gcd_Zabs_pos; auto with zarith.\napply Zis_gcd_Zabs_pos; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (fraction_encoding_correct_divisors_correct_divisors a b q r H H0 H).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\nrewrite <- (Zmult_1_l (a * q) (b * q)) at 1.\nrewrite H2.\nrewrite (Zmult_comm a b) at 1.\nrewrite (Zmult_comm a b) at 1.\nrewrite (Zmult_comm a b) at 1.\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm a b) at 1.\nrewrite (Zmult_comm a b) at 1.\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewrite (Zmult_comm b r).\nrewriteQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\ndestruct r; try discriminate.\nunfold gcd in H.\nelim H; auto with zarith.\nintros.\nabsurd (Zabs a = 0%Z).\nauto with zarith.\napply Zmult_integral with (a := (0 + q)%Z).\nauto with zarith.\napply Zmult_integral with (a := (0 + q)%Z).\nauto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim H; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\napply (Build_Z_is_gcd_Z a b q r H1).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_for_euclid a b (gcdZ a b) r r); auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\ngeneralize (Z_div_mod_eq a b q r H); clear H; intros H1.\nrewrite (Z_div_eq a b q r H H0 H1); auto with zarith.\napply gcd_unique with (1 := H1).\napply divide_refl.\napply gcd_sym; apply gcd_sym; apply gcd_nonneg; auto with zarith.\napply gcd_sym; apply gcd_sym; apply gcd_nonneg; auto with zarith.\napply gcd_sym; apply gcd_nonneg; auto with zarith.\napply gcd_sym; apply gcd_nonneg; auto with zarith.\napply gcd_sym; apply gcd_nonneg; auto with zarith.\napply gcd_sym; apply gcd_sym; apply gcd_nonneg; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nunfold gcdZ in H; rewrite H; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2.\napply (Zpower_non_gcd_pos_pos a b q r H H0 H1).\napply (Zpower_non_gcd_pos_pos a b q r H H2).\napply (Zpower_non_gcd_pos_pos a b q r H H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "ring b q d).\nexact H4. exact I. exact H3.\nintros. apply (H5 q0).\ncut (r = (a - b * q)%Z); intros. rewrite H8.\napply (div_add Z IdZ Zplus Zmult 0%Z Zopp Z_ring a (- (b * q))%Z q0 H7).\napply (div_opp Z IdZ Zplus Zmult 0%Z Zopp Z_ring (b * q)%Z q0).\nexact (div_mult Z IdZ Zplus Zmult 0%Z Zopp Z_ring b q q0 H6 I).\nrewrite H1; auto with zarith.\nexact H6.\nQed.\n\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof.\nexact (fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b)).\nQed.\n\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4939,
                "proof_end_offset": 5677,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros q f.\nelim (Z_zerop q); intro e.\nunfold Q in |- *; intro b.\nsplit with 1%Z (Zsgn b).\nrewrite e.\nsimpl in |- *.\nrewrite (Zsgn_Zabs b).\napply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (Zdiv_eucl_extended e b).\nintro p; elim p; clear p.\nintros div r; intros.\ncut (Zabs r < Zabs q)%Z; intros.\nelim (f r H q).\nintros.\nsplit with (v + - (div * u))%Z u.\nelim p.\nintros.\nelim H1.\nintros.\nintros.\npattern b at 1 in |- *.\nrewrite H0; auto with zarith.\nrewrite <- (gcd_modZ b q div r); auto with zarith.\nrewrite <- e0.\nring.\nelim p; intros; elim H0; intros.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\napply (Build_gen (fun m n => (m * n)%Z) (fun m n => (m * n)%Z) m n)).\napply (Build_gen (fun m n => (m * n)%Z) (fun m n => (m * n)%Z) m n)).\napply (Build_gen (fun m n => (m * n)%Z) (fun m n => (m * n)%Z) n)).\napply (Build_gen (fun m n => (m * n)%Z) n)).\napply (Build_gen (fun m n => (m * n)%Z) n)).\napply (Build_gen (fun m n => (m * n)%Z) (fun m n => (m * n)%Z) n)).\napply (Build_gen (fun m n => (m * n)%Z) n)).\napply (Build_gen (fun m n => (m * n)%Z) (fun m n => (m * n)%Z) n)).\napply (Build_gen (fun m n => (m * n)%Z) (fun m n => (m * n)%Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\ninduction n.\ndestruct m as [|m Hrec].\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m)).\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m)).\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m)).\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m)).\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m).\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m)).\nintros m Hrec.\napply (IH (fun m : nat => forall m : nat, (Zabs m > Zabs m)%Z -> Q m)).\nintros m Hrec.\napply (IH (fun m : nat => forall mQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H; apply (Z_div_mod_eq n (Zabs m)); auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H; elim H; auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\ninduction n; simpl; intros.\napply Z.le_antisymm; auto with zarith.\napply Z.le_antisym; auto with zarith.\napply Z.le_lt_trans with (Zabs n); auto with zarith.\napply Zmult_le_reg_r with (Zabs n); auto with zarith.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n intros.\n apply (Z_div_exact n H H0 H1).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H; elim H; auto with zarith.\nintros m H1; case H1; intros m0 H1; case H2; intros m1 H2;\n  try (intros m1 H2; case H3; intros m2 H3;\n  try (intros m2 H3; case H4; intros m3 H4; auto with zarith).\nintros m1 H2; case H2; intros m3 H4; case H4; intros m4 H5;\n  try (intros m3 H4; case H4; intros m4 H5; case H5; intros m4 H5;\n  try (intros m4 H5; case H5; intros m5 H6; fail); \n  try (intros m4 H5; case H6; intros m5 H6; case H6; intros m6 H7;\n  try (intros m4 H5; case H8; intros m9 H9; intros m9 H9; case H10; intros m12 H13;\n  try (intros m4 H5; case H9; intros m12 H13; auto with zarith).\nintros m1 H2; case HQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros.\ndestruct H0.\ndestruct H1.\nsplit.\nsplit.\napply Zle_antisym.\napply H.\nintros m H1.\napply H1.\napply H.\nintros m H1.\napply H1.\nintros m H1.\napply H1.\napply H1.\nintros m H2.\napply H1.\napply H2.\nintros m H2.\napply H2.\napply H3.\nintros m H3.\napply H3.\napply H3.\nintros m H3.\napply H3.\napply H4.\nintros m H3.\napply H4.\napply H4.\nintros m H3.\napply H4.\nintros m H3.\napply H4.\nintros m H3.\napply H4.\napply H4.\nintros m H3.\napply H4.\napply H4.\nintros m H3.\napply H4.\napply H4.\nintros m H3.\napply H4.\napply H4.\nintros m H3.\napply H4.\nintros m H3Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H.\nunfold Q in H.\ngeneralize (H n H); clear H; intro; apply H; clear H.\nintros.\napply H.\nintros m H1.\napply H.\napply H1.\napply H2.\napply H2.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\nintros n H; pattern n; apply Zlt_0_le_0_r.\napply (Z_div_mod_eq (Zabs n) (Zabs_nat n)); auto with zarith.\nintros m H1; pattern m; apply Zlt_0_le_0_r.\napply (Z_mod_lt (Zabs n) (Zabs_nat m)); auto with zarith.\nintros m H1; pattern m; apply Zlt_0_le_0_l.\napply (Zabs_eq (Zabs n)); auto with zarith.\nintros m H1; pattern m; apply Zlt_0_le_0_l.\napply (Zabs_eq (Zabs n)); auto with zarith.\nintros m H1; pattern m; apply Zlt_0_le_0_l.\napply (Zabs_eq (Zabs n)); auto with zarith.\nintros m H1; pattern m; apply Zlt_0_le_0_l.\napply (Zabs_eq (Zabs n)); auto with zarith.\nintros m H1; pattern m at 1; apply Zlt_0_le_0_l.\napply (Zabs_eq (Zabs n));Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.\nProof.\nintros; elim H; auto with zarith.\nQed.\n\nLemma unicity_is_gcdZ :\n forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5679,
                "proof_end_offset": 5780,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (Z_lt_abs_rec _ acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  unfold Q in |- *; intro b.\n  elim (gcd_bezout_mod a b (gcdZ_of_gcd b a)).\n  intros p; elim p; intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Build_ verify_ex (fun a b => (a * b)%Z) (fun b => a * b)%Z) (fun b => b * b)%Z).\n  intros.\n  apply (Build_ verify_ex (fun a b => a * b)%Z) (fun b => a * b)%Z).\n  intros.\n  apply (Build_ verify_ex (fun a b => a * b)%Z) (fun b => a * b)%Z) (fun b => a * b)%Z).\n  intros.\n  apply (Build_ verify_ex (fun a b => a * b)%Z) (fun b => a * b)%Z).\n  intros.\n  apply (Build_ verify_ex (fun a b => a * b)%Z) (fun b => a * b)%Z).\n  intros.\n  apply (Build_ verify_ex (fun a b => a * b)%Z) (fun b => a * b)%Z).\n  intros.\n  apply (Build_ verify_ex (fun a b => a * b)%Z) (fun b => a * b)%Z).\n  intros.\n  apply (Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (verify_gcd a b (gcd Z_of_gcd a b)); apply gcd_lincomb. unfold Q in |- *; intros.\n  elim (gcd_gcd_bezout_gcdZ a b (gcd Z_of_gcd a b)).\n  intros; elim (gcd_bezout_gcd_gcd_divisors_Z a b (gcd Z_of_gcd a b)).\n  intros; elim (gcd_bezout_gcd_divisors_Z a b (gcd Z_of_gcd a b)); intros;\n    elim (gcd_bezout_gcd_divisors_Z a b (gcd Z_of_gcd a b) (gcd Z_of_gcd a b)).\n  intros; elim (gcd_greatest_gcd_divisors_Z a b (gcd Z_of_gcd a b)); intros;\n    elim (gcd_greatest_gcd_greatest_divisors_Z a b (gcd Z_of_gcd a b) (gcd Z_of_gcd a b)).\n  intros; elim (gcd_greatest_gcd_divisors_Z a b (gcd Z_of_gcd a b)); intros;\n    elim (gcd_greatest_gcd_greatest_divisors_Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  elim (make_X (fun m : Z => a * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) c).\n  intros; apply (make_X (fun m : Z => a * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) c).\n  intros; apply (make_X (fun m : Z => a * b) (fun c : Z => c * b) (fun c : Z => c * b) (fun c : Z => c * b) c).\n  intros; apply (make_X (fun m : Z => a * b) (fun c : Z => c * b) (fun c : Z => c * b) c).\n  intros; apply (make_X (funQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nunfold Q in |- *.\nintros a b.\napply (Build_G (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) n).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  unfold Q in |- *; intro b.\n  elim (Z_zerop q).\n  intros.\n  elim (Zle_lt_or_eq _ _ H).\n  intros.\n  elim (Zle_lt_or_eq _ _ H).\n  intros.\n  elim (Zle_lt_or_eq _ _ H0).\n  intros.\n  elim H1. intros.\n  elim H2. intros.\n  elim H3. intros.\n  elim H4. intros.\n  elim H4. intros.\n  elim H5. intros.\n  elim H5. intros.\n  apply H6.\n  apply H7.\n  apply (gcdZ_div_exact a b (Zabs b)).\n  apply gcd_gcd_gcd_r; auto with zarith.\n  apply gcd_gcd_sym; auto with zarith.\n  apply gcd_gcd_sym; auto with zarith.\n  elim p; intros; elim H6.\n  intros.\n  elim H4. intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6.\n  intros.\n  elim H6Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold Q in |- *; intros; destruct a as [b c].\n  split with (Int_val a). rewrite e; auto with zarith.\n  rewrite e; auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- e; auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- e; auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- e; auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q mod); auto with zarith.\n  rewrite <- (gcd_modZ b q div); auto with zarith.\n  rewrite <- (gcd_modZ b q divQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; intros.\n  apply (derivZ_is_gcdZ a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b a (gcdZ b)).\n  apply (gcd_greatest b aQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (Build_G (fun m : Z => (a * b)%Z) (fun c : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * b)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * b)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (Build_G (fun m : Z => (a * c)%Z) c).\n  apply (BuildQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n intros a b.\n apply (gen_is_gcdZ a b (gcdZ_is_gcd a b)); apply gcd_greatest.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": " a b d -> d = c.\nProof.\nintros.\nelim\n (gcd_unicity_apart_sign a b c d (gcdZ_is_gcd a b c H) (gcdZ_is_gcd a b d H0)).\nintros; exact H1.\nintros.\ncut (d = 0%Z).\nintro eq; rewrite eq; rewrite eq in H1; auto with zarith.\napply Zle_antisym.\nrewrite H1; set (c_pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 5858,
                "proof_end_offset": 6105,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists 1%Z.\nsplit.\nexact I.\nauto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x; elim x; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros; apply (Z_div_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs yQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  generalize (Z_le_abs_abs x) (abs_nat_abs x) (abs_nat_abs y).\n  change (Zabs (Zabs x)) with (Zabs (Zabs (Zabs x))).\n  rewrite Zabs_eq; auto with zarith.\n  apply (gcd_divide_l (abs x) (abs_nat_abs y)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x; case x; simpl; auto with zarith.\n  intros; elim H; intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1; intros;\n    rewrite Zabs_eq; auto with zarith.\n  intros; elim H1;Qed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  unfold PrimeZ in |- *.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  apply (gcd_sym (Zabs_nat_dec (Zabs x) (Zabs y))) (Zabs_nat_dec (Zabs x) (Zabs y))).\n  intros.\n  elim H.\n  intros; rewrite Zabs_eq.\n  apply Zabs_eq; auto with zarith.\n  simpl in |- *.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  simpl in |- *.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  rewrite Zabs_eq.\n  apply (Zabs_eq (Zabs x) (Zabs y)).\n  intros.\n  apply Zabs_eq; auto with zarith.\n  apply Zabs_eq; auto with zarith.\n  simpl in |- *.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  simpl in |- *.\n  elim (Zabs_nat_dec (Zabs x) 1).\n  intros.\n  rewriteQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  unfold Qeq, Q in |- *.\n  apply (Build_Z_mult_div_mod Z 0%Z Z 0%Z Z.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  rewrite (Z_div_mod_eq (Zabs x) 1%Z).\n  apply (Zdiv_mult_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs z)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs x) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (Zabs y)).\n  apply (Zdiv_mult_mod_eq (Zabs y) (ZabsQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros.\n  apply (Zmult_integral_domain (Z_of_nat n) 0%Z (x + - y)%Z (x + - y)%Z).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x; unfold GL, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z,\n   %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z, %Z.\nProof.\nintros.\ndestruct x as (((a * a)%Z * b)%Z * b)%Z * b)%Z.\nrewrite Zmult_1_l.\nchange (Zpos (a * b))%ZQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\n  intros x; unfold %Z, num in |- *; simpl in |- *.\n  elim (Zdiv_eucl_rec x y n); intros.\n  change (Zabs (z - n)) with (Zabs (z - n)).\n  rewrite Zabs_eq; auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Zpos x) n (Zabs_nat n)); auto with zarith.\n  apply (gcd_greatest (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zgcd.v",
                "context": "pos := positive_is_gcdZ a b c H) in *.\nomega.\nset (d_pos := positive_is_gcdZ a b d H0) in *.\nauto with zarith.\nQed.\n\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\nLemma gcd_modZ :\n forall a b q r : Z,\n b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. \nProof.\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 H1 (gcdZ_correct r b)).\nQed.\n\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.\n\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.\nProof.\n  intros q f. elim (Z_zerop q); intro e. unfold Q in |- *; intro b.\n  split with 1%Z (Zsgn b). rewrite e. simpl in |- *. rewrite (Zsgn_Zabs b).\n  apply (gcdZ_is_gcdZ 0 b (Zabs b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (Zdiv_eucl_extended e b). intro p; elim p; clear p.\n  intros div r; intros. cut (Zabs r < Zabs q)%Z; intros.\n  elim (f r H q). intros. split with (v + - (div * u))%Z u.\n  elim p. intros. elim H1. intros. intros. pattern b at 1 in |- *.\n  rewrite H0; auto with zarith.\n  rewrite <- (gcd_modZ b q div r); auto with zarith.\n  rewrite <- e0.\n  ring.\n  elim p; intros; elim H0; intros. \n  rewrite Zabs_eq; auto with zarith.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (Z_lt_abs_rec _ acc_Q).\nQed.\n\nDefinition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.\n\nLemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.\nProof.\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (Z_zerop x); intros. left; exact a.\nright; split. exact b. exists 1%Z. split. exact I. auto with zarith.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6107,
                "proof_end_offset": 7147,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (x * (b * v) + y * (a * u))%Z.\nunfold congruentZ in |- *; split.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - x)%Z with (a * (u * (y - x)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop a); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (u * (y - x))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (b * v)%Z with (1 + - (a * u))%Z; auto with zarith.\nring.\nrewrite H in e.\nreplace (x * (b * v) + y * (a * u) + - y)%Z with (b * (v * (x - y)))%Z.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (Z_zerop b); intros.\nleft; rewrite a0; auto with zarith.\nright; split; trivial; exists (v * (x - y))%Z; auto with zarith.\nsplit.\nexact I.\nreflexivity.\nreplace (a * u)%Z with (1 + - (b * v))%Z; auto with zarith.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros a b x y.\ndestruct (gcdZ_is_gcdZ a b) as (q,r).\nexists q; split.\nunfold Q in |- *; simpl in |- *. rewrite (Zabs_eq a).\n apply (gcdZ_is_gcd_uniqueness a b q (Zabs b)); apply gcd_bezout.\nunfold Q in |- *; simpl in |- *.\nrewrite (Zabs_eq a).\nrewrite <- Zabs_eq; auto with zarith.\napply (Zabs_eq a); auto with zarith.\napply (Zabs_eq b); auto with zarith.\nintros n H; elim H; intros.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply (Zabs_eq b); auto with zarith.\nintros n H; elim H; intros.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold PrimeZ in |- *. split. exact I. split. exact I. split. exact I.\n  exact (gcd_greatest a b (gcd_greatest a b (gcd_greatest a b x) y (gcd_greatest a b x) y (gcd_greatest a b x) y (gcd_greatest a b x) y (gcd_greatest a b x) y (gcd_greatest a b y) H).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y H.\n unfold lcm in |- *.\n destruct (Z_zerop x) as [[Hx|Hx]|Hx].\n left; exists (Zabs a). split.\n  destruct (Zabs_dec a b) as [[Hx|Hx]|Hx].\n  left; exists (Zabs b).\n  split.\n  apply (gcdZ_div_mod_eq (Zabs a) (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r b (Zabs b)); auto with zarith.\n  apply (gcd_divide_r bQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y H.\n case (Z_zerop x); intros.\n left; exists (- (x - y))%Z; rewrite H; ring.\n right; split; auto.\nrewrite H; ring.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y.\n unfold lcm in |- *.\n split. exact (Z_lt_abs_pos 0 a).\n right; split; trivial.\n apply Zis_gcd_for_euclid with (1 := H).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y.\n unfold BetaZ in |- *.\n case (Z_zerop x); intros.\n exists (Z_of_nat (Z_of_nat (Z_of_nat x)) * x)%Z.\n rewrite Zmult_plus_distr_r.\n rewrite Zmult_1_r.\n rewrite Zmult_plus_distr_r.\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_plus_distr_l.\nrewrite Zmult_comm.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_comm.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_plus_distr_r.\nrewrite Zmult_comm.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_plus_distr_r.\nrewrite Zmult_comm.\nrewrite Zmult_plus_distr_r.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_comm.\nrewrite Zmult_plus_distr_l.\nrewrite Zmult_plus_distr_r.\nrewrite Zmult_plus_distr_r.\nrewrite Zmult_Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n intros a b x y.\nunfold Qeq_bool in |- *.\napply (Z_div_mod_eq (Zabs a) (Zabs b) (Zabs b));\n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b)); \n apply (Z_div_mod_eq (Zabs b) (Zabs b));Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros a b x y.\napply (euclid_gcd_for_euclid a b x y).\napply (euclid_gcd_for_euclid a b y (gcdZ_div a b) y (gcdZ_div b (Zpos a) y)).\napply (euclid_gcd_for_euclid a b y (Zpos a) y (Zpos a) (Zpos b) (Zpos b) (Zpos b)).\napply (euclid_gcd_for_euclid a b (Zpos a) y (Zpos a) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (Zpos b) (ZposQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. unfold BetaZ in |- *. split. exact I. split. exact I.\n  exact (Zle_bool_imp_le _ _ H).\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y.\n  elim (Z_div_eucl_sound a b (gcdZ_correct a b) y (gcdZ_correct b (Zpos x) y)).\n  intros. split with (Zabs b).\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n  rewrite Zabs_eq; auto with zarith.\n  rewrite Zabs_eq; auto with zarith.\n  intros; elim H0; intros.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nintros x.\nunfold Z.pow_pos.\ngeneralize (Z_div_mod_eq Z.opp_nonneg x).\ndestruct (Z_mod_eq Z.opp_bound x) as [Hx|Hx].\n(*. *)\nintros H'.\nrewrite H.\napply Z_div_mod_eq.\napply Z.mul_nonneg_nonneg.\n(*. *)\nintros H'.\nrewrite H'.\napply Z.mul_nonneg_nonneg.\n(*. *)\nintros H'.\nrewrite H'.\napply Z.mul_nonneg_nonneg.\n(*. *)\nintros H'.\nrewrite H'.\napply Z.mul_nonneg_nonneg.\nrewrite <- H'.\napply Z.mul_nonneg_nonneg.\n(*. *)\nintros H'.\nrewrite H'.\napply Z.mul_nonneg_nonneg.\nrewrite <- H'.\napply Z.mul_nonneg_nonneg.\nrewrite <- H'.\napply Z.mul_nonneg_nonneg.\nrewrite <- H'.\napply Z.mul_nonneg_nonneg.\nrewrite <- H'.\napply Z.mul_nonneg_nonneg.\nrewrite <- H'.\napply Z.mul_Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\napply Z_sub_0_abs.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z.pow at 1 in |- *.\nsimpl in |- *.\nunfold Z.pow at 1 in |- *.\nchange (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\ntrivial.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow.\ngeneralize (Z_div_mod Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd Z.gcd_div Z.gcd_div Z.gcd_div Z.gcd Z.gcd_div Z.gcd Z.gcd_div Z.gcd Z.gcd_div Z.gcd_div Z.gcd Z.gcd Z.gcd Z.gcd Z.Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nauto with algebra.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n unfold Z.pow, Z.pow in |- *.\n unfold Z.pow in |- *.\n simpl in |- *.\n intros.\n elim H.\n intros.\n apply Z.lt_irrefl with 0%Z.\n apply Z.lt_gt; auto with *.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x.\nunfold Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group in |- *.\nrewrite Z_to_group; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nred in |- *.\nintros x; try assumption.\nunfold Z_to_group, Z_to_group, Z_to_group in |- *.\nrewrite Z_to_group, Zplus_comm.\nrewrite Zplus_comm.\napply Z_mult_reg_l with (Z_of_nat 1); auto with algebra.\nunfold Z_to_group, Z_to_group, Z_to_group in |- *.\nrewrite Z_to_group.\nrewrite Zplus_comm.\napply Z_mult_reg_l with (Z_of_nat 1); auto with algebra.\nunfold Z_to_group, Z_to_group, Z_to_group in |- *.\nrewrite Z_to_group.\nrewrite Zplus_comm.\nrewrite <- Zopp_mult_distr_l.\napply Z_mult_reg_l with (Z_of_nat 1); auto with algebra.\nunfold Z_to_group, Z_to_group in |- *.\nrewrite Z_to_group.\nrewrite Zplus_comm.\napply Z_mult_reg_l with (Z_of_nat 1); auto with algebra.\nunfold ZQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.abs.\napply Z_mult_1_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nunfold Z in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z at 1 in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nunfold Z in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nred in |- *; auto with zarith.\nsplit; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; intros H; red in |- *; apply Z_mult_integral_l;\n auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_upper_bound, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_natQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow.\nintros.\napply is_upper_bound.\nsplit.\nred in |- *; auto with zarith.\nintros H; apply Z.lt_le_trans with 0%Z; auto with zarith.\napply Z.lt_le_trans with 0%Z; auto with zarith.\napply Z.lt_le_trans with 1%Z; auto with zarith.\napply Z.lt_le_trans with (Z.pow_pos 2 2); auto with zarith.\napply Z.pow_lt_mono_pos_l; auto with zarith.\napply Z.pow_lt_mono_pos_l; auto with zarith.\napply Z.pow_gt_1;Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_upper_bound, ZRing.pow, ZRing.pow, ZRing.pow, ZRing.pow, ZRing.pow, ZRing.pow, ZRing.pow, ZRing.pow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow.pow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow.pow, Zpow, Zpow, Zpow, Zpow.pow, Zpow.pow.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nunfold Z in |- *; simpl in |- *.\nintros H; elim H; intros; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nintros; discriminate.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_upper_bound, Z, Z, Z, Z, Z, Z, Z, Z.pow, Z, Z.pow in |- *.\nsplit; red in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nunfold Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.pow, Z.pow in |- *.\nintros.\nrewrite Zmult_comm.\napply Zmult_integral_l with (p:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (Q:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (Q:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z) (P:=Z)Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *.\nunfold F_Z in |- *; simpl in |- *.\nrewrite Z_mult_distr_l_reverse; auto with zarith.\nsplit; auto with zarith.\nred in |- *.\nsplit; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nintros; discriminate.\nsplit; red in |- *.\nintros; discriminate.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *.\nauto with zarith.\nsplit.\nred in |- *; auto with zarith.\nintros.\napply Z_mult_reg_l with (Zpos p).\napply Z_mult_reg_l with (Zpos p).\nrewrite Zplus_comm; rewrite Zplus_opp_l; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZQuot, ZQuot, ZQuot, ZQuot, ZtrivZ, ZtrivZ, ZtrivZ, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_natQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zeginputizable, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.opp.\nintros.\napply Zmult_integral_l.\napply Z_mult_integral_l.\nunfold Rminus in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zic in |- *.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nchange (Z_of_nat 0) with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nrewrite Zmult_comm.\napply Zmult_reg_l with (Z_of_nat 0).\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zic_eq in |- *.\nunfold Zic_eq in |- *.\nunfold Zic_eq in |- *.\napply Z_mult_inv_l with (Z_of_nat 0); auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZernZ, ZernZ, ZernZ, ZSepZ, ZSepZ, ZSepZ, ZSepZ, ZSep_mult.\nunfold ZenZ, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd.\n\n(* This is a b c d : c <> d *)\n\nRequire Import ZArith.\nRequire Import Zcomplements.\n\n(* The list is not necessary when the number is not a positive *)\n\nDefinition Z_to_nat (x : Z) :=\n  match x with\n  | O => 1\n  | S n => 1 + x\n  end.\n\nDefinition Z_of_nat (x : Z) :=\n  match x with\n  | O => 1Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer,, Zer, Zer, Zer, Zer, ZQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZMP, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.opp in |- *.\nintros H; split.\napply Zmult_integral_l with (Z := Z); auto with zarith.\napply Zmult_integral_l with (Z := Z); auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZernZ, ZSep, Z mk_nat, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd, ZAdd;\n ring.\n\n(* Z is a ring *)\n\nDefinition Z_to_R := Z.to_R.\n\nTheorem Z_to_R_opp : Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- Z_to_R (- ZQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, Zer, ZerQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zic in |- *.\nrewrite Zmult_comm.\nrewrite Zmult_comm; rewrite Zmult_comm; apply Z_mult_nonneg_nonneg; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; simpl in |- *; case x; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros H1 H2; subst.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H2; trivial.\nintros; left; apply sym_equal; apply Z_mult_mult_simpl_l; auto.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H2; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H2; trivial.\nintros; left; apply sym_equal; apply Z_mult_simpl_l; auto.\nintros; left; apply sym_equal; apply Z_mult_simpl_l; auto.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H2; trivial.\nintros; left; apply sym_equal; apply Z_mult_simpl_l; auto.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H2; trivial.\nintros; right.\ngeneralize H; clear HQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H.\napply Z_upper_bound with (1 := H).\nunfold inversible in |- *.\nintros x H1; elim H1; intros; inversion H1; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; rewrite H; intros; apply H; apply inversibleZ; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; intros H1; case H1; intros H2; case H2; intros H3;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\n try discriminate; clear H1;\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; case x; intros Hx; case x; intros Hx; case x; intros Hx;\n case x; intros Hx; case x; intros Hx;\n case y; intros Hy; case y; intros Hy; case z; intros Hy;\n try (intros Hy1; case z1; intros Hy2; case z2; intros Hy3;\n try (intros Hy3; case z4; intros Hy3; case z4; intros Hy5; case z6; intros Hy6; \n try (intros Hy5; case z6; intros Hy6; intros Hy6; case z6; intros Hy6; \n try (intros Hy6; case z6; intros Hy6; intros Hy6; case z7; intros Hy7; \n try (intros Hy6; case z6; intros Hy6; intros Hy7; case z8; intros Hy7; \n try (intros Hy7; case z8; intros Hy8; intros Hy8; case z8; intros Hy8; \n try (intros Hy8; case z8; intros Hy8; intros Hy8; case z8; intros Hy8; \n try (intros Hy8; case zQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros.\napply sym_equal; apply Z_unitFirst_injective; auto.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; auto.\nintros; right; red in |- *; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; simpl in |- *.\nintros; left; rewrite H; rewrite H; rewrite H0; rewrite H0; ring.\nintros x1; right; rewrite H; rewrite H; rewrite H; rewrite H0; ring.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros H1; rewrite H1; clear H1; simpl in |- *.\nintros; left; left; assumption.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n",
                "context_tokens": 187,
                "proof_start_offset": 546,
                "proof_end_offset": 679,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros; elim H; auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Add, Add, add, add, opp, opp, opp, opp, opp.\nintros; elim H; auto with *.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Equal in |- *; auto with algebra.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros H; split; intros H'0; try assumption.\nsplit; auto.\napply Trans with (S O); auto with sets.\napply Trans with (S O); auto with sets.\napply Trans with (Add O E); auto with sets.\napply Trans with (Add O E E); auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros H' H' x y H'0; try assumption.\napply Trans with (x y); auto with algebra.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nred in |- *; intros; red in H0; case H0; auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\napply Trans with (Equal S O); auto with algebra.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros H' H' x y H'0; try assumption.\napply Trans with (Add (Add x y) (Add x y)); auto with sets.\napply Trans with (Add x (Add x (Add x y))); auto with sets.\napply Trans with (Add x (Add x (Add x y))); auto with sets.\napply Trans with (Add (Add x (Add x y))); auto with sets.\napply Trans with (Add x (Add x y)); auto with sets.\napply Trans with (Add x (Add x (Add x y))); auto with sets.\napply Trans with (Add (Add x (Add x y))); auto with sets.\napply Trans with (Add x (Add x y)); auto with sets.\napply Trans with (Add x (Add x (Add x y))); auto with sets.\napply Trans with (Add x (Add x y)); auto with sets.\napply Trans with (Add x (Add x y)); auto with sets.\napply Trans with (Add x (Add x y)); auto with sets.\napply Trans with (Add (Add x y)); auto with sets.\napply Trans with (Add x (Add x y)); auto withQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\napply (Build_Map (Ap:=fun x y : S => Equal (Add x y) (Add x y)) (fun x y : S => Equal (Add x y) (Add x y)).\nred in |- *.\nintros x y H' H'0; try assumption.\napply Trans with (Ap (sgroup_law _ x (sgroup_law _ x y)) (monoid_unit G));\n auto with algebra.\napply Trans with (Ap (sgroup_law _ x (sgroup_law _ x y)) (monoid_unit G));\n auto with algebra.\napply Trans with (Ap (sgroup_law _ x (sgroup_law _ x y)) (monoid_unit G));\n auto with algebra.\napply Trans with (Ap (sgroup_law _ x (sgroup_law _ x y)) (monoid_unit G));\n auto with algebra.\napply Trans with (Ap (sgroup_law _ x (sgroup_law _ x y)) (sgroup_law _ x y));\n auto with algebra.\napply Trans with (Ap (sgroup_law _ x (sgroup_law _ x (sgroup_law _ x y)) (group_inverse _ x));\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold Equal, Equal, Equiv, Equiv, Equiv, Equiv in |- *;\n split; intros; try assumption.\napply Sym; assumption.\napply Sym; assumption.\napply Sym; assumption.\napply Sym; assumption.\napply Sym; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Lci.v",
                "context": "\n(* Properties of the laws of internal composition. *)\n\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\nLemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n",
                "context_tokens": 267,
                "proof_start_offset": 760,
                "proof_end_offset": 981,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H H' H'0 H'1; apply opp_assoc; apply opp_comm; assumption.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H1 H2 x y H3 H4.\napply H1; apply opp_comm; assumption.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H1 H2; apply (opp_def x y H1 H2 H3).\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H H' H'0; red in |- *.\nelim H'; intros; elim (H1 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H H' H'0; split.\nexact (opp_def_eq H'0).\nexact (opp_def_eq H'0).\nexact (opp_def_eq H'0).\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').\nexact (opp_def_eq H' H').Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nintros; red in |- *; intros.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n clear H3 H1 H2 H3 H4; clear H3 H4;\n clear H3 H4; clear H4; clear H4;\n clear H4; clear H4; clear H4; clear H4; clear H4;\n clear H4; clear H4; clear H4; clear H4; clear H4.\napply Trans with (is_empty E); auto with algebra.\napply Trans with (is_empty E); auto with algebra.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H H' H'0; elim H'0; intros; elim H'1; intros; clear H'1.\napply opp_eq; trivial.\napply opp_eq; trivial.\napply opp_eq; trivial.\napply opp_eq; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply (Build_Map (Ap:=fun x : S => add_op (add_op x y)) (add_op x y));\n trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H1 H2; symmetry  in |- *; elim H1; intros; elim (H2 O H0); trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros; apply same_add; apply same_add; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n",
                "context_tokens": 114,
                "proof_start_offset": 397,
                "proof_end_offset": 1206,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H.\napply (mult_reg_l (A:=A) (B:=A) (B:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (x:=A) (y:=A) (y:=A) (y:=A) (y:=A) (y:=A) (y:=A) (y:=A) (z:=A) (y:=A) (y:=A) (z:=A) (y:=A) (y:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=A) (z:=Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H; elim H; clear H; intros H0; elim H0;\n clear H0; intros; elim H0; clear H0; intros; elim H1;\n clear H0; intros; elim H1; clear H1; intros; elim H2;\n clear H2; intros; elim H3; clear H3; intros; elim H4; clear H4; intros;\n elim H4; clear H4; intros; elim H4; clear H4; intros; elim H4;\n clear H4; intros; elim H5; clear H5; intros; elim H5; clear H5; intros;\n elim H5; clear H5; intros; elim H5; clear H5; intros; elim H5; \n clear H5; intros; elim H5; clear H5; intros; elim H5; clear H5; intros;\n elim H5; clear H5; intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5; intros;\n elim H6; clear H6; intros; elimQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'.\nunfold is_power in |- *.\nelim H'.\nintros x H'0; elim H'0; intros H'1 H'2; try exact H'2; clear H'0.\napply sym_equal; apply sym_equal; apply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FM.mult_reg_l x 1 H'0).\napply sym_equal; apply (FMQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\napply le_antisym.\napply H.\napply le_n_S.\napply le_trans with (S x).\napply H.\napply plus_n_Sm.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H.\napply (mult_reg_l (A:=A) (B:=A) (c:=c) H).\napply H.\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply H.\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_l (S x) (c:=c) H).\napply Trans with (c mX plus_reg_Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'; auto with arith.\nintros x0 y0 H'0; elim H'0; auto with arith.\nintros x0 y0 H'1; elim H'0; auto with arith.\nintros x1 y0 H'2; elim H'2; auto with arith.\nintros x2 y1 H'3; elim H'3; auto with arith.\nintros x3 y3 H'4; elim H'3; auto with arith.\nintros x4 y5 H'6; elim H'4; auto with arith.\nintros x5 y6 H'6; elim H'5; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'.\nintros x0 H'0; elim H'0.\nintros x1 H'1; elim H'0.\nintros x2 H'3; elim H'3; intros H'4 H'5; try exact H'5; clear H'3 H'4 H'5.\nsplit; [ try assumption | idtac ].\nauto with sets.\nauto with sets.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n",
                "context_tokens": 463,
                "proof_start_offset": 1208,
                "proof_end_offset": 1952,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H8; intros; elim H7; intros; \n elim H7Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H7;Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim (mult_comm x y); intros.\nelim (mult_comm x y); intros.\nelim (mult_comm x y); intros.\nelim H2; intros.\nrewrite H9; rewrite H10; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n rewrite H6; rewrite H5; rewrite H6; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n rewrite H4; rewrite H5; rewrite H5; rewrite H5; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H; intros.\nelim H2; intros.\nelim H4; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \nsplit.\n(* [x*0 = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* [0*x = 0] *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n",
                "context_tokens": 721,
                "proof_start_offset": 1954,
                "proof_end_offset": 2696,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim HQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; \n rewrite H5; rewrite H6; rewrite H6; rewrite H7; ring.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16 H17 H18.\nelim (H7 x y); intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5;Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    rewrite H5; rewrite H5; rewrite H6; ring.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 2698,
                "proof_end_offset": 3190,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n generalize (mult_n_O (x + y) x H4); rewrite H5; \n auto.\nQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elimQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3490,
                "proof_end_offset": 3729,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nintros H H'; elim H'; intros H'0; elim H'0; intros;\n elim H'0; intros; clear H'0 H'0; clear H'0 H'0; intros.\nelim H'0; intros; clear H'0 H'1; intros; elim H'0; intros; clear H'0 H'1.\nexists x; split; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros H H0.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H3; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros H H.\nelim H; intros; elim H0; intros; elim H1; intros; clear H1 H2 H3;\n intros q H0 H1; elim H2; intros; elim H2; intros; clear H2 H3 H4 H5;\n intros q H0 H1; elim H3; intros; clear H3 H4 H5 H6 H7 H8 H9;\n intros q H0 H1; elim H2; intros; clear H2 H3 H4 H5 H6 H7 H8 H9 H10;\n intros q H0 H1; elim H2; intros; clear H2 H3 H4 H5 H6 H7 H8 H9 H10;\n intros q H0 H1; elim H2; intros; clear H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19;\n intros q H0 H1; elim H2; intros; clear H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nsimple induction 1.\nintros.\nsplit; try assumption.\napply div_O_O.\nintros.\nsplit; try assumption.\nelim H; intros; clear H; intros q H0; elim H0; intros.\nelim H1; intros; clear H1; intros; elim H1; intros; clear H1; intros.\nelim H2; intros; clear H2; intros.\nelim H4; intros; clear H5; intros; elim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros.\nelim H6; intros; clear H6; intros; elim H7; intros; clear H6; intros.\nexists x0; split; try assumption.\nexists x1; split; try assumption.\nexists x1; split; try assumption.\nelim H7; introsQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros H H.\nsplit; try exact H; clear H.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H; clear H.\nintros.\nsplit; try exact H;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro H; elim H; intros; elim H0; intros; clear H0 H1; intros; elim H1;\n intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H5 H6 H7 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H20 H20 H19 H20 H21 H22 H23 H24 H26 H27 H29 H30 H31 H32 H33 H34 H24 H25 H26 H29 H30 H31 H32 H33 H34 H35 H36 H37 H37 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49 H49 H46 H47 H48 H49 H48 H49).\n\nDefinition div_nat (a b : S) :=\n  A (B a + B b + CQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros.\nsplit; intros.\napply (H (S O) (S O)); auto with arith.\nsplit; auto.\napply (H (S O) (S (S O))); auto with arith.\nsplit; auto.\napply (H (S O) (S (S O))); auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros H H'.\napply O_ind_r with (A := Div); auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintros H H0.\napply (H (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S O)))))))).\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n    elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n    elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n    clear H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n    clear H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n    clear H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro H; elim H; intros; elim H; intros; auto.\nelim H; intros; auto.\nelim H0; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1; intros; auto.\nelim H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "Opp y) y); intros; rewrite H0; auto.\nQed.\n\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3731,
                "proof_end_offset": 4957,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1 H2; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros.\nsplit.\napply (div_O_le_reg_l (fun q : S => mult_reg_l (S q) (S q)) b d).\nexact (div_O_le_reg_l (fun q : S => mult_reg_l (S q) (S q)) b d).\nexact (div_O_le_reg_l (fun q : S => mult_reg_l (S q) (S q)) b d).\nexact (div_O_le_reg_l (fun q : S => mult_reg_l (S q) (S q)) b d).\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0; elim H; intros; elim H0; intros; elim H2; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H10; intros; elim H11; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0.\napply (H (fun d : S => mult_reg_l a b d) (S_le_reg_l a b d)); auto.\napply (H0 (fun d : S => mult_reg_l a b d) (S_le_reg_l a b d)); auto.\napply (H (fun d : S => mult_reg_l a b d) (S_le_reg_l a b d)); auto.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1.\nsplit.\napply (div_div_aux b d a H H0 H1 H2).\napply (div_div_aux b d b H H1 H2).\napply (div_div_aux b d b H H1 H2).\napply (div_div_aux b d b H H1 H2).\napply (div_div_aux b d a H H1 H2).\napply (div_div_aux b d b H1 H2).\napply (div_div_aux b d b H H1 H2).\napply (div_div_aux b d a H H1 H2).\napply (div_div_aux b d a H H1 H2).\napply (div_div_aux b d b H1 H2).\napply (div_div_aux b d b H H2).\napply (div_div_aux b d b H H1 H2).\napply (div_div_aux b d b H H1 H2).\napply (div_div_aux b d a H H1 H2).\napply (Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H12; intros; elim H12; intros; elim H10; intros; elim H10; intros; elim H10; intros;\n elim H11; intros; elim H11; intros; elim H11; intros; elim H12; intros; elim H11; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0 H1 H2; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elimQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0; elim H0; intros; elim H0; intros; elim H0; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H8; intros; elim H7; intros; elim H7; intros;\n elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0.\nrewrite <- (mult_n_O a b d).\nrewrite <- (mult_n_O a b d).\nrewrite <- (mult_n_O a b d).\nrewrite <- H1.\nrewrite (mult_n_O a b d).\nrewrite <- H1.\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nrewrite (mult_n_O a b d).\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nintros a b d H H0.\napply (div_O_O (fun a b => mult_comm a b) (fun a0 : S => mult_comm b a) (fun a0 : S => mult_comm a b)).\napply (div_O_O (fun a b => mult_comm a b) (fun a0 : S => mult_comm b a) (fun a0 : S => mult_comm b a)).\napply (div_O_O (fun a b => mult_comm b a) (fun a0 : S => mult_comm b a) (fun a0 : S => mult_comm b a0)).\nexact H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": " O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\nTheorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\n(* [A d] *)\nelim H0; trivial.\nsplit.\n(* [A (a+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 4959,
                "proof_end_offset": 5659,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d; elim (mult_comm b d); intros.\nrewrite (mult_comm a b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewriteQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div_mult in |- *; intros.\nelim H; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; clear H0 H1.\nelim H1; intros; elim H0; intros; elim H1; intros; elim H0; intros; clear H0 H1.\nelim H1; intros; elim H2; intros; elim H3; intros; clear H3 H4.\nelim H2; intros; elim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H3; intros; elim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H3; intros; clear H3 H4.\nelim H4; intros; clear H3 H4.\nelim H4Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div_mult in |- *; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n clear H4 H5 H6.\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H2 H3 H4 H5 H6.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3;\n clear H2 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H0; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4;\n clear H4 H5 H6.\nexists (S x0).\nsplit.\n(* [x0|x0] *)\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div in |- *; intros.\nelim H; intros; elim H; intros; elim H; intros; clear H H0 H1.\nelim H0; intros; elim H0; intros; clear H0 H1.\nelim H1; intros; elim H1; intros; clear H1 H2.\nexists (S x1).\nsplit.\nunfold div in |- *; rewrite H3; rewrite H4; rewrite H5; ring.\napply div_mult.\nrewrite H1; ring.\napply div_mult.\nrewrite H1; ring.\napply div_mult.\nrewrite H1; ring.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div_mult in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; clear H3 H4.\nelim H1; intros; elim H3; intros; elim H4; intros; elim H4; intros; clear H4 H5.\nelim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; clear H4 H5.\nelim H4; intros; elim H4; intros; elim H5; intros; clear H5 H6.\nelim H5; intros; elim H5; intros; elim H5; intros; clear H5 H6.\nexists (Div r); split.\nexact (proj1 H5).\nelim (H1 H2); intros; elim H5; intros; clear H5 H6.\nexists (Div r); split.\nexact (proj1 H5).\nelim H6; intros; elim H5; intros; elim H5; intros; clear H5 H6.\nexists (Div r); split.\nexactQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; clear H0 H1.\nelim H1; intros; elim H1; intros; clear H1 H2.\nelim H2; intros; clear H2 H3.\nelim H3; intros; clear H3.\nelim H3; intros; clear H3.\nelim H3; intros; clear H3.\nelim H3; intros; clear H3.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelimQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H0; intros; clear H0 H1.\nelim H1; intros; clear H1 H2.\nexists (S x0).\nsplit.\n(* [a] *)\nelim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H5; intros; elim H6Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nintros a b d H H0; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elimQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14.\nelim H0; intros; elim H3; intros; clear H3 H4.\nelim H0; intros; clear H0 H2.\nelim H2; intros; clear H3 H4 H5 H6 H7 H8 H9 H10 H11 H11 H12 H13 H14 H15 H16.\nelim H0; intros; clear H0 H4 H5.\nelim H0; intros; clear H0 H1 H2.\nelim H1; intros; clear H1 H2.\nelim H2; intros; clear H2 H4.\nelim H4; intros; clear H4 H5 H6.\nelim H5; intros; clear H5 H6.\nelim H6; intros; clear H5 H6.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold div_mult in |- *; intros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; clear H H0 H1.\nelim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; clear H2 H3.\nelim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; clear H3 H4 H5.\nelim H0; intros; elim H3; intros; elim H3; intros; clear H3 H4 H5.\nelim H0; intros; elim H3; intros; elim H3; intros; clear H3 H4 H5.\nelim H0; intros; elim H3; intros; clear H3 H4 H5.\nelim H0; intros; elim H4; intros; clear H4 H5 H6.\nelim H1; intros; elim H4; intros; clear H4 H5.\nelim H4; intros; elim H4; intros; clear H5 H6.\nelim H0; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "+b)] *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* [a+b = 0 or d <> 0 and a+b = d*q] *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* [a = 0] *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* [b = 0] *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* [a <> 0 and b <> 0] *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 5661,
                "proof_end_offset": 6477,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold div_mult in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim HQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nsplit.\nexact (proj1 (H2 H0)).\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nsplit.\nexact H.\nintros; exact H0.\nintros; exact H0.\nintros; exact H0.\nintros; exact H0.\nintros; exact H0.\nintros; exact H0.\nintros; exact H1.\nintros; exact H1.\nintros; exact H1.\nintros; exact H1.\nintros; exact H1.\nintros; exact H1.\nintros; exact H1.\nintros; exact H2.\nintros; exact H2.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.\nintros; exact H3.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H H0.\napply div_opp.\napply le_mult_inv_l; trivial.\napply le_trans with (div a b).\napply div_opp; trivial.\napply div_mult; trivial.\napply le_trans with (div a b).\napply div_opp; trivial.\napply div_opp; trivial.\napply le_trans with (div a b).\napply div_opp; trivial.\napply div_opp; trivial.\napply le_trans with (div a b).\napply div_opp; trivial.\napply le_trans with (div a b).\napply div_mult; trivial.\napply le_trans with (div a b).\napply div_mult; trivial.\napply div_mult; trivial.\napply le_trans with (div a b).\napply div_mult; trivial.\napply div_mult; trivial.\napply le_trans with (div a b).\napply div_mult; trivial.\napply div_mult; trivial.\napply le_trans with (div a b).\napply div_mult; trivial.\napply div_mult; trivial.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H8; intros;\n elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros;\n elim H10; intros; elim H10; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H11; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elimQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold div in |- *; intros.\n(* [a*b = 0] *)\nelim H0; intros.\nsplit.\nexact H1.\nexact H1.\nexact H2.\nexact H2.\nexact H2.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H4.\nexact H3.\nexact H4.\nexact H3.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H5.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H; elim H; intros; elim H; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; clear H2 H3.\nexists (div b a).\nunfold div, div, div in |- *.\nrewrite div_mul_div; try assumption.\nrewrite <- (mult_comm a b) at 1.\nrewrite <- H1.\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm a b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm a b).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm b d).\nrewrite (mult_comm d b).\nrewrite (mult_comm d b).\nrewrite (mult_comm b d).\nrewrite (mult_comm dQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *.\nintros.\nelim H; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; clear H5 H6.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5;Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H H0.\napply (div_intro a b d H H0).\napply div_opp; assumption.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a b d H H0.\nunfold divide in |- *.\nelim H; intros.\nrewrite H0.\nelim H; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros;\n elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* [A (a*b)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6601,
                "proof_end_offset": 6974,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nsplit.\nexact H1.\nelim H2; intros.\nsplit.\nexact H3.\nexact H3.\nsplit.\nexact H3.\nexact H4.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit.\nsplit; [ assumption | intros; apply (divide_abs_l a); assumption ].\nsplit; [ assumption | intros; apply (divide_abs_l a); assumption ].\nsplit; [ assumption | intros; apply (divide_abs_l a); assumption ].\nsplit.\nelim H; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros;Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nsplit.\nexact (gcd_sym (gcd_sym (gcd_sym (gcd_sym a b) (gcd_sym a b) H)).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit; intro H.\nsplit; intro; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintros p H; split; intro H; discriminate H.\nintrosQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b E.\nsplit.\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nsplit; [ exact H | exact H ].\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b E H0 H1.\nsplit.\nexact (gcd_intro a b E H1).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\nsplit.\napply (gcd_intro a); exact (gcd_intro a).\nelim (gcd_intro b); intros.\nsplit.\nexact (gcd_intro a).\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16 H17 H18 H19.\nrewrite (mult_comm (S a) (S a) (S a) (S a) (S a) (S a) (S a) H9 H10 H11).\nrewrite (mult_comm (S a) (S a) (S a) (S a) (S a) (S a) H9 H10 H11).\nrewrite (mult_comm (Qed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\nsplit.\nexact (gcd_uniqueness a b H). \nexact (gcd_uniqueness a b H).\nexact (gcd_uniqueness a b H).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit; intros; apply (gcd_intro (a, b)).\nrewrite <- H; rewrite <- H0; apply divide_refl.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0.\napply gcd_unique with b; assumption.\napply gcd_sym; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* [a*b = 0 or d <> 0 and a*b = d*q] *)\n  (* [a = 0] *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 6976,
                "proof_end_offset": 7247,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H2; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H7; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7;\n intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros;\n elim H10; intros; elim H11; intros; elim H12; intros; elim H12; intros; elim H12;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nelim H1; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9;\n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros;\n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; introsQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n    elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n    elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n    elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros;\n    elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros;\n    elim H10; intros; elim H10; intros; elim H10; intros;\n    elim H10; intros; elim H10; intros; elim H10; intros;\n    elim H10; intros; elim H10; intros; elim H10; intros;\n    elim H10; intros; elim H10; intros; elim H10; intros; elimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\n unfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "2.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\n(* [A d] *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* [A (-a)] *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* [(-a) = 0 or d <> 0 and (-a)= d*q] *)\n  (* [a = 0] *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* [a <> 0] *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 7249,
                "proof_end_offset": 8153,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_upper_bound in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H6; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H8; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\napply (Build_Map (A:=A) (B:=A) (B:=A) (c:=a)).\nred in |- *; intros.\nelim H0; intros; elim H1; intros; elim H2; intros.\nelim H9; intros.\nelim H11; intros.\nsplit.\nexact H10; exact H10.\nelim H9; intros.\nsplit.\nexact H10; exact H10.\nexact H10; exact H10.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim H; intros.\nelim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros.\nelim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros.\nelim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H4; intros; elim H4; intros.\nelim H5; intros.\nsplit.\nexact H6.\nexact H6.\nexact H6.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_factor,non_zero in |- *; intros.\nelim H; intros; elim H0; intros.\nelim H2; intros; elim H4; intros; elim H6; intros.\nelim H5; intros; elim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros; elim H6; intros; elim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros a x H H0.\nrewrite (mult_comm (div_inv a x) (div_inv a x) H0).\nrewrite (mult_comm (div_inv a x) (div_inv a x) H0).\nrewrite (mult_comm (div_inv a x) (div_inv a x) H0).\nrewrite <- (mult_comm (div_inv a x) (div_inv a x) H0).\nrewrite <- H2; rewrite (mult_comm (div_inv a x) (div_inv a x) H0).\nrewrite <- H3; rewrite <- H3; ring.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nunfold is_upper_bound in |- *.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim H7; intros; elim H7; intros.\nelim H7; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H11; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros a x H H0 H1 H2; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H5; intros.\nelim H8; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nunfold is_upper_bound in |- *.\nelim H; intros; elim H2; intros.\nsplit.\nexact H2.\nintros.\nsplit.\nexact H3.\nintros.\nsplit.\nexact H3.\nexact H4.\nintros.\nsplit.\nexact H3.\nexact H3.\nintros.\nsplit.\nexact H3.\nexact H3.\nintros.\nsplit.\nexact H4.\nexact H4.\nexact H4.\nintros.\nsplit.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "rewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n",
                "context_tokens": 684,
                "proof_start_offset": 8155,
                "proof_end_offset": 9563,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros.\nexists x; exists y; auto.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim HQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\n intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n   elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros;\n   elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros;\n    elimQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nsplit; intros.\nexists (fun x : S => is_gcd x (gcd x (gcd x (gcd y x))) d).\nsplit; intros.\nsplit.\napply H.\nunfold is_gcd in |- *; simpl in |- *.\nrewrite <- (abs_eq_pos (abs x)) in H; auto with arith.\nrewrite <- (abs_eq_pos (abs x)) in H; auto with arith.\napply H.\nunfold is_gcd in |- *; simpl in |- *.\nrewrite <- (abs_eq_pos x) in H; auto with arith.\nexists (abs x); split; simpl in |- *; auto with arith.\napply H.\nunfold is_gcd in |- *; simpl in |- *.\nrewrite <- (abs_eq_pos x) in H; auto with arith.\napply H.\nunfold is_gcd in |- *; simpl in |- *.\nrewrite <- (abs_eq_pos x) in H; auto with arith.\nrewrite <- (abs_eq_pos x) in H; auto with arith.\napply H.\nunfold is_gcd in |- *; simpl in |- *.\nrewrite <- (Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\n intros.\nelim H; intros; elim H0; intros; elim H0; intros.\nexists x; exists y; split; auto.\nelim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros.\nexists x; split; auto.\nexists x; split; auto.\nexists x; split; auto.\nexists x; split; auto.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nsplit; intros; auto with arith.\nexists (S x).\nsplit; intros; auto with arith.\nexists (S x).\nsplit; intros.\napply (alt_eq (fun m n : nat => plus_le_compat_l n n m) (S x) H0 H1).\napply (alt_eq (fun m n : nat => plus_le_compat_l n m) (S x) H1 H2).\napply plus_le_compat_l; auto with arith.\napply (alt_eq (fun m n : nat => plus_le_compat_l n m) (S x) H0 H1).\napply plus_le_compat_l; auto with arith.\napply (alt_eq (fun m n : nat => plus_le_compat_l n m) (S x) H1 H2).\napply plus_le_compat_l; auto with arith.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\n intros.\napply (gcd_uniqueness (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\n intros.\nelim H; intros; elim H1; intros; elim H2; intros.\nexists x; exists y; split; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/rings.v",
                "context": "elim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* [d2 = O] *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* [d2 <> 0] *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* [d1 <> 0] *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 9565,
                "proof_end_offset": 9774,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10;\n intros; elim H9; intros; elim H11; intros; elim H12; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H11; intros; elim H10; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H H0.\nrewrite <- (opp_def x).\nrewrite <- (opp_def x).\napply opp_inj; trivial.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elimQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros.\nelim (opp_pos_not_O _ H1); intros; elim H2; intros.\nexists x0.\nsplit.\nunfold opp in |- *; simpl in |- *; auto with arith.\nsplit.\napply opp_inj; auto with arith.\napply opp_inj; auto with arith.\napply opp_inj; auto with arith.\napply opp_inj; auto with arith.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H; elim H; intros; elim H0; intros.\nexists (S x0).\nsimpl in |- *; auto.\nelim H1; intros.\nexists (S x0).\nsimpl in |- *; auto.\nelim H2; intros.\nexists x0.\nsimpl in |- *; auto.\nelim H5; intros.\nexists (S x0).\nsimpl in |- *; auto.\nelim H5; intros.\nexists x1.\nsimpl in |- *; auto.\nelim H5; intros.\nexists x1.\nsimpl in |- *; auto.\nelim H5; intros.\nexists (S x1).\nsimpl in |- *; auto.\nelim H5; intros.\nexists (S x1).\nsimpl in |- *; auto.\nelim H5; intros.\nexists (S x1).\nsimpl in |- *; auto.\nelim H5; intros.\nexists (S x1).\nsimpl in |- *; auto.\nelim H5; intros.\nexists x1.\nsimpl in |- *; auto.\nelim H5; intros.\nexists (S x2).\nsimpl in |- *; auto.Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6;Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H8; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elimQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\napply (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eq (opp_eqQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros x H.\nelim H; intros; elim H; intros; elim H0; intros.\nexists x0.\nelim H; intros.\nexists x; elim H1; intros.\nexists x0; elim H2; intros.\nexists x0; elim H3; intros.\nexists x1; elim H4; intros.\nexists x2.\nsplit.\nunfold opp_seq, opp_seq, opp_seq, opp_seq, opp_seq in |- *.\nreplace (1 - x) with (- x1) in |- *.\napply opp_inj; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewrite opp_eq; trivial.\nrewriteQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nrewrite <- (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_eq_zero x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  destruct H as (x0,H).\n  destruct (H (fun x => P x)) as (x0,H0).\n  exists x0.\n  split.\n  exact (H x0).\n  exact (fun x => H x0).\n  exact (fun x => H x0).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x0; case H; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0.\n  destruct (H x0) as (y, Hy).\n  destruct (H y) as (y, Hy).\n  left. now apply H.\n  right. now apply H.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros.\nexact (fun x : A => P (proj1_sig x)) (fun x : A => P (proj1_sig x)) (fun x : A => P (proj1_sig x)) H0).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x.\n  destruct H.\n  left; assumption.\n  left; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0 H1.\n  destruct (H1 (fun _ : A => P) H1) as (x1,H2).\n  exists x0; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  destruct H as [H0 H1].\n  destruct H0.\n  left.\n  apply H.\n  left.\n  exact H.\n  right.\n  exact H.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x0.\ncase H.\nintros x0 y0.\ncase H.\nintros y1 y2.\ncase H.\nintros x1 y2.\ncase H0.\nintros y3.\ncase H0.\nintros x2 y3.\ncase H1.\nintros x3 y4.\ncase H4.\nintros x4 y5.\ncase H5.\nintros x5 y6.\ncase H6.\nintros x5 y6.\ncase H6.\nintros x6 y7.\ncase H8.\nintros x6 y7.\ncase H8.\nintros x7 y8.\ncase H8.\nintros x9 y10.\ncase H10.\nintros x9 y11.\ncase H10.\nintros x11 y12.\ncase H11.\nintros x13 y14.\ncase H11.\nintros x12 y12.\ncase H11.\nintros x13 y14.\ncase H11.\nintros x15 y11.\ncase H11.\nintros x12 y13.\ncase H13.\nintros x14 y15.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P P H x0.\n  case H; intros H'0; try exact H'0; clear H'.\n  left; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x.\n  destruct H.\n  apply H0.\n  right.\n  assumption.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\n simple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x; split; auto.\nintros; apply inv_trans with y; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x0; auto.\napply inv_trans with (2 := H2); auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; try discriminate.\nexists x0; exists y; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x0; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; trivial.\nexists I; exists I; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (fun x y : S => I (S x) (S y)).\nauto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (fun x : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S => I (fun _ : S =>Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; simpl in |- *; auto.\nintros x y H1 H2 H3.\napply H0.\nexists y; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H0.\nexists x0; split; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists I; split; trivial.\nelim H1; intros.\nexists x0; split; trivial.\nQed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\n",
                "context_tokens": 200,
                "proof_start_offset": 1664,
                "proof_end_offset": 2222,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H'0; elim H'0; intros H'1 H'2; elim H'2; intros H'3 H'4;\n clear H'0.\napply Trans with (Ap y); auto with sets.\napply Trans with (Ap y); auto with sets.\napply Trans with (Ap y); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros y z H' H'0 H'1; try assumption.\napply Trans with (sgroup_law G y); auto with sets.\napply Trans with (sgroup_law G y); auto with sets.\napply Trans with (sgroup_law G y); auto with sets.\napply Trans with (sgroup_law G y); auto with sets.\napply Trans with (sgroup_law G y); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H'0; try assumption.\napply Trans with (G x); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H'0; elim H'0.\nintros H'1 H'2; elim H'2; intros H'3 H'4; try exact H'4; clear H'2.\nexists x; split.\napply Trans with (sgroup_law R (group_inverse R x) (group_inverse R y)); auto with *.\napply Trans with (sgroup_law R (group_inverse R x) (group_inverse R y)); auto with *.\napply Trans with (sgroup_law R (group_inverse R x) (group_inverse R y));\n auto with *.\napply Trans with (sgroup_law R (group_inverse R x) (group_inverse R y)); auto with *.\napply Trans with (sgroup_law R (group_inverse R y) (group_inverse R y));\n auto with *.\napply Trans with (sgroup_law R (group_inverse R y) (group_inverse R y));\n auto with *.\napply Trans with (sgroup_law R (group_inverse R y) (group_inverse R y));\n auto with *.\napply Trans with (sgroup_law R (group_inverse R yQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nelim H.\nintros H' H'0; elim H'0; intros H'1 H'2; try exact H'2; clear H'0.\nelim H'; intros H'0 H'1; try exact H'1; clear H'0.\nelim H'; intros H'0 H'1; try exact H'1; clear H'1.\nelim H'; intros H'0 H'2; try exact H'2; clear H'2.\nelim H'; intros H'0 H'2; try exact H'2; clear H'2.\nelim H'0; intros H'0 H'2; try exact H'2; clear H'2.\nelim H'0; intros H'0 H'2; try exact H'2; clear H'2.\nelim H'0; intros H'0 H'2; try exact H'2; clear H'2.\nelim H'0; intros H'1 H'2; try exact H'2; clear H'2.\nelim H'0; intros H'1 H'2; try exact H'2; clear H'2.Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; intros.\napply H1.\napply Trans with (G y); auto with sets.\napply Trans with (G y); auto with sets.\napply Trans with (G y); auto with sets.\napply Trans with (G y); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nsimple induction 1; intros H' H'0; try assumption.\napply Trans with (G x); auto with sets.\napply Trans with (G y); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros; elim H; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\ncut (G x /\\ G x /\\ G x).\nintros H' H'0; elim H'0; intros H'1 H'3; clear H'0.\nelim H'0; intros H'3 H'4; clear H'0.\napply H'0; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H'0; elim H'0; auto with sets.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 434,
                "proof_start_offset": 2239,
                "proof_end_offset": 2567,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H6; intros; elim H9;\n clear H5 H6 H7.\n(* use of neutral *)\nelim (H0 y1); intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7;\n clear H5 H6 H7 H8.\n(* on natural *)\nelim (H0 y1); intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10.\n(* on natural *)\nelim (H0 y1); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10.\n(* on natural *)\nelim (H0 y1); intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10.\n(* on natural *)\nelim (H0 y1); intros; elim H6; intros; elimQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n clear H0 H1 H2.\n(* use of right side *)\nelim (H0 y1 H0); intros; elim H0; intros; elim H0; intros; elim H1; intros;\n clear H0 H1 H2.\n(* of right side *)\nelim (H0 y1 H0); intros; elim H0; intros; elim H1; intros; elim H1; intros;\n clear H1 H2.\n(* of left side *)\nelim (H0 y1 H0); intros; elim H1; intros; elim H1; intros; elim H2; intros;\n clear H1 H2.\n(* of right side *)\nelim (H0 y1 H0); intros; elim H1; intros; elim H2; intros; elim H3; intros;\n clear H3 H4 H5 H6 H7 H8 H9 H10; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H2;\n [ clear H3 H4 | intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n [ clear H3 H4 | intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n [ clear H5 H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n [ clear H5 H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n [ clear H5 H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n [ clear H5 H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6; intros; elim H6; intros; elim H5; intros; elim H5;\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros.\nclear H4 H5 H6 H7 H8 H9.\n(*\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x2 y1).\nrewrite (mult_comm x2 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x2 y2).\nrewrite (mult_comm x2 y1).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x2 y2).\nrewrite (mult_comm x2 y1).\nrewrite (mult_comm x2 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x2 y1).\nrewrite (mult_comm x2 y2).\nrewrite (mult_comm x1 y2).\nrewrite (mult_comm x2 y1).\nrewrite (mult_comm xQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros x1 y1 x2 y2.\nrewrite (add_commut x1 y1 x2 y2).\nrewrite (add_commut x2 y1 y2).\nrewrite (add_commut y1 y2 x2 y2).\nrewrite (add_commut x1 y2 x2 y2).\nrewrite (add_commut y2 y1 x2 y2).\nrewrite (add_commut x1 y2 x2 y2).\nrewrite (add_commut y1 x2 y2).\nrewrite (add_commut y1 x2 y2).\nrewrite (add_commut x2 y2 x2 y2).\nrewrite (add_commut y1 x2 y2).\nrewrite (add_commut y1 x2 y2).\nrewrite (add_commut y2 x2 y2).\nrewrite (add_commut x1 y2 x2 y2).\nrewrite (add_commut x2 y2 x2 y2).\nrewrite (add_commut y1 x2 y2).\nrewrite (add_commut y2 x2 y2).\nrewrite (add_commut y2 x2 y2).\nrewrite (add_Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nunfold Add in |- *.\nintros x1 y1 x2 y2 H H0 H1; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* of scalar *)\napply (Build_Map (A:=A) (B:=A) (B:=A) (B:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C':=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (C:=A) (CQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros x1 y1 x2 y2 H1 H2; rewrite <- H2; rewrite <- H2; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros.\nclear H4 H5.\nrewrite <- H2; rewrite <- H4; rewrite <- H1; rewrite <- H2; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n clear H0 H1 H2.\nelim (H0 (S x1) x1); intros; elim H0; intros; elim H0; intros; elim H1; intros;\n clear H1 H2 H3 H4.\nelim (H0 (S x1) x2); intros; elim H0; intros; elim H1; intros; elim H1; intros;\n clear H0 H1 H2.\nrewrite H0.\nrewrite (plus_comm x1 y2).\nrewrite (plus_comm x2 y2).\nrewrite (plus_comm x2 y1).\nrewrite (plus_comm x1 y2).\nrewrite (plus_comm x1 y2).\nrewrite (plus_comm x1 y2).\nrewrite (plus_comm x2 y2).\nrewrite (plus_comm x1 y2).\nrewrite (plus_comm x2 y1).\nrewrite (plus_comm x2 y2).\nrewrite (plus_comm x1 y2).\nrewrite (plus_comm x1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "                                                  *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 groups.v                                 *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\n\n(*****************************************************************************)\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 549,
                "proof_start_offset": 2588,
                "proof_end_offset": 3197,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H H0 H1.\nrewrite <- (inv_mult (S x) (S y) x).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nrewrite <- (inv_mult (S x) y x H).\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H'; elim H'; intros; elim H'; intros; elim H'; intros; elim H';\n clear H'.\nelim (H'0 y H'); intros; elim H'0; intros; elim H'0; intros; elim H'0;\n clear H'0 H'1.\nrewrite (inv_add x1 y1) in H'1; rewrite (inv_add x1 y1) in H'1; assumption.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H4;\n clear H4 H5 H6 H7 H8.\nrewrite (inv_add x1 y1) in H2; rewrite (inv_add x2 y2); elim (inv_add x1 y1 y2);\n try assumption.\napply sym_equal; apply (f_equal S); apply (f_equal S); apply (f_equal S);\n apply (f_equal S); apply (f_equal S);\n apply (f_equal S); apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S); apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n apply (f_equal S);\n applyQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive y); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H H0.\nrewrite (inv_l x y H0); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (inv_zero (S x) y); auto with algebra.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H'; elim H'; intros; elim H'; intros; elim H'; intros; elim H'.\nclear H'; rewrite H'0; rewrite (inv_inv x1 y1); rewrite (inv_inv x2 y2);\n auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive x); trivial.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (inv_l x y H); elim (inv_l x y H); trivial.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (opp_involutive x y); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": " Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n(*****************************************************************************)\n\n(*****************)\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n(**************)\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\n\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\n",
                "context_tokens": 733,
                "proof_start_offset": 3214,
                "proof_end_offset": 3568,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive (opp_involutive (opp x))).\nrewrite (opp_involutive (opp x)).\nrewrite opp_involutive; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite (opp_involutive x); reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <-opp_opp.\nrewrite <-opp_opp.\nrewrite <-opp_opp; rewrite opp_involutive; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite opp_involutive; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp; auto.\nrewrite <-opp_opp;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H9;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10;\n intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H10; intros;\n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elimQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros x H.\nunfold opp_seq in |- *.\nrewrite opp_add; rewrite opp_opp; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite opp_involutive; auto.\nrewrite oppQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold Rdiv; rewrite (Ropp_involutive (opp (opp x)) (opp x));\n rewrite (opp_involutive (opp (opp x)) (opp (opp x)));\n rewrite (opp_involutive (opp (opp x)) (opp (opp x)));\n rewrite (opp_involutive (opp x));\n rewrite (opp_involutive (opp (opp (opp x)) (opp (opp (opp x)));\n rewrite (opp_involutive (opp (opp (opp x)) (opp (opp x)));\n rewrite (opp_involutive (opp x)) (opp_involutive (opp (opp x)));\n rewrite (opp_involutive (opp (opp (opp x)) (opp (opp (opp x)));\n rewrite (opp_involutive (opp_involutive (opp x)));\n rewrite (opp_involutive (opp (opp (opp (opp x)));\n rewrite (opp_involutive (opp (opp x)) (opp x)); \n rewrite (opp_involutive (opp (opp x)) (opp_involutive (opp x));\n rewrite (opp_involutive (opp x))\n.\n(* (x+y) = (-x) + -y *)\nelim H; intros.\nrewriteQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold opp_seq in |- *.\nelim H; intros; elim H1; intros; elim H2; intros; clear H3 H4 H5;\n elim H3; intros; clear H3 H4 H5;\n elim H4; intros; clear H4 H5 H6; rewrite H5; clear H4 H5 H6 H7 H8 H9;\n elim H4; intros; clear H5 H6; rewrite H5; clear H5 H6 H7 H8 H9;\n elim H5; intros; clear H5 H6; rewrite H5; clear H5 H6 H7 H8 H9;\n elim H5; intros; clear H5 H6; rewrite H5; clear H5 H6 H7 H8 H9;\n elim H5; intros; clear H5 H6; rewrite H5; clear H5 H6 H7 H8 H9;\n elim H5; intros; clear H5 H6 H7; rewrite H5; clear H5 H6 H7 H8 H9;\n elim H5; intros; clear H5 H6; rewrite H5; clear H5 HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) at 1.\nrewrite <- (opp_involutive x) atQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold opp_seq; rewrite opp_involutive; trivial.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- H; rewrite <- H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n(************)\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\n\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n(****************)\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\n\nProof.\nintros.\n(* G y *)\nelim H0; intros; elim H2; intros.\n(* y = 0+y *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* 0=(-x)+x *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\n",
                "context_tokens": 716,
                "proof_start_offset": 3585,
                "proof_end_offset": 4727,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive y).\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive y).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold Basics in |- *.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (oppQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <-opp_opp.\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <- (opp_opp x).\nrewrite <-opp_opp.\nrewriteQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\n\nDefinition opp_inv (x y : S) : S := Equal (opp_inv x) (opp_inv y).\n\nLemma opp_inv : forall x y : S, x = y -> x = y.\nProof.\nintros.\nunfold opp_inv in |- *.\nelim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H0)).\nelim (Rlt_irrefl _ (Rlt_le_trans _ _ _ H H0)).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/groups.v",
                "context": "\n(* ((-x)+x)+y=(-x)+(x+y) *)\nelim (H7 (Opp x) x y).\n(* x+y = 0 *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* (-x)+0=(-x) *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n(************)\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\n\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n(************)\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\n\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* G (x+y) *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* G ((-x)+(-y)) *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* (x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0 *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* x+(-x) = 0 (-x)+x = 0 *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* y+(-y) = 0 (-y)+y = 0 *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* 0+0 = 0 *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n(****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 4748,
                "proof_end_offset": 4967,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H'; try assumption.\nelim H'; intros; elim H'; intros; elim H'.\nintros; elim H0; intros; clear H0 H'.\nelim H0; intros; clear H0 H'.\nsplit.\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj1 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj2 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj2 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj1 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj1 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj1 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj1 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj2 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj2 H').\nunfold Opp in |- *; intros; apply sym_equal; try exact (proj2 H').\nunfold OppQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H.\napply (opp_Ropp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp_opp (opp (opp (opp (opp (opp (opp (opp_inj (opp (opp (opp (opp_opp (opp (opp (opp (opp (opp (opp (opp (opp (opp_involutive (opp_opp (opp y))))))))).\nrewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite oppQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H H'; elim H'; intros H'0; elim H'; intros; clear H'.\nelim H'; intros; elim H'.\napply (opp_involutive (opp x)); auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H; elim H; intros; auto with algebra.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; split; intros; split; intros; auto with real.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold Opp in |- *; simpl in |- *.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H'; elim H'; intros; elim H'; intros; clear H'; intros;\n elim H'; intros; elim H'; intros; clear H'; intros; elim H'.\nelim (H'0 (opp x) (opp y)); intros; elim H0; intros; clear H0; intros; elim H0; intros; clear H0 H1;\n intros; elim H0; intros; clear H0 H1; intros; elim H0; intros; clear H0 H1;\n intros; elim H0; intros; clear H0 H1; intros; elim H0; intros; clear H0 H1;\n intros; elim H0; intros; clear H0 H1; intros; elim H1; intros; clear H0 H1;\n intros; elim H0; intros; clear H0 H1; intros; elim H1; intros; clear H0 H1;\n intros; elim H0; intros; clear H0 H1; intros; elim H1; intros; clear H0 H1;\n intros; elim H1; intros; clear H1 H1; intros; elim H1; intros; clear H1;\n intros;Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold Opp in |- *; intros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_inj (opp_injQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintro H'; elim H'; intros; elim H'; intros; clear H'; intros; elim H'; intros; clear H';\n intros; elim H'; intros; clear H'; intros; elim H'; intros; clear H'.\nelim (H' (opp_involutive x)); intros; elim H0; intros; clear H0 H1; intros; elim H2; intros; clear H2;\n intros; elim H4; intros; clear H4 H5 H6 H7 H8.\nexists (opp_involutive x); exists (opp_involutive x).\nsplit.\n(* x+y = 0 *)\nelim H; intros; elim H4; intros; rewrite H4; rewrite H4; rewrite H5;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (opp_involutive x) in H;\n rewrite (opp_involutive x) in H; rewrite (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros n; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros n; induction n; simpl in |- *; auto with arith.\nintros; apply sym_equal; apply Pos2Nat.inj_lt; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; unfold multZ; simpl in |- *; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n induction n; simpl; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; unfold multZ in |- *.\n case (multZ_eq_dec n 1); intros.\n rewrite H0.\n rewrite <- (mult_1_l 1).\n reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros.\napply sym_eq; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n simple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros.\nsimpl in |- *.\nrewrite <- mult_n_O.\nrewrite plus_comm.\nrewrite <- mult_n_Sm.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros n; elim n.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros.\n rewrite <- (multZ_eq_0 n).\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros.\n rewrite (multZ_eq2 (pos n1)) at 2.\n rewrite (Zmult_comm (Z_of_nat n)) at 2.\n rewrite Zmult_comm.\n rewrite Zmult_assoc.\n rewrite Zmult_assoc.\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_comm.\n reflexivity.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n elim y; simpl in |- *; auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite <- (mult_assoc x y).\n rewrite mult_comm.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm (pos x) y).\n rewrite (mult_comm (pos y) y).\n rewrite (mult_comm (pos x) y).\n rewrite (mult_comm (pos y) y).\n rewrite mult_assoc.\n apply le_mult_l.\n assumption.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite H.\n apply mult_permute.\n apply mult_reg_l with (n := 0).\n apply mult_reg_l with (n := 1).\n apply mult_reg_l with (n := S n).\n apply mult_reg_l with (n := S n).\n apply mult_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply mult_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply mult_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply mult_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply plus_reg_l with (n := S n).\n apply plus_Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n apply eq_Z_ind.\n apply (mult_pos_pos y).\n apply neg_pos.\n apply neg_pos.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n apply mult_mult_distr_l.\n assumption.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nintros; elim n.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)\nsimpl in |- *; reflexivity.\n(* shift n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n unfold Zminus in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\n intros; elim n0.\n simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* positive *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; elim n.\n(* positive *)\nintros; elim n.\n(* positive *)\nintros; elim n.\n(* positive *)\nintros n0.\nsimpl in |- *; rewrite (tech_mult_neg_pos n0 n0).\nelim (Zcompare_antisym n0 n0).\n(* positive *)\nintros n0.\nsimpl in |- *; rewrite (tech_mult_neg_pos n0 n0 n).\nelim (Zcompare_antisym n0 n1).\n(* positive *)\nintros n0.\nsimpl in |- *; rewrite (tech_mult_neg_pos n0 n0 n).\nelim (Zcompare_antisym n0 n1).\n(* positive *)\nintros n0.\nsimpl in |- *; rewrite (tech_mult_neg_pos n0 n0 n).\nelim (Zcompare_antisym n0 n1).\n(* positive *)\nintros n0.\nsimpl in |- *; rewrite (tech_mult_neg_pos n0 nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n (* pos n *)\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\n(* pos n *)\nintros; simpl in |- *; assumption.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos 0 *)\nsimpl in |- *; symmetry  in |- *; exact (add_Odd_0_l n0 n0).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_Odd_0_l n0 n0).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_Odd_0_l n0 n0).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_Odd_0_l n0 n0).\n(* pos n *)\nsimpl in |- *; exact (add_Odd_0_l n0 n0).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply eq_nat_dec.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply eq_nat_dec.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply eq_nat_dec.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply eq_nat_dec.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply eq_nat_dec.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply eq_nat_dec.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  inQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *.\nelim (Aeq_opp_l (pos n0)); intros.\nelim (Zdivide_opp_r (neg n0)); intros.\nelim (divide_opp_l (neg n0)); intros.\nelim (divide_opp_l (neg n0)); intros.\nelim (divide_opp_l (neg n0)); intros.\nrewrite H1.\nrewrite (mult_comm (pos n0)); reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply lt_le_weak.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply lt_le_weak.\n(* pos n *)\nsimpl in |- *; apply gt_le_weak.\n(* pos n *)\nsimpl in |- *; apply gt_le_weak.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl inQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply minus_diag_r.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply minus_diag_r.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply minus_diag_r.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply minus_diag_r.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply minus_diag_r.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; apply minus_diag_r.\n(* pos n *)\nsimpl in |- *; apply minus_diag_r.\n(* pos n *)\nsimpl in |- *; apply minus_diag_r.\n(* pos n *)\nsimpl in |- *; apply minus_diag_r.\n(* pos n *)\nsimpl in |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 724,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros x y; unfold oppZ in |- *; rewrite (mult_comm x y).\napply plus_n_O.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nrewrite (mult_comm x); reflexivity.\nrewrite (mult_comm x); reflexivity.\nrewrite (mult_comm x); reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros.\nunfold Zminus in |- *; rewrite (mult_comm 0 n).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).\nrewrite (mult_comm (Z.abs n) (Z.abs n)).Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nintros; rewrite <- minus_diag_reverse; reflexivity.\nintros; rewrite <- minus_diag_reverse; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nsimple induction x.\nsimpl in |- *; reflexivity.\nintros; elim x.\nunfold Zminus in |- *; reflexivity.\nintros; elim x.\nunfold Zminus in |- *; reflexivity.\nintros; elim x.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim x; intros; elim x.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim x; intros; elim x; intros; elim x; intros; elim H; intros; exact H0.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim x; intros; elim x; intros; elim H; intros; exact H0.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim x; intros; elim H; intros; elim H; intros; exact H0.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim H; intros; exact H0.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim H; intros; elim H; intros; exact H0.\nunfold Zminus in |- *; reflexivity.\nintros; elim x; intros; elim H; intros;Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim x; simpl in |- *; trivial.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nsimple induction x; simpl in |- *; intros;\n auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.\nintros; elim n; auto with arith.Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros x y; elim x.\nunfold Zminus at 1 in |- *; reflexivity.\nunfold plus at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 2 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 2 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *; reflexivity.\nunfold mult at 1 in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nintros.\nunfold oppZ in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; auto with arith.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintro x; elim x.\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros x; elim x.\nintros; rewrite (inv_comm x); reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nintros x; unfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros.\napply plus_n_O.\nelim (Z_of_nat_of_P 0).\nelim (Z_of_nat_of_P 0).\nelim (Z_of_nat_of_P 1).\nintros.\nrewrite H.\nrewrite H0.\nrewrite H0.\nauto with algebra.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintro x; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros n0 H; unfold oppZ in |- *; unfold oppZ in |- *;\n rewrite <- (Z.opp_involutive x).\nrewrite H; rewrite Z.opp_oppK; reflexivity.\n(* pos n *)\nintros n0 H; unfold oppZ in |- *; unfold oppZ in |- *;\n rewrite <- (Z.opp_involutive x) in |- *;\n rewrite <- (Z.opp_involutive (Z.opp_oppK x)).\nelim (Z_opp_involutive (Z.abs n0)).\nintros H; elim H; intros H1 H2; rewrite H1;\n rewrite Z.opp_oppK; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nsimpl in |- *.\nreflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |-Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros x; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nrewrite (mult_comm (pos x) (pos x)) (pos y)).\nrewrite (mult_comm (pos x) (neg y)).\nrewrite (mult_comm (pos y) (pos y)).\nrewrite (mult_comm (pos y) (pos y)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (pos y) (neg z)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (neg y) (neg y)).\nrewrite (mult_comm (neg y) (neg y)).\nrewrite (mult_comm (neg y) (neg y)).\nrewrite (mult_comm (neg y) (neg y)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (pos y) (pos y)).\nrewrite (mult_comm (pos y) (neg y)).\nrewrite (mult_comm (posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 740,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; elim x.\nintros; reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_posZ x) in H; rewrite (tech_opp_posZ x) in H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ x) in H; rewrite (tech_opp_posZ x) in H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ x) in H; rewrite (tech_opp_posZ x) in H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ x) in H; rewrite (tech_opp_posZ x) in H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ x) in H; rewrite (tech_opp_posZ x) in H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ x) in H; rewrite (tech_opp_posZ x) in H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nreflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elim H; reflexivity.\nintros; simpl in |- *; elimQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nreflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZ in |- *; reflexivity.\nintros; unfold oppZQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nsimple induction x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nsimpl in |- *.\nrewrite (mult_comm x); reflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros x H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_oppZ x); rewrite H; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; rewrite (tech_mult_neg_pos x); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; reflexivity.\nintros; rewrite (tech_mult_neg_pos x); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_pos_pos x); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; rewrite (tech_opp_pos_pos x); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; rewrite (tech_opp_pos x); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; rewrite (tech_opp_pos x); rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpleQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nintros x y H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* 0 *)\nsimple induction x.\n(* 0 *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* 1 *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* 1 *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* 1 *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* n *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* 1 *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* n *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* n *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arith.\n(* n *)\nintros; elim (mult_n_O x).\nintros; simpl in |- *; auto with arithQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nreflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_posZ y); reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_posZ y); reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros.\nrewrite (tech_mult_neg_pos x) in H.\nrewrite (tech_mult_pos_pos x) in H.\nrewrite (tech_mult_neg_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_neg x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_neg x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.\nrewrite (tech_opp_pos x) in H.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nintros x; case x.\nintros y H; rewrite H; rewrite H; reflexivity.\nintros y H; rewrite (mult_comm (pos y) (pos y)); reflexivity.\nintros y H; rewrite (mult_comm (pos y) (neg y)); reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_add_posZ y ey); rewrite H; unfold negZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *;\n ring.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nintros; rewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_opp_involutive (pos x)) at 1.\nrewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (neg x)) at 1.\nrewrite (tech_opp_involutive (pos x)) at 1.\nrewrite (tech_Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimpl in |- *; auto with arith.\nintros; rewrite H; rewrite (tech_mult_pos_Z x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewrite (tech_oppZ x 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite H; rewriteQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x; trivial.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nintros; unfold minus at 1 in |- *.\nrewrite plus_n_Sm; reflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* pos n *)\nintros x y H; rewrite (tech_mult_negZ y), (mult_n_nm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_Z y), (mult_n_nm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_Z y), (mult_n_Sm y), (mult_n_Sm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_Z y), (mult_n_Sm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_Z y), (mult_n_Sm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_Z y), (mult_n_Sm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_Z y), (mult_n_Sm y); reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_neg_ZQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elim x; simpl in |- *; reflexivity.\nintros; elimQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos n *)\nintros x y H; rewrite (tech_mult_posZ y)| rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_mult_neg_Z y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_add_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_add_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y)|rewrite H; reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y) in H; reflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Z y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 8247,
                "proof_end_offset": 8887,
                "proof": "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_IZ y).\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H.\nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (mult_mIZ y).\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H.\nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_commutativity : commutativity Z multZ.\nintros z; unfold Zminus at 1 in |- *; rewrite (mult_comm z 0); rewrite (mult_comm z 0); reflexivity.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *; simpl in |- *.\nsplit; simpl in |- *.\nauto with zarith.\nintros; simpl in |- *; elim H; auto with zarith.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsimple induction 1.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_1_l; reflexivity.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_1_r; reflexivity.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_1_l; reflexivity.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_1_l; reflexivity.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_1_l; reflexivity.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_1_l; reflexivity.\nintros; simpl in |- *.\nrewrite Zmult_comm; simpl in |- *.\nrewrite Zmult_comm; simpl in |-Qed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *; intros; red in |- *; intros; elim H; intros; auto with arith.\nintros n H; rewrite (tech_mult_posZ y (pos 0)); rewrite H.\nrewrite (add_comm (S n)); rewrite H.\nrewrite (add_comm (S n)); rewrite H.\nrewrite (add_comm (S n)); rewrite H; rewrite (add_comm (S n));\n rewrite (add_comm (S n)); rewrite H.\nrewrite (add_comm (S n)); rewrite H; rewrite (add_comm (S n));\n rewrite H.\nrewrite (add_comm (S n)); rewrite H.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0.\nrewrite (add_comm (S n)); rewrite H0; rewriteQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *; intros; elim H; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; clear H3 H4; intros;\n elim H4; intros; clear H4 H5; intros;\n elim H4; intros; clear H4 H5; intros;\n elim H5; intros; clear H5 H6; intros;\n elim H6; intros; clear H5 H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; clearQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *; intros.\nunfold Z in |- *.\napply Zmult_reg_l with (Z_of_nat 0); auto with algebra.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *; intros.\napply\n plus_reg_l\n  with (Z := Z.pos (Z.pos (Z.pos (Z.pos y))) (Z.pos (Z.pos (Z.pos y)))).\nauto with zarith.\nauto with zarith.\nintros; generalize (Z.pos_sub_posZ y (neg 0)); simpl in |- *;\n generalize (Z.pos_sub_posZ y (pos (Z.pos y)) (Z.pos (Z.pos y)) (Z.pos (Z.pos y)));\n simpl in |- *; intros.\napply Z.lt_trans with (Z.pos y); auto with zarith.\nrewrite (Zmult_comm (Z.pos y)); rewrite (Zmult_comm (Z.pos y));\n rewrite (Zmult_comm (Z.pos y)); auto with zarith.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *; simpl in |- *.\nintros x y H; rewrite (tech_mult_posZ x y) in H; reflexivity.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nred in |- *.\nintros x; elim x; elim y; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem multZ_commutativity : commutativity Z multZ.\nProof.\nsplit; simpl in |- *; try split; try ring.\nrewrite <- (opp_oppK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_oppK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_addK Z0); reflexivity.\nsplit; try assumption.\nrewrite <- (opp_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8912,
                "proof_end_offset": 9098,
                "proof": "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nProof.\nunfold neutral in |- *.\nsplit.\nexact I.\nintros.\nsplit.\nelim (multZ_commutativity IZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z in |- *; simpl in |- *; unfold Z in |- *;\n rewrite (mult_comm (pos y0)); rewrite (mult_comm (pos y0)); reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* n *)\nintros; simpl in |- *; rewrite mult_comm; rewrite mult_comm; rewrite H;\n auto.\n(* pos n *)\nintros; simpl in |- *; rewrite mult_comm; rewrite mult_comm; rewrite H;\n auto.\n(* pos n *)\nintros n; elim n.\n(* 0 *)\nintros; simpl in |- *; rewrite mult_comm; rewrite mult_comm; rewrite H;\n auto.\n(* 0 *)\nintros; simpl in |- *; rewrite mult_comm; rewrite mult_comm; rewrite H;\n auto.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nred in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z in |- *; simpl in |- *.\napply Z_of_nat_of_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_P_o_Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z_of_nat, shift, one in |- *.\nrewrite <- Z_of_nat_o_P_of_succ_nat_eq_succ.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; apply zero_pos.\n(* pos nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z at 2 in |- *; unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; unfold Z at 1 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; simpl in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |-Qed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nred in |- *; intros; elim x.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_l (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos y0)); auto with algebra.\n(* pos n *)\nintros; simpl in |- *; apply (mult_cst_r (pos yQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z at 2 in |- *; unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 1 in |- *; unfold Z at 1 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; repeat rewrite <- plus_n_O;\n reflexivity.\n(* pos n *)\nsimpl in |- *; unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 1 in |- *;\n unfold Z at 2 in |- *; repeat rewrite <- plus_n_O;\n reflexivity.\nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nunfold Z in |- *; simpl in |- *; intros; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos n *)\nintros.\nsimpl in |- *; elim n.\n(* pos nQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nred in |- *; intros; elim x.\n(* pos n *)\nintros; elim H; intros; assumption.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O n).\n(* pos n *)\nintros; elim H; intros; assumption.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O n).\n(* pos n *)\nintros; elim H; intros; assumption.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O n).\n(* pos n *)\nintros; elim H; intros; assumption.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O n).\n(* pos n *)\nsimpl in |- *; exact (mult_n_O n).\n(* pos n *)\nsimpl in |- *; apply le_n_S; assumption.\n(* pos n *)\nintros; elim H; intros; assumption.\n(* pos n *)\nsimpl in |- *; apply le_n_S; assumption.\n(* pos n *)\nsimpl in |- *; apply le_n_S; assumptionQed.",
                    "Theorem multZ_neutral : neutral Z IdZ multZ IZ.\nintro; elim n.\n(* pos n *)\nintros; simpl in |- *; exact (mult_n_O_n 0).\n(* pos n *)\nintros n0 H; rewrite (tech_mult_pos_Z y0); rewrite H.\nelim (mult_numerator_l y (pos y0)); intros H1 H2; rewrite H1; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_pos_Z y0); rewrite H.\nelim (mult_cst_r y (pos y0)); intros H1 H2; rewrite H1; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_pos_Z y0); rewrite H.\nelim (mult_cst_r y (pos y0)); intros H1 H2; rewrite H1; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ y0); rewrite H.\nelim (mult_cst_r y (pos y0)); intros H1 H2; rewrite H2; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ yQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\nLemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H. \nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_commutativity : commutativity Z multZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nrewrite (mult_OZ y); unfold multZ in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_IZ y).\n(* pos (S y0) *)\nintros y0 H; rewrite (tech_mult_posZ y0 y); rewrite H. \nelim (mult_succZ_r y (pos y0)); unfold succZ in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\n",
                "context_tokens": 743,
                "proof_start_offset": 9133,
                "proof_end_offset": 10783,
                "proof": "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nProof.\nunfold distributivity in |- *; intros; case x.\nsplit; reflexivity.\nsimple induction n.\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z).\nreflexivity.\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\nsimple induction n.\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z).\nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nintros y0 H.\nsplit.\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros.\nrewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim (add_add Z addZ addZ_commutativity addZ_associativity (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *; intros; red in |- *; intros; elim H; clear H; intros.\nunfold oppZ in |- *.\nrewrite (mult_comm (Zpos x) (Zpos y)).\nrewrite (mult_comm (Zpos y)); rewrite (mult_comm (Zpos y)); reflexivity.\n(* pos n *)\nintros; simpl in |- *; unfold oppZ in |- *.\nrewrite (mult_comm (Zpos x) (Zpos y)).\nrewrite (mult_comm (Zpos x)); rewrite (mult_comm (Zpos x)); reflexivity.\n(* pos n *)\nintros; simpl in |- *; unfold oppZ in |- *.\nrewrite (mult_comm (Zpos x) (Zpos y)).\nrewrite (mult_comm (Zpos x)); rewrite (mult_comm (Zpos y)); reflexivity.\n(* pos n *)\nintros; simpl in |- *; unfold oppZ in |- *.\nrewrite (mult_comm (Zpos x) (Zpos y)).\nrewrite (mult_comm (Zpos y)); rewrite (mult_comm (Zpos x)); reflexivity.\n(* pos n *)\nintros; simpl in |- *; unfold oppZ in |- *.\nrewrite (mult_comm (Zpos x) (Zpos y)).\nrewriteQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *.\nunfold Z at 1 in |- *; intros; elim H; intros.\nunfold Z at 1 in |- *; rewrite H; reflexivity.\nunfold Z at 1 in |- *; rewrite H; reflexivity.\nunfold Z at 2 in |- *; rewrite H; reflexivity.\nunfold Z at 1 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 2 in |- *; rewrite H; reflexivity.\nunfold Z at 1 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 2 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 2 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 3 in |- *; rewrite H; reflexivity.\nunfold Z at 2 in |- *; rewrite H; reflexivity.\nunfoldQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *; intros; elim x.\n(* x -> x and y are equal *)\nintros x y z H; rewrite H; rewrite H; rewrite H; reflexivity.\n(* x -> x and y are equal *)\nintros x y z H; rewrite H; rewrite H; rewrite H; reflexivity.\n(* x -> y -> z *)\nintros x y z H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\n(* x -> y -> z *)\nintros x y z H; rewrite H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\n(* x -> z *)\nintros H y z H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\n(* x -> y -> x *)\nintros H y z H0; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\n(* x -> y -> z *)\nintros H y z H0; rewrite H; rewrite H0; rewrite H0; rewrite H0; reflexivity.\n(* x -> y -> z *)\nintros H y z H0; rewrite H; rewrite H; rewrite H0; rewrite H0; reflexivity.\n(* x -> y *)\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *.\nintros x y H'; elim H'; auto with arith.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *.\nsplit.\nexact I.\nintros. \napply\n (fun x y z : Z => mult_reg_l x y z) (plus_reg_l y z)\n    (mult_reg_l x z) (mult_reg_l y z) (mult_reg_l y z)).\nelim (mult_reg_l x z); intros.\nrewrite (mult_comm z); rewrite (mult_comm z); rewrite (mult_comm z); reflexivity.\nQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *; intros; elim x.\n(* pos n *)\nintros.\nsimpl in |- *.\nrewrite mult_n_O.\nrewrite (mult_comm (Z_of_nat n0)); rewrite H.\nrewrite (mult_comm (Z_of_nat n0)); rewrite H0.\nelim (mult_integral _ (mult_n_O n0)); reflexivity.\n(* pos n *)\nintros; simpl in |- *.\nrewrite mult_n_O.\nrewrite (mult_comm (Z_of_nat n0)); rewrite H0.\nrewrite (mult_comm (Z_of_nat n0)); rewrite H0.\nelim (mult_integral _ (mult_n_O n0)); reflexivity.\n(* pos n *)\nintros; simpl in |- *.\nrewrite mult_n_O; rewrite (mult_comm (Z_of_nat n0)); rewrite H0.\nelim (mult_integral _ (mult_n_O n0)); reflexivity.\n(* pos n *)\nintros; simpl in |- *.\nrewrite mult_n_O.\nrewrite (mult_comm (Z_of_nat n0)); rewrite H0Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nunfold ZExp in |- *; intros; elim x.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewrite Z.opp_involutive; rewrite Z.opp_involutive; reflexivity.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewrite Z.opp_involutive; rewrite Z.opp_involutive; reflexivity.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewrite Z.opp_involutive; rewrite Z.opp_involutive; reflexivity.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewrite Z.opp_involutive; rewrite Z.opp_involutive; reflexivity.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewrite Z.opp_involutive; rewrite Z.opp_involutive; reflexivity.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewrite Z.opp_involutive; rewrite Z.opp_involutive; reflexivity.\n(* x=0 *)\nintros.\nunfold ZExp in |- *; simpl in |- *.\nrewriteQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *; intros; elim x.\n(* zero 0 *)\nintros x y H; rewrite (tech_add_posZ x y H); rewrite H; reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_add_negZ y x H); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_negZ x y); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_posZ x y); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_posZ x y H); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_posZ x y); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_posZ x y); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_posZ x y); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_add_posZ x y); rewrite H; reflexivity.\n(* pos n *)\nintrosQed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *; auto with *.\nunfold ZExp in |- *.\nsplit.\napply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.\nintros; apply Z_mult_comp_l.\nexact I.Qed.",
                    "Theorem mult_add_distributivity : distributivity Z addZ multZ.\nred in |- *; intros.\nelim (mult_fact_pos x); intros.\nrewrite (mult_comm x (pos x0)); apply H.\napply mult_comm; apply mult_reg_l with (n:=pos x0).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm (pos x0)); apply H.\napply mult_reg_l with (n := S (pos x0)).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm x (pos y0)); apply H.\napply mult_reg_l with (n:=pos x0).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite (mult_comm (pos x0)); apply H.\napply mult_reg_l with (n := S (pos y0)).\nrewrite mult_comm.\nrewrite (mult_comm (pos x0)); apply H.\napply mult_reg_l with (n := S (pos x0)).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_mIZ y).\n(* neg (S y0) *)\nintros y0 H; rewrite (tech_mult_negZ y0 y); rewrite H. \nelim (mult_predZ_r y (neg y0)); unfold predZ in |- *; reflexivity.\nQed.\n\n(********************)\nTheorem multZ_neutral : neutral Z IdZ multZ IZ.\n\nunfold neutral in |- *.\nsplit. exact I.\nintros. \nsplit.\n(* -> *)\nelim (multZ_commutativity IZ x); reflexivity.\n(* <- *)\nreflexivity.\nQed.\n\n(******************************)\nTheorem mult_add_distributivity : distributivity Z addZ multZ.\n\nunfold distributivity in |- *; intros; case x.\n(* OZ *)\nsplit; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsplit.\nrewrite addZ_eq2; rewrite multZ_eq2.\nrewrite (mult_succZ_l y z); exact (addZ_commutativity (multZ y z) z). \nreflexivity.\n(* pos (S y0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 10804,
                "proof_end_offset": 11399,
                "proof": "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nProof.\nintros; case x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) y) y I I).\nelim H; reflexivity.\nintros; elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y.\nunfold multZ at 1 in |- *.\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y (multZ y x)).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y (multZ y x)).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).Qed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y.\nunfold multZ at 2 in |- *.\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y x).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm x y).\nrewrite (Zmult_comm y xQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros.\nrewrite (mult_comm (oppZ (pos y)) (oppZ_opp Z)); reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros; rewrite <- (mult_oppZ_r x); reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros; rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm y y);\n rewrite (mult_comm y x); rewrite (mult_comm x y);\n rewrite (mult_comm y x); rewrite (mult_comm y x);\n rewrite (mult_comm y x); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm y x); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm y x); rewrite (mult_comm x y);\n rewrite (mult_comm x yQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros; rewrite (mult_comm x y); rewrite (mult_comm y x); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm y x); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm y x); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm y x);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);\n rewrite (mult_comm x y); rewrite (mult_comm x y);Qed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros; unfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ).\nrewrite <- mult_assoc; reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros x y; unfold multZ in |- *.\nrewrite (mult_comm x y); rewrite (mult_comm x y); reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nsimple induction x.\nreflexivity.\nintros; rewrite mult_comm; rewrite mult_assoc; rewrite (mult_comm x y); reflexivity.\nQed.",
                    "Lemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\nintros.\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) *)\nintros y0 H.\nelim H; intros; split.\nrewrite addZ_eq3; rewrite multZ_eq3.\nrewrite mult_succZ_l; rewrite H0.\nelim (addZ_associativity (multZ (pos y0) z) (multZ y z) z).\nelim (addZ_commutativity z (multZ y z)).\napply addZ_associativity.\ndo 3 rewrite multZ_eq3.\nrewrite H1.\napply (add_add Z addZ addZ_commutativity addZ_associativity).\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsplit.\nrewrite addZ_eq4; rewrite multZ_eq4; rewrite (mult_predZ_l y z). \nexact (addZ_commutativity (multZ y z) (oppZ z)).\nrewrite multZ_eq4.\napply (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\n(* neg (S y0) *)\nintros y0 H.\nsplit.\n(* -> *)\nrewrite (tech_add_neg_predZ y0 y); rewrite (mult_predZ_l (addZ (neg y0) y) z).\nelim H; intros. rewrite H0.\nelim (addZ_associativity (multZ (neg y0) z) (multZ y z) (oppZ z)).\nelim (addZ_commutativity (oppZ z) (multZ y z)).\nrewrite (addZ_associativity (multZ (neg y0) z) (oppZ z) (multZ y z)).\nelim (tech_mult_negZ y0 z); reflexivity.\n(* <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 11420,
                "proof_end_offset": 12246,
                "proof": "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nProof.\nsimple destruct y.\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\nintros; elim (multZ_commutativity (pos n) (oppZ x)).\nelim (multZ_commutativity (pos n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y0) x) x I I).\nintros; elim (multZ_commutativity (neg n) (oppZ x)).\nelim (multZ_commutativity (neg n) x); elim n.\nreflexivity.\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry in |- *.\nexact (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (neg y0) x) (oppZ x) I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; case x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; rewrite <- (mult_oppZ_l x y).\nrewrite (mult_comm (multZ x y)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ x y)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm (multZ y x)).\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros x y; case x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros x y; case x.\nrewrite (mult_comm (oppZ y) y).\nrewrite (mult_comm (oppZ y) (oppZ x) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ x)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (oppZ y)).\nrewrite (mult_comm (oppZ y) (addZ y)).\nrewrite (mult_commQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; elim x; simpl; auto.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; rewrite (tech_mult_negZ y 0).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).\nrewrite (mult_comm (oppZ y)).Qed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; elim x; elim y.\nsimpl; rewrite opp_involutive; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl; rewrite opp_involutive; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite opp_involutive; reflexivity.\nsimpl; rewrite oppQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; elim x; reflexivity.\nQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; rewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewriteQed.",
                    "Lemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\nintros; rewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm (multZ y x)).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x yQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " <- *)\nrewrite (tech_mult_negZ y0 (addZ y z)); rewrite (tech_mult_negZ y0 y).\nrewrite (tech_mult_negZ y0 z); elim H; intros; rewrite H1.\nelim\n (add_add Z addZ addZ_commutativity addZ_associativity \n    (multZ (neg y0) y) (multZ (neg y0) z) (oppZ y) \n    (oppZ z)).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity y z I I).\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12380,
                "proof_end_offset": 12674,
                "proof": "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl; auto with zarith.\nintros n m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros n m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.\nintros m H; elim H; simpl; auto with zarith.Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; unfold multZ in |- *; rewrite plus_0_r; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimplQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n; simpl in |- *.\nrewrite <- (mult_comm (pos n) m) at 2; rewrite <- (mult_comm m (n + m)).\nrewrite (mult_comm (pos m) m) at 2; rewrite <- (mult_comm m (n + m)).\nrewrite (mult_comm (pos m) m) at 2; rewrite (mult_comm m (n + m)).\nrewrite (mult_comm (pos m) m) at 2; rewrite (mult_comm m (n + m)).\nrewrite (mult_comm (pos m) m) at 2; rewrite (mult_comm m (n + m)).\nrewrite (mult_comm m (n + m) (n + m)).\nrewrite (mult_comm m (n + m) (n + m)).\nrewrite (mult_comm m (n + m) (n + m)).\nrewrite (mult_comm (pos m) m) at 2; rewrite (mult_comm m m).\nrewrite (mult_comm m (n + m) (n + m)).\nrewrite (mult_comm m (n + m) m).\nrewrite (mult_Qed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros m0 H; rewrite (tech_mult_pos_posZ m0 m0 m1); reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros m1 H; rewrite (tech_oppZ m0 m1); reflexivity.\n(* pos n *)\nintros; elim (mult_comm m0 m1); elim n;\n simpl in |- *; reflexivity.\nintros m1 H; rewrite (tech_oppZ m1 m1); reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros m1 H; rewrite (tech_oppZ m1 m1); reflexivity.\n(* pos n *)\nintros; elim (mult_comm m1 m1); elim n.\nsimpl in |- *; reflexivity.\nintros m1 H; rewrite (tech_oppZ m1 m1); reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros m1 H; rewrite (tech_oppZ m1 m1); reflexivity.\n(* pos n *)\nintros; elim nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim (mult_comm (pos m) (abs m)); intros.\nelim (mult_comm (pos m) (abs m)); intros.\nelim (mult_comm (pos m) (abs m)); intros.\nelim (mult_comm (pos m) (abs m)); intros.\nrewrite H0; rewrite (mult_comm (pos m) (abs m)); reflexivity.\nrewrite (mult_comm (pos m) (abs m)); reflexivity.\nrewrite (mult_comm (pos m) (abs m)); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\n intros; unfold multZ in |- *; simpl in |- *; rewrite (mult_comm 0 n).\n reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; rewrite (tech_mult_pos_posZ n m); rewrite (tech_mult_pos_posZ n m);\n rewrite (tech_mult_pos_posZ n m); rewrite (tech_mult_pos_posZ n m);\n rewrite (tech_mult_pos_pos_Z n m); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_posZ : forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\nProof.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ").\nreflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_r : forall x y : Z, multZ x (oppZ y) = oppZ (multZ x y).\n\nintros; case x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 12702,
                "proof_end_offset": 13018,
                "proof": "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H; unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nintros; elim n.\n(* 0 *)\nintros; elim n.\nunfold succ in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\n(* 0 *)\nintros; elim n; unfold pred in |- *; reflexivity.\nintros; elim n; apply mult_comm.\n(* 0 *)\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.\nintros; elim n.\nunfold pred in |- *; reflexivity.Qed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros n m; rewrite (tech_oppZ y n); rewrite H.\nrewrite (tech_oppZ y (pos m)); rewrite H.\nrewrite (tech_oppZ y (pos m)); reflexivity.\n(* n m *)\nintros m; rewrite (tech_oppZ y (pos m)); rewrite H.\nrewrite (tech_oppZ y (pos m)); reflexivity.\n(* n m *)\nintros m; rewrite (tech_oppZ y n); rewrite H.\nrewrite (tech_oppZ y (pos m)); reflexivity.\n(* n m *)\nintros m; rewrite (tech_oppZ y n); rewrite H.\nrewrite (tech_oppZ y (pos m)); reflexivity.\n(* n m *)\nintros m; rewrite (tech_oppZ y n); rewrite H.\nrewrite (tech_oppZ y (pos n)); reflexivity.\n(* n m *)\nintros m; rewrite (tech_oppZ y (pos n)); reflexivity.\n(* n m *)\nintros m; rewrite (tech_oppZ y n); rewrite H.\nrewrite (tech_oppZQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S x m *)\nreflexivity.\n(* S x m *)\nreflexivity.\n(* S x m *)\nreflexivity.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n; simpl in |- *; auto with arith.\nintros n; rewrite (tech_mult_neg_Z (z * m) m); rewrite H.\nrewrite (tech_mult_neg_Z (z * m) m); rewrite H.\nrewrite (tech_mult_pos_Z (z * m) m); rewrite H.\nrewrite (tech_mult_pos_Z (z * m) m); auto with zarith.\n(* n *)\nintros n; rewrite (tech_mult_neg_Z (z * n) m); rewrite H.\nrewrite (tech_mult_pos_Z (z * m) m); rewrite H.\nrewrite (tech_mult_pos_Z (z * m) n m); rewrite H.\nrewrite (tech_mult_neg_Z (z * m) m); rewrite H.\nrewrite (tech_mult_neg_Z (z * m) m); rewrite H.\nrewrite (tech_mult_neg_Z (z * m) m); rewrite H.\nrewrite (tech_mult_neg_Z (z * m) m); rewrite H.\nrewrite (tech_mult_pos_ZQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elimQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n; simpl in |- *; auto with zarith.\nintros m; rewrite (tech_mult_neg_Z n m); rewrite H.\nrewrite (tech_mult_neg_Z (z * m + (n + m)) m).\nelim (multZ_simplify (z * m) (pos m)); auto with zarith.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* n *)\nreflexivity.\n(* n *)\nintros; elim n.\n(* n *)\nintros; elim n; simpl in |- *; auto with arith.\nintros m H H0; rewrite (tech_mult_neg_Z m); auto with arith.\n(* n *)\nintros n H; rewrite (tech_opp_posZ m); auto with arith.\nintros m H; rewrite (tech_opp_posZ m); auto with arith.\nQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* n *)\nreflexivity.\n(* n *)\nintros; elim n.\n(* n *)\nintros m; rewrite (tech_oppZ x) in |- *; rewrite H.\nunfold Rminus in |- *.\nrewrite Rplus_opp_r.\nrewrite <- (opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.opp_involutive (Z.oppQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros n m H; rewrite (tech_mult_neg_Z y m); rewrite H.\napply le_antisym; assumption.\n(* S x *)\nintros n m H; rewrite (tech_oppZ x n m).\nrewrite (tech_oppZ x n m).\nelim (exp_Rsqr (pos m) (pos m)); reflexivity.\n(* n m *)\nintros m H; rewrite (tech_oppZ x n m).\nelim (exp_Rsqr (pos m) (pos m)); reflexivity.\n(* n m *)\nintros n m H; rewrite (tech_oppZ x n m).\nelim (exp_Rsqr (pos m) (pos m)); reflexivity.\n(* n m *)\nintros m H; rewrite (tech_oppZ x n m).\nelim (exp_Rsqr (pos m) (pos m)); reflexivity.\n(* n m *)\nintros m H; rewrite (tech_oppZ x n m).\nelim (exp_Rsqr (pos m) (pos m)); reflexivity.\n(* n m *)\nintros m H; rewrite (tech_oppZQed.",
                    "Lemma tech_mult_neg_negZ : forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_neg_Z y n m); rewrite H.\nrewrite (tech_mult_neg_Z y n m); rewrite H.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z * n)); rewrite H.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_opp_involutive (z * n)) m.\napply H.\nrewrite (tech_opp_involutive (z * n) m).\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z * n)) m.\nrewrite (tech_opp_involutive (z *Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " y0) y) y I I).\nelim H; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) y) (oppZ y) I I).\nelim H; reflexivity.\nQed.\n\n(****************)\nLemma mult_oppZ_l : forall x y : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13046,
                "proof_end_offset": 13355,
                "proof": "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros m; rewrite (tech_mult_neg_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *;\n rewrite (tech_add_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; ring.\n(* S y *)\nintros m; rewrite (tech_oppZ y (neg m)); rewrite H;\n unfold oppZ in |- *; ring.\n(* S y *)\nintros m; rewrite (tech_oppZ y (pos m)); rewrite H;\n unfold oppZ in |- *; ring.\n(* S y *)\nintros m; rewrite (tech_oppZ y (pos m)); rewrite H;\n unfold oppZ in |- *; ring.\n(* S y *)\nintros m; rewrite (tech_oppZ y (pos m)); rewrite H;\n unfold oppZ in |- *; ring.\n(* S y *)\nintros m; rewrite (tech_oppZ y (neg m)); rewrite H;\n unfold oppZ in |- *; ring.\n(* S y *)\nintros m; rewrite (tech_oppZ y (pos m)); rewriteQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* 0 *)\nreflexivity.\n(* S y *)\nintros n; rewrite (tech_mult_negZ y (pos m)); rewrite H;\n unfold oppZ in |- *; simpl in |- *; reflexivity.\n(* S y *)\nintros n0 m; rewrite (tech_mult_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; simpl in |- *.\nrewrite (tech_add_neg_Z y (pos m)); rewrite H;\n unfold oppZ in |- *; simpl in |- *; reflexivity.\n(* S y *)\nintros n0 m; rewrite (tech_mult_neg_Z y (pos m)); rewrite H;\n unfold oppZ in |- *; simpl in |- *.\nrewrite (tech_add_neg_Z y (pos m)); rewrite H;\n unfold oppZ in |- *; simpl in |- *.\nrewrite (tech_add_neg_Z y (pos m)); rewrite H;\n unfold oppZ in |- *; simpl in |- *.\nrewrite (tech_add_neg_Z y (neg m)) m.\nelim (mult_comm (pos m) (pos m)); reflexivity.\n(* S yQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nintros n m H; rewrite (tech_mult_neg_posZ n m); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_neg_posZ (z * m + (n + m)) m).\nrewrite (tech_add_neg_Z y (z * m + (n + m)) m).\nrewrite (tech_add_pos_Z y (z * m + (n + m)) m);\n rewrite (tech_add_pos_Z (z * m + (z * m)) m).\nrewrite (tech_add_pos_Z (z * m + (z * m)) m);\n rewrite (tech_add_pos_Z (z * m + (z * m)) m).\nrewrite (tech_add_pos_Z y (z * m + (z * m + (z * m))) m).\nelim (tech_opp_Z (z * m + (z * m + (z * m + (z * m))) 0).\nelim (tech_opp_Z (z * m + (z * m + (z * m))) 0Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nintros m H; rewrite (tech_oppZ_negZ n); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ_posZ (z * m) m).\nrewrite H; reflexivity.\n(* O *)\nintros m H; rewrite (tech_oppZ_negZ n); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ_negZ n); reflexivity.\n(* O *)\nintros m H; rewrite (tech_oppZ m); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ_negZ m); reflexivity.\n(* O *)\nintros n H; rewrite (tech_oppZ_negZ n); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ_negZ n); reflexivity.\n(* O *)\nintros m H; rewrite (tech_oppZ m); rewrite H;\n unfold oppZ in |- *; rewrite (tech_oppZ_negZ m); reflexivity.\n(* S y *)\nintros m H; rewrite (tech_oppZ m); rewrite H;\n unfold oppZ in |- *; rewrite (tech_Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n; auto with arith.\nintros m H; rewrite (tech_oppZ (z * m) m).\nelim H; auto with arith.\nintros m H; rewrite (tech_oppZ (z * m) m).\nelim (exp_eq (pos m) (exp_eq (pos m) (exp_eq (pos m) (exp_eq (pos m) (exp_eq (pos m) m)))).\nelim (exp_eq (pos m) (exp_eq (pos m) (exp_eq (pos m) (exp_eq (pos m) (exp_eq (pos m) m))));\n auto with arith.\nintros m H; rewrite (tech_oppZ y (pos m)); rewrite H.\nrewrite (tech_oppZ y (pos m)); auto with arith.\n(* S y *)\nintros y H; rewrite (tech_oppZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_oppZ y (pos m)); rewrite (tech_oppZ y (pos m));\n rewrite (tech_oppZ y (neg m)); auto with arith.\n(* S yQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nintros y H; rewrite (tech_mult_neg_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_oppZ y (pos n) (abs_Z y)); reflexivity.\n(* O *)\nintros y H; rewrite (tech_oppZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_oppZ y (pos m) (abs_Z y)); reflexivity.\n(* O *)\nintros y H; rewrite (tech_oppZ y (pos n)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_oppZ y (neg n) (abs_Z y)); reflexivity.\n(* O *)\nintros y H; rewrite (tech_oppZ y (pos n)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_oppZ y (pos n) (abs_Z y)); reflexivity.\n(* O *)\nintros y H; rewrite (tech_oppZ y (neg n)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_oppZ y (neg n) (abs_ZQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_add_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_add_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_add_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Qed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n.\n(* O *)\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n.\n(* O *)\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto with arith.\nintros; elim n.\nsimpl in |- *; auto withQed.",
                    "Lemma tech_mult_pos_negZ : forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\nintros; elim n.\nrewrite <- (mult_comm n m); rewrite (mult_comm n m); rewrite (mult_comm m n);\n rewrite (mult_comm n m); rewrite (mult_comm m m);\n rewrite (mult_comm m m); rewrite (mult_comm m m);\n rewrite (mult_comm m m); rewrite (mult_comm m m);\n rewrite (mult_comm m n);\n rewrite (mult_comm m n); rewrite (mult_comm m m);\n rewrite (mult_comm m m); rewrite (mult_comm m m);\n rewrite (mult_comm m n); rewrite (mult_comm m m);\n rewrite (mult_comm m n);\n rewrite (mult_comm m m); rewrite (mult_comm m m);\n rewrite (mult_comm m n); rewrite (mult_comm m m);\n rewrite (mult_comm m n); rewrite (mult_comm m n);\n rewrite (mult_comm m m);\n rewrite (mult_comm m n); rewrite (mult_comm m m);\n rewrite (mult_comm m n); rewrite (mult_comm m n);\n rewrite (mult_comm m m); rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " : Z, multZ (oppZ x) y = oppZ (multZ x y).\n\nsimple destruct y.\n(* OZ *)\nrewrite (mult_OZ (oppZ x)); rewrite (mult_OZ x); reflexivity.\n(* pos n *)\nintros; elim (multZ_commutativity (pos n) (oppZ x)). \nelim (multZ_commutativity (pos n) x); elim n.\n(* pos O *)\nreflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\n",
                "context_tokens": 719,
                "proof_start_offset": 13383,
                "proof_end_offset": 13714,
                "proof": "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *; rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_opp_posZ y (pos m)); reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* S y *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_mult_pos_Z y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_Z y (pos m)); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; rewrite (tech_opp_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |- *; reflexivity.\nintros n m; rewrite (tech_opp_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; reflexivity.\nintros n m; rewrite (tech_opp_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(*O *)\nsimpl in |- *; reflexivity.\n(* S x *)\nintros y H; rewrite (tech_mult_neg_posZ y (pos n)); rewrite H.\nrewrite (tech_add_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ y (pos n) (pos m)); reflexivity.\n(* S y *)\nintros m H; rewrite (tech_add_pos_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z y (pos n) (pos m)); reflexivity.\n(* S x *)\nintros m H; rewrite (tech_add_pos_posZ y (pos n)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z y (pos m)); rewrite H; reflexivity.\n(* S x *)\nintros m H; rewrite (tech_add_pos_Z y (pos m)); rewrite H;\n unfold oppZ in |-Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\n(* O *)\nintros y H; rewrite (tech_opp_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; rewrite (tech_opp_posZ y (pos m));\n rewrite (tech_opp_posZ y (pos m)); reflexivity.\n(* S y *)\nintros y H; rewrite (tech_opp_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; rewrite (tech_opp_posZ y (pos m));\n rewrite (tech_opp_posZ y (pos m)); reflexivity.\n(* S y *)\nintros y H; rewrite (tech_opp_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *; rewrite (tech_opp_posZ y (pos m));\n rewrite (tech_opp_posZ y (pos m)); reflexivity.\n(* S y *)\nintros y H; rewrite (tech_opp_posZ y (pos m)); rewrite H;\n unfold oppZ in |- *; rewrite (tech_opp_posZ y (pos m));\n rewrite (tech_opp_posZ y (pos m)); reflexivity.\n(* SQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_pos_Z y (pos n) m); rewrite H.\nrewrite (tech_add_neg_posZ y (pos m)); reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *;Qed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nintros; elim n; auto with arith.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_neg_posZ : forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n; simpl in |- *; auto with zarith.\nintros m; rewrite (tech_mult_neg_posZ m); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_Z m n); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; symmetry  in |- *. \nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (pos y0) x) x I I).\n(* neg n *)\nintros; elim (multZ_commutativity (neg n) (oppZ x)). \nelim (multZ_commutativity (neg n) x); elim n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; symmetry  in |- *.\nexact\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity \n    (multZ (neg y0) x) (oppZ x) I I).\nQed.\n\n(********************)\nLemma tech_multZ_negO : forall x : Z, multZ (neg 0) x = oppZ x.\n\nProof multZ_eq4.\n\n(***********************)\nLemma tech_mult_pos_posZ :\n forall n m : nat, multZ (pos n) (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\n",
                "context_tokens": 746,
                "proof_start_offset": 13745,
                "proof_end_offset": 14428,
                "proof": "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nreflexivity.\nsimple induction n.\nunfold multZ in |- *; reflexivity.\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros.\nelim H0.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (mult_oppZ_l y z).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros.\nelim H0.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem multZ_associativity : associativity Z multZ.\napply Z_mult_cst_nonneg.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply Z_mult_nonneg_nonneg.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\ngeneralize (Z_mult_neg_posZ (Z_of_nat_of_P n)); elim n.\n(* O *)\nintros m; rewrite (tech_opp_posZ m); rewrite (tech_opp_posZ m); reflexivity.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply Zmult_integral_l with (Z := Z).\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\ncut (0 <= Z_of_nat 0)%Z.\nintros H; rewrite (tech_oppZ (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (S n))))) n).\napply nat_of_P_mult_pos_nat.\napply le_O_n.\nrewrite mult_comm; apply le_O_n.\nrewrite <- mult_n_Sm; rewrite <- mult_n_Sm;\n rewrite <-Qed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nrepeat rewrite Z_mult_neg_pos; reflexivity.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\napply Z_mult_cst_posZ; assumption.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply Z_mult_nonneg_nonneg.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\napply Z_mult_nonneg_nonneg.\nQed.",
                    "Theorem multZ_associativity : associativity Z multZ.\nProof.\nunfold Z.abs at 1 in |- *; simpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") (pos m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (pos m)); rewrite H.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 739,
                "proof_start_offset": 14446,
                "proof_end_offset": 14693,
                "proof": "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nProof.\nunfold is_ring in |- *.\nsplit.\nexact addZ_commutativity.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit.\nexact multZ_associativity.\nexact mult_add_distributivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nred in |- *; intros.\nelim x.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros n; case n.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros n; case n.\n(* pos n *)\nintros; apply sym_equal; apply eq_Z_opp; auto.\n(* pos n *)\nintros n; case n.\n(* pos n *)\nintros; apply sym_Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nintros x y H; elim H.\nintros x y z H'; elim H'.\nintros z H'; elim H'.\nintros z H'; elim H'.\nintros H'0 H'1 H'2 H'3 H'4; elim H'4; intros H'5 H'6;\n elim H'6; intros H'6 H'7; clear H'6 H'7;\n elim H'6; intros H'7 H'7; clear H'6 H'7;\n elim H'6; intros H'7 H'7; clear H'6 H'7;\n elim H'6; intros H'7 H'7; clear H'6 H'7;\n clear H'6 H'7; intros H'7 H'7; clear H'6 H'7;\n elim H'6; intros H'7 H'8; clear H'6 H'7;\n elim H'6; intros H'7 H'7; clear H'6 H'7;\n elim H'7; intros H'8 H'8; clear H'6 H'7;\n clear H'6 H'7; intros HQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_mult in |- *; intros.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_cst.\napply Z_mult_Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_to_Z in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nred in |- *; intros; elim x.\n(* pos n *)\nintros; exists 0; auto with zarith.\n(* pos n *)\nintros; exists 0; auto with zarith.\n(* pos n *)\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nintros n0 H; exists 0; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_to_group in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivityQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\napply Z_to_group_nat_fun_pos.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_ring in |- *; intros.\nelim (mult_inv_posZ (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_of_nat (Z_Qed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nred in |- *; intros; elim H; intros; auto with arith.\n(* pos n *)\nunfold Z_to_group in |- *; rewrite H.\nrewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\n rewrite (Zmult_comm z0); rewrite (Zmult_comm z0);\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\nunfold Z_of_nat in |- *; simpl in |- *.\nrewrite <- mult_assoc.\nrewrite <- mult_plus_distr_r.\nrewrite (mult_comm (Z_of_nat (S z0)) (Z_of_nat (S z0)));\n repeat rewrite mult_assoc;\n rewrite <- mult_plus_distr_r.\nrewrite (mult_comm (Z_of_nat (S z0)) (Z_of_nat (S z0)));\n repeat rewrite mult_assoc;\n rewrite <- mult_plus_distr_r.\nrewrite (mult_comm (Z_of_nat (S z0)) (Z_of_nat (S z0)));\n repeat rewrite mult_assoc;\n rewrite <- mult_plus_distr_l.\nrewrite (mult_comm (Z_of_nat (S z0)) (Z_of_nat (S z0)));\n repeat rewrite mult_assoc;\n rewrite <- mult_plus_distr_r.\nrewrite (mult_comm (Z_of_nat (S z0)) (Z_of_nat (S z0)));\n repeat rewrite mult_assoc;\n rewrite <- mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(***********************)\nLemma tech_mult_neg_negZ :\n forall n m : nat, multZ (neg n) (neg m) = pos (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (neg m)); rewrite H;\n unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\n",
                "context_tokens": 728,
                "proof_start_offset": 14731,
                "proof_end_offset": 14951,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nexact multZ_commutativity.\nexact multZ_neutral.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold Z_ring in |- *.\nsplit. exact Z_unitExp_mult_nonneg_Z.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unitary_inj.\nsplit.\nexact Z_unitExp_zero.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nred in |- *.\nunfold Z_unit, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat in |- *.\nintros.\nrewrite <- (Z_of_nat_of_P_of_succ_nat_eq_succ_nat_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_pred.\napply Z_unitExp_Setoid.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold Z_of_minus in |- *.\nintros x y H'; rewrite (tech_mult_neg_Z y 0 H').\nunfold Z_of_nat, Z_of_nat in |- *; simpl in |- *.\nrewrite\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y)\n (fun x y => mult_comm y x) (fun x y => mult_comm x y) H').\nunfold Z_of_nat, Z_of_nat in |- *; simpl in |- *.\nrewrite\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y) (fun x y => mult_comm x y) H').\nunfold Z_of_nat, Z_of_nat in |- *; simpl in |- *.\nrewrite\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y)\n (fun x y => mult_comm x y)\n (funQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nred in |- *.\nsplit.\nexact Z_unitMap_injective.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nintros a; unfold Z_unitExp at 1 in |- *.\nred in |- *.\nintros; elim a.\nunfold Z_unitExp at 1 in |- *; simpl in |- *.\nintros; elim a; simpl in |- *.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nintros; apply Z_unitExp_left; assumption.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nred in |- *.\nunfold Z_of_nat, Z_of_nat, Z_of_nat in |- *; simpl in |- *;\n unfold Z_of_nat, Z_of_nat in |- *; simpl in |- *;\n unfold Z_of_nat, Z_of_nat in |- *; simpl in |- *;\n unfold Z_of_nat, Z_of_nat in |- *; simpl in |- *;\n auto with zarith.\nintros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Rgt in |- *; intros; apply Z_unitExp_left_pos.\nunfold Zminus in |- *; intros; apply Z_unitExp_left_pos.\nunfold ZminusQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit.\nexact Z_unitExp_plus_l.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nunfold is_ring in |- *.\nsplit. exact Z_unit radix_left.\nunfold is_upper_bound, oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_mult_plus_distr_r; reflexivity.\nunfold oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_mult_distr_l; reflexivity.\nunfold oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_mult_distr_r; reflexivity.\nunfold oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_mult_distr_l; reflexivity.\nunfold oppZ, oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_mult_distr_r; reflexivity.\nunfold oppZ, oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_mult_distr_r; reflexivity.\nunfold oppZ, oppZ, oppZ, oppZ in |- *; simpl in |- *.\nrewrite <- Z_opp_involutive.\nrewrite <- Z_opp_involutive.\nrewrite <- Z_Qed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\nProof.\nsplit.\nexact Z_unitExp_zero.\nexact Z_unitExp_zero.\nexact Z_unitExp_zero.\nexact Z_unitExp_zero.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " unfold oppZ in |- *.\nrewrite (tech_add_pos_posZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_pos_negZ :\n forall n m : nat, multZ (pos n) (neg m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_posZ y (neg m)); rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15006,
                "proof_end_offset": 15394,
                "proof": "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n x.\nrewrite (tech_mult_pos_posZ n (pos n) x).\nrewrite (tech_mult_pos_pos_posZ n (pos n) x).\nelim (mult_comm (pos n) x); intros.\nrewrite H; rewrite H0; reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x H; elim H; intros.\nunfold Z in |- *.\nelim H; intros.\nrewrite H0; rewrite H1; rewrite H1; rewrite H2; reflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n; elim n.\nunfold Zminus in |- *.\napply Z_unitExp_eq_pos.\nexact Z_unitExp_eq_pos.\nexact Z_unitExp_eq_pos.\nexact Z_unitExp_eq_pos.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros.\nrewrite <- H.\napply (ring_mult_pos_pos_posZ (pos n) x H).\nexact (Z_unit_left n x H).\nexact (Z_unit_right n x H).\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintro n; elim n; simpl in |- *; auto with arith.\nintros.\nrewrite (tech_opp_pos_posZ n) in |- *.\nrewrite H0.\nrewrite H0.\nrewrite <- H.\nreflexivity.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintro n.\nelim n.\nintros.\nsimpl in |- *.\napply Z_of_nat_complete_O.\napply Z_unit_l.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\nexact ZL4.\nintros; simpl in |- *; auto with *.\nintros; elim H.\nintros; simpl in |- *.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\nrewrite <- ZL4.\nintros; simpl in |- *; auto with *.\nintros; elim H.\nintros.\nsimpl in |- *.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply Z_of_nat_complete_O.\napply ZQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintros n; elim n.\nintros.\nunfold oppZ in |- *.\nrewrite (inv_permute_reverse n 0 x H).\nrewrite (inv_permute_reverse n 0 x H).\napply sym_equal; rewrite <- H; trivial.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n x H; elim H; intros; auto with zarith.\nQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nintros n; elim n.\nsimpl in |- *; reflexivity.\nintros n; elim n; simpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n1 x H; elim n1.\nsimpl in |- *; reflexivity.\nintros n1 x H; elim n1.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n1.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n2 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n3 x H; elim n2.\nsimpl in |- *; reflexivity.\nintros n3 x H; elim n3.\nsimpl in |- *; reflexivityQed.",
                    "Lemma tech_integ_posZ : forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\nProof.\nintro n; elim n.\nintros.\nrewrite (tech_opp_pos_posZ n x); unfold oppZ in |- *.\nrewrite Zmult_comm.\nrewrite (Zmult_comm (Z_of_nat n) (Z_of_nat n)).\nrewrite (Zmult_comm (Z_of_nat n) (Z_of_nat n)).\nrewrite (Zmult_comm (Z_of_nat n) (Z_of_nat n)).\nrewrite <- (Zmult_comm (Z_of_nat n) (Z_of_nat n)).\nrewrite <- (Zmult_comm (Z_of_nat n) (Z_of_nat n)).\nrewrite H0; reflexivity.\nrewrite <- H1; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_lemma y m); reflexivity.\nQed.\n\n(***********************)\nLemma tech_mult_neg_posZ :\n forall n m : nat, multZ (neg n) (pos m) = neg (n * m + (n + m)).\n\nintros; elim n.\n(* O *)\nsimpl in |- *; reflexivity.\n(* S y *)\nintros y H; rewrite (tech_mult_negZ y (pos m)); unfold oppZ in |- *;\n rewrite H.\nrewrite (tech_add_neg_negZ (y * m + (y + m)) m).\nelim (technical_lemma y m); reflexivity.\nQed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 15419,
                "proof_end_offset": 15807,
                "proof": "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nProof.\nintros n x; elim x.\nreflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ).\ndiscriminate.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_oppZ n n0); intros.\nabsurd (pos (n * n0 + n0) = 0).\nrewrite H0.\nrewrite H; apply minus_Sn_m.\napply sym_equal.\napply eq_Z_mult_cst.\nrewrite <- (mult_comm n n0); reflexivity.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\nintros n0 x H; rewrite (tech_opp_posZ n n0); intros.\nabsurd (pos (n * n0 + x) = true).\nrewrite H0.\napply sym_equal.\napply H.\napply sym_equal.\napply neg_inj; trivial.\nrewrite H0; rewrite H1; reflexivity.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n0 * n0 + n0) = pos (n0 * n0 + n0)).\nrewrite (tech_mult_neg_posZ n n0); intros.\ncut (pos (n0 * n0 + n0) = pos n0 * 0).\nrewrite H0; trivial.\nrewrite (tech_mult_pos_posZ n n0 n0); trivial.\nrewrite (tech_mult_pos_posZ n n0 n0); trivial.\nrewrite (tech_mult_neg_posZ n n0); trivial.\nrewrite (tech_opp_pos_posZ n n0); trivial.\nrewrite (tech_mult_neg_posZ n n0 n0); trivial.\nrewrite (tech_opp_pos_posZ n n0); trivial.\nrewrite (tech_opp_posZ n n0); trivial.\nrewrite (tech_opp_pos_posZ n n0); trivial.\nrewrite (tech_opp_posZ nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\nintros; rewrite (tech_opp_posZ n n0); intros.\nabsurd (pos (n * n0 + n0) = true).\nrewrite H0; exact H.\n(* pos n0 *)\nintros n0 H; rewrite (tech_opp_posZ n n0); intros.\nabsurd (pos (n0 * n0 + (n0 + n0)) = false).\nrewrite H0; exact H.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\nintros; simpl in |- *.\nrewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0) = 0).\nrewrite H0; rewrite H0; reflexivity.\nrewrite H; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = true).\nrewrite H0; rewrite H0; reflexivity.\nrewrite H; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = true).\nrewrite H0; reflexivity.\nrewrite H; reflexivity.\nrewrite H; reflexivity.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_opp_pos_posZ n n0); intros.\nabsurd (pos (n0 + n0) = pos n0).\nrewrite (tech_opp_pos_posZ n n0); intros.\nabsurd (pos (n0 + n0) = pos n0).\nrewrite (tech_opp_pos_posZ n n0); intros.\nabsurd (pos (n0 + n0) = pos n0).\nrewrite H2; reflexivity.\nabsurd (pos (n0 + n0) = pos n0).\nrewrite (tech_opp_pos_posZ n n0); intros.\nabsurd (pos (n0 + n0) = pos n0).\nrewrite H2; reflexivity.\napply H2.\nrewrite H1; reflexivity.\nQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x H'; elim H'; intros.\n(* pos n0 *)\nelim H'; intros.\nrewrite H'; rewrite H'; rewrite H'; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_oppZ n n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = true).\nrewrite H'; rewrite (tech_oppZ n n0); intros.\nabsurd (pos (n0 * n0 + (n0 + n0)) = true).\nrewrite H'; reflexivity.\nrewrite H'; rewrite H'; reflexivity.\nrewrite H'; reflexivity.\nrewrite H'; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_oppZ n n0); intros.\ncut (pos (n0 * n0 + (n0 + n0)) = false).\nrewrite H'; reflexivity.\nrewrite H'; reflexivity.\nrewrite H'; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_oppZ n n0); intros.\ncut (pos (n0 * n0 + (n0 + n0)) = true).\nrewrite H'; reflexivity.\nrewriteQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x H; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_opp_posZ n n0); intros.\ncut (n0 = 0).\nsimpl in |- *; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_opp_posZ n n0); intros.\ncut (n0 = 0).\nsimpl in |- *; reflexivity.\napply H.\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H1.\napply H2.\napply H2.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply HQed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (pos (n0 * n0 + (n0 + n0)) = true).\nrewrite H0.\nrewrite (tech_mult_neg_posZ n n0); trivial.\nchange (pos (n0 * n0) = pos n0 * n0 + (n0 + n0)) in |- *.\nrewrite H0.\nrewrite (tech_mult_pos_posZ n n0); trivial.\nchange (pos (n0 * n0 + (n0 + n0)) = pos n0 * n0) in |- *.\nrewrite H0.\nrewrite (tech_mult_pos_posZ n n0); trivial.\nchange (pos (n0 * n0 + (n0 + n0)) = pos n0 * n0 + (n0 + n0)) in |- *.\nrewrite H0.\nrewrite (tech_mult_pos_posZ n n0); trivial.\nchange (pos (n0 * n0 + (n0 + n0))Qed.",
                    "Lemma tech_integ_negZ : forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\nintros n x; elim x.\n(* pos n0 *)\nintros n0; rewrite (tech_opp_posZ n n0); intros.\nreplace (pos n0 + (n0 + n0)) with (pos n0 + 0)%Z.\nrewrite H; rewrite (tech_opp_posZ n n0); auto with zarith.\nrewrite H0; rewrite (tech_opp_pos_posZ n n0); auto with zarith.\nrewrite H0; rewrite (tech_opp_posZ n n0); auto with zarith.\n(* pos n0 *)\nintros n0; rewrite (tech_opp_posZ n n0); intros.\nreplace (pos n0 + (n0 + n0)) with (pos n0 + 0)%Z.\nrewrite H; rewrite (tech_opp_pos_posZ n n0); auto with zarith.\napply sym_equal; apply sym_equal; apply (Z_mult_comm n0 n); auto with zarith.\nrewrite H0; rewrite (tech_opp_posZ n n0); auto with zarith.\napply sym_equal; apply (Z_mult_comm n0 n);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "Qed.\n\n(**************************)\nTheorem multZ_associativity : associativity Z multZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nunfold multZ in |- *; reflexivity.\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (pos y0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\n",
                "context_tokens": 743,
                "proof_start_offset": 15829,
                "proof_end_offset": 16089,
                "proof": "Theorem integrityZ : integrity Z multZ OZ.\nProof.\nunfold integrity in |- *; intros a b; elim a.\nintros; left; reflexivity.\nintros; right; apply (tech_integ_posZ n b); exact H.\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold oppZ at 1 in |- *; unfold oppZ at 1 in |- *; unfold oppZ at 1 in |- *;\n unfold oppZ at 1 in |- *; unfold oppZ at 1 in |- *;\n unfold oppZ at 1 in |- *; rewrite oppZ_def; rewrite oppZ_def;\n apply Z_one_pos.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply (Build_Z (Z:=Z)).\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.\napply Z_oneFirst.Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold Zenencoding, Zenbound, Zenbound, Zenbound, Zenbound, Zenbound, Zenbound, Zenbound, Zenbound.\nintros n x H'; elim H'.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (0 < n0).\nauto with arith.\n(* pos n0 *)\nintros n0 H'; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (n0 < n0).\nauto with arith.\ncut (pos (n0 * n0 + n0) = 0).\nauto with arith.\napply sym_equal.\napply not_O_INR.\napply not_O_INR.\napply lt_O_nat_of_P.\nauto with arith.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold ZegLn in |- *.\nunfold ZegLn in |- *.\nunfold ZegLn in |- *.\napply\n (Build_Setoid (Z * Z) (Z * Z))\n    (Z * (Z * Z)) (Z * (Z * Z)) (Z * (Z * Z)))\n     (nat * (Z * Z)) (Z * Z)) (Z * Z)) (Z * Z))\n     (fun x : Z =>\n   match x return Z with\n   | Z0 => 0\n   | Zpos p =>\n       match p with\n       | Zpos p =>\n          match p with\n          | Z0 => 1\n          | Zpos p => Zneg p\n          end\n       | Zneg p =>\n          match p with\n          | Z0 => 1\n          | Zneg p => Zneg p\n          end\n      end\n  end.\n\nTheorem tech_pos20 :\n forall (n : nat) (x : Z),\n ~ (0 < n)%Z ->\n (0 < n)%Z ->\n (0 <= x)%Z ->\n (0 <= x)%Z ->\n (0 <= x)%Z ->\n (0 <= x)%Z ->\n (0 <= x)%Z ->\n (0 <= x)%Z ->Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.\napply Z_one_gen.Qed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold Zer in |- *; intros.\nrewrite H; rewrite (tech_oppZ n n0); intros.\nabsurd (pos (n * n0 + (n0 + n0)) = true).\nrewrite H; apply Z.mul_opp_l.\nrewrite H0; rewrite (tech_oppZ n n0); intros.\nabsurd (pos (n * n0 + n0) = false).\nrewrite H0; apply Z.mul_opp_r.\nrewrite H; apply Z.mul_opp_l.\nrewrite H; reflexivity.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\napply Z_one_gen.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold Zeg)^~ in |- *.\nunfold Zer at 1 in |- *.\nunfold Zer at 1 in |- *.\nrewrite <- Z_mult_distr_l_reverse; reflexivity.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nred in |- *.\napply Z_oneExp_zero.\nsplit.\nexact Z_unitExp_zero.\nexact Z_unitExp_zero.\nexact Z_unitExp_zero.\nQed.",
                    "Theorem integrityZ : integrity Z multZ OZ.\nunfold one in |- *.\nunfold oppZ at 1 in |- *.\nunfold oppZ at 1 in |- *.\nunfold oppZ at 1 in |- *.\nrewrite plus_comm.\nrewrite plus_opp_diag.\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "0) y) y z); intros. elim H0.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (mult_oppZ_l y z).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nrewrite H; elim (mult_oppZ_l y z).\nelim (mult_add_distributivity (multZ (neg y0) y) (oppZ y) z); intros. elim H0.\nreflexivity.\nQed.\n\n(*************)\nTheorem Z_ring : is_ring Z IdZ addZ multZ OZ oppZ.\n\nunfold is_ring in |- *.\nsplit. exact addZ_commutativity.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit. exact multZ_associativity. exact mult_add_distributivity.\nQed.\n\n(*********************************)\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ addZ multZ OZ IZ oppZ.\n\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit. exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\n",
                "context_tokens": 722,
                "proof_start_offset": 16118,
                "proof_end_offset": 16787,
                "proof": "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros; elim m.\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros.\nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)).\nrewrite (mult_neutr (S n)).\nunfold posOZ in |- *; reflexivity.\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)); elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\nunfold opp at 2 in |- *; unfold opp at 2 in |- *.\nintros n m; rewrite (tech_mult_neg_posZ n m); intros.\nabsurd (pos (n * m) = pos n * pos m).\nrewrite H; reflexivity.\nrewrite H; reflexivity.\nunfold opp at 2 in |- *; unfold opp at 2 in |- *.\nrewrite (mult_comm (pos n)); reflexivity.\nrewrite H; reflexivity.\nunfold opp at 2 in |- *; unfold opp at 2 in |- *.\nrewrite (mult_comm (pos n)); reflexivity.\nrewrite H; reflexivity.\nunfold opp at 2 in |- *; unfold opp at 2 in |- *.\nrewrite (mult_comm (pos n)); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\n(* pos n *)\nintros; left; apply (tech_mult_pos_posZ n m); exact H.\n(* pos n *)\nintros n0; right; apply (tech_mult_pos_posZ n m); exact H.\n(* pos n0 *)\nintros n0; right; apply (tech_mult_pos_pos_posZ n m); exact H.\n(* pos n0 *)\nintros n0; right; apply (tech_mult_neg_posZ n m); exact H.\n(* pos n0 *)\nintros n0; right; apply (tech_opp_pos_posZ n m); exact H.\n(* pos n0 *)\nintros n0; right; apply (tech_opp_pos_posZ n m); exact H.\n(* pos n0 *)\nintros n1; right; apply (tech_opp_pos_posZ n m); exact H.\n(* pos n0 *)\nintros n1; right; apply (tech_opp_pos_posZ n m); exact H.\n(* pos n0 *)\nintros n1; right; apply (tech_oppQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\nsimpl in |- *.\nrewrite <- (tech_mult_neg_posZ n m); intros.\ncut (pos (S n) = pos (S m)).\nrewrite (tech_mult_neg_pos_posZ n m); intros.\ncut (pos (S m) = pos (S m)).\nrewrite <- (pos_abs_posZ n m); auto with arith.\nrewrite (tech_mult_pos_posZ n m); intros.\nabsurd (pos (S m) = pos (S m)).\nrewrite H; auto with arith.\nrewrite H0; auto with arith.\nrewrite H0; auto with arith.\nrewrite H0; auto with arith.\nrewrite H0; auto with arith.\nrewrite H0; auto with arith.\nrewrite H; auto with arith.\nrewrite H; auto with arith.\nrewrite H; auto with arith.\nrewrite H; auto with arith.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros; elim n.\n(* pos n *)\nintros; right; apply (tech_mult_pos_pos_posZ n m); exact H.\n(* pos n *)\nintros; left; apply (tech_mult_neg_posZ n m); exact H.\n(* pos n *)\nintros; right; apply (tech_mult_pos_posZ n m); exact H.\n(* pos n *)\nintros; right; apply (tech_mult_pos_posZ n m); exact H.\n(* pos n *)\nintros; left; apply (tech_opp_pos_posZ n m); exact H.\n(* pos n *)\nintros n0; rewrite (tech_mult_neg_posZ n0); exact H.\n(* pos n *)\nintros n0; rewrite (tech_opp_pos_posZ n0); exact H.\nintros; left; apply (tech_opp_pos_posZ n0); exact H.\n(* pos n *)\nintros; left; apply (tech_opp_pos_posZ n0); exact H.\n(* pos n *)\nintros n0; rewrite (tech_opp_pos_posQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\nsimpl in |- *; reflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n n0); reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nProof.\nintros n m; elim n.\nsimpl in |- *.\napply (tech_mult_pos_pos_pos (S n) (pos m)); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n; simpl in |- *; auto with arith.\nintros m H; rewrite (tech_mult_pos_posZ m n); intros.\nabsurd (pos (n * m) = pos n0).\nrewrite H; rewrite H; auto with arith.\nelim H; auto with arith.\nintros n0 H1; rewrite (tech_mult_pos_posZ m n0); intros.\nabsurd (pos (n0 * m) = pos n0).\nrewrite H; auto with arith.\nelim H; auto with arith.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim m.\n(* 0 *)\nintros n m; rewrite (tech_mult_neg_posZ n m); intros.\nabsurd (pos (pos m) = pos (n * m)).\nrewrite H; reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_opp_posZ n m); intros.\nabsurd (pos (n * m) = pos (n * m)); auto.\nrewrite H; reflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_opp_posZ n m); intros.\ncut (pos (n * m) = pos (n * m)).\nrewrite H; reflexivity.\nrewrite (tech_opp_posZ n m); intros.\nrewrite (tech_opp_posZ n m); intros.\ncut (pos (n * m) = pos (n * m)).\nrewrite H; reflexivity.\nrewrite (tech_opp_posZ n m); intros.\ncut (pos (n * m) = pos (n * m)).\nrewrite H; reflexivity.\nrewrite (tech_opp_posZ n m); intros.\ncut (pos (n * m) =Qed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; right; apply (tech_eq (pos m) (S m)); exact H.\nQed.",
                    "Lemma tech_mult_pos_succZ : forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\nintros n m; elim n.\nsimpl in |- *; reflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n m); reflexivity.\n(* pos n *)\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; rewrite (tech_mult_neg_posZ n m); reflexivity.\n(* pos n *)\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivity.\nintros n0; elim n0.\nsimpl in |- *; reflexivityQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " exact multZ_commutativity. exact multZ_neutral.\nQed.\n\n(* Z is an integral domain *)\n(********************)\nLemma tech_integ_posZ :\n forall (n : nat) (x : Z), multZ (pos n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_pos_posZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\n",
                "context_tokens": 721,
                "proof_start_offset": 16816,
                "proof_end_offset": 17035,
                "proof": "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim n; elim m.\n(* 0 *)\nintros; left; reflexivity.\n(* 0 *)\nintros; right; apply (tech_add_pos_posZ n m); intros;\n [ rewrite (tech_add_pos_posZ n m) | idtac ];\n rewrite (tech_add_pos_posZ n m) ;\n rewrite (tech_add_pos_posZ n m) ;\n rewrite (tech_add_pos_posZ n m) ;\n rewrite (tech_add_pos_posZ n m) ;\n rewrite (tech_add_pos_posZ n m) ;\n rewrite (tech_add_pos_pos_posZ n m) ;\n rewrite (tech_add_pos_pos_posZ m m) ;\n rewrite (tech_add_pos_pos_posZ m n) ;\n rewrite (tech_add_pos_pos_pos_posZ m m) ;\n rewrite (tech_add_pos_pos_posZ m m) ;\n rewrite (tech_add_pos_pos_pos_posZ m m) ;\n rewrite (tech_add_pos_pos_posQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim (mult_comm (pos m) (pos m)).\nrewrite (tech_mult_pos_posZ m n); intros.\nrewrite (tech_mult_neg_posZ m n); rewrite (tech_mult_pos_posZ m n);\n rewrite (tech_mult_neg_pos_posZ m n); rewrite (tech_mult_neg_pos_posZ m n);\n rewrite (tech_mult_pos_posZ m n); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros n m; elim n; elim m.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |-Qed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nreflexivity.\nrewrite (tech_mult_pos_pos_posZ n n m); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros y H; elim (mult_comm y (pos m)); intros.\nreplace (pos (S m) + (n + m)) with (pos m * S m + n).\nrewrite H; reflexivity.\nrewrite H; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nrewrite (tech_mult_pos_pos_posZ n n0); reflexivity.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim n; simpl in |- *; auto.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nelim multZ_gt_0_compat; intros; elim (H0 (pos n) I); intros.\nreplace (pos (S (pos n) * pos (S (pos m) * pos (S (pos m))) with (pos n * pos n).\napply le_IZR_lt; intros; rewrite H0.\nelim (mult_comm (pos n) (pos m)); auto with arith.\nrewrite H0.\nelim (mult_comm (pos n) (pos m)); auto with arith.\nrewrite H0.\nelim (mult_comm (pos n) (pos m)); auto with arith.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nsimple induction n; intros; simpl in |- *.\nrewrite (tech_mult_pos_posZ n m); trivial.\nQed.",
                    "Lemma tech_mult_pos_succZ2 : forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_pos_negZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(********************)\nLemma tech_integ_negZ :\n forall (n : nat) (x : Z), multZ (neg n) x = OZ -> x = OZ.\n\nintros n x; elim x.\n(* OZ *)\nreflexivity.\n(* pos n0 *)\nintros n0; rewrite (tech_mult_neg_posZ n n0); intros.\nabsurd (neg (n * n0 + (n + n0)) = OZ). discriminate. exact H.\n(* neg n0 *)\nintros n0; rewrite (tech_mult_neg_negZ n n0); intros.\nabsurd (pos (n * n0 + (n + n0)) = OZ). discriminate. exact H.\nQed.\n\n(*****************)\nTheorem integrityZ : integrity Z multZ OZ.\n\nunfold integrity in |- *; intros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right; apply (tech_integ_posZ n b); exact H.\n(* neg n *)\nintros; right; apply (tech_integ_negZ n b); exact H.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ :\n forall n m : nat, posOZ (S n * S m) = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 17054,
                "proof_end_offset": 17961,
                "proof": "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nProof.\nintros n0 n q r; elim q.\nelim r.\nintros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *; reflexivity.\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim H; intros.\nreplace (pos (pred (pred (S (pred n0) * S n))) with (S (pred (S (pred n0))).\nrewrite <- H2; rewrite H2; rewrite H0; reflexivity.\napply tech_mult_pos_fibonacci; auto with arith.\nunfold pos at 2 in |- *; rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); reflexivity.\napply tech_mult_pos_fibonacci; auto with arith.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (mult_n_Sm n0 q); intros.\nreplace (pos (pred (S n0)) with (pos n0 + r); auto.\napply tech_mult_pos_Zneg_pos with (S n0); auto.\napply tech_mult_pos_Zneg_pos with (S n0); auto.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros n0 n q r H0; elim H0; elim H0; elim H0; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H0; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H0; intros; auto.\nelim H0; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H0; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H0; intros; auto.\nelim H0; intros; auto.\nelim H0; intros; auto.\nelim H; intros; auto.\nelim H0; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros; auto.\nelim H; intros;Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nLemma tech_pow_pos_apart1 :\n forall n m : nat, S n = q * m + r -> pos (n * m) = pos n * pos m.\nintros n m; elim (mult_comm (pos n) (pos m));\n simpl in |- *; elim (mult_comm (pos m) (pos m));\n intros; elim (mult_comm (pos m) (pos m));\n simpl in |- *; elim (mult_comm (pos m) (pos m));\n simpl in |- *; elim (mult_comm (pos m) (pos m));\n simpl in |- *; elim (mult_comm (pos m) (pos m));\n simpl in |- *; elim (mult_comm (pos m) (pos m)); \n simpl in |- *; elim (mult_comm (pos m)); \n intros; simpl in |- *; elim (mult_comm (pos m) (pos m)); \n simpl in |- *; elim (mult_comm (pos m) (pos m)); \n simpl in |- *; elim (mult_comm (pos m)); \n intros; simpl in |- *; elim (mult_comm (pos m) (pos m)); \n simpl in |- *;Qed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros n0 n1 q r; elim r.\nsimpl in |- *; elim (mult_n_Sm n0 n1); elim (mult_n_Sm n0 n1);\n reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim (mult_n_Sm n0 n); elim (mult_n_Sm n0 n);\n simpl in |- *; elim (mult_assoc n0 n); simpl in |- *; auto.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim H; elim H; elim H; elim H;\n elim (mult_n_Sm (pos n) (pos q)); intros; rewrite H0;\n rewrite H0; reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros n0 n q r H0 H1 H2; rewrite (tech_mult_pos_posZ n0 n0); intros; rewrite H1;\n rewrite (tech_mult_pos_pos_pos n0 n0); intros;\n rewrite H1; rewrite (tech_mult_pos_pos_pos n0 n0); \n intros; reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\nintros; elim H; elim H; elim H0; intros; auto.\nelim (mult_n_Sm (S n0) q); elim (mult_n_Sm (S n0) q r);\n reflexivity.\nQed.",
                    "Lemma tech_div1 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nLemma tech_pow2 :\n forall n m : nat,\n n = m ->\n (n * m) * (n + m) = multZ (pos n) (pos m).\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; right; reflexivity.\nintros; right; reflexivity.\nintros; left; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ") = multZ (pos n) (pos m).\n\nintros; elim m.\n(* O *)\nelim multZ_neutral; intros; elim (H0 (pos n) I); intros. \nreplace (pos 0) with IZ; auto.\nrewrite H1.\nelim (mult_commut 1 (S n)). rewrite (mult_neutr (S n)). \nunfold posOZ in |- *; reflexivity.\n(* S y *)\nintros y H; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n));\n elim (multZ_commutativity (pos n) (pos y)).\nelim H; elim (mult_n_Sm (S n) (S y)); elim (plus_n_Sm (S n * S y) n).\nelim (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 17980,
                "proof_end_offset": 18420,
                "proof": "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nProof.\nintros n0 n q; elim q.\nsimpl in |- *; intros; absurd (S n0 = 0).\ndiscriminate.\nexact H.\nintros y H; unfold negOZ in |- *.\nrewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros; elim (mult_integral _ _ H); intros.\nrewrite H; rewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0) (neg _)), H1.\nrewrite (mult_comm (pos n0)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (neg n0)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (pos n0) (neg q)).\nrewrite (mult_comm (pos n0) (pos q)).\nrewrite (mult_comm (posQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q H0 H1; elim H1; auto with arith.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0).\ndiscriminate.\nintros; absurd (S n0 = 0).\ndiscriminate.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q H; elim q.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q H H0; elim H; elim H; elim H; simpl in |- *;\n intros; elim H0; intros; elim H1; intros;\n    rewrite H2; rewrite H3; rewrite H4; rewrite H4;\n    reflexivity.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim n; simpl in |- *; auto with arith.\nintros; absurd (S n0 = 0). discriminate.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q H H0; elim H; elim H; elim H; elim H0;\n [ intros; assumption\n | intros; rewrite H0; rewrite H1; rewrite H2; rewrite H2;\n assumption ].\nintros n0 p H; unfold pos at 1 in |- *; rewrite (mult_comm (pos n0)).\nsimpl in |- *; intros; elim (plus_n_O (S n0));\n [ rewrite (mult_comm (pos n0) (pos z0));\n rewrite (mult_comm (pos n0));\n rewrite (mult_comm (pos n0)); reflexivity\n | intros; apply (mult_reg_l (S n0) (S q) (S q) H0);\n apply (mult_reg_l (S n0) (S q) (S q) (S q) H0);\n apply (mult_reg_l (S n0) (S q) (S q) (S q) H0);\n apply (mult_reg_l (S n0) (S q) (S q) (S q) H0);\n apply (mult_reg_l (S nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros; elim q.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros;Qed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nsimple induction n.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arith.\nintros; elim n; simpl in |- *; auto with arithQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q H; elim H; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_div2 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\nintros n0 n q; elim q.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminate.\nintros; absurd (S n0 = 0). discriminateQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (mult_n_Sm (S n) y); elim (plus_n_Sm (S n * y) n).\nunfold posOZ in |- *; rewrite (tech_add_pos_posZ (S n * y + n) n).\nreflexivity.\nQed.\n\n(************************)\nLemma tech_mult_pos_succZ2 :\n forall n m : nat, multZ (pos n) (pos m) = pos (S n * m + n).\n\nintros; elim (tech_mult_pos_succZ n m).\nsimpl in |- *; elim (mult_n_Sm n m); elim (plus_assoc m (n * m) n);\n reflexivity. \nQed.\n\n(**************)\nLemma tech_div1 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (pos n) (posOZ q)) (posOZ r).\n\nintros n0 n q r; elim q.\n(* O O *)\nelim r.\nintros; absurd (S n0 = 0). discriminate. exact H.\n(* O (S y) *)\nintros y H; unfold posOZ in |- *; rewrite (mult_OZ (pos n)).\nsimpl in |- *; intros; elim (eq_add_S n0 y H0); reflexivity.\n(* (S n) O *)\nelim r.\nintros y H; unfold posOZ in |- *; elim (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 711,
                "proof_start_offset": 18440,
                "proof_end_offset": 19318,
                "proof": "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nProof.\nintros; elim q.\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)).\ncut (IZ = pos 0); intros.\nelim H.\nrewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity.\nreflexivity.\nintros y H; unfold posOZ in |- *; elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos y) (pos n)) (pos n) I I).\nelim (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros; elim q.\nintros; apply tech_div4; trivial.\napply tech_mult_pos_fibonacci; trivial.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\nsimpl in |- *; intros; absurd (S (n0 = 0)).\napply sym_equal; apply eq_add_S; assumption.\nrewrite tech_add_pos_pos; rewrite (pos_sub_correct n0 n); reflexivity.\nrewrite H; reflexivity.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\nsimpl in |- *; intros; absurd (S n = 0).\ndiscriminate.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros; elim (mult_comm (S n) (pos q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n elim (mult_comm (S n) (S q)); simpl in |- *;\n auto with arith.\nQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl inQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\nsimpl in |- *; intros; absurd (S n = 0).\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S y *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S x *)\nsimpl in |- *; intros; cut (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S x *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S x *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S x *)\nsimpl in |- *; intros; absurd (S (n * y)).\nsimpl in |- *; reflexivity.\n(* S x *)\nsimpl in |- *; introsQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\nsimpl in |- *; intros; rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (mult_comm (S n)); simpl in |- *;\n rewrite (multQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\nintros n q; elim q.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (S n = 0).\nreflexivity.\nsimpl in |- *; intros; absurd (SQed.",
                    "Lemma tech_div31 : forall n q : nat, addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros n q; elim q.\nsimpl in |- *; reflexivity.\nintros; absurd (S n = 0).\ndiscriminate.\nintros; absurd (S n = 0).\ndiscriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (plus_n_O (S y * S n)).\nrewrite (add_OZ (multZ (pos n) (pos y))); elim (tech_mult_pos_succZ n y).\nelim (mult_commut (S n) (S y)); intros; elim H0; unfold posOZ in |- *;\n reflexivity.\n(* (S n) (S y) *)\nintros y H y0 H0; unfold posOZ in |- *; elim (plus_n_Sm (S y0 * S n) y).\nintros; rewrite (eq_add_S n0 (S y0 * S n + y) H1).\nrewrite (tech_mult_pos_succZ2 n y0).\nrewrite (tech_add_pos_posZ (S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 719,
                "proof_start_offset": 19338,
                "proof_end_offset": 19708,
                "proof": "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nProof.\nintros n q r; elim r.\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n)); elim (minus_n_O n).\nreflexivity.\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry in |- *.\nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nsimple induction n; intros.\nrewrite H0.\nrewrite H1.\nrewrite (mult_comm (pos n) (pos Dz)); reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nsimple induction n.\nintros; simpl in |- *; intros; cut (S n > r); auto with arith.\nintros; simpl in |- *; intros; cut (S r < r); auto with arith.\nintros; simpl in |- *; intros; apply H; rewrite <- H0; rewrite (mult_comm x);\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (pos y));\n rewrite (mult_comm (pos y)); rewrite (mult_comm (Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n; simpl in |- *; intros; elim H; intros; simpl in |- *;\n reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim r.\nsimpl in |- *; intros; absurd (n = 0).\nexact (fun q0 : nat => multZ (pos n) (posggcd q0)) (pos n).\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim q.\n(* O *)\nunfold pos at 1 in |- *; rewrite (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite <- (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nrewrite (mult_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim n.\nsimpl in |- *; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros;\n   generalize (mult_fact_pos_pos n y); intros; elim H5; intros; \n generalize (mult_fact_pos_pos n y); intros; elim H5; intros; \n generalize (mult_fact_pos_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nsimple induction n; intros; simpl in |- *; elim H;\n rewrite (mult_recompose (pos n)).\nelim (mult_comm (pos n) (pos q)); intros; elim H0; intros; elim H0; intros; elim H3; intros;\n rewrite H5; reflexivity.\nQed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nsimple induction n; intros; simpl in |- *; elim (mult_comm (pos n)); simpl in |- *;\n intros; elim H; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H7; intros; elim H5; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; \n elim H7; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7;Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim q.\nintros q0 H; unfold neg in |- *; rewrite (mult_comm (pos n)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_comm (pos n) (pos q0)).\nelim (mult_Qed.",
                    "Lemma tech_div32 : forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\nintros; elim q.\n(* pos *)\nunfold pos at 1 in |- *; rewrite (mult_comm (pos n)).\nrewrite (mult_comm (pos n)).\nelim (mult_comm (pos n) (pos n)).\nintros; elim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n rewrite H6; rewrite (add_multKr (pos n)));\n rewrite H6; rewrite (add_multKr (pos n)) (minus_n_O (S n)));\n rewrite H6; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "S n * y0 + n) y).\nelim (plus_comm n (S n * y0)); elim (mult_commut y0 (S n)); simpl in |- *.\nreflexivity.\nQed.\n\n(**************)\nLemma tech_div2 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (pos n) (negOZ q).\n\nintros n0 n q; elim q.\n(* O *)\nsimpl in |- *; intros; absurd (S n0 = 0). discriminate. exact H.\n(* S y *)\nintros y H; unfold negOZ in |- *. rewrite (tech_mult_pos_negZ n y); intros.\nsimpl in H0; rewrite (eq_add_S _ _ H0).\nelim (mult_commut (S n) y); simpl in |- *; elim (plus_comm (n + y) (n * y)).\nelim (plus_assoc n y (n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 19727,
                "proof_end_offset": 20249,
                "proof": "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r))) .\nrewrite (tech_div31 n q).\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r H0; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n rewrite H4; rewrite (mult_comm (pos n0)) (mult_comm (pos n0)).\nelim (mult_comm (pos n0)); simpl in |- *; elim (plus_comm (pos n0)); simpl in |- *;\n elim (mult_comm (pos n0)); simpl in |- *; elim (mult_comm (pos n0)); simpl in |- *;\n elim (mult_comm (pos n0)); simpl in |- *; elim (mult_comm (pos n0)); simpl in |- *;\n elim (mult_comm (pos n0)); simpl in |- *;\n elim (mult_comm (pos n0)); simpl in |- *; elim (mult_comm (pos n0)); simpl in |- *;\n elim (mult_comm (pos n0)); simpl in |- *; \n elim (mult_comm (pos n0)); simpl in |- *;\n elim (mult_comm (pos n0)); simpl in |- *; elim (mult_comm (pos n0)); simpl in |- *;\n elim (mult_comm (posQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r H0; elim H; elim H; intros; elim H0; intros; elim H1; intros;\n    assumption.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r H H0; elim H; elim H; elim H0; intros; elim H1; intros; elim H2; intros;\n    rewrite H1; rewrite (add_multKr (pos n0)) in H2;\n      rewrite (add_multKr (pos n0)) in H2; rewrite (add_multKr (pos n0)) in H2;\n        rewrite (add_multKr (pos n0)) in H2; rewrite (add_multKr (pos n0)) in H2;\n          rewrite (add_multKr (pos n0)) in H2; rewrite (add_multKr (pos n0)) in H2;\n          rewrite (add_multKr (pos n0)) in H2; rewrite (add_multKr (neg n0)) in H2;\n            rewrite (add_multKr (pos n0)) in H2; rewrite (add_multKr (pos n0)) in H2;\n            rewrite (add_multKr (pos n0)) in H2; rewrite (add_multKr (pos n0)) in H2;\n            rewrite (add_multKr (pos n0)) in H2;\n            rewrite (add_multKr (pos n0)) in HQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r H; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n    rewrite H2; rewrite (mult_comm (pos n0)) in H1; elim (mult_comm (pos n0) (S n0));\n      intro; elim H1; intros; elim H2; intros; elim H3; intros;\n      rewrite H4; rewrite (mult_comm (pos n0)) in H2;\n        rewrite (mult_comm (pos n0)) in H2;\n          rewrite (mult_comm (pos n0)) in H2;\n            rewrite (mult_comm (pos n0)) in H2;\n              rewrite (mult_comm (pos n0)) in H2;\n              rewrite (mult_comm (pos n0)) in H2;\n              rewrite (mult_comm (pos n0)) in H2;\n                rewrite (mult_comm (pos n0)) in H2;\n                rewrite (mult_comm (pos n0)) in H2;\n                  rewrite (mult_comm (pos n0)) in H2;\n                  rewrite (mult_comm (pos n0)) in H2;\n                  rewrite (Qed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n0 q r H0; elim H; simpl in |- *; auto.\nintros; rewrite H0; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (neg n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (neg n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg q)).\nrewrite H; rewrite (add_multKr (pos n0) (neg qQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros; elim n.\nauto with arith.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros; elim H.\nrewrite (mult_comm (pos n0) (pos q)); rewrite H; intros.\nrewrite H; rewrite (mult_comm (pos n0) (pos q));\n rewrite H; rewrite (mult_comm (pos n0)); reflexivity.\nrewrite H; rewrite (mult_comm (pos n0) (pos q)); reflexivity.\n(* S y *)\nintros n0 q r H0; rewrite (mult_comm (pos n0) (pos q));\n rewrite H; intros.\nrewrite H; rewrite (mult_comm (pos n0) (pos q));\n rewrite H; intros.\nrewrite H; rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite H; intros.\nrewrite H; rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite H; intros.\nrewrite H; rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite H; intros.\nQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r; elim r.\nsimpl in |- *; intros; rewrite (mult_comm (pos n0));\n elim (mult_assoc n0 n0 (S q) (S q) r).\nsimpl in |- *; intros; elim H; intros.\nrewrite H5; rewrite (mult_comm (pos n0)); reflexivity.\n(* S y *)\nintros n0 n1 p q r H H0 H1 H2; rewrite (mult_comm (pos n0) (neg q)).\nrewrite H1; rewrite (mult_comm (pos n0) (neg q)).\nelim (mult_assoc n0 n1 (S q) r).\nsimpl in |- *; intros; elim H; intros.\nrewrite H5; rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewrite (mult_comm (pos n0) (pos q));\n rewriteQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n0 q r H H0 H1.\nelim H.\nsimpl in |- *; intros; absurd (S n0 = 0).\napply H; auto with arith.\nrewrite (mult_comm (pos n0)); rewrite H1; rewrite (mult_comm (pos n0));\n apply (fun (x y : Z) (H : x + y = S n0) => H H).\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n    rewrite H3; rewrite (mult_comm (pos n0) (pos n0));\n    rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n    rewrite (mult_comm (pos n0) (pos n0));\n    apply (fun (x y : Z) (H : x + y = S n0) => H H).\nelim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n    rewrite H3; rewrite (mult_comm (pos n0) (pos n0));\n    rewrite (mult_comm (pos n0) (posQed.",
                    "Lemma tech_div3 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\nintros n0 n q r H0 H1 H2; rewrite H1; rewrite H2; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "n * y)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div31 :\n forall n q : nat,\n addZ (oppZ (multZ (pos n) (pos q))) (pos n) = oppZ (multZ (pos n) (posOZ q)).\n\nintros; elim q.\n(* O *)\nunfold posOZ in |- *; rewrite (mult_OZ (pos n)). \ncut (IZ = pos 0); intros. elim H. rewrite (mult_IZ (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; reflexivity. reflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *;\n elim (multZ_commutativity (pos (S y)) (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 709,
                "proof_start_offset": 20268,
                "proof_end_offset": 20706,
                "proof": "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nProof.\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim H; intros.\nrewrite (mult_comm (pos n0) (neg q)); rewrite (tech_add_pos_pos_pos n0 q); reflexivity.\nrewrite (mult_comm (pos n0) (pos q)); rewrite (tech_add_pos_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_add_pos_neg n0 q); reflexivity.\nrewrite (tech_add_pos_pos n0 q); reflexivity.\nrewrite (tech_Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim H; intros.\nrewrite H0; rewrite (mult_comm (pos n0)).\nrewrite <- H1.\nrewrite <- H2.\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H1.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite (mult_comm (pos n0)).\nrewrite H2.\nrewrite (mult_comm (pos n0)).\nrewrite <- H2.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite H2.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite H2.Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n rewrite H4; rewrite H1; ring.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros.\nelim (tech_opp_pos_pos n0 n q); intros; elim H0.\nrewrite (mult_comm (pos n0)); rewrite (tech_opp_l (pos n0)); reflexivity.\nQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n rewrite (mult_comm (pos n0)) (pos n0);\n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0)) (pos n0);\n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0));\n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0));\n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0));\n rewrite (Zmult_comm (pos n0)); rewrite (Zmult_comm (pos n0)); \n rewrite (Zmult_comm (pos n0)); rewrite (Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_opp_pos_pos n0 n q r H); intros.\nrewrite (mult_comm (pos n) (pos q)); rewrite (tech_div4 n q r H0).\nrewrite (tech_add_pos_pos_neg_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_pos n0 n q).\nrewrite (tech_add_pos_Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_opp_pos_pos n0 n q); intros; elim H0; intros; elim H1; intros; elim H2; intros;\n rewrite H3; rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0)).\nelim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n    rewrite H5; rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n    rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n      rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0)).\nelim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n    rewrite H5; rewrite (mult_comm (pos n0) (pos q));\n      rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0));\n      rewrite (mult_comm (pos n0)); rewrite (mult_comm (pos n0Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_opp_pos_pos q); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n rewrite H5; rewrite (mult_comm (pos n0) (pos q));\n rewrite (tech_add_pos_neg_pos n0 q H0).\nelim (tech_opp_pos_pos q); intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n rewrite H5; rewrite (mult_comm (pos n0) (pos q0));\n rewrite (tech_add_pos_pos n0 q H0).\nelim (tech_opp_pos_pos q); intros; elim H5; intros; elim H5; intros;\n rewrite H5; rewrite (mult_comm (pos n0) (pos q0));\n rewrite (tech_add_pos_pos n0 q H0).\nelim (tech_opp_pos q); intros; elim H5; intros;\n rewrite H5; rewrite (mult_comm (pos n0) (pos q0));\n rewrite (techQed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (mult_n_O n0); intros.\nrewrite (mult_comm (pos n0)); rewrite (tech_div4 n q r H0).\nrewrite (tech_mult_neg_pos_pos_pos (pos n0) (pos q)); reflexivity.\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) (pos q) r H0).\nrewrite (tech_add_pos_pos (pos n0) r r H0).\nrewrite (tech_add_pos_pos (Qed.",
                    "Lemma tech_div4 : forall n0 n q r : nat, S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\nintros.\nelim (tech_opp_pos_pos n0 n q r H); intros.\nrewrite (mult_comm (pos n0) (pos q)); rewrite (tech_div4 n q r H0).\nrewrite <- (mult_comm (pos n0) (pos q)); rewrite (tech_div4 n q r H0).\nrewrite (tech_add_pos_pos_pos n0 n q); rewrite (tech_add_pos_pos n0 n q); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (pos n)).\nrewrite (tech_mult_posZ y (pos n)).\nrewrite\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos y) (pos n)) (pos n) I I).\nelim\n (addZ_associativity (oppZ (multZ (pos y) (pos n))) (oppZ (pos n)) (pos n)).\nelim (addZ_opposite (pos n) I); intros; elim H1; intros; elim H3; intros.\nrewrite H5; rewrite (add_OZ (oppZ (multZ (pos y) (pos n)))).\nelim (multZ_commutativity (pos y) (pos n)); reflexivity.\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 719,
                "proof_start_offset": 20725,
                "proof_end_offset": 21054,
                "proof": "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nProof.\nintros; cut (posOZ q = oppZ (negOZ q)); intros.\nrewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (S n0 = n0); intros.\nrewrite H; apply tech_div5; assumption.\napply (mult_comm (pos n0)).\napply (mult_comm (pos n0)).\nrewrite H; reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; elim H; intros; elim H0; intros; elim H1; intros;\n    rewrite H1; rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0));\n    rewrite (mult_comm (pos n0) (pos q)); rewrite (mult_comm (pos n0) (pos q));\n    rewrite (mult_comm (Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; unfold oppZ in |- *; rewrite (mult_comm (pos n));\n elim (mult_comm (pos n)); reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (S n0 = q * S n0); intros.\nrewrite H; rewrite H0; rewrite (tech_div4 n0 n q); reflexivity.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nsimple induction n; intros; try discriminate.\napply eq_Z_div2; assumption.\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; cut (multZ (neg n) (neg q) = multZ (neg n) (posTrecE q));\n [ apply (mult_comm (pos n) (pos q)); reflexivity | apply (mult_comm (pos n) (pos q)); reflexivity ].\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros.\nrewrite H; intros; exact (tech_div4 n0 n q (le_refl _)).\nrewrite <- H0; intros; exact (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).\nrewrite (tech_div4 n0 n q (le_refl _)).Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros n0 n q; elim n; elim q.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *;Qed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nintros; rewrite H; intros; exact (tech_div4 n0 n q (le_refl q)).\nQed.",
                    "Lemma tech_div5 : forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\nsimple induction n; intros; simpl in |- *; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nQed.\n\n(***************)\nLemma tech_div32 :\n forall n q r : nat, S n > r -> pos (n - r) = addZ (pos n) (oppZ (posOZ r)).\n\nintros n q r; elim r.\n(* O *)\nunfold posOZ in |- *; unfold oppZ in |- *; rewrite (add_OZ (pos n));\n elim (minus_n_O n).\nreflexivity.\n(* S y *)\nintros y H; unfold posOZ in |- *; unfold oppZ in |- *; symmetry  in |- *. \nexact (tech_add_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 703,
                "proof_start_offset": 21073,
                "proof_end_offset": 21415,
                "proof": "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nProof.\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (pos r = oppZ (neg n) (neg q)); intros.\nrewrite H0; intros; exact (tech_opp_opp_l n m p H).\nrewrite H1; intros; exact (tech_opp_opp_r n m p H).\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (pos RatIntro n0 n = pos n0); intros.\nrewrite H0; intros; exact (tech_div2 n0 n q r H0).\nrewrite H1; intros; exact (tech_div2 n0 n q r H0).\nrewrite H2; intros; exact (tech_div2 n0 n q r H0).\nrewrite H2; intros; exact (tech_div2 n0 n q r H0).\nrewrite H2; intros; exact (tech_div2 n0 n q r H0).\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros; cut (S n0 = S n0); [ intro H0; rewrite H0 | intros; ring ].\nexact (tech_div2 n0 n q r H0 H1).\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros; cut (pos NArith (pos NArith (pos NArith (pos n0)) = pos n0);\n [ intros; apply (pos_div2 (pos n0) (pos q)) | idtac ];\n [ apply (pos_div2 (pos n0) (pos (n - r)) ];\n [ apply (pos_div2 (pos n0) (pos q)) | idtac ];\n [ apply (pos_div2 (pos n0) (pos (n - r)) ];\n [ apply (pos_div2 (pos n0) (pos q)) ];\n [ apply (pos_div2 (pos n0) (pos q)) ];\n [ apply (pos_div2 (pos n0) (pos q)) ];\n [ apply (pos_div2 (pos n0) (pos q) ];\n [ apply (pos_div2 (pos n0) (pos q) ];\n [ apply (pos_div2 (pos n0) (pos q)) ];\n [ apply (pos_div2 (pos n0) (pos q) ];\n [ apply (pos_div2 (pos n0) (pos q)) ];\n [ apply (Qed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros n0 n q r H H0; elim H; auto with arith.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (abs r <> 0); intros.\nrewrite H1; apply tech_rec_pos; assumption.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros; cut (pos RatIntro n0 n = multZ (neg n) (neg q)); intros.\nrewrite H0; intros; exact (tech_div4 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H0; intros; exact (tech_div2 n0 n q r H0).\nrewrite H0; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (tech_div2 n0 n q r H0).\nrewrite H; intros; exact (techQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nLemma tech_pos_pos : forall n : nat, 0 < n -> 0 < n.\nintros; unfold not in |- *; intro; elim H; clear H.\nintros; elim H; clear H; intros.\nrewrite (mult_comm (pos n0)); auto with arith.\nrewrite (mult_comm (pos n0)); auto with arith.\nrewrite (mult_comm (pos n0)); auto with arith.\nrewrite (mult_comm (pos n0)); auto with arith.\nQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (multZ (pos n0) (pos q) = multZ (pos n0) (pos q)); intros.\nrewrite H0; intros; exact (tech_div2 n0 n q r H).\nrewrite (tech_div2 n q r H0 H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewrite (tech_div2 n q r H0 H1 H2).\nrewriteQed.",
                    "Lemma tech_div6 : forall n0 n q r : nat, S n0 = q * S n + r -> S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\nintros; cut (multZ (pos n) (pos q) = pos n0); intros.\nrewrite H0; intros; exact (tech_div2 n0 n q r H).\nrewrite (tech_div2 n0 n q r H0 H0).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H0 H1).\nrewrite (tech_div2 n0 n q r H1).\nrewrite (tech_div2 n0 n q r H0 H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "_pos_neg_posZ n y (gt_S_n y n H0)).\nQed.\n\n(**************)\nLemma tech_div3 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (pos n) (neg q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H1.\nrewrite (mult_oppZ_r (pos n) (pos q)); rewrite (tech_div32 n q r H0).\nrewrite\n (addZ_associativity (oppZ (multZ (pos n) (pos q))) (pos n) (oppZ (posOZ r)))\n.\nrewrite (tech_div31 n q).\nelim\n (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity\n    (multZ (pos n) (posOZ q)) (posOZ r) I I).\nelim (tech_div1 n0 n q r H); reflexivity.\nQed.\n\n(**************)\nLemma tech_div4 :\n forall n0 n q r : nat,\n S n0 = q * S n + r -> pos n0 = addZ (multZ (neg n) (negOZ q)) (posOZ r).\n\nintros; cut (multZ (neg n) (negOZ q) = multZ (pos n) (posOZ q)); intros.\nrewrite H0; intros; exact (tech_div1 n0 n q r H).\ncut (negOZ q = oppZ (posOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\napply (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (posOZ q) I I).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div5 :\n forall n0 n q : nat, S n0 = q * S n -> neg n0 = multZ (neg n) (posOZ q).\n\nintros; cut (posOZ q = oppZ (negOZ q)); intros. rewrite H0.\nelim (tech_opp_pos_negZ n); intros; elim H1.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (negOZ q) I I).\nexact (tech_div2 n0 n q H).\nelim q; reflexivity.\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\n",
                "context_tokens": 727,
                "proof_start_offset": 21436,
                "proof_end_offset": 22829,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nsimple destruct x.\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\nsimple induction n.\nintros; left; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (pos (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\nsimple induction n.\nright; reflexivity.\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ).\nelim x0.\nrewrite (mult_OZ (neg (S y))).\ndiscriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nsimple induction x; intros.\napply (inv20 (fun x : Z => x = zero) (fun x : Z => x)); auto.\nrewrite <- (inv22 (fun x : Z => x = zero) (fun x : Z => x)); auto.\nrewrite <- (inv22 (fun x : Z => x = zero) (fun x : Z => x)); auto.\nrewrite <- (inv22 (fun x : Z => x = zero) (fun x : Z => x)); auto.\nrewrite <- (inv22 (fun x : Z => x = zero) (fun x : Z => x)); auto.\nrewrite <- (inv22 (fun x : Z => x = one) (fun x : Z => x = zero) (fun x : Z => x)); auto.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim x.\nsimpl in |- *; intros.\nrewrite H; intros.\nrewrite H; auto.\nrewrite H; intros.\nrewrite H; auto.\nrewrite H; intros.\nrewrite H; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim (inversibleZ); intros; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros x H; split; intro H; elim H;\n intros; split; [ try assumption | idtac ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac | trivial ]\n | case (Req_dec x 0); intro H; [ idtac |Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nProof.\nintros.\nassert (F : 0 < x) by exact (fun x => oppZ (pos x)) x).\nassert (F : 0 < x) by exact (fun x => oppZ (neg x)) x).\nassert (F : 0 < x) by exact (fun x => oppZ (neg x)) x).\nassert (F : 0 < x) by exact (fun x => oppZ (neg x)) x).\nassert (H : x = pos x) by exact (fun x => oppZ (neg x)) x).\nrewrite H; intros; exact (H x).\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nunfold oppZ in |- *.\nelim (inversibleZ x); intros; elim H1.\nrewrite <- (inversibleZ x H).\napply (inversibleZ x H).\napply (inversibleZ x H).\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nrewrite H.\nrewrite (inversfield_zero_pos_negZ x); trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros.\nelim (pos_absZ x); intros; trivial.\nrewrite <- (pos_absZ x H0).\nrewrite (pos_absZ x H0).\napply (pos_absZ (pos x)); trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros; elim x; simpl; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\nintros x H.\napply (inversibleZ (fun y : Z => x) (fun y : Z => y) H H0); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ".\nQed.\n\n(**************)\nLemma tech_div6 :\n forall n0 n q r : nat,\n S n0 = q * S n + r ->\n S n > r -> neg n0 = addZ (multZ (neg n) (pos q)) (pos (n - r)).\n\nintros.\nelim (tech_opp_pos_negZ q); intros; elim H2.\nelim (tech_opp_pos_negZ n); intros; elim H3.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring (pos n) (neg q) I I).\napply (tech_div3 n0 n q r H H0).\nQed.\n\n(****************)\nLemma inversibleZ :\n forall x : Z, inversible Z multZ IZ x -> x = IZ \\/ x = oppZ IZ.\n\nsimple destruct x.\n(* OZ *)\nintros; elim H; intros; elim H0; intros; elim H1.\nleft; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nintros; left; reflexivity.\n(* pos (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (pos (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (pos (S y))). discriminate.\nintros; rewrite (tech_mult_pos_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nintros; rewrite (tech_mult_pos_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nexact H2.\n(* neg n *) \nsimple induction n.\n(* neg O *)\nright; reflexivity.\n(* neg (S y) *)\nintros y H H0; elim H0; intros; elim H1; intros.\nabsurd (multZ (neg (S y)) x0 = IZ). elim x0.\nrewrite (mult_OZ (neg (S y))). discriminate.\nintros; rewrite (tech_mult_neg_posZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *; discriminate.\nintros; rewrite (tech_mult_neg_negZ (S y) n0).\nelim (plus_comm (S y + n0) (S y * n0)).\nelim (plus_assoc (S y) n0 (S y * n0)); simpl in |- *.\napply (tech_pos_not_posZ (S (y + (n0 + (n0 + y * n0)))) 0).\ndiscriminate.\nexact H2.\nQed.\n\n(************)\n",
                "context_tokens": 734,
                "proof_start_offset": 22846,
                "proof_end_offset": 23040,
                "proof": "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nsimple destruct x.\nreflexivity.\nintros; exact (mult_IZ (pos n)).\nintros; exact (mult_mIZ (neg n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros.\nunfold absZ at 1 in |- *.\nrewrite abs_mult.\nrewrite abs_mult.\nrewrite abs_mult.\nrewrite abs_mult.\nrewrite abs_mult.\nreflexivity.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple destruct x; trivial.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nintros; elim (mult_Rsqr (absZ x) (absZ x)); simpl in |- *.\nrewrite <- (mult_comm (absZ x)).\napply abs_mult_pos_pos.\napply abs_mult_neg_pos.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros.\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z => x)).\napply (f_equal Z (fun x : Z =>Qed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros x; elim x; simpl in |- *; trivial.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nunfold not in |- *; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; assumption.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple destruct x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nintros; unfold absZ in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite neg_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_pos; simpl in |- *.\nrewrite pos_abs_posQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nProof.\nintros.\nrewrite (Zdiv_abs x).\nrewrite (Zdiv_abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (d + n)))))))) (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (dQed.",
                    "Lemma sgn_abs : forall x : Z, multZ x (sgnZ x) = absZ x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\n",
                "context_tokens": 307,
                "proof_start_offset": 1870,
                "proof_end_offset": 2140,
                "proof": "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nintro.\nelim (pred_prime_dec x 0).\nauto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; simple induction x; simple induction x0; simple induction x1; simple induction x2; simple induction x2;\n intros; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nProof.\n  simple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nreflexivity.\nsimpl in |- *.\nintros.\nrewrite H0.\nrewrite H0.\nrewriteQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nintros.\napply neg_pred_pos_pos.\nelim H.\napply neg_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napply pos_pred_pos.\napplyQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x.\nsimpl in |- *.\nauto with *.\nintros.\nelim H.\nauto with *.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.\nintros.\nelim x.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2160,
                "proof_end_offset": 2430,
                "proof": "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; pattern x in |- *; elim x.\n(* succ n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; exists 0; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\n(* lam *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; elim x.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros x; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nProof.\nintros; unfold succZ in |- *; elim x.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.\nintros; unfold succZ in |- *; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "******************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 471,
                "proof_start_offset": 2460,
                "proof_end_offset": 2604,
                "proof": "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; replace x with (pred (pred (pred (pred (pred n))) 0).\napply pred_succ_pred_pos; assumption.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; unfold succ at 1 in |- *; reflexivity.\nQed.",
                    "Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\nProof.\nintros; pattern x in |- *; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                    *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\n",
                "context_tokens": 513,
                "proof_start_offset": 2627,
                "proof_end_offset": 2801,
                "proof": "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro; elim n; intro.\nelim (lt_n_O 0); exact H.\nintros; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; rewrite (pred_posZ_posZ_posZ (pos n)) at 2.\nrewrite <- pred_pos_Z_pos.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; unfold succZ in |- *; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro n; elim n.\n simpl in |- *; reflexivity.\n intros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; elim n.\n simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.Qed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nsimple induction n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintros; unfold succ in |- *; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro n; elim n.\n simpl in |- *; reflexivity.\n intros n H.\nelim H.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro n; elim n.\n simpl in |- *; reflexivity.\nintros n0 H'; elim H'.\nsimpl in |- *; reflexivity.\nintros n0 H'; elim H'.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros n0 H'; elim H'.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros n0 H'; elim H'.\nsimpl in |- *; reflexivity.\nintros n0 H'; elim H'.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros n0 H'; elim H'.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\nProof.\nintro n; elim n; simpl in |- *; auto.\nintros; elim n; simpl in |- *; auto.\nintros; elim n.\nsimpl in |- *; auto.\nintros; elim n0; simpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n.\nsimpl in |- *; auto.\nintros; elim n.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimpl in |- *; auto.\nintros; elim n0.\nsimplQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Z_succ_pred.v",
                "context": "                  INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                              Z_succ_pred.v                               *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Zbase.\n\n(* Succ and Pred on Z *)\n\n(**************)\nDefinition succZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  IZ \n      (* pos n *) \n  | pos n => pos (S n)\n      (* neg n *) \n  | neg n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => neg m\n      end\n  end.\n\n(**************)\nDefinition predZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  neg 0\n      (* pos n *) \n  | pos n =>\n      match n return Z with\n      | O =>\n          (* O *)  OZ\n          (* S m *) \n      | S m => pos m\n      end\n      (* neg n *) \n  | neg n => neg (S n)\n  end.\n    \n(***************)\nLemma pred_succZ : forall x : Z, predZ (succZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.\n\n(***************)\nLemma succ_predZ : forall x : Z, succZ (predZ x) = x.\n\nProof.\nintros; pattern x in |- *; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\nQed.\n\n(*************************)\nLemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).\n\nProof.\nintros; rewrite (pred_succZ x); exact (succ_predZ x).\nQed.\n\n(******************)\nLemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).\n\nProof.\nintro; elim n; intro. elim (lt_n_O 0); exact H. intros; simpl in |- *; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 566,
                "proof_start_offset": 2826,
                "proof_end_offset": 2975,
                "proof": "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintros; elim n; simpl in |- *; reflexivity; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro n; elim n; intro.\n rewrite (pred_posZ n) in H; rewrite H; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; elim n; intro.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\n simpl in |- *; reflexivity.\n intros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\n intro; elim n; intro.\n simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n; intro.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro n; elim n; intro.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\nintro; elim n.\n simpl in |- *; reflexivity.\n intros; elim n; simpl in |- *; reflexivity.\n intros; elim n.\n simpl in |- *; reflexivity.\n intros; elim n; simpl in |- *; reflexivity.\n intros; elim n; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n.\nProof.\n intro; elim n; intro.\nsimpl in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\n",
                "context_tokens": 158,
                "proof_start_offset": 1436,
                "proof_end_offset": 1965,
                "proof": "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros.\nelim (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nexact (mult_IZ d1).\nright.\nelim H1; intros; elim H4; intros.\nrewrite H6.\nrewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n  intros.\n  elim (Z_le_gt_dec d1 d2 H H0).\n  intro.\n  elim H0.\n  intro.\n  elim H1.\n  intro.\n  rewrite H2 in H0.\n  rewrite (abs_pos_abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n   intros.\n   elim (gcd_bezout_sign a b d1 d2).\n   intros.\n   elim H0.\n   intros.\n   rewrite H2.\n   split with (Z_of_nat (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H H0.\nelim H0; intros H1 H2; elim H2; intros H3 H4;\n elim H4; intros H5 H6; elim H6; intros H7 H8;\n elim H8; intros H9 H10; elim H10; intros H10 H11; elim H11; intros H11 H12; \n clear H11 H12.\nelim H; intros H12 H13; elim H12; intros H13 H14; elim H13; intros H14 H15;\n elim H15; intros H15 H16; elim H15; intros H16 H17;\n elim H15; intros H16 H18; elim H18; intros H18 H18;\n elim H18; intros H18 H18; elim H18; intros H18 H19; \n clear H20 H20 H21.\nrewrite H18; rewrite H18; rewrite H17; ring.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H H0 H1.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H2.\nintros.\nelim H4.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H11.\nintros.\nelimQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nsimple induction 1; intros.\nauto with arith.\nintros.\napply H with (z := Z_of_nat n0 + z).\nauto with arith.\nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\nintros a b d1 d2 H.\nelim H.\nintros; elim H; intros; elim H0; intros; clear H0.\nexists (ZExp b d1).\nexists (ZExp b d2).\nexists (ZExp b d2).\nexists (ZExp b d2).\nexists (ZExp b d2).\nsplit.\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\nsplit.\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napply (ZExp_correct (ZExp b d1) (ZExp b d2)).\napplyQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b c d1 d2 H H0 H1 H2; elim H1; clear H1; intros H1 H2;\n elim H2; clear H2; intros H3 H4; elim H4;\n clear H4; intros H5 H6; elim H5;\n clear H5; intros H6 H7; elim H6; clear H6; intros H7 H8;\n elim H9; clear H9; intros H10 H11; elim H11;\n clear H11; intros H12 H13; elim H11; clear H11; intros H12 H13; \n clear H13 H14; intros H14 H15; elim H15; clear H15; intros H15 H16; elim H15; \n clear H15; intros H16 H18; elim H18; clear H18; intros H16 H18;\n elim H18; clear H18; intros H18 H19; elim H18;\n clear H18; intros H18 H19; elim H18; clear H18; intros H18 H20;\n clear H20 H21 H22; intros H20 H21 H22; elim H18; \nQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H H0 H1; elim H; intros H1 H2; elim H2; intros H3 H4;\n elim H4; intros H5 H6; elim H5; intros H6 H7;\n elim H5; intros H6 H7; elim H7; intros H8 H9; elim H10;\n intros H11 H12; elim H13; intros H12 H13;\n elim H13; intros H14 H15; elim H15; intros H15 H16;\n elim H17; intros H17 H18; elim H18; intros H18 H19;\n elim H18; intros H19 H20; elim H19; intros H20 H20; \n elim H18; intros H18 H19; elim H19; intros H20 H21;\n   elim H18; intros H20 H21; elim H18; intros H18 H19;\n   elim H18; intros H18 H20; elim H18; intros H19 H20;\n   elim H18; intros H21 H22; elim H18; intros H20 H21;\n   elim H18; intros H22 H23; elim HQed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nintros a b d1 d2 H H0 H1; elim H0; intros H2 H3; elim H3;\n intros H4 H5; elim H5; intros H6 H7;\n elim H6; intros H7 H8; elim H8; intros H9 H10;\n elim H9; intros H11 H12; elim H12; intros H13 H14;\n elim H15; intros H15 H16; elim H18; intros H17 H18;\n elim H17; intros H18 H18; elim H18; intros H18 H19;\n elim H18; intros H18 H19; elim H20; intros H20 H21;\n elim H17; intros H20 H21; elim H17; intros H20 H21;\n elim H18; intros H18 H19; elim H18; intros H20 H21;\n   elim H18; intros H17 H18; elim H18; intros H20 H21;\n   elim H18; intros H20 H21; elim H22; intros H22 H23;\n   elim H22; intros H22 H22 H23; elim H23; intros H24 H24Qed.",
                    "Lemma gcd_unicity_apart_sign : forall a b d1 d2 : Z, is_gcd Z IdZ multZ OZ a b d1 -> is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\nProof.\n  intros a b c d1 d2.\n  elim (gcd_bezout_sign a b d1 d2); intros.\n  elim H0; intros; assumption.\n  apply (gcd_bezout_sign a b d1 d2); intros.\n  elim H1; intros; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zgcd.v                                  *)\n(****************************************************************************)\nRequire Export misc.\nRequire Export Zadd.\nRequire Export Zle.\nRequire Export Euclid.\nRequire Export Peano_dec.\nRequire Export Zrec.\nRequire Export Zmult.\nRequire Export Zdiv.\n\nUnset Standard Proposition Elimination Names.\n\n(***************************)\nLemma gcd_unicity_apart_sign :\n forall a b d1 d2 : Z,\n is_gcd Z IdZ multZ OZ a b d1 ->\n is_gcd Z IdZ multZ OZ a b d2 -> d2 = d1 \\/ d2 = oppZ d1.\n\nintros.\nelim\n (gcd_unicity_apart_unities Z IdZ addZ multZ OZ IZ oppZ\n    Z_unitary_commutative_ring integrityZ a b d1 d2 H H0).\nintros.\nelim (inversibleZ x); intros.\nleft. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2. \nexact (mult_IZ d1).\nright. elim H1; intros; elim H4; intros. rewrite H6. rewrite H2.\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\n",
                "context_tokens": 373,
                "proof_start_offset": 1981,
                "proof_end_offset": 3327,
                "proof": "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (abs_eq_or_oppZ b); intro y.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nexact y0.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ b).\nintros; exact H0.\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nleft; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec b); intro y0.\nleft; exact y0.\nright.\nsplit.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split.\nexact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry in |- *; exact (mult_IZ b).\nexact I.\nsplit.\nexact I.\nelim H0; intros; elim H2; intros; elim H4; intros.\nrewrite H5.\nleft; reflexivity.\nright; split.\nelim H5; intros; exact H6.\nelim H5; intros; elim H7; intros.\nexists (oppZ x).\nsplit.\nexact I.\nelim H8; intros; rewrite H10.\nsymmetry in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nProof.\nintros.\nelim (Z_div_mod_op_prime_bezout_sign b (absZ b) (absZ b)).\nintros.\nelim H; intros.\nleft. elim H; intros.\nleft. elim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumption.\nright.\nelim H; intros.\nright.\napply eq_Z_div_mod_eq; assumptionQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nunfold is_gcd in |- *.\nelim (gcd_uniqueness_apart_sign a b d); intros.\nelim H; intros.\nleft. elim H1; intros.\nright.\nelim H2; intros.\nleft.\nelim H2; intros.\nright.\nelim H2; intros.\nright.\nelim H3; intros.\nright.\nelim H2; intros.\nright.\nelim H3; intros.\nleft.\nelim H4; intros.\nright.\nelim H3; intros.\nright.\nelim H4; intros.\nleft.\nelim H4; intros.\nleft.\nelim H4; intros.\nleft.\nelim H4; intros.\nright.\nelim H4; intros.\nright.\nelim H4; intros.\nright.\nelim H4; intros.\nleft.\nelim H5; intros.\nright.\nelim H5; intros.\nright.\nelim H5; intros.\nright.\nelim H4; intros.\nright.\nelim H4; intros.\nright.\nelim H5; intros.\nright.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nred in |- *.\nintros.\nelim (gcd_bezout_absZ (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_zero (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_zero (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_zero (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_one (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_correct (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_correct (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_one (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_correct (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_one (Z_of_nat b) (Zabs_nat b)).\napply (gcd_greatest_correct (Z_of_nat b) (Zabs_nat b)).\napply (gcd_Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (Z_div_un_zero Z Zscale_zero (absZ b) (absZ b)).\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nrewrite H1.\nsimpl in |- *; reflexivity.\nintros; apply H2.\nsimpl in |- *; exact (mult_ntriv d1).\nright.\nelim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim HQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nunfold is_gcd in |- *.\nintros.\nelim H.\nauto with *.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nsimple induction b.\nintro; simpl in |- *.\napply rel_prime_pos; auto.\nsimpl in |- *.\nintros; elim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10Qed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nsimple induction b.\nauto with arith.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim (gcd_divisors b (absZ b)).\napply (gcd_bezout_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b))).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\napply (gcd_greatest_absZ b (absZ b)).\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nintros.\nelim H; intros.\nelim H; intros.\nelim H0; intros; elim H4; intros; elim H4; intros.\nright.\nsplit.\nrewrite H1.\nunfold quad in |- *; simpl in |- *.\nrewrite H2; reflexivity.\nQed.",
                    "Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\nred in |- *; intros.\napply (gcd_bezout_sign (absZ b) (absZ b) (absZ b)).\napply (gcd_bezout_absZ (absZ b) (absZ b)).\napply (gcd_bezout_absZ (absZ b) (absZ b)).\napply (gcd_bezout_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZ b)).\napply (gcd_greatest_absZ (absZ b) (absZQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "\nsimpl in |- *; exact (mult_mIZ d1).\nelim H1; intros; exact H2.\nQed.\n\n(***********)\nLemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ multZ OZ OZ b (absZ b).\n\nintros. elim (abs_eq_or_oppZ b); intro y.\n(* |b|=b *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 3865,
                "proof_end_offset": 4332,
                "proof": "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros.\ncase (eq_OZ_dec n); intro.\nunfold P in |- *.\nintro.\nsplit with (absZ b).\nrewrite e.\napply (gcd_OZ b).\nunfold P in |- *; intro.\nelim (divZ b n).\nintros.\ncut (lt_absZ r n); intros.\nelim (H r H0 n).\nintros.\nsplit with x.\napply gcd_mod with (2 := i); trivial.\ninversion i.\ndecompose [and] H1.\nunfold lt_absZ in |- *.\nrewrite (tech_le_pos_abs r H2).\nexact H4.\nexact n0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros.\n induction  n as  n as [| n Hrec].\n simpl in |- *.\n assumption.\n intros.\n induction  n as  n as [| n Hrec].\n simpl in |- *.\n assumption.\n intros.\n induction  n as  [| n Hrec].\n simpl in |- *.\n intros.\n inversion H.\n apply lt_le_weak.\n assumption.\n intros m Hrec.\n induction  n as [| n Hrec].\n simpl in |- *.\n assumption.\n intros.\n inversion H.\n apply lt_le_weak.\n assumption.\n intros m Hrec.\n induction  n as [| n Hrec].\n simpl in |- *.\n assumption.\n intros m Hrec.\n induction  n as [| m Hrec].\n simpl in |- *.\n assumption.\n intros m Hrec.\n induction  n as [| m Hrec].\n simpl in |- *.\n assumption.\n intros m Hrec.\n induction  n as [| m Hrec].\n simpl in |- *.\n assumption.\n intros m Hrec.\n induction  n as [| m Hrec].\n simpl in |- *.\n assumption.\n intros.\n inversion H.\n apply lt_le_weak.\n assumption.\n intros mQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros.\n case (Z_le_gt_dec n m).\n intro.\n apply H; exact H0.\n intro; apply H; exact H0.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros n H; elim H; intros; auto.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros [|n|n] H; try easy.\n apply (fun m n => le_0_n n H).\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nsimple induction n.\nintros m H; elim H; intros m H1.\nelim H1; intros m H2.\nelim H2; intros H3 H4.\napply (lt_irrefl m H4).\nelim H4; intros m H5.\nelim H5; intros m H6.\nelim H5; intros m H6.\napply (lt_irrefl m H4).\napply lt_le_trans with m.\napply lt_le_trans with m.\napply lt_trans with m.\napply lt_le_trans with m.\napply lt_trans with m.\napply lt_trans with m.\napply lt_le_trans with m.\napply lt_trans with m.\napply lt_trans with m.\napply lt_le_trans with m.\napply lt_trans with m.\napply le_trans with m.\napply lt_trans with m.\napply lt_trans with m.\napply lt_le_trans with m.\napply lt_trans with m.\napply lt_trans with m.\napply lt_trans with m.\napply lt_trans with m.Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n H; elim H; intros.\nunfold P in |- *; apply le_antisym; assumption.\napply H; assumption.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros.\n destruct (Z_le_or_eq _ _ H) as [H0|H0].\n apply (H0 n H1).\n apply H1; trivial.\nQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros [|n|n] H; try exact H.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact H1.\nintros m H1; try exact HQed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n intros n H.\n apply (Build_well_founded_ind (P:=P) (P:=P) (c:=P) (c:=P) (c:=P) (c:=P) (c:=P) (c:=P) (c:=P) (c:=P) (d:=P) (c:=P) (c:=P) (d:=P) (d:=P) (c:=P) (c:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=P) (d:=Qed.",
                    "Lemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\nintros n H.\napply (H (fun m n => P (m n))).\napply le_trans with (S n); auto with arith.\napply H.\napply le_trans with (S n); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " y0. \nleft; exact y0.\nright. split. exact y0. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ b).\nintros; exact H0.\n(* |b|=(-b) *)\nrewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4334,
                "proof_end_offset": 4420,
                "proof": "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\nexact (recZ P acc_P).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (dec_pointsH a); intro. unfold P in |- *. intro.\n  elim (gcd_lincomb_dec a b); intro. unfold P in |- *. intro. elim (gcd_bezout_dec b a H0 n).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  right. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  right. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  right. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  right. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  left. apply (gcd_greatest b).\n  right. apply (gcd_greatest b).\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Req_EM_T a b); intro. unfold P in |- *. intro.\n  elim (gcd_greatest a b n). intros.\n  split with (absZ b). rewrite e. apply (gcd_greatest b).\n  unfold P in |- *; intro. elim (gcd_greatest b (Z_of_nat n)).\n  intros.\n  split with (absZ b). rewrite e. apply (gcd_greatest b).\n  unfold P in |- *; intro. elim (gcd_greatest b (Z_of_nat n)).\n  intros.\n  split with (Zabs_nat b). rewrite e. apply (gcd_greatest b).\n  unfold P in |- *; intro. elim (gcd_greatest b (Z_of_nat n)).\n  intros.\n  split with (Zabs_nat b). rewrite e. apply (gcd_greatest b).\n  unfold P in |- *; intro. elim (gcd_greatest b (Z_of_nat n)).\n  intros.\n  split with (Zabs_nat b). rewrite e. apply (gcd_greatest b).\n  unfold P in |- *; intro. elim (gcd_greatest b (Z_of_nat n)).\n  intros.\n Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (gcdZ_dec a b); intro.\n  apply gcd_div with (2 := 1); trivial. inversion H.\n  apply gcd_bound; trivial.\n  apply gcd_bound; trivial.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Z_dec a); intro.\n  unfold P in |- *. intro. elim (gcd_lincomb_dec a b).\n  unfold Q in |- *. intro. elim (gcd_lincomb_dec a b).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intros. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatest b a).\n  unfold Q in |- *. intro. elim (gcd_greatestQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros a b.\n  intros.\n  case (gcd_bezout_dec a b); intros.\n  assumption.\n  assumption.\n  intros; apply H; auto with zarith.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Zle_lt_or_eq _ _ H); intro. unfold P in |- *. intro.\n  elim (Zle_lt_or_eq _ _ H0). intros. unfold P in |- *. intro.\n  elim (Zle_lt_or_eq _ _ H1). intros.\n  apply gcd_opp_l.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_sym. assumption.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (le_decidable 0 b); intro. unfold P in |- *. intro.\n  elim (gcd_bezout_dec a b); intro. unfold P in |- *. intro. elim (gcd_bezout_dec a b); intro.\n  apply gcd_greatest with b; trivial. inversion H1.\n  split. apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatest with b; trivial.\n  apply gcd_greatestQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (le_gt_dec 0 n); intro. unfold P in |- *. intro.\n  elim (gcd_bezout_dec a b n).\n  intros. cut (Z.gcd a b = 1%Z); intros.\n  elim (gcd_bezout_dec a b n). intros.\n  rewrite H2 in H0. elim (gcd_bezout_dec a b n).\n  intros.\n  unfold P in |- *.\n  apply gcd_greatest; trivial.\n  unfold P in |- *; intro. elim (gcd_bezout_dec a b n).\n  intros.\n  rewrite H2 in H0. elim (gcd_greatest a b n).\n  intros.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\n  apply gcd_greatest;Qed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (gcdZ_dec a b); intro.\n  left. apply gcd_greatest; trivial.\n  right. apply gcd_greatest; trivial.\n  right. apply gcd_greatest; trivial.\n  left. apply gcd_greatest; trivial.\nQed.",
                    "Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  intros. case (Req_EM_T a b); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b H1).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b H1).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b H2).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b H2).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b H2).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b H3).\n  unfold P in |- *. intro. elim (gcd_bezout_dec b a H3).\n  intros.\n  split with (absZ b). rewrite e. apply gcd_comm.\n  apply gcd_gcd_l with (2 := b). rewrite e.\n  apply gcd_gcd_l with (2 := b).\n  apply gcd_gcd_r with (2 := b).\n  apply gcd_gcd_l with (2 := b).\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "rewrite y.\nunfold is_gcd in |- *; split.\nunfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I. left; reflexivity.\nsplit; unfold divide in |- *; unfold IdZ in |- *; split. exact I. split. exact I.\nelim (eq_OZ_dec b); intro y0. \nleft; exact y0.\nright. split.\nunfold not in |- *; intros; elim y0.\nexact (opp_O Z IdZ addZ multZ OZ oppZ Z_ring b I H).\nexists (oppZ IZ); split. exact I.\nrewrite (mult_opp_opp Z IdZ addZ multZ OZ oppZ Z_ring b IZ I I).\nsymmetry  in |- *; exact (mult_IZ b). exact I. split. exact I.\nelim H0; intros; elim H2; intros; elim H4; intros. rewrite H5. \nleft; reflexivity.\nright; split. elim H5; intros; exact H6. elim H5; intros; elim H7; intros.\nexists (oppZ x). split. exact I. elim H8; intros; rewrite H10.\nsymmetry  in |- *; exact (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q x I I).\nQed.\n\n(******************)\nInductive is_gcdZ : Z -> Z -> Z -> Prop :=\n  | gcd_OZ : forall b : Z, is_gcdZ OZ b (absZ b)\n  | gcd_mod :\n      forall b a d q r : Z,\n      b <> OZ -> is_diveuclZ a b q r -> is_gcdZ r b d -> is_gcdZ b a d.\n\n(******************)\nDefinition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.\n\nDefinition gcdZ_i (a b : Z) := exist (is_gcdZ a b).\n\n(* Inductive have_gcdZ [a, b: Z]: Set\n  := gcdZ_i: (d: Z) (is_gcdZ a b d) -> (have_gcdZ a b). *)\n\n(*******************)\nDefinition P (a : Z) := forall b : Z, have_gcdZ a b.\n\nLemma acc_P : forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\n",
                "context_tokens": 721,
                "proof_start_offset": 4441,
                "proof_end_offset": 5553,
                "proof": "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\nintros.\nelim H; intros.\napply (gcd_OZ_absZ b0).\nunfold is_gcd in |- *.\nsplit.\nelim H3; intros; elim H5; intros; exact H6.\nsplit.\nelim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros.\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros.\nelim H3; intros; elim H7; intros.\napply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros.\nrewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros.\nelim H17; intros.\nelim H19; intros.\nrewrite H20.\nsymmetry in |- *.\nexact (add_OZ r).\nexact H4.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros a b d.\n  elim (gcd_bezout_dec a b d); intros.\n  split with (absZ b).\n  rewrite e. apply (gcd_bezout a b).\n  unfold Q in |- *; intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold Q in |- *. intro. elim (gcd_greatest_dec b d).\n  unfold Q in |- *. intro. elim (gcd_greatest_dec b d).\n  unfold Q in |- *. intro. elim (gcd_greatest_dec b d).\n  unfold Q in |- *. intro. elim (gcd_greatest_dec b d).\n  unfold Q in |- *. intro. elim (gcd_greatest_decQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_dec a b); intro.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  right. reflexivity.\n  right. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  right. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  left. assumption.\n  elim (gcd_bezout_dec b d); intros.\n  left. reflexivity.\n  right. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  right. reflexivity.\n  left. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  right. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  elim (gcd_lincomb_dec b d); intros.\n  left. reflexivity.\n  elim (gcd_lincomb_dec b d);Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros a b d H; unfold P in |- *.\n  elim (gcd_bezout a b d).\n  unfold P in |- *. intro. elim (gcd_greatest a b d).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H0).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H).\n  intros.\n  apply gcd_greatest with (2 := H0).\n  intros.\n  apply gcd_greatest with (2 := H0).\n  intros.\n  apply gcd_greatest with (2 := H0).Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (dec_Odd a); intro.\n  unfold P in |- *. intro. elim (gcd_bezout_dec a b d).\n  unfold P in |- *. intro. elim (gcd_bezout_dec b d).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a d).\n  intros.\n  split with (absZ b).\n  rewrite abs_eq.\n  rewrite abs_eq.\n  apply (gcd_bezout_l b).\n  unfold P in |- *. intro. elim (gcd_bezout_dec b d).\n  intros.\n  split with (absZ b).\n  rewrite abs_eq.\n  rewrite abs_eq.\n  rewrite abs_eq.\n  rewrite abs_eq.\n  apply (gcd_greatest_inv b d).\n  unfold P in |- *. intro. elim (gcd_bezout_dec a d).\n  intros.\n  split with (absZ b).\n  rewrite abs_eq.\n  rewrite abs_eq.\n  rewrite abs_eq.\n  rewrite abs_eq.\n  reflexivity.\n  apply (gcd_greatest_inv b d).\n  unfold P in |- *. intro. elim (gcd_greatest_nonneg b d).\n  intros.\n Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros.\n  split with (absZ b).\n  split; intros.\n  apply (gcd_greatest b).\n  apply Zis_gcd_for_euclid with (2 := b).\n  unfold P in |- *; intros; unfold P in |- *.\n  elim (gcd_greatest b).\n  intros.\n  apply Zis_gcd_for_euclid with (2 := b).\n  unfold P in |- *; intros; unfold P in |- *;\n    apply (gcd_greatest b).\n  unfold P in |- *; intros; unfold P in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; intros; unfold Q in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; intros; unfold Q in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; intros; unfold Q in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; intros; unfold Q in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; intros; unfold Q in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; intros; unfold Q in |- *;\n    apply (gcd_greatest b).\n  unfold Q in |- *; introsQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_dec a b); intro.\n  unfold Q in |- *. intro. elim (gcd_greatest a b d).\n  unfold P in |- *. intro. elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest a b d).\n  intros.  elim (gcd_greatest aQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_dec a b); intro. unfold P in |- *.\n  apply gcd_greatest.\n  apply Zis_gcd_for_euclid with (Z := Z) (Z := Z) (Z := Z).\n  intros.\n  split with (absZ b). rewrite e. apply gcd_greatest.\n  apply Zis_gcd_for_euclid with (Z := Z) (Z := Z).\n  intros.\n  split with (absZ b). rewrite e. apply gcd_greatest.\n  apply Zis_gcd_for_euclid with (Z := Z) (Z := Z) (Z := Z).\n  intros.\n  split with (Zabs (Z_of_nat (S n))).\n  rewrite e. apply gcd_greatest.\n  apply Zis_gcd_for_euclid with (Z := Z) (Z := Z).\n  intros.\n  split with (Zabs (Z_of_nat (S n))).\n  rewrite e. apply gcd_greatest.\n  apply Zis_gcd_for_euclid with (Z := Z) (Z := Z).\n  intros.\n  split with (Zabs (Z_of_nat n)).\n  rewrite e. apply gcd_greatest.\n Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_dec a b); intro.\n  left. apply (gcd_greatest_gcd_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold Q in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold Q in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold Q in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_for a b d).\n  unfold P in |- *; intro. elim (gcd_greatest_Qed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros.\n  case (le_dec 0 a); intro. unfold P in |- *. intro.\n  apply H.\n  apply gcd_divide_r; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b a d).\n  intro.\n  left; apply gcd_greatest; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b a d).\n  intro.\n  left; apply gcd_greatest; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b a d).\n  intro.\n  left; apply gcd_greatest; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b a d).\n  intro.\n  left; apply gcd_greatest; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b a d).\n  intro.\n  left; apply gcd_greatest; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b a d).\n  intro.\n  left; apply gcd_greatest; trivial.\n  unfold P in |- *. intro. elim (gcd_greatest b b a d).\n  intro.\n  left. apply gcd_greatest; trivial.\n  unfold P in |- *. introQed.",
                    "Lemma gcdZ_is_gcd : forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\nProof.\n  intros. case (gcdZ_dec a b).\n  intros.\n  apply gcd_greatest with (2 := b); trivial.\n  exact (gcd_greatest b d).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "absZ m n -> P m) -> P n.\nProof.\n  intros. case (eq_OZ_dec n); intro. unfold P in |- *. intro.\n  split with (absZ b). rewrite e. apply (gcd_OZ b).\n  unfold P in |- *; intro. elim (divZ b n). intros. cut (lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 5810,
                "proof_end_offset": 5941,
                "proof": "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros; elim H; intros.\napply (sign_absZ b0).\nexact H3.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d H; split; intros.\napply (gcd_bezout_absZ a b d H H0 H1); auto with arith.\napply (gcd_greatest_absZ a b d H H0 H1); auto with arith.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d.\nunfold BezoutZ in |- *.\napply (gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\nexact (gcd_for_euclid (Z_of_nat n) (Z_of_nat n)).\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d; elim d; intros.\nelim H; intros.\nelim H0; intros; elim H1; intros; rewrite H2.\nelim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H5; intros; elim H5; intros; clear H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; clear H5; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; clear H6; intros; \n elim H6; intros; elim H7; intros; clear H6; intros; \n elim H7; intros; elim H6; intros; clear H6; intros; \n elim H6; intros; clear H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; clear H6; intros; \n elim H6; intros; elim H6; intros; clear H6; intros; \n elim H6; introsQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d; unfold prime_divisors in |- *.\nelim (Z_div_mod a b d); intros.\nexists (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat n)))) d)).\napply Zabs_ind; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\napply Zabs_ind; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_eq; auto with zarith.\nrewrite Zabs_Qed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  simple induction 1.\n  apply Zlt_is_gcd. assumption.\n  apply Zlt_is_gcd. assumption.\n  apply Zgt_is_gcd. assumption.\n  apply Zgt_is_gcd. assumption.\n  apply Zgt_is_gcd. assumption.\n  apply Zgt_is_gcd. assumption.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  simple induction a; simple induction d; intros;\n   [ apply (gcd_sym 0 a) | apply (gcd_sym (absZ_of_gcd a b) (absZ_of_gcd a b)) ].\n  elim (gcd_divisors a b); intros; elim H0; intros; elim H1; intros;\n    [ assumption | apply (gcd_comm (absZ_of_gcd a b) (absZ_of_gcd a b)) ].\n  elim (gcd_divisors a b); intros; elim H0; intros;\n    [ assumption | apply (gcd_sym (absZ_of_gcd a b) (absZ_of_gcd a b)) ].\n  elim (gcd_divisors a b); intros; elim H0; intros;\n    [ assumption | apply (gcd_sym (absZ_of_gcd a b) (absZ_of_gcd a b)) ].\n  elim (gcd_divisors a b); intros; elim H0; intros;\n    [ assumption | apply (gcd_sym (absZ_of_gcd a b) (absZ_of_gcd a b)) ].\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  simple induction a.\n   simpl in |- *. intros. elim H; intros; elim H1; intros.\n   elim (divide_1_r _ H3 H4 H5).\n   intros; elim H0; intros.\n   elim (divide_1_r _ H3 H4 H6).\n   intros; elim H1; intros.\n   elim (divide_1_l _ H3 H6).\n   intros; elim H1; intros.\n   elim (divide_1_r _ H3 H6).\n   intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n   elim H4; intros; elim H5; intros; elim H6; intros;\n   elim H6; intros; elim H6; intros; elim H6; intros;\n   elim H6; intros; elim H6; intros;\n    elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n     elim H6; intros; elim H6; intros;\n    elim H6; intros; elim H6; intros; elim H6; intros;\n    elimQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\nintros a b d H H0; apply (gcd_uniqueness a b d H).\napply gcd_sym; assumption.\nQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros.\n  apply (gcd_for_euclid (Z_of_P a) (Z_of_P b)).\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  apply divide_antisym; assumption.\n  applyQed.",
                    "Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\nProof.\n  intros.\n  elim H; intros.\n  apply (gcd_bezout a b H).\n  exact (gcd_greatest a b H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "lt_absZ r n); intros.\n  elim (H r H0 n). intros. split with x.\n  apply gcd_mod with (2 := i); trivial. inversion i. decompose [and] H1.\n  unfold lt_absZ in |- *. rewrite (tech_le_pos_abs r H2). exact H4. exact n0.\nQed.\n\nLemma gcdZ_exists : forall a b : Z, have_gcdZ a b.\nProof.\n  exact (recZ P acc_P).\nQed.\n\n(****************)\nLemma gcdZ_is_gcd :\n forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\n",
                "context_tokens": 714,
                "proof_start_offset": 5966,
                "proof_end_offset": 6284,
                "proof": "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros.\nelim (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H) (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros; apply (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0) (positive_is_gcdZ a b d1 H)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros.\napply (gcd_bezout_absZ a b d1).\nunfold upper_bound in |- *.\napply H0.\napply (num_den a b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den a b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den a b d2).\nunfold upper_bound in |- *.\napply H.\napply (num_den a b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den a b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den b d1).\nunfold upper_bound in |- *.\napply H.\napply (num_den b d1).\nunfold upper_boundQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros; elim H; intros.\nelim H0; intros; elim H0; intros; rewrite H1; rewrite H2; reflexivity.\nelim H; intros; rewrite H1; rewrite H2; reflexivity.\nelim H; intros; rewrite H1; rewrite H2; reflexivity.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros.\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H H1 H2 H2).\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H0 H1 H2).\napply (gcd_for_euclid a b d1 d2 H H0 H1).\napply (gcd_for_euclid a b d1 d2 H H1 H2 H3).\napply (gcd_for_euclid a b d1 d2 H H0 H1 H2 H3).\napply (gcd_for_euclid a b d1 d2 H H1 H0 H1).\napplyQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros.\napply Z_is_gcd_for_euclid with (p := q) (r := q); auto.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros; elim H; intros.\napply (dist_triZ a b d1).\nrewrite <- H; reflexivity.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nunfold Bezout in |- *.\nrewrite <- (Zmult_1_r (Z_of_nat d1)).\nrewrite (Zmult_comm d1 d2).\nrewrite (Zmult_comm d2).\nrewrite (Zmult_comm d1 d2).\nrewrite (Zmult_comm d1).\nrewrite Zmult_assoc.\napply Zmult_reg_l with d1; auto.\napply Zmult_reg_l with d2; auto.\napply Zmult_reg_l with d2; auto.\napply Zmult_reg_l with d2; auto.\napply Zmult_reg_l with d2; auto.\napply Zmult_reg_l with d2; auto.\napply Zmult_reg_l with d2; auto.\napply Zmult_reg_l with d1; auto.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros; elim H; intros.\napply (inj_is_gcdZ_correct (Zabs_nat a) (Zabs_nat b)); trivial.\napply Z_of_P_lt_is_gcd_Z; trivial.\napply Z_of_P_lt_is_gcd_Z; trivial.\napply Z_of_P_lt_is_gcd_Z; trivial.\napply Z_of_P_gt_is_gcd_Z; trivial.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros; elim H; intros.\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_neg a b).\napply (sg_pos_pos a b).\napply (sg_pos_neg a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_pos_pos a b).\napply (sg_posQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nProof.\nintros a b d1 d2 H1 H2.\napply H2; rewrite <- H2; rewrite <- H3; rewrite H3; rewrite H3; reflexivity.\nQed.",
                    "Lemma unicity_is_gcdZ : forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\nintros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; \n elim H6; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " b d -> is_gcd Z IdZ multZ OZ a b d.\n\nintros. elim H; intros. apply (gcd_OZ_absZ b0). unfold is_gcd in |- *.\nsplit. elim H3; intros; elim H5; intros; exact H6.\nsplit. elim H1; intros; elim H5; intros; elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\n",
                "context_tokens": 726,
                "proof_start_offset": 6306,
                "proof_end_offset": 6452,
                "proof": "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\napply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nintros.\nelim H; intros; elim H0; intros; rewrite H0;\n  apply Zis_gcd_for_euclid2; assumption.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros.\napply (gcd_bezout_absZ a b d H H0).\napply gcd_lincomb_eq; assumption.\nrewrite H0; rewrite H0; rewrite H0; ring.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nintros a b d.\nunfold Bezout in |- *.\napply gcd_sym.\napply (gcd_sym (gcd_gcdZ a b d)).\napply Zis_gcd_for_euclid2; assumption.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nunfold gcdZ in |- *.\nelim (gcd_divisors a b); intros.\nrewrite H0; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_bezout_nat a b d); intros.\nrewrite H0; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_greatest_nat a b d); intros.\nrewrite H0; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_bezout_nat a b d); intros.\nrewrite H0; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_greatest_nat a b d); intros.\nrewrite H1; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_greatest_nat a b d); intros.\nrewrite H0; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_greatest_nat a b d); intros.\nrewrite H0; rewrite H0; reflexivity.\nunfold gcdZ in |- *.\nelim (gcd_greatest_nat a b d); intros.\nrewrite H0; rewrite H0Qed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d H.\napply (gcd_greatest a b d H).\napply (gcd_divide_l a b d H).\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nintros.\nelim (gcd_bezout a b d H); intros.\nrewrite H1; rewrite H2; rewrite H0; reflexivity.\nrewrite <- (gcd_sym a b); reflexivity.\nrewrite <- (gcd_comm b b); reflexivity.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nintros a b d H.\nelim H; intros.\nunfold Bezout in |- *.\nelim (gcd_bezout a b d H).\nelim H0; intros.\nelim H1; intros.\nrewrite H2; intros.\nrewrite H2; rewrite H3.\napply gcd_sym.\napply gcd_sym; apply gcd_opp_l.\napply gcd_opp_l.\nrewrite <- H1; rewrite <- H2; rewrite <- H3; ring.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nintros.\nelim H; intros.\nrewrite <- (gcd_sym a b); rewrite <- H; ring.\nrewrite (gcd_sym a b); rewrite <- H; ring.\nQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros a b d;\n elim (gcd_bezout_sign a b d); intros; \n [ apply Z_of_gcd_for_euclid2; trivial\n | apply Z_of_gcd_for_euclid2; trivial\n | apply Z_of_gcd_for_euclid2; trivial\n | apply Z_of_gcd_for_euclid2; trivial\n | apply Z_of_gcd_for_euclid2; trivial\n | apply Z_of_gcd_for_euclid2; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid3; trivial\n | apply Z_of_gcd_for_euclid4; trivial\n | apply Z_of_gcdQed.",
                    "Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\nProof.\nintros.\nelim H; intros; apply (gcd_sym a b).\napply (gcd_sym a b).\napply Zis_gcd_for_euclid2; auto.\napply Zis_gcd_for_euclid2; auto.\napply Zis_gcd_for_euclid2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": " elim H7; intros; rewrite H9.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) r d0).\nelim H3; intros; elim H11; intros. \nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q d0 H12 I).\nelim H3; intros; exact H10.\nintros. elim H3; intros; elim H7; intros. apply (H9 q0).\ncut (r = addZ a0 (oppZ (multZ b0 q))); intros. rewrite H10.\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring a0 (oppZ (multZ b0 q)) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\n",
                "context_tokens": 719,
                "proof_start_offset": 6470,
                "proof_end_offset": 6674,
                "proof": "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H H0.\napply gcd_unique_aux with q r; auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_euclid2 p q r); auto.\nintros; apply (gcd_for_Qed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H; case (gcd_bezout_sign a b q r); intros.\nrewrite H0.\napply Zis_gcd_for_euclid2; auto with zarith.\napply Zis_gcd_for_euclid2; auto with zarith.\napply Zis_gcd_for_euclid2; auto with zarith.\napply Zis_gcd_for_euclid2; auto with zarith.\napply Zis_gcd_for_euclid2; auto with zarith.\napply Zis_gcd_for_euclid2; auto with zarith.\napply Zis_gcd_for_euclid2; auto with zarith.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H.\napply (gcd_divide_l (Z_of_nat q) (Z_of_nat q) r).\napply gcd_greatest.\nexact H.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2; apply gcd_unique with (1 := H2) (2 := H1);\n apply divide_antisym; trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros a b q r H1 H2 H3; apply gcd_unique with (1 := H3) (2 := H4) (2 := H1);\n generalize (Z_div_mod a b q r H1 H2).\nintros; apply gcd_for_euclid_aux; trivial.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\napply (gcd_sym q r H).\napply gcd_sym.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\n intros a b q r H0 H1 H2.\n apply (gcd_for_euclid (gcd a b) q r).\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nintros.\nelim (gcd_divide_l a b); intros.\nelim (gcd_divide_r a b); intros.\nelim H0; intros; elim H1; intros; clear H1 H2; intros.\nelim H0; intros; rewrite H3; rewrite H4; rewrite H3;\n apply gcd_greatest; try assumption.\nrewrite H1; rewrite H3; rewrite H4; apply gcd_greatest; try assumption.\nQed.",
                    "Lemma gcd_modZ : forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a.\nProof.\nintros.\nelim H; intros.\nrewrite H2.\nrewrite <- H0; rewrite <- H1; rewrite <- H2; apply gcd_opp_r; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ")) q0 H5).\napply (div_opp Z IdZ addZ multZ OZ oppZ Z_ring (multZ b0 q) q0).\nexact (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b0 q q0 H4 I).\nelim H1; intros; elim H11; intros; elim H13; intros; rewrite H15.\nelim (addZ_commutativity r (multZ b0 q)).\nelim (addZ_associativity r (multZ b0 q) (oppZ (multZ b0 q))).\nelim (addZ_opposite (multZ b0 q) I); intros. \nelim H17; intros. elim H19; intros. rewrite H20. symmetry  in |- *. exact (add_OZ r).\nexact H4.\nQed.\n\n(*************)\nDefinition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*******************)\nTheorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).\nProof fun a b : Z => pi2 Z (is_gcdZ a b) (gcdZ_exists a b).\n\n(*********************)\nLemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> leZ OZ d.\n\nintros; elim H; intros. apply (sign_absZ b0). exact H3.\nQed.\n\n(********************)\nLemma unicity_is_gcdZ :\n forall a b d1 d2 : Z, is_gcdZ a b d1 -> is_gcdZ a b d2 -> d2 = d1.\n\nintros.\nelim\n (gcd_unicity_apart_sign a b d1 d2 (gcdZ_is_gcd a b d1 H)\n    (gcdZ_is_gcd a b d2 H0)).\nintros; exact H1.\nintros;\n apply\n  (le_opp_OZ2 d2 d1 H1 (positive_is_gcdZ a b d2 H0)\n     (positive_is_gcdZ a b d1 H)).\nQed.\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6945,
                "proof_end_offset": 8358,
                "proof": "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros q f.\ncase (eq_OZ_dec q); intro.\nunfold Q in |- *; intro b.\nsplit with IZ (sgnZ b).\nrewrite e.\nsimpl in |- *.\nrewrite (sgn_abs b).\napply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ.\nunfold Q in |- *; intro b.\nelim (divZ b q).\nintros div rem; intros.\ncut (lt_absZ rem q); intros.\nelim (f rem H q).\nintros.\nsplit with (addZ v (oppZ (multZ div u))) u.\nelim i.\nintros.\nelim H1.\nintros.\nelim H3.\nintros.\npattern b at 1 in |- *.\nrewrite H5.\nelim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\nrewrite H7.\nelim (mult_add_distributivity (multZ q div) rem u); intros.\nrewrite H8.\nrewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\nelim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\nrewrite (add_add Z addZ addZ_commutativity addZ_associativity (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u) (multZ (multZ q div) u)).\nelim (addZ_commutativity (multZ rem u) (multZ q v)).\nrewrite e.\nelim (multZ_associativity q div u).\nelim (addZ_opposite (multZ q (multZ div u)) I); intros.\nelim H11; intros; elim H13; intros.\nrewrite H15.\nrewrite (add_OZ (gcdZ rem q)).\nexact (gcd_modZ b q div rem n i).\nunfold lt_absZ in |- *.\nelim i; intros; elim H0; intros.\nrewrite (tech_le_pos_abs rem H1).\nelim H2; trivial.\nexact n.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros.\napply (gen_intro _ _ _ H0 H1 H2 H3).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros n H.\napply (Build_R_equiv (R:=fun n => Q n))); assumption.\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros n H.\napply (Build_field_mon_prop (fun m : nat => forall m : nat, lt_decZ m n -> Q m) n).\nred in |- *; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n    apply (no_a_value_dec (fun m : nat => m) n a b H2 H3 H4 H5).\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n    apply (no_a_value_dec (fun m : nat => m) n a b H4 H5).\nelim H1; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n    apply (no_a_value_dec (fun m : nat => m) n a b H4 H5).\nelim H0; intros; elim H4; intros; elim H4; intros;\n    apply (no_a_value_dec (fun m : nat => m) n a b H4 H5).\nelim H0; intros; elim HQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros.\napply (gen_mon_correct _ _ _ H H0 H1).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros.\napply (rel_prime_cross_prod a b (fun m : Z => forall m : Z, n <= m -> Q m) -> Q n).\napply (rel_prime_cross_prod a b (fun m : Z => forall m : Z, n <= m -> Q m) -> Q m).\napply (rel_prime_cross_prod a b (fun m : Z => forall m : Z, n <= m -> Q m) -> Q m).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros.\n  apply (equiv_refl (fun m => forall m : Z, lt_absZ m n -> Q m) (n, m)).\nQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof fun n => Q (nat_of_P n).\n\nDefinition Q_i (a : Z) := forall b : Z, (forall m : Z, lt_absZ m n -> Q (S m) -> Q n) -> Q n.\n\nDefinition Q_i (a b : Z) := forall b : Z, (forall m : Z, R m n -> Q (S m) -> Q n) -> Q n.\n\nDefinition Q_i (a b : Z) := forall b : Z, (forall m : Z, R m n -> Q (S m) -> Q n) -> Q n.\n\nDefinition Q_i (a b : Z) := forall b : Z, (forall m : Z, R m n -> Q (S m) -> Q n) -> Q n.\n\nDefinition Q_i (a b : Z) := forall b : Z, (forall m : Z, R (S m) -> Q (S m) -> Q (S m) -> Q n.\n\nDefinition Q_i (a b : Z) := forall b : Z, (forall m : Z, R (S m) -> QQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros.\n  induction n; intros.\n  simpl in H.\n  destruct a0; destruct b; try discriminate.\n  simpl in H.\n  destruct (le_gt_dec 0 n1); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (lt_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (lt_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (lt_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); try discriminate.\n  destruct (le_gt_dec 0 m); tryQed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros; apply (gen_intro _ _ H); clear H; intros.\napply (gen_intro _ _ H0); clear H0; intros.\napply (exp_intro _ _ H0); clear H0; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H0); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H0); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1; intros.\napply (exp_intro _ _ H1); clear H1;Qed.",
                    "Lemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\nintros n H; unfold Q; simpl.\napply (le_refl (S n)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": ".\n\n(*****************)\nLemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.\n\nintros. apply (unicity_is_gcdZ a b (gcdZ a b) d (gcdZ_correct a b) H).\nQed.\n\n(*************)\nLemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 8360,
                "proof_end_offset": 8453,
                "proof": "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\nexact (recZ Q acc_Q).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b; unfold Q in |- *; intro b.\n  split with Scope Q; trivial.\n  apply (gcdZ_is_gcdZ a b (gcdZ b) (gcdZ b)).\n  apply (gcdZ_is_gcdZ a b (gcdZ b)); apply gcd_gcdl. unfold Q in |- *; intro b.\n  elim (gcdZ_is_gcdZ a b (gcdZ b)); intros.\n  elim H; intros; elim H0; intros.\n  rewrite (gcd_eq_Z_is_gcdZ a b (gcdZ b)) in H; trivial.\n  elim (gcdZ_is_gcdZ b (gcdZ b) (gcdZ b)).\n  rewrite H0. rewrite (gcd_eq_Z_is_gcdZ b b (gcdZ b) (gcdZ b)).\n  elim (gcdZ_is_gcdZ b (gcdZ b) (gcdZ b)); intros.\n  elim H0; intros; elim H0; intros; elim H1; intros.\n  rewrite (gcd_eq_Z_is_gcdZ b (gcdZ b) (gcdZ b) (gcdZ b)).\n  rewrite HQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (verify_arg_prod (fun a b => a * b) (fun b => a * b) (fun c => a * b) c).\n  + apply (verify_arg_prod (fun a b => a * b) (fun c => a * b) c).\n  + apply (verify_arg_prod (fun a b => a * b) (fun c => a * b) c)).\n    + apply (verify_arg_prod (fun a b => a * b) c).\n    + apply (verify_arg_prod (fun a b => a * b) c).\n    + apply (verify_arg_prod (fun a b => a * b) c).\n  + apply (verify_arg_prod (fun a b => a * b) c).\n    + apply (verify_arg_prod (fun a b => a * b) c).\n    + apply (verify_arg_prod (fun a b => a * b) c).\n    + apply (verify_arg_prod (fun a b => a * b) c).\n    + apply (verify_arg_prod (fun a b => a * bQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold Q; intros.\n  apply (Build_G (fun a b =>\n   let (q, r) := a in let (q, r) := b in let (q, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (q, r) := b in let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   let (r, r) := b in r.\n  apply (Build_G (fun a b =>\n   letQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (gen_is_gcdZ a b (gcdZ b)).\n  apply (gen_is_gcdZ a b (gcdZ b)).\n  apply (gen_is_gcdZ a b (gcdZ b)); apply (gen_is_gcdZ a b).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  apply (gen_is_gcdZ a b (gcdZ a b)).\nQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold Q in |- *; intros.\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => let (v, _) := v in a) (divZ b n)).\n  apply (gen_intro (fun n => letQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  induction a; simpl; intros; auto.\n  destruct a; auto.\n  destruct b; auto.\n  destruct a; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct a; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct b; auto.\n  destruct H.\n  destruct H.\n  subst.\n  apply (gcdZ_is_gcdZ a (absZ b)) p (gcdZ b q)).\n  elim (Zis_gcdZ_is_gcdZ a (absZ b)); intros.\n  rewrite H.\n  apply (gcdZ_is_gcdZ a (absZ b)) p (gcdZ b q)).\n  elim (Zis_gcdZ_is_gcdZ b (absZ b)); intros.\n  elim H0; intros; elim H1; intros;\n    elim H2; intros; elim H3; intros;\n      elim H4; intros; elim H4; intros;\n        elim H4; intros; split;\n        [ elim H4; intros; assumption | split;\n          [ elim H4; intros; assumption | split;\n              [ elim H4Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros a b.\n  unfold Q in |- *.\n  apply (Build_G (fun x => a) (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) H).\n  apply (Build_G (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) H0).\n  apply (Build_G (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) H0).\n  apply (Build_G (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) H0).\n  apply H; simpl in |- *; trivial.\n  apply (Build_G (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) (fun x : Z => a) H0).\n  apply (Build_G (fun x : Z => a) (fun x : Z => a)Qed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  unfold Q in |- *. intros.\n  apply (eqp_is_gcdZ a b (gcdZ a b)).\n  apply (eqp_is_gcdZ a b (gcdZ b)); apply (gcdZ_is_gcdZ a b).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZ b)).\n  apply (gcd_greatest b (gcdZ b)).\n  apply (gcd_greatest b (gcdZ b)).\n  apply (gcd_greatest b (gcdZ b)).\n  apply (gcd_greatest b (gcdZ b)).\n  apply (gcd_greatest b (gcdZ b)).\n  apply (gcd_greatest a b (gcdZQed.",
                    "Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  intros.\n  destruct a; destruct b; auto.\n  unfold Q in |- *; intros.\n  destruct a; destruct b; auto.\n  unfold Q in |- *; intros.\n  destruct b; auto.\n  unfold Q in |- *; intros.\n  destruct a0; auto.\n  unfold Q in |- *; intros.\n  destruct b; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "Lemma gcd_modZ :\n forall a b q r : Z, b <> OZ -> is_diveuclZ a b q r -> gcdZ r b = gcdZ b a. \n\nintros. apply (gcdZ_is_gcdZ b a (gcdZ r b)).\napply (gcd_mod b a (gcdZ r b) q r H H0 (gcdZ_correct r b)).\nQed.\n\n(*********************************)\nInductive verify_BezoutZ (a b : Z) : Set :=\n    Bezout_i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\n",
                "context_tokens": 736,
                "proof_start_offset": 8579,
                "proof_end_offset": 8840,
                "proof": "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\nintros.\nunfold divide in |- *.\nsplit.\nexact I.\nsplit.\nexact I.\nelim (eq_OZ_dec x); intros.\nleft; exact a.\nright; split.\nexact b.\nexists IZ.\nsplit.\nexact I.\nsymmetry in |- *; exact (mult_IZ x).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros; unfold BetaZ in |- *; simpl in |- *.\n  split with (two_power 1 1).\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\n  unfold Zminus in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  generalize (Z_div_mod_eq (absZ x) (absZ_of_nat n)).\n  unfold recrZ in |- *.\n  rewrite (Z_div_mod_eq (absZ x) (absZ_of_nat n)).\n  rewrite (Z_div_mod_eq (absZ x) (absZ_of_nat n)).\n  rewrite (Zmult_comm (Zabs_nat n)).\n  reflexivity.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros. apply (Zdivide_divides x (absZ y)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  unfoldPost, Q, Q, x, x, y.\n  intros.\n  unfold Q, Q, x, y.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  unfold recrZ in |- *.\n  unfold Pre in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold eval_be' in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold Q in |- *.\n  unfold eval_be' in |- *.\n  unfold Q in |- *.\n  unfold QQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  elim (Z_div_mod_eq (fun x y => x = y) (Zmult_comm x (multZ y)).\n  intros.\n  elim H.\n  unfold Q in |- *. intros.\n  rewrite (mult_comm x y).\n  rewrite (Zmult_comm x y).\n  rewrite H.\n  reflexivity.\n  exact n.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  elim H; intros; apply H; trivial.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros x; unfold divide, Q in |- *.\n  generalize (Z_mod_eq (Z_of_nat n) (absZ_of_nat (S n))).\n  change (two_power_nat (S n)) with (two_power_nat (S n)).\n  rewrite H.\n  rewrite H; trivial.\n  apply (gcd_comm (Z_of_nat n)).\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intro. unfold DividesZ in |- *.\n  elim (gcdZ_is_gcdZ x (absZ y)).\n  intros.\n  elim H; intros.\n  split with (- (1)).\n  rewrite H. simpl in |- *.\n  apply Z.gcd_greatest; trivial.\n  apply gcd_greatest; trivial.\nQed.",
                    "Lemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\nProof.\n  intros.\n  apply (div_exact (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) (fun x : Z => x) x).\n  intros.\n  elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H4; intros;\n    rewrite H5; rewrite H5; rewrite H5; rewrite H5;\n    reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zgcd.v",
                "context": "i :\n      forall u v : Z,\n      addZ (multZ a u) (multZ b v) = gcdZ a b -> verify_BezoutZ a b.\n\n(********************)\nDefinition Q (a : Z) := forall b : Z, verify_BezoutZ a b.\n\nLemma acc_Q : forall n : Z, (forall m : Z, lt_absZ m n -> Q m) -> Q n.\nProof.\n  intros q f. case (eq_OZ_dec q); intro. unfold Q in |- *; intro b.\n  split with IZ (sgnZ b). rewrite e. simpl in |- *. rewrite (sgn_abs b).\n  apply (gcdZ_is_gcdZ OZ b (absZ b)); apply gcd_OZ. unfold Q in |- *; intro b.\n  elim (divZ b q). intros div rem; intros. cut (lt_absZ rem q); intros.\n  elim (f rem H q). intros. split with (addZ v (oppZ (multZ div u))) u.\n  elim i. intros. elim H1. intros. elim H3. intros. pattern b at 1 in |- *.\n  rewrite H5. elim (mult_add_distributivity q v (oppZ (multZ div u))); intros.\n  rewrite H7. elim (mult_add_distributivity (multZ q div) rem u); intros.\n  rewrite H8. rewrite (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring q (multZ div u) I I).\n  elim (addZ_commutativity (multZ rem u) (multZ (multZ q div) u)).\n  rewrite\n   (add_add Z addZ addZ_commutativity addZ_associativity \n      (multZ q v) (oppZ (multZ q (multZ div u))) (multZ rem u)\n      (multZ (multZ q div) u)).\n    elim (addZ_commutativity (multZ rem u) (multZ q v)). rewrite e.\n    elim (multZ_associativity q div u).\n    elim (addZ_opposite (multZ q (multZ div u)) I); intros.\n    elim H11; intros; elim H13; intros. rewrite H15.\n    rewrite (add_OZ (gcdZ rem q)).\n    exact (gcd_modZ b q div rem n i). unfold lt_absZ in |- *.\n    elim i; intros; elim H0; intros. rewrite (tech_le_pos_abs rem H1).\n    elim H2; trivial. exact n.\nQed.\n\nLemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.\nProof.\n  exact (recZ Q acc_Q).\nQed.\n\n(******************)\nDefinition congruentZ (x y n : Z) :=\n  divide Z IdZ multZ OZ n (addZ x (oppZ y)).\n\n(*****************)\nLemma divide_selfZ : forall x : Z, divide Z IdZ multZ OZ x x.\n\nintros. unfold divide in |- *. split. exact I. split. exact I.\nelim (eq_OZ_dec x); intros. left; exact a.\nright; split. exact b. exists IZ. split. exact I. symmetry  in |- *; exact (mult_IZ x).\nQed.\n\n(**********************************)\n",
                "context_tokens": 717,
                "proof_start_offset": 8879,
                "proof_end_offset": 12106,
                "proof": "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\nintros.\nelim (Bezout_exists a b); intros.\nexists (addZ (multZ x (multZ b v)) (multZ y (multZ a u))).\nunfold congruentZ in |- *; split.\nreplace (multZ b v) with (addZ IZ (oppZ (multZ a u))).\nelim (mult_add_distributivity x IZ (oppZ (multZ a u))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ x).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring a u I I).\nrewrite (multZ_associativity x a (oppZ u)).\nelim (multZ_commutativity a x).\nelim (multZ_associativity a x (oppZ u)).\nrewrite (multZ_associativity y a u).\nelim (multZ_commutativity a y).\nelim (multZ_associativity a y u).\nelim (addZ_associativity x (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))).\nelim (addZ_commutativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x).\nelim (addZ_associativity (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u))) x (oppZ x)).\nelim (addZ_opposite x I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ a (multZ x (oppZ u))) (multZ a (multZ y u)) a).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ x (oppZ u)) a (divide_selfZ a) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring a (multZ y u) a (divide_selfZ a) I).\nelim H.\nelim e.\nelim (addZ_commutativity (multZ b v) (multZ a u)).\nelim (addZ_associativity (multZ b v) (multZ a u) (oppZ (multZ a u))).\nelim (addZ_opposite (multZ a u) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nexact (add_OZ (multZ b v)).\ncut (multZ a u = addZ IZ (oppZ (multZ b v))); intros.\nrewrite H0; clear H0.\nelim (mult_add_distributivity y IZ (oppZ (multZ b v))); intros.\nrewrite H1; clear H0 H1.\nrewrite (mult_IZ y).\nelim (mult_opp_r Z IdZ addZ multZ OZ oppZ Z_ring b v I I).\nrewrite (multZ_associativity y b (oppZ v)).\nelim (multZ_commutativity b y).\nelim (multZ_associativity b y (oppZ v)).\nrewrite (multZ_associativity x b v).\nelim (multZ_commutativity b x).\nelim (multZ_associativity b x v).\nelim (addZ_commutativity (multZ b (multZ y (oppZ v))) y).\nrewrite (addZ_associativity (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) y) .\nelim (addZ_associativity (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v)))) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nrewrite (add_OZ (addZ (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))))).\napply (div_add Z IdZ addZ multZ OZ oppZ Z_ring (multZ b (multZ x v)) (multZ b (multZ y (oppZ v))) b).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ x v) b (divide_selfZ b) I).\napply (div_mult Z IdZ addZ multZ OZ oppZ Z_ring b (multZ y (oppZ v)) b (divide_selfZ b) I).\nelim H.\nelim e.\nelim (addZ_associativity (multZ a u) (multZ b v) (oppZ (multZ b v))).\nelim (addZ_opposite (multZ b v) I); intros.\nelim H1; intros.\nelim H3; intros.\nrewrite H4; clear H0 H1 H2 H3 H4 H5.\nsymmetry in |- *; exact (add_OZ (multZ a u)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. destruct (le_or_lt 0 x) as [H|H].\n  left; exact H.\n  right; exact H.\n  right; assumption.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  destruct H as [n [H0 H1]].\n  split with n; trivial.\n  intros.\n  destruct H as [n [H1 H2]].\n  exists (S n).\n  split.\n  red in |- *.\n  split.\n  red in |- *.\n  split; trivial.\n  split; trivial.\n  intros.\n  destruct H as [n [H1 H2]].\n  exists (S n).\n  split.\n  red in |- *.\n  split; trivial.\n  split; trivial.\n  intros.\n  destruct H as [n [H1 H2]].\n  exists (S n).\n  split.\n  red in |- *.\n  split; trivial.\n  split; trivial.\n  red in |- *.\n  split; trivial.\n  split; trivial.\n  intros.\n  destruct H as [n [H1 H2]].\n  exists (S n).\n  split.\n  red in |- *.\n  split; trivial.\n  red in |- *.\n  split; trivial.\n  split; trivial.\n  red in |- *.\n  split; trivial.\n  intros.\n  destruct H as [n [H1 H2]].\n  exists (S n).\n  split.\n  red in |- *.\n  split;Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  destruct H.\n  destruct H0.\n  left.\n  left.\n  exists (ZscaleZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppZ oppQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y.\n  case (eqVneq a 0) as [a b]; intros; exists b; split; trivial.\n  intros; right; split; trivial.\n  intros; right; apply H; trivial.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y.\n  case (Z_zerop_dec x); intros.\n  left; apply Z.divide_refl.\n  right; apply Z.divide_refl.\n  right; apply Z.divide_refl.\n  right; apply Z.divide_refl.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros a b x y; case (gcdZdiv_eucl a b); intros.\n  left; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  right; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).\n  left; apply (gcd_greatest_bound a b).Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros.\n  destruct (eq_Rat_dec a b).\n  left. apply H. right; reflexivity.\n  right. apply H. right; reflexivity.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. destruct H as [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z z]]]]]]]]]]]]]]]].\n  exists (Z.modulo z z).\n  destruct (gcdZ z z) as [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z z]]]]]].\n  exists (Z.div z z).\n  exists (Z.div z z).\n  exists (Z.div z z).\n  rewrite <- (Z.mul_comm z z). rewrite z.\n  rewrite (Zmult_comm z z). rewrite (Zmult_comm z z).\n  rewrite (Zmult_comm z z). rewrite (Zmult_comm z z).\n  rewrite (Zmult_comm z z).\n  reflexivity.Qed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. destruct H as [a [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z' z']]]]]; simpl in z; intros;\n    red in H; rewrite H in H; inversion H; clear H; subst.\n  exists z; exists z; exists z; exists z; exists z; exists z; exists z; auto.\nQed.",
                    "Theorem chinese_remaindering_theorem : forall a b x y : Z, gcdZ a b = IZ -> {z : Z | congruentZ z x a /\\ congruentZ z y b}.\nProof.\n  intros. destruct H. left; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\n",
                "context_tokens": 134,
                "proof_start_offset": 1314,
                "proof_end_offset": 1558,
                "proof": "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nProof.\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros.\nelim (le_or_lt 0 m).\napply le_antisym.\napply le_antisym.\napply lt_le_weak.\napply le_antisym.\napply le_weak.\napply le_trans with (m := nat_of_P m).\napply le_S_n.\napply le_trans with (m := nat_of_P m).\napply lt_le_weak.\napply le_S_n.\napply le_trans with (m := nat_of_P m).\napply le_O_n.\napply le_trans with (m := nat_of_P m).\napply le_trans with (m := nat_of_P m).\napply le_plus_trans with (m := nat_of_P m).\napply le_plus_trans with (m := nat_of_P m).\napply le_plus_trans with (m := nat_of_P m).\napply le_plus_trans with (m := nat_of_P m).\napply le_plus_trans with (m := nat_of_P m).\napply le_plus_trans withQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros m H; elim (le_Sn_O m H); auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros m; elim m.\nsimpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m.\nauto.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nred in |- *; intros m H; elim (le_O_eq m H).\nauto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nunfold not in |- *; intros.\nelim (lt_O_eq _ _ H).\nintros.\nelim H; intros.\nelim H0; intros.\nsplit; [ assumption | assumption ].\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nintros.\nelim (le_Sn_O m).\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact le_antisym.\nexact leQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nsimple induction m; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\nunfold not in |- *; intros m H; elim H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\n",
                "context_tokens": 219,
                "proof_start_offset": 1573,
                "proof_end_offset": 1786,
                "proof": "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nProof.\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H0; elim H0; intros.\nsplit; auto.\nelim H1; intros.\nsplit; auto.\nelim H1; intros.\nelim H2; intros.\napply H2; auto.\napply H0; auto.\napply H0; auto.\napply H0; auto.\napply H0; auto.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H H0; elim H; intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6;\n elim H6; intros H7 H8; elim H8; intros H9 H10;\n elim H10; intros H12 H13; elim H12; intros H12 H13; elim H13;\n intros H14 H15; elim H15; intros H15 H16; elim H15; intros H16 H17;\n elim H17; intros H17 H18; elim H18; intros H18 H20; elim H18;\n intros H17 H18; elim H18; intros H18 H20; elim H18;\n intros H18 H20; elim H18; intros H19 H20; elim H18; intros H18 H20; elim H18;\n intros H20 H21; elim H20; intros H22 H23; elim H23; intros H24 H25;\n elim H25; intros H25 H26 H27; elim H25; intros H26 H29; elim H26; intros H26 H29;\n elim H26; intros H25 H26Qed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros; elim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nexists x0; auto with arith.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros; unfold ltZ in |- *; elim n.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros; apply nat_ind_r; apply lt_irrefl.\nexact lt_inc_inc_inc_inc_inc.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros; elim (le_or_lt (absZ m) (absZ m)); intros H1.\nelim H1; intros H2; elim H2; intros H3 H4; elim H4; intros H5 H6.\nelim H2; intros H5 H6.\nexists (absZ m0); exists (absZ m0); split;\n [ idtac | simpl in |- *; ring ].\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H' H'0; cut (forall m : Z, (forall m : Z, lt_absZ m n -> P m) -> P n);\n [ intros; apply lt_irrefl | apply lt_irrefl ].\napply le_antisym; assumption.\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros; unfold lt in |- *; elim (le_or_lt 0 n); intros.\napply H2.\nelim H2; intros.\nsplit.\nexact (H2 H0).\nelim H2; intros.\nsplit.\nexact (H2 H0).\nexact (H1 H).\nQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros P H' H'0; elim H'; clear H'; intros H'1; elim H'1;\n clear H'1; intros H'2; elim H'2; intros H'3 H'4; elim H'4;\n clear H'2; intros H'4 H'5; elim H'4;\n clear H'4; intros H'5; elim H'5; intros H'6 H'7; clear H'5;\n elim H'6; intros H'6 H'7; clear H'5;\n elim H'5; intros H'6 H'7; clear H'6;\n elim H'6; intros H'7 H'7; clear H'5;\n elim H'5; intros H'6 H'7; clear H'5;\n elim H'6; intros H'7 H'7; clear H'6;\n elim H'6; intros H'8 H'9; clear H'5;\n elim H'6; intros H'7 H'7; clear H'6;\n elim H'7; intros H'7 H'7; clear H'5;\n elimQed.",
                    "Lemma Zrec1 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\nintros; unfold iff in |- *; simpl in |- *; intros; apply H; apply lt_irrefl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\n",
                "context_tokens": 413,
                "proof_start_offset": 2085,
                "proof_end_offset": 2498,
                "proof": "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\nelim (le_n_O_eq n H0).\napply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nelim (le_n_O_eq n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m).\napply (Zrec1 P H).\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nProof.\nintros P H; elim H; intros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\napply H1; assumption.\napply H1; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold not in |- *; intros; apply (H be); intros.\nunfold not in |- *; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim HQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros P H0; elim H0; intros.\nunfold iff in |- *; simpl in |- *; intros; elim H1; intros.\nunfold not in |- *; intros.\nelim H1; intros.\nunfold not in |- *; intros.\nelim H2; intros.\nunfold not in |- *; intros.\nelim H3; intros.\nunfold not in |- *; intros.\nelim H4; intros.\nunfold not in |- *; intros.\nelim H4; intros.\nunfold not in |- *; intros.\nelim H4; intros.\nunfold not in |- *; intros.\nelim H4; intros.\nunfold not in |- *; intros.\nelim H4; intros.\nunfold not in |- *; intros.\nelim H5; intros.\nunfold not in |- *; intros.\nelim H6; intros.\nunfold not in |- *; intros.\nelim H6; intros.\nunfold not in |- *; intros.\nelim H5; intros.\nunfold not in |- *; intros.\nelim H5; intros.\nunfold not in |- *; intros.\nelim H6; intros.\nunfold not in |- *; intros.\nelim H6; intros.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold not in |- *; intros; elim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nexists x0; auto with arith.\nexists x0; auto with arith.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nunfold not in |- *; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n generalize H3; rewrite <- H2; clear H3 H4; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H4; intros;\n    generalize (H1 n H4 H6); clear H5 H6; intros;\n    generalize H1; rewrite <- H4; clear H4 H5 H6;\n      intros; generalize (H1 n H4); clear H1 H4 H5;\n      intros; elim H4; intros; elim H5; intros;\n      elim H5; intros;\n      elim H5; intros;\n      elim H5; intros;\n      elim H6; intros; apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n      apply H6; elim H6; intros;\n     Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros; apply (H Zero); intros.\nunfold or_ind in |- *; intros; elim H1; intros.\nelim H2; intros.\nelim H4; intros.\nexists (pos x0).\nelim H5; intros.\nexists (pos x0).\n elim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumption | assumption ].\nelim H5; intros.\nexists (pos x0).\nsplit; [ assumptionQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros.\napply (H (fun m : nat => P (pos m))).\nunfold not in |- *; simpl in |- *; intros; elim H0; intros; elim H1; intros.\nsplit; [ assumption | intros; elim H1; intros; elim H2; intros; elim H3; intros;\n    apply H4; apply H5; assumption ].\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nsimple induction 1; intros.\napply H; assumption.\nQed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros; apply (H One H0); intros.\nunfold not in |- *; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros;\n    elim H5; intros; elim H5; intros; elim H5; intros;\n      elim H5;Qed.",
                    "Lemma Zrec2 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\nintros; apply (H P); intros; split; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "                                                                        *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zrec.v                                  *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export misc.\nRequire Export Zbase.\nRequire Export Zle.\n\n(**********)\nLemma lt_OZ : forall m : Z, ~ ltZ (absZ m) OZ.\n\nintros; unfold ltZ in |- *; elim m.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nunfold not in |- *; simpl in |- *; intros; exact H.\nQed.\n\n(**********)\nLemma Zrec1 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\n",
                "context_tokens": 562,
                "proof_start_offset": 2513,
                "proof_end_offset": 3508,
                "proof": "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nsplit.\nelim (lt_succ n p H1); intros.\nelim (H0 n a); intros; trivial with arith.\nrewrite b.\napply (H (neg (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nelim (lt_succ n p H1); intros.\nelim (H0 n); intros; trivial with arith.\nrewrite b.\napply (H (pos (S p))).\nsimple destruct m.\nintros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros; apply iff_trans with (P (pos 0)); intros.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napply iff_trans with (P (pos 0)); auto.\napplyQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros.\nunfold and_recZ in |- *; intros; apply and_set_eq_i.\n(* pos n *)\nelim (le_n_O_eq n H).\napply (H (pos (pred n)) (fun m : nat => plus_le_compat_l n m) H0).\n(* pos n *)\nelim (le_n_O_eq n H).\napply (H (pos 0)); intros.\nrewrite (tech_le_abs_fibonacci n).\napply (fun m : nat => plus_le_compat_l n m) H0 H).\n(* pos n *)\nelim (le_S_n n H0).\napply (H (pos 0)); intros.\nrewrite (tech_lt_abs_fibonacci n).\napply (fun m : nat => plus_le_compat_l n m) H0).\n(* pos n *)\nelim (le_n_O_eq n H0).\n(* pos n *)\nelim (le_S_n n H0).\n(* pos n *)\nelim (le_Sn_O_eq n H0).\n(* pos n *)\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nProof.\nintros P p H H0; pattern p in |- *; apply (H (pos n)); intros.\napply (H0 (pos n)); intros.\nrewrite (tech_lt_abs_everything m).\n apply (H (pos n)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos n)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos n)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos n)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos m)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos m)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos m)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos n)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos n)); intros.\nrewrite (tech_lt_abs_fibonacci m).\napply (H (pos n)); intros.Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros; apply iff_antisym.\nunfold not in |- *; intros; apply iff_antisym; assumption.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros; apply iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Q := fun n : nat => P (pos n)).\nexact iff_antisym with (Qed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros; apply iff_refl.\nunfold not in |- *; intro; apply H.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros P p; elim p.\nunfold not in |- *; intros; elim p.\nunfold not in |- *; intros; elim p0; intros; elim p0; intros; elim p0; intros; elim p0; intros; elim p0; intros;\n    assumption.\nunfold not in |- *; intros; elim p0; intros; elim p0; intros; elim p0; intros; elim p0; intros;\n    assumption.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nunfold and_recZ in |- *; intros; elim H.\nunfold not in |- *; intros; apply or_ind_r; intros; elim H; intros.\nrewrite (tech_le_abs_Apart m); assumption.\nQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros P p p H H0; split; intros.\nelim H0; intros.\nrewrite (tech_lt_abs_Aeq m).\napply (H (pos (S p) H1)).\napply (H (pos (S p) H1)).\napply (H (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H (pos (S p) H1)).\napply (H (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H0 (pos (S p) H1)).\napply (H (pos (S p) H1)).\napply (H0 (posQed.",
                    "Lemma Zrec3 : forall (P : Z -> Set) (p : nat), (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ p P -> and_recZ (S p) P.\nintros; apply iff_antisym; apply iff_antisym; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": " -> P m) -> P n) -> P OZ.\n\nintros; apply (H OZ); intros.\nunfold lt_absZ in H0; unfold absZ at 2 in H0; elim (lt_OZ m); assumption.\nQed.\n\n(**********************************)\nInductive and_set_set_set (S1 S2 : Set) : Set :=\n    and_set_set_set_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\n",
                "context_tokens": 707,
                "proof_start_offset": 3526,
                "proof_end_offset": 3740,
                "proof": "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nintros; elim p.\nexact (Zrec2 P H).\nintros; apply Zrec3; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n\nDefinition P_pos (n : nat) (P : Z -> Set) :=\n  forall n : nat, P n -> P (pos n).\n\nDefinition P_pos (n : nat) (P : Z -> Set) (n : nat) :=\n  forall m : Z, P (pos m) -> P n.\n\nDefinition P_pos (n : nat) (P : Z -> Set) :=\n  forall n : nat, P n -> P n.\n\nDefinition P_pos (n : nat) (P : Z -> Set) (n : nat) :=\n  forall n : nat, P n -> P (pos n).\n\nDefinition P_pos (n : nat) (P : Z -> Set) :=\n  forall n : nat, P n -> P (pos n).\n\nDefinition P_pos (n : nat) (P : Z -> Set) :=\n  forall n : nat, P n -> P n.\n\nDefinition P_pos (n : nat) (P : Z -> Set) :=\n  forall n : nat, P n -> P (pos n).\n\nNotation P_pos := (fun n : nat => P_pos n).Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n\n(* P (neg n) *)\n\nTheorem Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, (forall m : Z, n <= m -> P m)) -> P n) ->\n forall p : nat, (forall m : Z, (forall m : Z, n <= m -> P m) -> P n) ->\n (p <= p)%Z -> P p.\nintros P p; elim p; intros.\nelim (le_gt_dec 0 p H0).\nintro H1; apply (H (pos n)).\napply (H (pos n)).\nauto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nProof.\nsimple induction 1; intros.\napply (H (pos (S p))); auto with arith.\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n\nDefinition explicit_strong (P : Z -> Set) (n : nat) (P : Z -> Prop) :=\n  forall m : Z, (forall m : Z, (m <= n)%Z -> P m) -> P n.\n\nTheorem explicit_strong_rec_weak :\n forall (P : Z -> Set) (n : nat),\n (forall m : Z, (n <= m)%Z -> P m) ->\n (forall m : Z, (m <= n)%Z -> P m) ->\n forall p : nat, (forall m : Z, (m <= n)%Z -> P m) ->\n (n <= p)%Z -> P n.\nProof.\nintros P n m.\ncase n.\nintros m H1 H2.\napply (H3 H1).\nintros m H3.\napply (H3 H4).\nintros m H4.\napply (H4 m H5).\napply (H3 H4).\nintros m H5.\napply (H4 m H5).\nintros m H5.\napply (H5 m H5).\nintros m H5.\napply (H4 m HQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros; apply (H (pos n)); intros.\napply (H (pos n)); intros.\napply (H0 H1).\napply (H (pos n)); intros.\napply (H0 H1).\napply (H0 H1).\napply (H1 (pos (S p))); intros.\napply (H0 H1).\napply (H1 H2).\napply (H0 H1).\napply (H0 H1).\napply (H0 H1).\nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n\n(* P (neg n) *)\nintros.\nunfold le_absZ in |- *; unfold le_absZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold Zlt in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; simpl in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros; apply (H (pos n)).\nunfold not in |- *; intro; apply (H (pos n0)); intros.\napply (H0 (pos n0)); intros.\napply (H0 (pos n0)); intros.\napply (H (pos (S p0))); intros.\napply (H (pos (S p0))); intros.\napply (H1 (pos (S p0))); intros.\napply (H1 (pos n0)); intros.\napply (H0 (pos (S p0))); intros.\napply (H1 (pos n0)); intros.\napply (H0 (pos n0)); intros.\napply (H1 (pos (S p0))); intros.\napply (H1 (pos n0)); intros.\napply (H0 (pos n0)); intros.\napply (H (pos (S p0))); intros.\napply (H1 (pos (S p0))); intros.\napply (H0 (pos (S p0))); intros.\napply (H1 (pos n0)); intros.\napply (H0 (pos (S p0))); intros.\napply (H1 (pos (SQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n\n(* P (neg n) *)\n\nTheorem Zind4 :\n forall P : Z -> Set, (forall n : Z, (forall m : Z, n <= p -> P m) -> P n) ->\n(forall n m : Z, (n <= p -> P m) -> P n) ->\n(forall n m : Z, (n <= m)%Z -> P n) ->\n (forall m : Z, (n <= m)%Z -> P m) ->\n(forall n m : Z, (n <= m)%Z -> P n) ->\n(forall m : Z, (n <= m)%Z -> P n) ->\n(forall m : Z, (n <= m)%Z -> P n) ->\n(forall m : Z, (n <= m)%Z -> P m) ->\n(forall n m : Z, (n <= m)%Z -> P n) ->\n (n <= m)%Z -> forall m : Z, (n <= m)%Z -> P n) ->\n (n <= m)%Z -> P n.\nintros; apply iff_trans with (m := (fun m : Z => P (S m) /\\ (Qed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\nintros P H p; elim p; intros.\nelim (le_S n p H0); intros.\nelim (le_S n p H0); intros.\nelim (le_S n p H0); intros.\nelim (le_S n p H0); intros.\nrewrite (tech_lt_abs_nocontinue n p H0 H).\napply (H (pos n) H1).\n(* a case analysis on n *)\nintros m; rewrite (tech_lt_abs_fibonacci m).\napply (H (pos n) H0).\n(* a case analysis on n *)\nintros m; rewrite (tech_lt_abs_fibonacci m).\napply (H (pos n) H0).\n(* a case analysis on n *)\nintros m; rewrite (tech_lt_abs_fibonacci m).\napply (H (pos n) H0).\n(* a case analysis on m *)\nintros m; rewrite (tech_lt_abs_fibonacci m).\napply (H (pos n) H0).\n(* a case analysis on m *)\nintros m; rewrite (tech_le_abs_fibonacci m).\napply (H (pos nQed.",
                    "Theorem Zrec4 : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : nat, and_recZ p P.\n\nDefinition F : Z -> Set :=\n  forall n : nat, F n -> F (n - 1) -> forall m : nat, F m.\n\nDefinition F : Z -> Set :=\n  forall n : nat, F n -> F (n - 1) -> forall m : nat, F m.\n\nDefinition F : Z -> Z :=\n  forall m : nat, F m -> F m.\n\nDefinition F : Z -> Z :=\n  forall m : nat, F m -> F m.\n\nDefinition Z_of_nat (n : nat) :=\n  match n return (0 <= n)%nat with\n  | O => 0\n  | S m => 0\n  end.\n\nDefinition F (n : nat) (H : 0 < n) :=\n  match n return (0 <= n)%nat with\n  | O => 0\n  | S n => F (S n)\n  end.\n\nDefinition Z_of_nat (n : nat) :=\n  match n return (0 <= n)%nat with\n  | O => 0\n  | S n => 0\n  end.\n\nFixpoint Z_of_nat (n : nat) :=\n  match n return (0 <= n)%natQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zrec.v",
                "context": "_i : S2 -> S1 -> and_set_set_set S1 S2.\n\n(*****************)\nDefinition and_recZ (p : nat) (P : Z -> Set) :=\n  forall n : nat, n <= p -> and_set_set_set (P (pos n)) (P (neg n)).\n\n(**********)\nLemma Zrec2 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> and_recZ 0 P.\n\nunfold and_recZ in |- *; intros; apply and_set_set_set_i.\n(* neg n *)\nelim (le_n_O_eq n H0). apply (H (neg 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\n(* pos n *)\nelim (le_n_O_eq n H0). apply (H (pos 0)); intros.\nrewrite (tech_lt_abs_OZ m). apply (Zrec1 P H). exact H1.\nQed.\n\n(**********)\nLemma Zrec3 :\n forall (P : Z -> Set) (p : nat),\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n and_recZ p P -> and_recZ (S p) P.\n\nsplit.\n(* P (neg n) *)\nelim (lt_succ n p H1); intros. elim (H0 n a); intros; trivial with arith.\nrewrite b. apply (H (neg (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\n(* P (pos n) *)\nelim (lt_succ n p H1); intros. elim (H0 n); intros; trivial with arith.\nrewrite b. apply (H (pos (S p))).\nsimple destruct m. intros; apply (Zrec1 P H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros.\nelim (H0 n0); auto with arith.\nQed.\n\n(*************)\nTheorem Zrec4 :\n forall P : Z -> Set,\n (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) ->\n forall p : nat, and_recZ p P.\n\nintros; elim p. \nexact (Zrec2 P H). \nintros; apply Zrec3; trivial with arith.\nQed.\n\n(************)\n",
                "context_tokens": 711,
                "proof_start_offset": 3757,
                "proof_end_offset": 4149,
                "proof": "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nProof.\nintros; elim p.\nexact (Zrec1 P H).\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nintro n; cut (and_recZ n P).\nintros.\nelim (H0 n); auto with arith.\napply Zrec4; trivial with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun n m : Z => plus_comm (S n) (S m)).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p; intros.\nexact (fun m n p : nat => plus_comm m p).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros P H p; elim H; intros.\npattern p in |- *; apply case_eq (p + p); intros.\nelim H1; intros.\nabsurd (p < p)%Z.\napply lt_le_weak; assumption.\napply (H0 (pos n0)); intros.\ncut (p < p)%Z.\napply lt_le_weak; assumption.\napply (H (pos n0)); intros.\nabsurd (p < p)%Z.\napply lt_le_weak; assumption.\napply (H (pos n0)); intros.\nabsurd (p < p)%Z.\napply lt_le_weak; assumption.\napply (H0 (pos n0)); intros.\nabsurd (p < p)%Z.\napply lt_le_weak; assumption.\napply (H0 (pos n0)); intros.\nabsurd (p < p)%Z.\napply lt_le_weak; assumption.\napply (H (pos n0)); intros.\nabsurd (p < p)%Z.\napply le_lt_weak; assumption.\napply (H (pos n0)); intros.\nabsurd (p < p)%ZQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun m n : nat => plus_comm n m p).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nintros m H H0; elim H0; intros; assumption.\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p.\napply (fun n m => plus_comm m n p).\napply (fun n m => plus_comm m n p).\napply (fun n m => plus_comm m n p).\napply (fun n m => plus_comm m n p).\napply (fun n m => plus_comm m n p).\napply (fun n m => plus_comm m n p).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun n : Z => plus_comm n (S p)).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun n m : Z => plus_comm m n p).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \n exact (fun m n : nat => plus_comm m n).\nQed.",
                    "Theorem recZ : forall P : Z -> Set, (forall n : Z, (forall m : Z, lt_absZ m n -> P m) -> P n) -> forall p : Z, P p.\nintros; elim p. \nexact (fun m n p : Z => plus_comm m n p).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nintros.\nunfold Feven in |- *.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  case (Z_dec x y); intro; try assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H; intro; assumption.\n  elim H;Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfoldrht, ordered in |- *.\nintros.\napply eq_S_n.\nrewrite H.\nrewrite H.\nreflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  case (eq_nat_dec x1 y); intros.\n  reflexivity.\n  rewrite H0.\n  reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nintros.\ncase y; simpl in |- *; intros; trivial.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nintros.\nunfold OZ in |- *.\nelim (multpos x1 n).\nauto with arith.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold bequiv in |- *; intros.\nelim H; intros.\nrewrite <- (inv_inv x1); rewrite (inv_inv x2); reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfoldnop, zero, addpos; reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\ninduction y; intros; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\n auto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; unfold pred_nat, pred_nat, pred_nat; simpl.\n reflexivity.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* succ n *)\nintros; elim x.\n(* succ n *)\nintros; elim x.\n(* succ n *)\nintros; elim x.\n(* succ n *)\nsimpl in |- *; exact (pred_succZ (pos n0)).\n(* abs n *)\nintros; elim x.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ_pred with n0; assumption.\n(* succ n *)\nintros; elim x.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ_pred with n0; assumption.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ_pred with n0; assumption.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ_pred with n0; assumption.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ with n0; assumption.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ with n0; assumption.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ with n0; assumption.\n(* n0 *)\nsimpl in |- *; rewrite pred_succ with n0; assumption.\n(* n0 *)\nsimplQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ y).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predX y). \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predX y). \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predX y).  \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_zerop y).  \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; apply pred_absolu_l.\n(* pos n *)\nsimpl in |- *; exact (pred_zerop n).  \n(* pos n *)\nsimpl in |-Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n0).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ n0).\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n0).\n(* pos n *)\nintros n H; try assumption.\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_antisymmetric n0).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ n0).\n(* pos n *)\nintros n H; try assumption.\nsimpl in |- *; symmetry  in |- *; exact (pred_scmult n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_ZERO n0).\n(* pos n *)\nintros n H; try assumption.\nsimplQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim x.\nsimpl in |- *; rewrite pred_absolu_absolu.\nelim n0.\nsimpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite pred_predX_l; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_predX_r; simpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim y.\nintros; elim H.\nintros; elim H.\nintros; elim H.\nintros; elim H0.\nintros; elim H0.\nintros; elim H0.\nintros; elim H0.\nintros; elim H0.\nintros; elim H0.\nintros; elimQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 730,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\n intros; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros.\napply pred_powers_l.\nreflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nsimple induction x.\n simpl in |- *.\n reflexivity.\n intros; rewrite pred_ coqtop_eq_0; reflexivity.\n intros; rewrite pred_of_exp_eq0; reflexivity.\n intros; rewrite pred_of_exp_eq0; reflexivity.\n intros; rewrite pred_of_exp_eq0; reflexivity.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite pred_succZ; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\nintros; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\nintros; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors; trivial.\nintros; rewrite pred_ authors; trivial.\n(* pos n *)\nsimple destruct n.\nsimplQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros.\nelim x.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nsimpl in |- *; rewrite pred_succZ.\nsimpl in |- *; rewrite pred_ HCdC; trivial.\nintros; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x; simpl in |- *; trivial.\nintros; rewrite pred_ authors; trivial.\nintros; rewrite pred_ authors; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ caseEq_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_ authors_succ; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_dec_refl; reflexivity.\n(* shift n *)\nsimple destruct n.\nsimpl in |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* zero 0 *)\nsimple induction n.\n(* zero 0 *)\nsimple induction n.\n(* zero 0 *)\nsimple induction n.\n(* zero 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* zero 0 *)\nsimple induction n.\n(* zero 0 *)\nsimple induction n.\n(* zero 0 *)\nsimple induction n0.\n(* zero 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 0 *)\nsimple induction n0.\n(* cond 0 *)\nsimple induction n0.\n(* cond 0Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_succZ.\nrewrite pred_ authors; trivial.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; rewrite pred_prime_divisors.\nelim H;Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* zero 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\nsimpl in |- *; rewrite pred_pos_neg.\nintros; rewrite pred_pos_pos; trivial.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\n(* pos 0 *)\nsimple induction x.\nsimpl in |- *; rewrite pred_pos_pos.\nintros; rewrite pred_pos_pos.\napply pred_pos_pos_pos.\napply pred_pos_pos.\napply pred_pos_pos.\napply pred_pos.\napply pred_pos_pos.\napply pred_pos.\napply pred_pos_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.\napply pred_pos.Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite pred_ authors.\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_predZ n0).\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* loc n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimpl in |- *; rewrite pred_succZ; trivial.\n(* pos n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nsimple inductionQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_ Geometry.\nsimpl in |- *; rewrite pred_pos_pred_succ; simpl in |- *.\napply pred_pos_pred_succ_pred_pred.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_pos_pred_succ; simpl in |- *.\napply pred_pos_pred_succ_pred.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_pos_pred_succ; simpl in |- *.\napply pred_pos_pred_plus_pred; assumption.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_pos_pred_succ; simpl in |- *.\napply pred_pos_pred_succ_pred_nat.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_pos_pred_succ; simpl in |- *.\napply pred_pos_pred_succ_predQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_succ_pred_pos; trivial.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_ rightc n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_frac n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* zero 0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* one n *)\nintros; do 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* zero 0 *)\nintros; do 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_Vfold n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_predZ n0).Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_fibonacci n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_fibonacci n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_derivative n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_fibonacci n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_fibonacci n0).\nelim H; reflexivity.\n(* pos n *)\nintros; do 2 rewrite (tech_add_pos_fibonacci n0Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite pred_prime_POS; trivial.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n0 *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n0 *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0 *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 741,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; intros; trivial.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nsimpl in |- *; rewrite pred_predn; reflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\n(* (pos n) *)\nsimple induction n.\nreflexivity.\n (* (neg n) *)\nsimple induction n.\nreflexivity.\n (* (neg n) *)\nsimple induction n.\nreflexivity.\n (* (neg n) *)\nsimple induction n.\nreflexivity.\nsimpl in |- *; apply succ_pred_pred_pred_pred_pred_pred_pred.\n(* (pos n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\nreflexivity.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x; reflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimpl in |- *; apply succ_pred_pred_pos; assumption.\n(* (neg n) *)\nintros; simpl in |- *; apply succ_pred_pos; assumption.\n(* (pos n) *)\nsimple induction n.\n(* (neg n) *)\nsimpl in |- *; apply succ_pred_pos; assumption.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\n(* (pos n) *)\nreflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* (pos n) *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* (neg n) *)\nintros; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* (neg n) *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* (pos n) *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* (neg n) *)\nintros; rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* (neg n) *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* (neg n) *)\nintros; rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* (neg nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ") y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_fibonacci; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; reflexivity.\n(* pos n *)Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; rewrite tech_add_pos_fibonacci; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nsimpl in |- *; apply pred_pos_pos.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 4952,
                "proof_end_offset": 5141,
                "proof": "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\ncut (predZ OZ = neg 0); intros.\nelim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite H; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nrewrite (tech_add_pos_apart x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_succZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_fibonacci x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_things x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_predZ x); rewrite (add_comm (- x)).\nrewrite (tech_add_pos_succZ x); rewriteQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nProof.\nintros.\napply succ_pred_pred_pos_predZ.\nunfold lt in |- *; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\napply add_mIZ_Mptr; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nunfold succ in |- *; apply pred_succ_pred_predZ.\nunfold succ in |- *; apply pred_succ_pred_itself.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros; elim x.\nrewrite (tech_add_pos_predZ x); rewrite (add_comm x (neg 1)); reflexivity.\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintro.\nrewrite (pred_ **************************************************************)\nelim H; reflexivity.\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros; elim x.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros; elim x.\nreflexivity.\nintros; rewrite tech_add_pos_OZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\nintros.\nunfold succ in |- *; apply succ_pred_pred_pos with (n := 0); simpl in |- *.\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 5171,
                "proof_end_offset": 5905,
                "proof": "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold commutativity in |- *; intros; elim x.\nsimpl in |- *; symmetry in |- *; exact (add_OZ y).\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_IZ_succZ y).\nintros; rewrite (tech_add_pos_succZ n0 y).\nrewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros.\nelim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros; rewrite (tech_add_neg_predZ n0 y).\nrewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros.\nelim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_commutativity : commutativity Z addZ.\nconstructor.\nexact add_mID_succ.\nexact add_mID_succ.\nexact add_mID_succ.\nexact add_mID_succ.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nred in |- *.\nintro x; elim x; intros.\nrewrite H.\nrewrite H0; reflexivity.\napply neg_pred_pred_n with (pred (pred (pred (pred (pred x)))).\napply succ_pred_n_S.\napply pred_nat_n_element.\napply succ_pred_n_element.\nunfold pred, pred, pred, pred, pred in |- *; simpl in |- *; auto.\nintros; elim H0; reflexivity.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\ntrivial.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\napply Build_Setoid\n    with (R := Build_Setoid (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (fun x y => R) (funQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\napply opp_mCocard.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napply opp_inj.\napplyQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold ptrofs, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp.\nintros.\ncut (0 < pos 1); trivial.\ncut (0 < pos 1); trivial.\nassert (0 < pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (0 < pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 < pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (1 <= pos 1); trivial.\nassert (Qed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\nunfold pow, exp, exp, exp, exp, exp, exp, exp, exp, exp, exp in |- *.\nintros.\nrewrite (exp_sgn (/abs (/abs (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nunfold ZgG, Zcring, Zcring, Zcring, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow, Zpow in |- *.\nintros x H.\nrepeat rewrite (mul_comm (pos x)) (mult_comm (pos x))).\napply sym_eq; assumption.\nQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\nProof.\napply Build_Map with (A := Z) (B := zero) (B := one) (B := one) (c := zero) (c := zero).\napply Build_Map with (A := zero) (B := zero) (c := zero) (c := zero).\napply Build_Map with (A := zero) (B := zero) (c := zero) (c := zero) (c := zero).\napply Build_Map with (A := one) (c := zero) (c := zero).\napply Build_Map with (A := zero) (c := zero) (c := zero).\napply Build_Map with (A := one) (c := zero) (c := zero) (c := zero).\napply Build_Map with (A := zero) (c := zero) (c := zero).\napply Build_Map with (A := zero) (c := zero) (c := zero).\napply Build_Map with (A := zero) (c := zero) (c := zero).\napply Build_Map with (A := zero) (c := zero) (c := zero).\napply Build_Map with (AQed.",
                    "Theorem addZ_commutativity : commutativity Z addZ.\napply one_eq_add_pos.\napply one_eq_add_pos.\nrewrite one_succ_eq_mult_neg_rev.\nrewrite one_succ_eq_mult_neg_rev.\nrewrite one_succ_eq_mult_neg_rev.\nrewrite one_succ_eq_mult_neg_rev.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_neg.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_opp_pos.\nrewrite pos_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "intros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\n",
                "context_tokens": 710,
                "proof_start_offset": 5935,
                "proof_end_offset": 6461,
                "proof": "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nProof.\nsimple induction n2.\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (n1 = n2); auto with arith.\nelim H.\nrewrite (exp_succZ_l (pos n1) n2); reflexivity.\nreflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros; elim n2.\nsimpl in |- *; reflexivity.\nintros; rewrite H; rewrite (tech_add_pos_posZ n1 n2); reflexivity.\nintros; rewrite H; rewrite (tech_add_pos_posZ n1 n2); reflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros n1 n2; elim n2.\n(* pos n *)\nsimpl in |- *; apply succ_pred_pos_pos.\n(* pos n *)\nintros; rewrite (tech_add_pos_fibonacci n0 n1); rewrite (tech_add_pos_fibonacci n0 n1); reflexivity.\n(* pos n *)\nintros; rewrite (tech_add_pos_fibonacci n0 n1); rewrite (tech_add_pos_fibonacci n0 n1); reflexivity.\n(* pos n *)\nsimpl in |- *; apply pred_nat_pos.\n(* pos n *)\nintros; rewrite (tech_add_pos_fibonacci n0 n1); rewrite (tech_add_pos_fibonacci n0 n1); reflexivity.\n(* pos n *)\nsimpl in |- *; apply pred_nat_pos.\n(* pos n *)\nsimpl in |- *; apply pred_nat_pos.\n(* pos n *)\nintros; rewrite (tech_add_pos_fibonacci n0 n1); rewrite (tech_add_pos_fibonacci n0 n1); reflexivity.\n(* pos n *)\nsimpl in |- *; apply pred_nat_pos.\n(* pos n *)\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nrewrite (tech_add_pos_posZ n1 n2); reflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros; rewrite (tech_add_pos_posZ n1 n2).\nelim (mult_fact_neq_0_posZ n1 n2); simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nsimple induction n1; intros.\nrewrite (tech_add_pos_posZ n1 n2); reflexivity.\nreflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite H; reflexivity.\nsimpl in |- *; rewrite HQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\ncut (pos (S n1) = pos (S n2)); intros.\nelim H.\nrewrite (tech_add_pos_fibonacci n1 n2); reflexivity.\nreflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\nunfold Zquotient in |- *; simpl in |- *.\nrewrite (pred_Peano_rec n1 n2).\nrewrite (pred_Peano_rec n1 n2); reflexivity.\nreflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros.\napply tech_add_pos_pos_posZ.\napply H.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_add_pos_neg_posZ : forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\nintros; rewrite (tech_add_pos_posZ (pos n1) n2 H); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "reflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\nLemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\n\nintros.\ncut (succZ OZ = IZ); intros. elim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*****************)\nLemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.\n\nintros.\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\n",
                "context_tokens": 748,
                "proof_start_offset": 6491,
                "proof_end_offset": 7092,
                "proof": "Theorem addZ_associativity : associativity Z addZ.\nProof.\nunfold associativity in |- *; intros; elim x.\nunfold addZ in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *; exact (succ_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (pred_addZ_l y z).\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Ctypes, ZPrime in |- *; intros.\nelim x.\nunfold ZPrime in |- *; auto with arith.\nintros n1; elim minus_n_O; trivial.\nintros n2; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elim minus_n_O; trivial.\nintros n3; elimQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold 18, Zurals in |- *; intros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nintros; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold [\\/, one, one, one, one, one, one, one, one, one, one, one, one) *)\nintros; elim x.\n(* pos n *)\nintros.\nrewrite <- (inv_0_l (S n)) at 1.\nrewrite <- (inv_1_l (S n) (neg n)).\nrewrite <- (inv_0_l (S n) (neg n)).\nrewrite H; auto with arith.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold 11, Z at 2 in |- *; auto with arith.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold ZPrime in |- *; intros; elim x; intros.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (add_mparties (pos n)).\n(* pos n *)\nsimpl in |- *; apply le_antisym.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelimQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Zurals in |- *; intros.\napply sym_equal; apply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napply eq_add_S.\napplyQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Zurals in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nintros; elim minus_n_O.\nrewrite H; rewrite H0; reflexivity.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; exact (mult_comm n1 n2).\n(* pos n *)\nsimpl in |- *; exact (mult_Qed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold HHH, Zggcd in |- *; intros; elim x.\nsimpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_P.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_succ_P.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nintros; simpl in |- *; apply Z_of_P.\nintros; simpl in |- *; apply Z_of_succ_morphism.\nintros; simpl in |- *; apply Z_of_nat_of_P.\nQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold Nnat in |- *; intros.\nelim (le_or_lt 0 n1).\nintros; rewrite H; rewrite H; auto with arith.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O.\napply le_antisym; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivial.\nelim minus_n_O; trivialQed.",
                    "Theorem addZ_associativity : associativity Z addZ.\nunfold ZPrime, ZPrime, ZPrime, ZPrime.\nsimple induction 1; intros; auto with arith.\nintros; elim (diag_pred_posZ (S n)) with (S n); auto with arith.\nrewrite H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": ".\ncut (predZ OZ = neg 0); intros. elim H.\nrewrite (pred_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nTheorem addZ_commutativity : commutativity Z addZ.\n\nunfold commutativity in |- *; intros; elim x.\n(* OZ *)\nsimpl in |- *; symmetry  in |- *; exact (add_OZ y).\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\n",
                "context_tokens": 745,
                "proof_start_offset": 7164,
                "proof_end_offset": 7330,
                "proof": "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nProof.\nunfold neutral in |- *; intros.\nsplit.\nexact I.\nintros.\nsplit.\nexact (add_OZ x).\nunfold addZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ.\nintros; unfold ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ.\nintros; simpl in |- *; rewrite <- ZoddZ_succ; simpl in |- *;\n rewrite <- ZoddZ_succ; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZevenZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simpl in |- *;\n rewrite <- ZoddZ_pred; simplQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z at 2 in |- *; unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 1 in |- *; unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; simpl in |- *;\n unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; simpl in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *; simpl in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; unfold Z at 3 in |- *;\n unfold Z at 2 in |- *; simpl in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *; unfold Z at 2 in |- *; \n unfold Z at 2 in |- *;\n unfold Z at 3 in |- *;\n unfold Z at 2 in |- *; repeat rewrite Zplus_0_r;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |- *;\n unfold Z at 2 in |-Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ.\n\n(*************************************************)\nDefinition ZoddZ (x : Z) :=\n  match x with\n  | Z0 => 1\n  | Zpos p => Zpos (Zpos p)\n  | Zneg p => Zneg (Zpos p)\n  end.\n\nDefinition ZoddZ (x : Z) :=\n  match x with\n  | Z0 => 1\n  | Zpos p => Zpos (Zpos p)\n  | Zneg p => Zneg (Zpos p)\n  end.\n\nDefinition ZoddZ (x : Z) :=\n  match x with\n  | Z0 => 1\n  | Zpos p => Zneg (Zpos p)\n  | Zneg p => Zneg (Zpos p)\n  end.\n\nDefinition Zpos (x : Z) :=\n  match x with\n  | Zpos p => Zpos (Zpos p)\n  | Zneg p => Zpos (Zpos p)\n  | Zneg p => Zneg (Zpos p)\n  end.\n\nTheorem Zpos_P_mult_nat : forall x : Z, Zpos (P x) = Zpos (Zpos x).\nProofQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z at 2 in |- *; unfold Z at 2 in |- *; unfold Z at 2 in |- *; simpl in |- *;\n intros.\nrewrite ZL7.\nrewrite H0.\napply Z.le_refl.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold ZExpZ in |- *; simpl in |- *; intros; elim n;\n simpl in |- *; intros; elim n; intros; simpl in |- *;\n try assumption.\nintros; elim n.\nrewrite H0; rewrite H1; rewrite H2; auto with arith.\nintros; elim n; intros.\nrewrite H0; rewrite H1; rewrite H2; auto with arith.\nrewrite H1; rewrite H2; auto with arith.\n(* pos n *)\nsimpl in |- *; apply le_n_S; apply le_O_n.\nQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ.\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_PGR Z) (at level 30, n0) *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_PGR Z) (at level 30, n0) *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_PGR Z) (at level 30, n0) *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_PGR Z) (at level 30, n0) *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_PGR Z) (at level 30, n0) *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_PGR Z) (atQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ, ZoddZ.\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nintros; simpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nintros; simpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_l; assumption.\n(* pos n *)\nsimpl in |- *; apply Z.add_0_Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold Z in |- *; intros; elim H.\n(* pos (S y) *)\nsimpl in |- *; rewrite (pred_succZ (pos n0) (S n0)).\nunfold Z in |- *; rewrite (pred_succZ (pos n0) (pos n0)).\nrewrite H; auto with arith.\n(* pos (S y) *)\nsimpl in |- *; rewrite (pred_predZ (pos n0) (pos n0)).\n(* pos n *)\nsimpl in |- *; rewrite (pred_OZ (pos n0) (pos n0)).\nunfold Z in |- *; rewrite (pred_predZ (pos n0) (pos n0)).\nunfold Z in |- *; rewrite (pred_predZ (pos n0) (pos n0)).\nrewrite H; auto with arith.\n(* pos (S y) *)\nsimpl in |- *; rewrite (pred_succZ (pos n0) (pos n0)).\nunfold Z in |- *; rewrite (pred_predZ (pos n0) (pos n0)).\nunfold Z in |- *; rewrite (pred_ received (pos n0) (pos n0)).\nrewrite H; auto with arith.\n(* pos n *)\nsimplQed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\napply\n (Build_ring (R:=Z) (B:=Z) (c:=Z)\n    (Ap:=fun x : Z => x)).\nred in |- *; intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |-Qed.",
                    "Theorem addZ_neutral : neutral Z IdZ addZ OZ.\nunfold ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpZ, ZExpQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n(* pos (S y0) *)\nintros; rewrite (tech_add_pos_succZ n0 y). rewrite H.\ncut (succZ (pos n0) = pos (S n0)); intros. elim H0.\nrewrite (succ_addZ_r y (pos n0)); reflexivity.\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\n",
                "context_tokens": 734,
                "proof_start_offset": 7528,
                "proof_end_offset": 7725,
                "proof": "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nintros; reflexivity.\nsimple destruct n; intros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintro.\nrewrite opp_add_pos_pos.\nrewrite <-opp_opp.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewriteQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ,oppZQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros; unfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nsimple induction x; intros.\nrewrite (tech_add_neg_pos x).\nrewrite H.\nrewrite opp_oppK; trivial.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nunfold oppZ in |- *; intros.\nsplit.\nexact I.\nintros.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply symQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros.\nrewrite (tech_add_pos_succZ (pos x) (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_predZ (pos x) (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_succZ (pos x) (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_recombine (pos x) (absZ (absZ x))).\nrewrite (tech_add_pos_recombine (pos x) (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_predZ (pos x) (absZ (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_predZ (pos x) (absZ (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_NEG (pos x) (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_NEG (pos x) (absZ (absZ (absZ (absZ x)))).\nrewrite (tech_add_pos_fibonacci (pos x) (absZ (absZ (absQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros.\nrewrite <- (opp_diag_reverse x).\nrewrite opp_inv.\nrewrite opp_inv.\napply minus_diag_uniq; assumption.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros.\nunfold oppZ in |- *.\nrewrite <-opp_def; reflexivity.\nQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nProof.\nintros.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZQed.",
                    "Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\nintros; unfold oppZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* neg (S y0) *)\nintros; rewrite (tech_add_neg_predZ n0 y). rewrite H.\ncut (predZ (neg n0) = neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\n",
                "context_tokens": 733,
                "proof_start_offset": 7743,
                "proof_end_offset": 7940,
                "proof": "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nProof.\nsimple destruct x.\nreflexivity.\nsimple destruct n; intros; reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x; simpl in |- *; trivial.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nunfold oppZ in |- *; intros.\nrewrite (opp_involutive x).\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutive.\nrewrite opp_involutiveQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros; unfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros.\nrewrite (opp_involutive (absZ x)).\nrewrite opp_involutive; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x; trivial.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros.\nunfold oppZ in |- *.\nrewrite opp_multKr, opp_oppK, opp_oppK, opp_oppK, opp_oppK, opp_oppK.\nrewrite opp_addK, opp_oppK, opp_oppK, opp_oppK.\nrewrite opp_addK; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x; reflexivity. \nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nsimple destruct x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\nintros; unfold oppZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " neg (S n0)); intros. elim H0.\nrewrite (pred_addZ_r y (neg n0)); reflexivity.\nreflexivity.\nQed.\n\n(*************************)\nLemma tech_add_pos_neg_posZ :\n forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 7966,
                "proof_end_offset": 8159,
                "proof": "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintro; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros.\nunfold oppZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nintros; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; intros; reflexivity.\nQed.",
                    "Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\nsimple destruct n; simpl in |- *; trivial.\nintros.\nunfold oppZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " pos (n1 - S n2).\n\nsimple induction n2.\n(* O *)\nintros; elim (addZ_commutativity (neg 0) (pos n1)).\nrewrite addZ_eq4.\nelim minus_n_Sm; trivial.\nelim minus_n_O.\napply tech_pred_posZ; trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\n",
                "context_tokens": 730,
                "proof_start_offset": 8185,
                "proof_end_offset": 8340,
                "proof": "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nProof.\nintros; elim (addZ_commutativity (pos n) (neg n)); exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n; trivial.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n; simpl in |- *; auto with arith.\nintros; rewrite (tech_add_neg_posZ n0).\nelim succ_predZ_r; reflexivity.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* O *)\nintros; rewrite (tech_add_neg_posZ n) at 2.\nelim succ_addrstack_r; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_pos_posZ n) at 2.\nelim succ_ semSem_r; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_posZ n) at 2.\nelim succ_ **************************************************************)\n(* n *)\nintros; rewrite (tech_add_pos_posZ n) at 2.\nelim succ_ semSem_r; reflexivity.\n(* n *)\nintros; simpl; rewrite (tech_add_pos_posZ n) at 2.\nelim pred_pos_pos; reflexivity.\n(* n *)\nintros; simpl; rewrite (tech_add_pos_posZ n) at 2.\nelim pred_pos_pos; reflexivity.\n(* n *)\nintros; simpl; rewrite (tech_add_pos_posZ n) at 2.\nelim pred_pos_pos; reflexivity.\n(* n *)\nintros; simpl; rewrite (tech_add_pos_posZ n) atQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* 0 *)\nintros; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n).\nelim succ_predZ_l; reflexivity.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n0).\nelim succ_predZ_l; reflexivity.\n(* n *)\nintros; rewrite (tech_add_neg_posZ n0).\nelim succ_predZ_r; reflexivity.\n(* n *)\nintros; rewrite (tech_add_pos_negZ n0).\nelim succ_predZ_l; reflexivity.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n0).\nelim pred_addZ_r; reflexivity.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n0).\nelim succ_ semSem_r; reflexivity.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n0).\nelim pred_Rlength_l; reflexivity.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n0).\nelim pred_Rlength_l; reflexivity.\n(* n *)\nintros; rewrite (tech_addQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* n *)\nsimple induction n.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nintros; simpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)\nsimpl in |- *; reflexivity.\n(* n *)Qed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nsimple induction n.\n(* n *)\nintros; rewrite (tech_add_pos_posZ n).\nelim succ_ **************************************************************)\nintros.\napply add_pos_pos_pos.\nrewrite (tech_add_pos_pos_posZ n).\nelim succ_ **************************************************************)\nintros; rewrite (tech_add_pos_pos_posZ n).\nelim succ_ **************************************************************)\nintros; rewrite (tech_add_pos_pos_posZ n).\nelim exp_ **************************************************************)\nintros; rewrite (tech_add_pos_pos_posZ n).\nelim exp_is_exp.\nintros; rewrite (tech_add_pos_posZ n).\nelim exp_is_exp.\nintros; rewrite (tech_add_pos_posZ n).\nelim exp_is_exp.\nintros; rewrite (tech_add_pos_posZ n).\nelim exp_is_exp.\nintros; rewrite (tech_add_pos_posZ n).\nelim exp_is_exp.\nintros; rewrite (tech_add_pos_posZ n).\nelim exp_is_exp.\nintros; rewrite (tech_add_posQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nintros; rewrite (tech_add_pos_posZ n).\nelim succ_succZ_r; exact H.\nQed.",
                    "Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\nintro; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " trivial.\n(* S y *)\nintros; elim (addZ_commutativity (neg (S n)) (pos n1)).\nrewrite tech_add_neg_predZ.\nelim (addZ_commutativity (pos n1) (neg n)).\nrewrite H; auto with arith.\nelim (minus_n_Sm n1 (S n) H0).\napply tech_pred_posZ.\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8366,
                "proof_end_offset": 8577,
                "proof": "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nProof.\nintros; elim n.\nreflexivity.\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nsimple induction n.\n(* n m *)\nintros; rewrite (tech_add_pos_negZ n m); reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros n; rewrite (tech_add_neg_posZ n m); reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros n m; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros n m; rewrite (tech_add_pos_negZ n m); reflexivity.\n(* n m *)\nintros n m; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros n m; rewrite (tech_add_pos_posZ n m); reflexivity.\n(* n m *)\nintros n m; rewriteQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (apart_comm (pos n) (pos m));\n unfold pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S, pos_S;\n simpl in |- *; intros; discriminate.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (apart_commutativity (pos n) (neg m)).\nreflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_negZ (pos n) (pos m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_negZ (pos n) (pos m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_negZ (pos n) (neg m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_posZ (pos n) (pos m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_posZ (pos n) (pos m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_posZ (pos n) (pos m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_posZ (pos n) (pos m)); reflexivity.\n(* n = 0 *)\nintros; rewrite (tech_add_pos_posZ (pos n) (pos m)); reflexivity.\n(* n = 0Qed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (peano_ind _ (pos m));\n intros; unfold succ in |- *; rewrite <- succ_pred_pos_pos; reflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n;\n [ intros; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity\n | intros; simpl in |- *; reflexivity ].\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nsimple induction n.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivityQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (Zminus_assoc (pos n) (neg m));\n rewrite (tech_add_pos_negZ n m); reflexivity.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (Aeq_dec (pos n) (pos m));\n case (sumbool_of_bool (is_true (pos m))) with\n  (fun n : nat =>\n   match m with\n   | O => 0\n   | S m' => pos m'\n   end).\nintros; elim (Zlt_irrefl m); auto.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim (Peano_dec n m); simpl in |- *; trivial.\nQed.",
                    "Lemma tech_add_pos_posZ : forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\nintros; elim (addZ_comm (pos n) (neg m));\n exact (tech_add_neg_posZ n m).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\napply lt_minus2; trivial.\nQed.\n\n(*************************)\nTheorem addZ_associativity : associativity Z addZ.\n\nunfold associativity in |- *; intros; elim x.\n(* OZ *)\nunfold addZ in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\n",
                "context_tokens": 723,
                "proof_start_offset": 8603,
                "proof_end_offset": 8818,
                "proof": "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nsimple induction n.\nreflexivity.\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nintros; elim n.\n(* O *)\nreflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (neg m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewriteQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* n m *)\nintros; rewrite (tech_add_pos_ZnegZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* n m *)\nintros; rewrite (tech_add_pos_predZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_frac n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_predZ n m); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* n m *)\nintros; rewrite (tech_add_pos_fibonacci n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_fibonacci n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_ rightc n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_fibonacci m n); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* S n m *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_negZ (pos m)); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_pos_negZ (pos n) (pos m)); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_neg_posZ (pos m)); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_pos_negZ (pos m)); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_posZ (pos m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nintros; elim n.\n(* n m *)\nintros; rewrite (tech_add_pos_pos_negZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_neg_pos_posZ n m); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nintros; elim n.\n(* n m *)\nintros; rewrite (tech_add_pos_ Renamings n0 (pos m)); rewrite H; reflexivity.\n(* n m *)\nintros n H0; rewrite (tech_add_pos_fibonacci n0 n (pos m)); rewrite H; reflexivity.\n(* n m *)\nintros n H0; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_neg_fibonacci n0 (pos m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintro; elim n.\n(* m *)\nintros; rewrite (tech_add_pos_fibonacci n0 m); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_posZ (pos m)); rewrite H; reflexivity.\n(* S n *)\nintros; rewrite (tech_add_pos_negZ (pos m)); rewrite H; reflexivity.\nQed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nProof.\nintros; elim n.\n(* m *)\nintros; rewrite (tech_add_neg_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_negZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_negZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_neg_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)\nintros; rewrite (tech_add_pos_posZ m (pos m)); rewrite H; reflexivity.\n(* m *)Qed.",
                    "Lemma tech_add_neg_negZ : forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\nintros; elim n.\n(* n m *)\nintros; rewrite (tech_add_neg_posZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_neg_posZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_neg_posZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); rewrite H; reflexivity.\n(* n m *)\nintros; rewrite (tech_add_pos_posZ n m); rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " *)\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l y z).\n(* pos (S y0) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite (succ_addZ_l (addZ (pos n0) y) z); elim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (pred_addZ_l y z).\n(* neg (S n0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite (pred_addZ_l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\n",
                "context_tokens": 743,
                "proof_start_offset": 8843,
                "proof_end_offset": 9198,
                "proof": "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nProof.\nrepeat split; trivial.\ncase x.\nreflexivity.\nintros; exact (tech_add_pos_negZ n).\nintros; exact (tech_add_neg_posZ n).\ncase x.\nreflexivity.\nintros; exact (tech_add_neg_posZ n).\nintros; exact (tech_add_pos_negZ n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros.\nsplit.\nexact (add_multKr (pos m)).\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ.oppZ.\n\nTheorem opp_inv_l : forall n m : nat, n <> 0 -> 0 < m -> 0 < n -> 0 < m -> n = m.\nintros n m H' H'0; rewrite (tech_add_pos_posZ n m H');\n  rewrite (tech_add_pos_pos_posZ n m H');\n  rewrite (tech_add_pos_pos_posZ n m H');\n  rewrite (tech_add_pos_pos_posZ n m H');\n  rewrite (tech_add_pos_pos_posZ n m H');\n  rewrite (tech_add_pos_pos_pos_posZ n m H');\n  rewrite (tech_add_pos_pos_posZ n m H');\n  rewrite (tech_add_Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nsimple induction n.\n(* O *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.\n(* S n *)\nintros; simpl in |- *; reflexivity.Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros.\nelim (ZdividesP_oppZ (Zpos n0) (Zpos m)); intros.\nunfold sign_or_zero in |- *; intros.\nelim (Odd_oppZ (Zpos n0) (Zpos m0)); intros.\nunfold sign_or_zero in |- *; intros.\nelim (Odd_oppZ (Zpos n0) (Zpos m0)); intros.\nelim (Odd_oppZ (Zpos n0) (Zpos m0)); intros.\nrewrite H; rewrite H0; rewrite H0; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_predZ n0 (pos m0)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (pos m0)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m0) (pos m0)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m0) (pos m0)); rewrite H; reflexivity.\n(* S n0 *)Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *; simpl in |- *.\nunfold oppZ in |- *; simpl in |- *.\nrewrite <- (mult_assoc (pos n) (pos m)).\nrewrite mult_comm; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)).\nrewrite (tech_add_neg_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_NEG n0 (pos m)).\nrewrite (tech_add_pos_fibonacci n0 (pos m)).\nrewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_fibonacci n0 (pos m)); rewrite H; reflexivity.\n(* S n0 *)Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros; rewrite H; rewrite H; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros.\nsplit; intros.\nelim (op_opp_posZ n0); intros; try assumption.\nelim (op_opp_posZ n0); intros; try assumption.\nelim (op_opp_posZ n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0); intros; try assumption.\nelim (op_opp_pos_Z n0);Qed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nunfold oppZ in |- *; intros; simpl in |- *.\nrewrite <- (opp_involutive n); rewrite opp_oppK; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros; elim H.\n(* n *)\nintros; simpl in |- *; rewrite H; rewrite H0; rewrite H0; reflexivity.\n(* n *)\nintros; simpl in |- *; rewrite H; rewrite H0; rewrite H0; reflexivity.\n(* n *)\nintros; simpl in |- *; rewrite H; rewrite H0; rewrite H0; reflexivity.\n(* n *)\nintros; simpl in |- *; rewrite H; rewrite H0; rewrite H0; reflexivity.\nQed.",
                    "Theorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\nred in |- *; intros.\nsplit; intros; apply (opp_involutive (n0 + m)); apply sym_equal; assumption.\n(* O *)\nintros; rewrite (tech_add_neg_fibonacci n0 (pos m)); rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "l (addZ (neg n0) y) z); elim H; reflexivity.\nQed.\n\n(************)\nDefinition IdZ (x : Z) := True.\n\n(*******************)\nTheorem addZ_neutral : neutral Z IdZ addZ OZ.\n\nunfold neutral in |- *; intros.\nsplit. exact I.\nintros. split. exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\n",
                "context_tokens": 741,
                "proof_start_offset": 9217,
                "proof_end_offset": 9379,
                "proof": "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nexact addZ_associativity.\nsplit.\nexact addZ_neutral.\nexact addZ_opposite.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\napply Build_Z_prop; intros; apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_nat_pos;\n apply Z_group_natQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_power).\nrepeat split; simpl; auto with zarith.\nintros n; rewrite Z_group_nat_succ; rewrite Z_group_nat_S; simpl; ring.\nintros n H; rewrite Z_group_nat_S; simpl; ring.\nintros n H; rewrite Z_group_nat_S; simpl; ring.\nintros n H; rewrite Z_group_nat_S; simpl; ring.\nintros n H; rewrite Z_group_nat_S; simpl; ring.\nintros n H; rewrite Z_group_nat_S; simpl; ring.\nintros m H; rewrite Z_power_nat_S; simpl; ring.\nintros n H; rewrite Z_power_nat_S; simpl; ring.\nintros m H; rewrite Z_power_nat_S; simpl; ring.\nintros n H; rewriteQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_power, Z_power, Z_power, Z_power, Z_power, Z_power, Z_power, Z_power, Z_power, Z_power).\ncase x.\nintros; rewrite <- (Zmult_assoc (Zpos x) (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos x) (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos x) (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos (pos m)));\n rewrite (Zmult_assoc (Zpos (pos m)));\n rewrite (Zmult_comm (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos (pos m)));\n rewrite (Zmult_assoc (Zpos m))); rewrite (Zmult_comm (Zpos (pos m)));\n rewrite (Zmult_assoc (Zpos (pos m)));\n rewrite <- (Zmult_assoc (Zpos (pos m)));\n rewrite (Zmult_assoc (Zpos m)); rewriteQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat;\n\n repeat rewrite ZL9; unfold Z_of_succ;\n repeat rewrite ZL9;\n repeat rewrite ZL9;\n repeat rewrite ZL9;\n repeat rewrite ZL9;\n repeatQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group, group.\n\n(** Proves that 1 is the only number is the number of number *)\nDefinition Z_of_nat (x : Z) := 1.\n\nDefinition Z_of_nat (x : Z) := 1.\n\nDefinition Z_of_nat (x : Z) := 1.\n\nDefinition Z_of_nat (x : Z) := 1.\n\nNotation Z_of_nat := Z_of_nat (only parsing).\n\nDefinition Z_of_nat (x : Z) := S (Z_of_nat (S x)).\n\nDefinition Z_of_nat (x : Z) := S (Z_of_nat (S x)).\n\nNotation Z_of_nat := Z_of_nat (only parsing).\n\nDefinition Z_of_nat (x : Z) := S (Z_of_nat x).\n\nDefinition Z_of_nat (x : Z) := x.\n\nDefinition ZQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\napply Z_group.\napply Z_group.\napply Z_group_nat_fun_pos.\n(* S n *)\nintros n H'; exact (tech_opp_posZ n).\n(* n m *)\nintros n H'; exact (tech_opp_posZ n).\n(* n m *)\nintros n H'; exact (tech_opp_posZ n).\n(* n m *)\nintros n m H'; exact (tech_opp_posZ n).\n(* n m *)\nintros n m H'; exact (tech_opp_posZ n m).\n(* n m H'; exact (tech_opp_posZ n m).\n(* n m *)\nintros m H'; exact (tech_opp_posZ n m).\n(* n m H'; exact (tech_opp_posZ n m).\n(* n m *)\nintros n m H'; exact (tech_opp_posZ n m).\n(* n m *)\nintros m H'; exact (tech_opp_posZ n m).\n(* n m *)\nintros n m H'; exact (tech_opp_posZ n m).\n(* n m *)\nintros m HQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group at 1 in |- *; simpl in |- *.\nintros; apply Z_group.\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_group in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfold Z_power_nat in |- *; simpl in |- *.\nunfoldQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_group, Z_power).\nintros n; case n.\nintros; exact (Z_group_nat_pos n).\nintros; exact (Z_group_nat_neg n).\nintros; exact (Z_group_nat_neg n).\nintros; exact (Z_group_nat_neg n).\nintros; exact (Z_group_nat_neg n).\nintros; exact (Z_group_nat_neg n).\nintros; exact (Z_group_nat_neg n).\nQed.",
                    "Theorem Z_group : is_group Z IdZ addZ OZ oppZ.\nunfold Z.pow at 1.\nunfold Z.pow at 1.\nunfold Z.pow at 1.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 1.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 1.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 1.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 1.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.pow_pos_correct; reflexivity.\nunfold Z.pow at 2.\nrewrite Z.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " exact (add_OZ x). unfold addZ in |- *; reflexivity.\nQed.\n\n(*************)\nDefinition oppZ (x : Z) :=\n  match x return Z with\n  | OZ =>\n      (* OZ *)  OZ\n      (* pos n *) \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\n",
                "context_tokens": 725,
                "proof_start_offset": 9404,
                "proof_end_offset": 9518,
                "proof": "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nProof.\nsimple destruct x; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; rewrite <- neg_eq_opp_pos; rewrite neg_eq_opp_pos; reflexivity.\nintros x; case x.\nsimpl in |- *; intros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; unfold zero in |- *; rewrite opp_def; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; unfold absZ in |- *; simpl in |- *.\nrewrite (tech_add_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_pos_posZ (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_pos_posZ (Zpos x) (Zpos x) (Zpos x));\n rewrite (tech_add_pos_pos_pos_posZ (Zpos x) (Zpos x)); \n rewrite (tech_add_pos_pos_pos_negZ (Zpos x) (Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; case x; trivial.\nintros; exact (tech_opp_Z x).\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; unfold oppZ in |- *; rewrite oppZ_eq_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_opp_oppQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_pos_posZ n).\n(* pos n *)\nintros; exact (tech_opp_pos_posZ n).\n(* pos n *)\nintros; exact (tech_opp_pos_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_negZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros x; case x.\n(* pos n *)\nintros; exact (tech_add_pos_posZ n).\nintros; exact (tech_add_pos_posZ n).\nintros; exact (tech_add_pos_posZ n).\n(* pos n *)\nintros; exact (tech_add_pos_posZ n).\n(* pos n *)\nintros; exact (tech_add_pos_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_posZ n).\n(* pos n *)\nintros; exact (tech_opp_negQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_pos_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_pos_negZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_neg_posZ n) in H; assumption.\n(* pos n *)\nintros.\nrewrite (tech_add_Qed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; unfold zero in |- *.\nrewrite opp_multKr; rewrite opp_multKr; reflexivity.\nQed.",
                    "Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\nintros; elim x.\nrewrite (tech_add_pos_negZ x); reflexivity.\nintros; exact (tech_opp_posZ x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " \n  | pos n => neg n\n      (* neg n *) \n  | neg n => pos n\n  end.\n\n(*************)\nLemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; reflexivity.\n(* neg n *)\nsimple destruct n; intros; reflexivity. \nQed.\n\n(*************)\nLemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n; intros; reflexivity. \n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S y *)\nintros; rewrite (tech_add_pos_succZ n0).\nelim succ_addZ_r; exact H.\nQed.\n\n(*********************)\nLemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.\n\nintros; elim (addZ_commutativity (pos n) (neg n));\n exact (tech_add_pos_negZ n).\nQed.\n\n(*********************)\nLemma tech_add_pos_posZ :\n forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).\n\nintros; elim n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_pos_succZ n0 (pos m)); rewrite H; reflexivity.\nQed.\n\n(*********************)\nLemma tech_add_neg_negZ :\n forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).\n\nsimple induction n.\n(* O *)\nreflexivity.\n(* S n0 *)\nintros; rewrite (tech_add_neg_predZ n0 (neg m)); rewrite H; reflexivity.\nQed.\n\n(********************)\nTheorem addZ_opposite : opposite Z IdZ addZ OZ oppZ.\n\nrepeat split; trivial.\n(* -> *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_pos_negZ n).\n(* neg n *)\nintros; exact (tech_add_neg_posZ n).\n(* <- *)\ncase x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nintros; exact (tech_add_neg_posZ n).\n(* neg n *)\nintros; exact (tech_add_pos_negZ n).\nQed.\n\n(**************)\nTheorem Z_group : is_group Z IdZ addZ OZ oppZ.\n\nsplit.\nred in |- *; trivial.\nsplit. exact addZ_associativity.\nsplit. exact addZ_neutral.\nexact addZ_opposite.\nQed.\n\n(********************)\nTheorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.\n\nsimple destruct x; auto with arith.\nQed.\n\n(*********************)\n",
                "context_tokens": 722,
                "proof_start_offset": 9544,
                "proof_end_offset": 9675,
                "proof": "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nsimple induction n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n.\nintros; rewrite opp_multKr; rewrite opp_oppK; reflexivity.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nsimple destruct n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros n; elim n.\nunfold oppZ in |- *; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; auto with arith.\nintros; rewrite opp_oppK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_addK; rewrite opp_addK;\n rewrite opp_addK; rewrite opp_Qed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nProof.\nintro n; case n.\nsimpl in |- *; auto with arith.\nintros; apply opp_involutive; rewrite opp_involutive; rewrite opp_involutive; auto.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros n; elim n; auto with arith.\nintros; rewrite <- (tech_opp_pos_posZ n).\nrewrite <- (opp_involutive Z).\nrewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; auto with zarith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_opp_pos_negZ : forall n : nat, oppZ (pos n) = neg n /\\ oppZ (neg n) = pos n.\nintros; elim n; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\n",
                "context_tokens": 316,
                "proof_start_offset": 1992,
                "proof_end_offset": 2126,
                "proof": "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nProof.\nintros; symmetry in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold eq in |- *; intros; elim H; auto with arith.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold eq in |- *; intros.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; intro; apply H0.\napply (H (I E)).\nred in |- *; red in |- *; introQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nunfold app, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add,Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add.\n\nAdd Add := Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add Add AddQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nelim H.\nelim H0; auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nelim H; auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nelim H; intros H'0 H'1; elim H'0; auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nelim H.\nelim H0.\nelim H1.\nelim H2.\nelim H2.\nelim H3.\nelim H3.\nelim H3.\nelim H4.\nelim H4.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H7.\nelim H6.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7Qed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintro H'; elim H'.\nintros x0 y z H' H'0; rewrite H'0.\nrewrite <- (plus_comm x0 y).\napply plus_comm.\napply H'1.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nunfold eq in |- *.\nintros H' x y H' H'0; rewrite H'0; auto with sets.\nQed.",
                    "Lemma neutral_add : neutral S G Add O -> O = Add O O.\nintros.\nelim H; auto with sets.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Lci.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Lci.v                                   *)\n(****************************************************************************)\n\n(* Proprie'te's des lois de composition interne *)\n\n(*****************************************************************************)\nSection Internal.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O I : S.\nVariable Opp Inv : S -> S.\n(*****************************************************************************)\n\n(***************)\nDefinition intern := forall x y : S, G x -> G y -> G (Add x y).\n\n(**********************)\nDefinition commutativity := forall x y : S, Add x y = Add y x.\n\n(**********************)\nDefinition associativity :=\n  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.\n\n(****************)\nDefinition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) \n  (O : S) := G O /\\ (forall x : S, G x -> Add x O = x /\\ Add O x = x).\n\n(****************)\nLemma neutral_add : neutral S G Add O -> O = Add O O.\n\nProof.\nintros; symmetry  in |- *.\nelim H; intros; elim (H1 O H0); trivial.\nQed.\n\n(********************)\nDefinition is_opposite (x y : S) := G x /\\ G y /\\ Add x y = O /\\ Add y x = O.\n\n(************)\n",
                "context_tokens": 403,
                "proof_start_offset": 2245,
                "proof_end_offset": 2466,
                "proof": "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros.\nunfold is_opposite in |- *.\nsplit.\nexact H0.\nsplit.\nexact H1.\nsplit.\nexact H2.\nelim (H x y).\nexact H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H0 H1 H2; apply H1; auto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nsimple induction 1; intros.\nsplit; trivial.\nsplit; trivial.\nintro; elim H0; intros.\napply H1.\napply H2.\napply H1.\napply H3.\napply H2.\napply H2.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H4.\napply H4.\napply H4.\napply H2.\napply H4.\napply H2.\napply H4.\napply H1.\napply H4.\napply H3.\napply H2.\napply H4.\napply H4.\napply H3.\napply H4.\napply H4.\napply H2.\napply H2.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H2.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6;\n   elim H5; intros H6 H7; clear H7 H8 H9 H10;\n   rewrite (opp_def x y H5 H6 H7) in H6; rewrite (opp_def x y H7) in H6;\n   rewrite (opp_def x y H5) in H6; rewrite (opp_def x y H5) in H6;\n   rewrite (opp_def x y H5) in H6; rewrite (opp_def x y H5) in H6;\n   rewrite (opp_def x y H5) in H6; rewrite (opp_def x y H5) in H6;\n   rewrite (opp_def x y H5) in H6; rewrite (opp_def x y H5) in H6;\n   rewrite (opp_def x y H5) in H6;\n   rewrite (opp_def x y H5) in H6; rewrite (opp_def x y H5) in H6;\n   rewrite (opp_def x y H5) inQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nintros x y H'; elim H'; intros H'1 H'2; try exact H'2;\n try exact H'2; clear H'2.\nunfold not in |- *; intros H'0 H'1; elim H'1; intros H'2 H'3; try exact H'3; clear H'1.\nunfold not in |- *; intros H'0 H'1; elim H'1; intros H'3 H'4; try exact H'4; clear H'1.\nunfold not in |- *; intros H'1 H'2; elim H'2; intros H'4 H'5; try exact H'4; clear H'2.\nunfold not in |- *; intros H'1 H'2; elim H'1; intros H'3 H'4; try exact H'4; clear H'2.\nunfold not in |- *; intros H'1 H'2; elim H'2; intros H'3 H'4; try exact H'4; clear H'2.\nunfold not in |- *; intros H'1 H'2; elim H'1; intros H'3 H'4; try exact H'Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nsimple induction 1.\nintros; rewrite H1; rewrite H2; auto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H'; elim H'; intros H'0 H'1; elim H'1;\n [ intros H'2; elim H'2; intros H'3 H'4; clear H'2 | idtac ]; \n auto.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H0; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros H' H'0; split; intro H'1; elim H'1; intros; elim H'1; intros; clear H'1;\n elim H'1; intros; clear H'1; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_part; auto.\napply opp_Qed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H'; elim H'; intros H'0 H'1; elim H'1; trivial.\nQed.",
                    "Lemma opp_com : commutativity -> forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.\nProof.\nintros x y H'; elim H'; intros H'0; elim H'0;\n clear H'0; intros H'1; elim H'0;\n clear H'0; intros H'2; elim H'2;\n clear H'2; intros H'3; elim H'3;\n clear H'3; intros H'3; elim H'3;\n clear H'3; intros H'4; elim H'4;\n clear H'4; intros H'5 H'6; elim H'5;\n clear H'5; intros H'6 H'7; elim H'6;\n clear H'5; intros H'6 H'7; elim H'7;\n clear H'5; intros H'6 H'7; elim H'7;\n clear H'5; intros H'8 H'9; elim H'9;\n clear H'5; intros H'6 H'7; elim H'7;\n clear H'5; intros H'6 H'7; elim H'7;\n clear H'6; intros H'7 H'8; elim H'10;\n clearQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\n",
                "context_tokens": 227,
                "proof_start_offset": 1772,
                "proof_end_offset": 2677,
                "proof": "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nProof.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros.\nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14.\nsplit.\napply (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\napply (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'.\nelim H'; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros.\napply (mult_O_l (S x) (S x)).\napply H.\napply (mult_O_r (S x) (S x)).\napply (mult_O_r (S x) (S x)).\napply mult_reg_l with (A := x).\napply mult_reg_l with (A := S).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := S).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := S).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := S).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := A).\napply plus_reg_l with (A := S).\napply plus_reg_l with (A := A).\napply plus_reg_Qed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H; elim H; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H; elim H; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H; elim H; auto with sets.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'.\nelim H'; auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nsimple induction 1; intros; try assumption.\ninversion H1; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'.\napply (H' x); auto with arith.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H'; elim H'; auto.\nQed.",
                    "Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\nintros x H.\nunfold A in |- *.\nelim H.\nintros.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "              *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 rings.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export groups.\nRequire Export Compare_dec.\n\n(*****************************************************************************)\nSection ring.\n\nVariable S : Set.\nVariable A : S -> Prop.\nVariable Add Mult : S -> S -> S.\nVariable O I : S.\nVariable Opp : S -> S.\nVariable v : S -> nat.\n(*****************************************************************************)\n\n(****************)\nDefinition is_ring :=\n  commutativity S Add /\\\n  is_group S A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 576,
                "proof_start_offset": 2697,
                "proof_end_offset": 3436,
                "proof": "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros;\n elim H9; intros; elim H9; intros; elim H10; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H11; intros; elim H12; intros;\n elim H12; intros; elim H12; intros; elim H11; intros; elim H12; intros; \n elim H13; introsQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros x y H.\nrewrite <- (mult_comm x y).\nrewrite mult_opp_l; rewrite <- mult_opp_l; rewrite mult_comm;\n rewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite mult_opp_r; rewrite mult_comm; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H2;\n intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H3; intros; elim H3; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; elim H10; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H9Qed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n rewrite H8; rewrite H8; rewrite H9; rewrite H9; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nrewrite mult_opp_r.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_opp_opp; rewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_opp_opp; rewrite mult_comm; reflexivity.\nQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; \n elim H11; intros; elim H10; intros; elim H11; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H13; intros; elim H13; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim HQed.",
                    "Lemma mult_opp_r : is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " A Add O Opp /\\\n  intern S A Mult /\\ associativity S Mult /\\ distributivity S Add Mult.\n\n(***********)\nLemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\\ Mult O x = O.\n\n\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros. \nelim H6; intros; elim H8; intros; elim H10; intros; elim H13; intros.\nclear H2 H4 H5 H6 H8 H9 H10 H11 H13 H14. \n(* H3: is_group, H7: intern Mult, H0: (A x), H15: (A O), H16: rest of neutral,\n   H12: distributivity *)\nsplit.\n(* x*0 = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult x O) O (H7 x O H0 H15) H15 \n    (Mult x O) (H7 x O H0 H15)).\nelim (H16 (Mult x O) (H7 x O H0 H15)); intros; rewrite H2.\nelim (H12 x O O); intros; elim H6.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\n(* 0*x = 0 *)\napply\n (regular_l S A Add O Opp H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\n",
                "context_tokens": 721,
                "proof_start_offset": 3456,
                "proof_end_offset": 4193,
                "proof": "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nexists x0; exists x1; exists y; auto.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n clear H1 H2 H3 H4; rewrite H2; rewrite H1; rewrite H2; ring.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4;\n clear H4 H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim (mult_n_O _ H6); intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nsplit.\n(* 1*x = 1 *)\napply\n (Build_Map (A:=A) (B:=A)\n    (B:=A)\n      (B:=A) (B:=A) (B:=A)\n      (B:=A) (B:=A) (B:=A)\n      (B':=A) (B':=A)\n        (B':=B') (C':=A) (C':=A)\n        (C':=A') (C':=B') (C':=A)\n        (D':=AQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; introsQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n clear H3 H4 H5; rewrite H1; auto.\nQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y). \n\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15.\nelim (mult_O_l x y); intros; elim H2; intros; elim H2; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n clear H6 H7 H8 H9 H10 H11 H12 H13 H14 H14 H15 H16.\nelim (mult_O_l x y); intros; elim H2; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H5 H6 H8 H9 H10 H11 H12 H14 H15 H16 H17 H18.\nelim (mult_Qed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elimQed.",
                    "Lemma mult_opp_l : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros; elim H3; intros;\n elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": " H3 (Mult O x) O (H7 O x H15 H0) H15 \n    (Mult O x) (H7 O x H15 H0)).\nelim (H16 (Mult O x) (H7 O x H15 H0)); intros; rewrite H2.\nelim (H12 O O x); intros; elim H5.\nelim (H16 O H15); intros; rewrite H8; reflexivity.\nQed.\n\n(***************)\nLemma mult_opp_r :\n is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 y H1); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult x (Opp y))).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 x (Opp y) H0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\n",
                "context_tokens": 720,
                "proof_start_offset": 4215,
                "proof_end_offset": 4702,
                "proof": "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10 H11 H12 H14 H15 H16 H17 H18 H19 H20 H19 H20 H21 H22 H23 H24 H26 H27 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H43 H44 H45 H45 H49 H48 H49).\nelim (mult_O H0 H1); intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H5; intros; elim H5;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H6; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; \n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H4; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H6; introsQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H2; intros; elim H2; intros;\n elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; elim H9; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; elim H11; intros; \n elim H11; intros; elim H12; intros; elim H11; intros; \n elim H11; intros; elim H11; intros; elim H12; intros; \n elim H12; intros; elim H12;Qed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros;\n elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim HQed.",
                    "Lemma mult_opp_opp : is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0 H18).\nelim (mult_O H x H0); intros; elim H2; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x y (Opp y)); intros; rewrite H0; clear H H0.\nelim (H13 x (Opp y) y); intros; rewrite H0; auto.\nQed.\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\n",
                "context_tokens": 742,
                "proof_start_offset": 5096,
                "proof_end_offset": 5330,
                "proof": "Theorem div_O_O : is_ring -> divide O O.\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit.\nexact H10.\nsplit.\nexact H10.\nleft; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_O_O : is_ring -> divide O O.\nsimple induction 1; intros H H0; try assumption.\nelim H0; intros; elim H0; intros; elim H0; intros; clear H0 H1; intros; elim H0; intros; clear H0 H1;\n elim H1; intros; elim H2; intros; clear H2 H3 H4; intros; elim H3; intros; clear H3 H4;\n elim H3; intros; clear H3 H4; intros; elim H4; intros; clear H4 H5;\n elim H5; intros; clear H5 H6; intros; elim H5; intros; clear H5 H6;\n elim H5; intros; clear H5 H6; intros; elim H5; intros; clear H5 H6;\n intros; clear H5 H6; intros; elim H6; intros; clear H5 H6;\n elim H5; intros; clear H5 H6; intros; clear H5 H6;\n elim H6; intros; clear H6; intros; elim H5; intros; clear H5 H6;\n elim H5; intros; clear H5 H6; intros; elim H6;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nsplit;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros H H'; elim H'; auto.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nProof.\nintro H; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H1 H2 H3;\n elim H3; intros; clear H3 H4 H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; clear H5 H6; intros; elim H6; intros; elim H6; intros; \n clear H5 H6; intros; elim H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6; intros; elim H6; intros; \n clear H6;Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_upper_bound in |- *.\nintros p q H H0; elim H; intros; elim H0; intros; elim H1; intros.\nunfold div in |- *.\nsplit; auto.\nred in |- *.\nintro; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.Qed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros H H0.\nelim H; intros; elim H0; intros; elim H1; intros; clear H1 H2 H0;\n elim H2; intros; elim H2; intros; clear H2 H3 H4; elim H4; intros; clear H4 H5 H6;\n elim H5; intros; clear H5 H6 H7; intros; elim H7; intros; clear H7 H8;\n elim H6; intros; clear H7 H8; intros; elim H7; intros; clear H7 H8;\n elim H8; intros; clear H7 H8; intros; elim H7; intros; clear H7 H8;\n elim H8; intros; clear H7 H8; intros; clear H8 H9;\n elim H9; intros; clear H9 H9; intros; elim H10; intros; clear H10 H11;\n elim H12; intros; clear H12 H13; intros; elim H12; intros; clear H12 H12;\n elim H12; intros; clear H12 H13 H14; intros; elim H12; intros; clear H13 H14;\n elimQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros H H0; elim H; intros; elim H0; intros; elim H0; intros;\n    elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros;\n    elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros;\n    clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19.\nexists x0; split; [ idtac | assumption ].\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nunfold is_upperable in |- *.\nintros a b H'; elim H'; intros; elim H'0; intros.\nelim H'0; intros.\nexists x; auto with arith.\nexists x; auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros.\nelim H; intros; auto with arith.\nelim H0; intros; auto with arith.\nelim H1; intros; auto with arith.\nelim H1; intros; auto with arith.\nelim H2; intros; auto with arith.\nelim H2; intros; auto with arith.\nelim H2; intros; auto with arith.\nelim H3; intros; auto with arith.\nelim H3; intros; auto with arith.\nelim H4; intros; auto with arith.\nelim H4; intros; auto with arith.\nelim H4; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nelim H5; intros; auto with arith.\nQed.",
                    "Theorem div_O_O : is_ring -> divide O O.\nintros H H0; elim H0; intros; elim H0; intros; auto.\nelim H1; intros; auto.\nelim H2; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H3; intros; auto.\nelim H4; intros; auto.\nelim H3; intros; auto.\nelim H4; intros; auto.\nelim H4; intros; auto.\nelim H4; intros; auto.\nelim H4; intros; auto.\nelim H4; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelim H5; intros; auto.\nelimQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": ".\n\n(***************)\nLemma mult_opp_l :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; elim H19; intros.\nclear H2 H3 H5 H6 H7 H9 H10 H11 H12 H14 H15 H16 H17 H19.\napply (opp_unicity S A Add O Opp H4 (Mult x y) (Mult (Opp x) y)).\nunfold is_opposite in |- *; split.\nexact (H8 x y H0 H1).\nsplit.\nexact (H8 (Opp x) y H18 H1).\nelim (mult_O H y H1); intros; elim H3; clear H H0 H1 H2 H3 H4 H8 H18.\npattern O at 1 in |- *; elim H20; elim H21; clear H20 H21.\nelim (H13 x (Opp x) y); intros; rewrite H; clear H H0.\nelim (H13 (Opp x) x y); intros; rewrite H; auto.\nQed.\n\n(*****************)\nLemma mult_opp_opp :\n is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.\n\n\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim (H15 x H0); intros.\nelim H17; intros; clear H2 H3 H5 H6 H7 H9 H10 H11 H12 H13 H14 H15 H16 H17 H19.\nrewrite (mult_opp_r H (Opp x) y H18 H1).\nrewrite (mult_opp_l H x y H0 H1).\nsymmetry  in |- *.\nexact (opp_opp S A Add O Opp H4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 5349,
                "proof_end_offset": 6556,
                "proof": "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nProof.\nunfold divide in |- *; intros.\nsplit.\nelim H0; trivial.\nsplit.\nelim H; intros; elim H3; intros; elim H4; intros.\nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\nelim H4; intros.\nrewrite H.\nelim (H17 b H2); intros.\nrewrite H1.\nexact H5.\nelim H5; intros.\nrewrite H0.\nelim (H17 a H3); intros.\nrewrite H1.\nexact H4.\nclear H2 H3 H4 H5 H17.\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1.\nclear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7).\nelim (H13 d x x0); intros.\nclear H4 H6 H7 H13.\nrewrite H0.\nclear H H0.\nelim H5; elim H8; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0 H1; split; try assumption.\nintros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H12; intros; elim H12; intros; \n elim H11; intros; elim H12; intros; elim H10; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; introsQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\napply H.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_r; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nintros; apply div_mult_l; trivial.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros.\nelim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0 H1.\nelim H; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12;\n intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0 H1 H2; split.\napply div_mult_l; assumption.\napply div_sym; assumption.\napply div_sym; assumption.\napply div_sym; assumption.\nQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    clear H7 H8 H9 H10 H11 H11 H12 H13 H14 H15 H16 H17 H18 H18.\nelim H; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; elim H11; intros; elim H9; intros;\n    clear H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H20 H18 H20 H21 H22 H24 H26 H27 H29 H29 HQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H7; intros; elim H7; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H10; intros; elim H11; intros; elim H12; intros; elim H12; intros; \n elim H10; intros; elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; intros; elim H12; intros; \n elim H12; intros; elim H12; intros; elim H12; introsQed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nintros a b d H H0.\nrewrite H1.\nrewrite H1; apply H.\nintros; split; try assumption.\nelim H; intros; elim H1; intros; elim H2; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;Qed.",
                    "Theorem div_add : is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\nunfold div in |- *; intros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "4 (Mult x y) (H8 x y H0 H1)).\nQed.\n\n(******************)\nDefinition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.\n\n(************************************)\nDefinition is_unitary_commutative_ring :=\n  is_ring /\\ commutativity S Mult /\\ neutral S A Mult I.\n\n(* Division *)\n(***************)\nDefinition divide (a b : S) :=\n  A a /\\ A b /\\ (b = O \\/ a <> O /\\ (exists q : S, A q /\\ b = Mult a q)).\n\n(**************)\nTheorem div_O_O : is_ring -> divide O O.\n\n\nunfold divide in |- *; intros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H5; intros.\nelim H7; intros; elim H8; intros.\nsplit. exact H10.\nsplit. exact H10.\nleft; reflexivity.\nQed.\n\n(**************)\nTheorem div_add :\n is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).\n\n\nunfold divide in |- *; intros.\nsplit.\n(* A d *)\nelim H0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 727,
                "proof_start_offset": 6576,
                "proof_end_offset": 7261,
                "proof": "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros.\nsplit.\nexact H2.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit.\nexact (H6 a b H0 H1).\nclear H0 H3.\nelim H2; intros.\nrewrite H0.\nelim (mult_O H b H1); intros.\nrewrite H4.\nleft; reflexivity.\nclear H H2.\nright.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H.\nexists (Mult x b).\nelim H3; intros.\nsplit.\nexact (H6 x b H4 H1).\nrewrite (H8 d x b).\nelim H5; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros;\n clear H H4 H5 H6 H7 H8 H9 H11 H12 H13 H14 H15.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16 H17.\nelim H0; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n clear H H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim HQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0.\napply H.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; clear H5 H6.\nelim H5; intros; elim H5; intros; clear H5 H6.\nelim H5; intros; elim H5; intros; clear H5 H6.\nexists (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b (Div b)))))) y).\nsplit.\n(* A p b = 0 *)\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H5; intros; elim H5; introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nsimple induction 1; intros.\nleft; auto with arith.\nexists a; auto with arith.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; clear H5 H6.\nelim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; clear H5 H6.\nelim H6; intros; elim H5; intros; clear H5 H6.\nelim H6; intros; elim H6; intros; elim H6; intros; clear H6.\nexists (S x1).\nexists (S x1).\nexists (S x2).\nexists (S x2).\nexists (S x2).\nexists (S x1).\nexists (S x2).\nsplit.\napply (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (altQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H1; intros; clear H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H; intros; elim H1; intros; clear H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13.\nelim H; intros; clear H1 H2 H3 H4 H5 H6.\nelim H1; intros; clear H1 H2 H3 H4 H5.\nelim H1; intros; clear H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15.\nelim H; intros; clear H1 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15.\nelim H; intros;Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros;\n clear H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14.\nelim H0; intros; elim H0; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H11 H12 H13 H14 H15.\nelim H0; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n clear H5 H6 H7 H8 H9 H10 H11 H14 H15 H16.\nelim H0; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; introsQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nsimple induction 1; intros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H4; intros; elim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros;\n clear H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H14 H15.\nelim H0; intros; elim H1; intros; elim H1; intros; clear H1 H2.\nelim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros;\n clear H1 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H0; intros; elim H3; intros; elim H3; intros; elim H4; intros; clear H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15.\nelim H0; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5Qed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1.\napply le_antisym; apply H; assumption.\nQed.",
                    "Theorem div_mult : is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\nintros a b d H H0 H1 H2; elim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H6; intros;\n clear H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H7; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n clear H6 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H7; intros; elim H6; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n clear H6 H7 H8 H9 H10 H11 H12 H14 H15 H16 H17.\nelim H7; intros; elim H7; intros; elim H5; intros; elim H5; intros; elim H5;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "0; trivial.\nsplit.\n(* A (a+b) *)\nelim H; intros; elim H3; intros; elim H4; intros. \nelim H0; intros; elim H9; intros; elim H1; intros; elim H13; intros.\nexact (H6 a b H10 H14).\n(* a+b = 0 or d <> 0 and a+b = d*q *)\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros.\nelim H7; intros; elim H9; intros; elim H11; intros; elim H14; intros.\nclear H H2 H3 H4 H5 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H0; intros; elim H2; intros; clear H H0 H2.\nelim H1; intros; elim H0; intros; clear H H0 H1.\n  (* a = 0 *)\nelim H4; intros. rewrite H. \nelim (H17 b H2); intros. rewrite H1.\nexact H5.\n  (* b = 0 *)\nelim H5; intros. rewrite H0.\nelim (H17 a H3); intros. rewrite H1.\nexact H4. clear H2 H3 H4 H5 H17.\n  (* a <> 0 & b <> 0 *)\nright.\nelim H; intros; elim H2; intros; elim H3; intros; clear H H2 H3.\nelim H0; intros; elim H2; intros; elim H3; intros; clear H H0 H2 H3.\nsplit.\nexact H1. clear H1.\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 732,
                "proof_start_offset": 7280,
                "proof_end_offset": 8081,
                "proof": "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H0; intros; elim H2; intros.\nsplit.\nexact H1.\nclear H0 H2.\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit.\nexact H15.\nclear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\nelim H4; intros.\nrewrite H0.\nleft.\nexact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\nright.\nelim H0; intros; elim H3; intros; elim H4; intros.\nsplit.\nexact H2.\nclear H0 H2 H3 H4.\nexists (Opp x).\nelim (H12 x H6); intros; elim H2; intros.\nsplit.\nexact H3.\nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0).\nelim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros a d H H0.\nrewrite (div_opp a) at 1.\nrewrite (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite (div_opp a) at 1.\nrewrite <- (div_opp b) at 2.\nrewrite <- (div_opp a) at 1.\nrewrite (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite (div_opp b) at 1.\nrewrite <- (div_opp b) at 2.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewrite <- (div_opp b) at 1.\nrewriteQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold div in |- *; intros.\nsplit.\nexact H.\napply div_opp; assumption.\napply div_opp; assumption.\napply div_opp; assumption.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold div in |- *; intros.\nsplit.\nexact H.\nexact H.\nQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nunfold divide in |- *; intros.\nelim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros;Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros a d.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nrewrite H5.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nrewrite H5.\nelim H7; intros.\nelim H7; intros.\nrewrite H7.\nelim H8; intros.\nelim H9; intros.\nrewrite H7.\nelim H7; intros.\nrewrite H7.\nelim H7; intros.\nrewrite H7.\nelim H8; intros.\nrewrite H7.\nelim H8; intros.\nrewrite H9.\nelim H9; intros.\nrewrite H9.\nelim H9; intros.\nrewrite H10.\nelim H10; intros.\nrewrite H9.\nelim H9; intros.\nrewrite H10.\nelim H9; intros.\nrewrite H9.\nelim H10; intros.\nrewrite H10.Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a). \nintros a d H; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; \n elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H5; intros; \n elim H6; intros; elim H6; intros;Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H H0.\nrewrite <- (div_opp a d).\nrewrite <- (div_opp a d).\nrewrite <- (div_opp a d).\nrewrite <- (div_opp a d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (div_opp b d).\nrewrite <- (divQed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nProof.\nintros a d H; elim H; intros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros;Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nunfold div in |- *.\nintros.\nunfold div in |- *.\nelim H; intros.\nsplit.\nexact H2.\nelim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n    clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n    clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H3; intros; elim H5; intros; elim H5; intros;\n    clear H5 H6 H7 H8 H9 H11 H12 H13 H14 H15 H16.\nelim H3; intros; elim H5; intros; elim H5; intros;\n    clear H5 H6 H7 H8 H9 H10 H11 H12 H14 H15 H16.\nelim H3; intros; elim H5; intros; elim H5; intros;\n    clear H5Qed.",
                    "Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\nintros.\nunfold divide in |- *.\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (mult_n_O a).\nrewrite <- (multQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\nexists (Add x x0).\nsplit.\nexact (H6 x x0 H4 H7). \nelim (H13 d x x0); intros. clear H4 H6 H7 H13.\nrewrite H0. clear H H0.\nelim H5; elim H8; reflexivity.\nQed.\n\n(***************)\nTheorem div_mult :\n is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros. split. exact H2. clear H0 H2.\n(* A (a*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8240,
                "proof_end_offset": 8608,
                "proof": "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros.\nsplit.\nexact H6.\nclear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros.\nexact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\n intros.\nsplit.\napply (gcd_for_euclid (a * b)).\napply divide_antisym; assumption.\nsplit.\nexact (gcd_for_euclid (a * b)).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nsimple induction 1; intros.\nsplit.\nexact (gcd_0_l 0).\nexact (gcd_0_l (S a) (S b) H0 H).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\n intros a b H.\n rewrite <- (gcd_intro a b H).\n rewrite <- (gcd_intro a b H).\n rewrite <- H; reflexivity.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit.\nexact (gcd_intro (gcd a b) (gcd b (gcd a b))).\nexact (gcd_intro (gcd a b) (gcd b (gcd a b))).\nexact (gcd_intro (gcd a b) (gcd a b)).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H.\napply (gcd_for_euclid a b d); try assumption.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros.\nsplit.\nexact (gcd_0_l a b).\nexact (gcd_0_l a b).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nintros.\nelim H; intros; split.\nexact H0.\nintros.\nsplit; trivial.\napply H0.\nexact H1.\nintros.\nsplit; trivial.\nexact H1.\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nintros a b H H0.\nsplit.\nexact H.\nintros q H0.\nsplit.\nexact H.\nintros q H1.\nsplit.\nexact H.\nintros q H1.\nsplit.\nexact H.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H1.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H1.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros q H2.\nsplit.\nexact H2.\nintros qQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nProof.\nunfold is_gcd in |- *; intros.\nsplit.\nexact (gcd_uniqueness a b).\nexact (gcd_uniqueness a b).\nQed.",
                    "Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\nintros.\nsplit.\napply divide_antisym.\napply (gcd_intro a b); auto with arith.\napply gcd_sym.\napply (gcd_intro a b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "*b) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H7; intros.\nclear H0 H2 H4 H5 H7 H9.\nelim H3; intros.\nsplit. exact (H6 a b H0 H1). clear H0 H3.\n(* a*b = 0 or d <> 0 and a*b = d*q *)\n  (* a = 0 *)\nelim H2; intros. rewrite H0. \nelim (mult_O H b H1); intros. rewrite H4. left; reflexivity. clear H H2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\n",
                "context_tokens": 731,
                "proof_start_offset": 8628,
                "proof_end_offset": 8894,
                "proof": "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nunfold is_gcd in |- *.\nintros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros.\nexact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros.\nelim H0; intros.\nelim H0; intros; elim H0; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nsplit.\nexact H10.\nelim H10; intros.\nsplit.\nexact H10.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nsplit.\nexact H10.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; introsQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros; trivial.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H3; intros.\nelim H1; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; assumption.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nProof.\nsimple induction 1; intros.\nleft; reflexivity.\nright; reflexivity.\nintros; discriminate.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H8;\n intros; elim H8; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2; intros; \n elim H3; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; \n elim H4; intros; elim H4; intros; elim H4; intros;\n    elim H4; intros; elim H4; intros;\n    elim H4; intros; elim H4; intros; elim H4Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nintros.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros;\n elim H5; intros; elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elimQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nsimple induction 1; intros; trivial.\nQed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H2;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7;Qed.",
                    "Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16.\nelim H0; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H5; intros; elim H5; introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "2.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H2; intros. split. exact H.\nexists (Mult x b). \nelim H3; intros. split. exact (H6 x b H4 H1).\nrewrite (H8 d x b). elim H5; reflexivity.\nQed.\n\n(**************)\nTheorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).\n\n\nunfold divide in |- *; intros.\n(* A d *)\nelim H0; intros; elim H2; intros. split. exact H1. clear H0 H2.\n(* A (-a) *)\nelim H; intros; elim H2; intros; elim H5; intros; elim H8; intros.\nelim H10; intros; elim (H12 a H3); intros; elim H14; intros.\nsplit. exact H15. clear H0 H2 H3 H6 H7 H8 H9 H10 H13 H14 H15 H16.\n(* (-a) = 0 or d <> 0 and (-a)= d*q *)\n  (* a = 0 *)\nelim H4; intros. rewrite H0. left. exact (opp_neutral S A Add O Opp H5).\nclear H4 H11.\n  (* a <> 0 *)\nright.\nelim H0; intros; elim H3; intros; elim H4; intros. \nsplit. exact H2. clear H0 H2 H3 H4.\nexists (Opp x). \nelim (H12 x H6); intros; elim H2; intros. split. exact H3. \nclear H3 H4 H5 H6 H12.\nrewrite (mult_opp_r H d x H1 H0). elim H7; reflexivity.\nQed.\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\n",
                "context_tokens": 711,
                "proof_start_offset": 8928,
                "proof_end_offset": 9827,
                "proof": "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H6; intros; elim H8; intros.\nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros.\nclear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2).\nsymmetry in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13).\nclear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros.\nelim H3.\nexact a0.\nexact b.\nelim (H20 a (Opp x) I); intros.\nrewrite H8.\nelim (H14 a H1); intros.\nrewrite H12.\nclear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2).\nrewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\n(*************************************************)\nProof.\nunfold is_gcd in |- *; intros.\nelim H0; intros; elim H1; intros; elim H2; intros.\nelim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros.\nelim H6; intros; elim H6; intros.\nelim H6; intros.\nsplit.\nexact H6; exact H6.\nexact H6.\nelim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros.\nelim H7; intros; elim H7; intros.\nsplit.\nexact H6; exact H6.\nelim H7; intros; elim H7; intros; elim H8; intros.\nsplit.\nexact H6; exact H7.\napply (proj1 H4).\nelim H7; intros; elim H8; intros; elim H8; intros.\nsplit.\nexact H6; exact H7.\nelim H8; intros; elim H8; intros.\nsplit.\nexact H9; exact H8.\nelim H8; intros; elim H8; intros.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\napply (Build_Map (A:=A) (B:=A) (B:=A) (B:=A) (c:=c)).\napply (Build_Map (A:=A) (B:=A) (c:=c)).\nred in |- *; intros.\nelim H0; intros; elim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; introsQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nsimple induction 1; intros; auto with arith.\nelim H0; intros.\nelim H2; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H12; intros.\nelim H13; intros.\nelim H11; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H12; intros.\nelim H13; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nunfold a in |- *.\nelim H; intros.\nelim H; intros; elim H0; intros.\nsplit.\nexact H1.\nelim H2; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elimQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nsimple induction 1; intros.\nelim H1; intros; elim H2; intros.\nelim H4; intros; elim H4; intros.\nelim H5; intros.\nelim H5; intros; elim H6; intros.\nelim H6; intros.\nsplit.\nexact H6.\nelim H7; intros.\nsplit.\nexact H7.\nelim H7; intros.\nsplit.\nexact H9.\nexact H10.\nelim H7; intros.\nsplit.\nexact H7.\nelim H7; intros.\nsplit.\nexact H7.\nelim H8; intros.\nsplit.\nexact H10.\nexact H10.\nelim H8; intros.\nsplit.\nexact H8.\nelim H9; intros.\nsplit.\nexact H10.\nexact H9.\nexact H10.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nelim H; intros; elim H0; intros.\nelim H1; intros; elim H1; intros.\nelim H2; intros.\nelim H4; intros; elim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros.\nelim H5; intros; elim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\n(******************************************************)\nintros a x H H0; elim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim HQed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\nunfold is_gcd in |- *.\nelim H; intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros;Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\napply (Build_Map (A:=A) (B:=A) (B:=A) (c:=c)).\napply (Build_Map (A:=A) (B:=A) (c:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=c)).\napply (Build_Map (A:=A) (B:=Qed.",
                    "Lemma simplification_integrity : is_unitary_commutative_ring -> integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\nintros.\napply (Build_Setoid (A:=A) (B:=A) (B:=A) (B:=A) (C:=A) (c:=a)); auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "\n\n(***************)\nDefinition is_gcd (a b d : S) :=\n  divide d a /\\\n  divide d b /\\ (forall q : S, divide q a -> divide q b -> divide q d).\n\n(**************)\nLemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\\ b = O.\n\n\nunfold is_gcd in |- *; intros.\nelim H; intros; elim H0; intros; elim H3; intros.\nelim H5; intros. split. exact H6. clear H H0 H2 H3 H4 H5 H6.\nelim H1; intros; elim H; intros; elim H3; intros; elim H5; intros. exact H6.\nelim H6; intros; elim H7; reflexivity.\nelim H6; intros; elim H7; reflexivity.\nQed.\n\n(***************)\nLemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.\n\n\nunfold is_gcd in |- *. intros.\nelim H0; intros; elim H2; intros.\nelim (H4 O (div_O_O H) (div_O_O H)); intros; elim H6; intros.\nelim H8; intros. exact H9.\nelim H9; intros; elim H10; reflexivity.\nQed.\n\n(*****************************)\nLemma simplification_integrity :\n is_unitary_commutative_ring ->\n integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.\n\n\nintros. elim H; intros; elim H5; intros; elim H6; intros; elim H8; intros. \nelim H11; intros; elim H12; intros; elim H14; intros; elim H16; intros.\nelim H18; intros. clear H6 H8 H9 H12 H13 H14 H15 H16 H17 H18 H19 H21.\nrewrite (opp_opp S A Add O Opp H11 x H2). \nsymmetry  in |- *; apply (opp_unicity S A Add O Opp H11 (Opp x) I).\nelim (H22 x H2); intros; elim H8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\n",
                "context_tokens": 684,
                "proof_start_offset": 9908,
                "proof_end_offset": 11305,
                "proof": "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nProof.\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\nexists I.\nunfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit.\nexists I.\nexact (H21 I H20).\nsplit.\nexact H20.\nelim (gcd_null a b); intros.\nrewrite H15.\nrewrite (gcd_null2 H16 d1).\nelim (mult_O H16 I); intros.\nsymmetry in |- *; exact H25.\nexact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1.\nelim H15; exact H2.\nelim H15; intros; elim H17; intros.\nexists x.\nelim H; intros; elim H20; intros.\nsplit.\napply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros.\nelim H16; exact H31.\nelim H31; intros; elim H33; intros.\nexists x0.\nelim H34; intro; clear H35.\nelim H18; intro; intro.\nrewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0); intros.\nelim H34; intros.\napply (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry in |- *; exact H47.\nexact H18.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nsplit.\napply H2.\napply H0.\nassumption.\nsplit; assumption.\nexists (S d1).\nexists (S d2).\nexists (S d2).\nexists (S d1).\nexists (S d2).\nsplit.\napply H2.\nassumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nexists (S d1).\nexists (S d2).\nexists (S d2).\nexists (S d2).\nsplit.\napply H2.\nassumption.\nsplit; assumption.\nsplit; assumption.\nexists (S d1).\nexists (S d1).\nexists (S d2).\nexists (S d2).\nsplit.\napply H2.\nassumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nexists (S d2).\nexists (S d2).\nexists (S d2).\nsplit.\napply H3.\nassumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nsplit; assumption.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros.\nexists x; split.\napply (gcd_for_euclid (fun c : S => is_gcd (gcd c d1) (gcd c d2)) (gcd c d1)).\napply gcd_sym; assumption.\nunfold is_gcd in |- *; intros.\nelim H; intros.\nelim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H5; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; elim H8; intros; elim H7;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros.\nexists x; split.\napply sym_equal; assumption.\napply (gcd_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid.\nexists (a + b + d1).\nsplit.\napply euclid.\nsplit.\napply (gcd_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclid_for_euclidQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros.\nexists x; split.\napply (alt_eq (fun q : S => div_exact q q) (fun x : S => div_exact q q) a b d1).\napply (alt_eq (fun q : S => div_exact q q) (fun x : S => div_exact q q) a b d).\napply H; trivial.\napply H; trivial.\napply H0; trivial.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros.\nexists x; split.\napply (alt_eq_mult_l (fun a : S => mult_comm a b) (fun c : S => mult_comm c c) a b d1 d2).\napply (alt_eq_mult_l (fun a : S => mult_comm b c) a b d).\napply (alt_eq_mult_l (fun a : S => mult_comm a b) (fun c : S => mult_comm c c)).\napply (alt_eq_mult_l (fun a : S => mult_comm a c) (fun c : S => mult_comm c c)).\napply (alt_eq_mult_l (fun a : S => mult_comm a c) (fun c : S => mult_comm c c)).\napply (alt_eq_mult_l (fun a : S => mult_comm a c) (fun c : S => mult_comm c c)).\napply (alt_eq_mult_l (fun a : S => mult_comm a c) (fun c : S => mult_comm c c)).\napply (altQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros.\nexists x; exists y; split; auto.\nexists x; exists y; split; auto.\nexists x; exists y; split; auto.\nexists x; exists y; split; auto.\nexists y; exists y; split; auto.\nexists y; exists y; split; auto.\nexists y; exists y; split; auto.\nexists y; exists y; split; auto.\nexists y; exists y; split; auto.\nexists y; exists y; split; auto.\nexists y; exists x; split; auto.\nQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\n\nintros.\nelim H; intros.\nexists (S x).\napply (alt_eq_apart_unit line); assumption.\nexists (S x).\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumption.\nsplit.\napply (alt_eq_apart_unit line); assumptionQed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H6; intros; elim H7; intros;Qed.",
                    "Lemma gcd_unicity_apart_unities : is_unitary_commutative_ring -> integrity -> forall a b d1 d2 : S, is_gcd a b d1 -> is_gcd a b d2 -> exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\nintros.\nelim H; intros.\nelim H; intros.\nelim H1; intros.\nexists x0; split; auto.\napply H.\napply H2.\napply H1.\napply H3.\napply H1.\napply H1.\napply H2.\napply H3.\napply H1.\napply H1.\napply H1.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H4.\napply H4.\napply H4.\napply H4.\napply H3.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napply H3.\napply H4.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/rings.v",
                "context": "8; intros; elim H10; intros.\napply (opp_com S A Add O H7 (Opp x) I H9 H13). clear H6 H8 H12 H13.\nelim (H0 a (Add (Opp x) I)); intros. \nelim H3. exact a0. exact b.\nelim (H20 a (Opp x) I); intros. rewrite H8. elim (H14 a H1); intros.\nrewrite H12. clear H6 H8 H9 H12 H13 H14.\nrewrite (mult_opp_r H5 a x H1 H2). rewrite H4.\nelim (H22 a H1); intros; elim H8; intros; elim H12; intros; exact H14.\nQed.\n\n(******************************) (* Pas aussi propre que je le souhaiterais *)\nLemma gcd_unicity_apart_unities :\n is_unitary_commutative_ring ->\n integrity ->\n forall a b d1 d2 : S,\n is_gcd a b d1 ->\n is_gcd a b d2 ->\n exists x : S, inversible S Mult I x /\\ A x /\\ d2 = Mult d1 x.\n\n\nintros.\nelim H2; intros; elim H4; intros; elim H1; intros; elim H8; intros.\nelim (H6 d1 H7 H9); intros; elim H12; intros; elim H14; intros.\n(* d2 = O *)\nexists I. unfold inversible in |- *.\nelim H; intros; elim H17; intros; elim H19; intros.\nsplit. exists I. exact (H21 I H20). split. exact H20.\nelim (gcd_null a b); intros. rewrite H15. rewrite (gcd_null2 H16 d1). \nelim (mult_O H16 I); intros. symmetry  in |- *; exact H25. exact H20.\npattern O at 1 in |- *; elim H22; elim H23; exact H1. elim H15; exact H2.\n(* d2 <> 0 *)\nelim H15; intros; elim H17; intros. exists x.\nelim H; intros; elim H20; intros. split. apply (inv_com S Mult I x H21).\nelim H1; intros; elim H24; intros; elim (H26 d2 H3 H5); intros.\nelim H28; intros; elim H30; intros. elim H16; exact H31.\n(* d1 <> 0 *)\nelim H31; intros; elim H33; intros. exists x0.\nelim H34; intro; clear H35. elim H18; intro; intro. rewrite H36.\nelim H; intros H37 H38; elim H37; intros H39 H40; elim H40; intros H41 H42.\nelim H42; intros H43 H44; elim H44; intros H45 H46; elim (H45 d1 x x0);\n intros.\nelim H34; intros.\napply\n (simplification_integrity H H0 d1 (Mult x x0) H11 (H43 x x0 H35 H48) H16).\nsymmetry  in |- *; exact H47.\nexact H18.\nQed.\n\n(**********)\n",
                "context_tokens": 731,
                "proof_start_offset": 11320,
                "proof_end_offset": 11524,
                "proof": "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nProof.\nintros.\nelim H; intros; elim H3; intros.\nrewrite (opp_opp S A Add O Opp H4 x H0).\nrewrite H1.\nexact (opp_neutral S A Add O Opp H4).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros.\nexists (S x0).\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit; auto.\nelim H1; intros; elim H0; intros; elim H1; intros.\nexists (S x1).\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napply opp_inj; auto.\nsplit.\napplyQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nsimple induction 1; intros; trivial.\ninversion H; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H0; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H0; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion H1; trivial.\ninversion HQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nexists (div x x).\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\nsplit; auto.\napply opp_inj; auto.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H2; intros; elim H3; intros.\nexists (S x1).\nexists (S x2).\nexists (S x1).\nexists (S x1).\nexists (S x2).\nexists (S x1).\nsplit.\napply H2.\nsplit.\nexact H3.\nrewrite <- H5.\napply sym_equal.\nexact H2.\napply sym_equal.\nexact H1.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros;\n generalize H5; rewrite (mult_comm x0 x1 x0 H4); rewrite H5;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14.\nrewrite (mult_comm x0 x1 x1 x0 H3 H4); rewrite H5; intros.\nelim H3; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n generalize H6; rewrite (mult_comm x1 x0 x1 x2 H5); \n rewrite H6; intros.\nexists (S x1).\nsplit.\napply (mult_reg_l (S x1) (S y1) (S y2) H6 H7).\nexact H5.\n\nunfold mult at 1 in |- *.\nrewrite (mult_comm x0 x1 x0 H3 H6).\nrewrite (mult_comm x0 x1 x0Qed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\napply (opp_opp_O (A:=A)).\napply opp_O.\napply opp_O.\napply opp_O.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros.\nelim H; intros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nelim H2; intros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\napply sym_equal; apply minus_O; assumption.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplit.\napply sym_equal; apply minus_O; assumption.\nintros.\nsplitQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros.\nelim H; intros; elim H0; intros.\nexists (pos x0).\nsplit.\napply neg_inv_l.\ntrivial.\nsplit.\napply pos_inv_l.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\napply neg_inv_r.\ntrivial.\nsplit.\napply neg_inv_l.\ntrivial.\nsplit.\napply pos_inv_l.\ntrivial.\nsplit.\napply pos_inv_l.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\napply neg_inv_r.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\napply neg_inv_r.\ntrivial.\nsplit.\napply neg_inv_r.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\napply pos_inv_r.\ntrivial.\nsplit.\nQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros.\nexists (S x); split; auto with arith.\nelim H2; intros; elim H4; intros.\nexists (S x0); split; auto with arith.\nelim H5; intros; elim H5; intros.\nexists (S x0); split; auto with arith.\nelim H5; intros; elim H5; intros.\nexists (S x1); split; auto with arith.\nelim H5; intros; elim H5; intros.\nexists (S x1); split; auto with arith.\nelim H5; intros.\nexists (S x1); split; auto with arith.\nelim H5; intros; elim H5; intros.\nexists (S x1); split; auto with arith.\nelim H5; intros; elim H5; intros; elim H6; intros.\nexists (S x1); split; auto with arith.\nelim H5; intros; elim H5; intros.\nexists (S x1); split; auto with arith.\nelim H5; intros.\nexists (S x1); splitQed.",
                    "Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros.\nexists (S x).\nsplit.\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_reg_l with (S x).\napply mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zdiv.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zdiv.v                                  *)\n(****************************************************************************)\nRequire Export Zbase.\nRequire Export Zadd.\nRequire Export Zmult.\nRequire Export Zle.\nRequire Export Euclid.\n\nUnset Standard Proposition Elimination Names.\n\n(********************)\nDefinition is_diveuclZ (a b q r : Z) :=\n  b <> OZ /\\ leZ OZ r /\\ ltZ r (absZ b) /\\ a = addZ (multZ b q) r.\n\n(***************************)\nInductive diveuclZ (a b : Z) : Set :=\n    divexZ : forall q r : Z, is_diveuclZ a b q r -> diveuclZ a b.\n\n(************************)\n",
                "context_tokens": 234,
                "proof_start_offset": 1632,
                "proof_end_offset": 3661,
                "proof": "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nintros a b; case b; intros.\nelim H; reflexivity.\ncase a; intros.\napply (divexZ OZ (pos n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (pos n)).\nreflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)).\nintros.\napply (divexZ (pos n0) (pos n) (posOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r).\nexact (gt_S_le r n g).\nexact (tech_div1 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (pos n) (negOZ q) OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (pos n) (negOZ q))).\napply (tech_div2 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (pos n) (neg q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div3 n0 n q r e g).\ncase a; intros.\napply (divexZ OZ (neg n) OZ OZ).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (mult_OZ (neg n)); reflexivity.\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\napply (divexZ (pos n0) (neg n) (negOZ q) (posOZ r)).\nsplit.\ndiscriminate.\nsplit.\napply (tech_posOZ_pos r).\nsplit.\nunfold ltZ in |- *; rewrite (tech_succ_posOZ r); exact (gt_S_le r n g).\nexact (tech_div4 n0 n q r e).\nelim (eucl_dev (S n) (gt_Sn_O n) (S n0)); intros.\ncase (eq_gt_O_dec r); intro.\napply (divexZ (neg n0) (neg n) (posOZ q) OZ).\nunfold is_diveuclZ in |- *.\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (le_O_n n).\nrewrite (add_OZ (multZ (neg n) (posOZ q))).\napply (tech_div5 n0 n q).\nrewrite e; rewrite e0; auto with arith.\napply (divexZ (neg n0) (neg n) (pos q) (pos (n - r))).\nsplit.\ndiscriminate.\nsplit.\nexact I.\nsplit.\nexact (lt_le_S (n - r) n (lt_minus n r (gt_S_le r n g) g0)).\nexact (tech_div6 n0 n q r e g).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction a.\nintros.\napply eq_Z_div_mod_eq_full; auto with arith.\napply le_antisym; auto with arith.\napply le_antisym; auto with arith.\napply le_antisym; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; simpl in |- *; intros.\nauto.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nintros a b; elim a.\nauto.\nauto.\nauto.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nsimple induction 1; intros.\nabsurd (0 = b); auto with arith.\nabsurd (0 = b); auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction 1; intros.\nelim H; intros.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim HQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction 1; intros.\nabsurd (0 = 0).\nelim H0; intros.\nabsurd (0 = 0).\nelim H1; intros.\nabsurd (0 = 0).\ndiscriminate.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nintros a b H.\nelim H.\nintros H0.\napply H.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexactQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a; simpl in |- *; auto with arith.\nQed.",
                    "Lemma divZ : forall a b : Z, b <> OZ -> diveuclZ a b.\nProof.\nsimple induction a.\n simpl in |- *.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\n",
                "context_tokens": 286,
                "proof_start_offset": 1694,
                "proof_end_offset": 1893,
                "proof": "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n  simple induction n; intros.\n  inversion H; trivial.\n  simpl in |- *; intros.\n  inversion H.\n  simpl in H; discriminate.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n.\nsimple induction m.\nintros.\napply neg_O_not_posZ.\napply eq_sym.\napply ZL6.\nexact (fun n m : nat => n <> m :>nat).\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n; intros.\nabsurd (0 = pos n0).\nauto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n simple induction n; intros.\n discriminate.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n  intros.\n  apply H.\n  intro.\n  case H; intros.\n  apply H.\n  intro.\n  case H; intros.\n  apply H; apply pos_O_nat_of_P_pos_nat_of_P_pos_nat_of_P_pos_nat_of_P_pos_nat_of_P.\n  assumption.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n  simple induction n; simpl in |- *; intros; try discriminate; elim H; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\n simple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nProof.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\nsimple induction n; intros.\nleft; assumption.\nright; symmetry  in |- *; apply pos_S_not_posZ; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zbase.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zbase.v                                  *)\n(****************************************************************************)\n\n(* Basic definitions on type Z *)\n\n(*************)\nInductive Z : Set :=\n  | OZ : Z\n  | pos : nat -> Z\n  | neg : nat -> Z.\n\n(***********)\nDefinition IZ := pos 0.\n\n(****************)\n(* was\nFixpoint is_posn [x,z :Z] : Prop :=\nCases x z of \n  OZ       y => False\n| (pos n) OZ => False \n| (pos n) (pos m) => (eq nat n m)\n| (pos n) (neg m) => False\n| (neg n) y => False\nend.\n*)\n\nDefinition is_posn (x z : Z) :=\n  match x, z with\n  | pos n, pos m => n = m :>nat\n  | _, _ => False\n  end.\n\n\n\n(**********************)\nLemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.\n\n\nunfold not in |- *; intros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H. rewrite H0; simpl in |- *; reflexivity.\nQed.\n\n(**************)\n",
                "context_tokens": 362,
                "proof_start_offset": 1912,
                "proof_end_offset": 2065,
                "proof": "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nProof.\nintros; elim x.\nleft; reflexivity.\nintros; right; discriminate.\nintros; right; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintro.\ngeneralize (eq_hor_dec (x = x) H); intro.\nelim H; intro.\nright; apply H; trivial.\nright; apply H; trivial.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (not_O_nat (pos n) (pos m)).\n simpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (exists n : nat, x = n).\nintro.\nexists 0; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (fun n : nat => x = n).\nsimpl in |- *; reflexivity.\nexists (funQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (eq_part (pos n) (pos n)).\nintros.\ncut (eq_part (pos n) (pos n)).\nintro.\ncut (eq_part (pos n) (pos m)).\nintro.\ncut (eq_part (pos n) (pos m)).\nintro.\ncut (eq_part (pos n) (neg m)).\nintro.\ncut (eq_part (pos n) (pos m)).\nintro.\ncut (eq_part (pos m) (neg n)).\nintro.\ncut (eq_part (pos m) (neg m)).\nintro.\ncut (eq_part (pos m) (neg m)).\nintro.\ncut (eq_part (pos m) (neg m)).\nintro.\ncut (eq_part (pos m) (neg m)).\nintro.\ncut (eq_part (pos m) (pos m)).\nintro.\ncut (eq_part (pos m) (neg m)).\nintro.\ncut (eq_part (pos m) (neg m)).\nintro.\ncut (eq_part (pos m) (neg m)).\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nunfold not in |- *; intros.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z, x = z).\nintro.\ncut (exists z : Z,Qed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ninjection (Lt_dec x 0).\nintros.\nelim H; intros; rewrite H0; simpl in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\nchange (0 = 0) in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (is_posn (pos n) (pos m)).\nsimpl in |- *; exact H.\nrewrite H0; simpl in |- *; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (exists n : nat, x = 0).\nintro; elim H; intros.\nexists (S x0).\nexists (S x0).\nsplit; reflexivity.\nexists (S x0).\nsplit; reflexivity.\nexists (S x).\nsplit; reflexivity.\nQed.",
                    "Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.\nintros.\ncut (exists n : nat, x = 0).\nintro; elim H; intros.\nexists x; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\n",
                "context_tokens": 156,
                "proof_start_offset": 1347,
                "proof_end_offset": 1460,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H; elim H; intros.\nelim H0; intros.\nelim (H x0 y x0 H1); intros.\ncut (ex x y).\n2: intro; assumption.\nintros.\nelim H1; intros.\nelim (H2 x y0); intros.\nexists x0; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x y H.\nelim H.\nelim H.\nintros x0 y0 H'1; elim H'1; intros H'3 H'4; try exact H'5; clear H'4.\nelim H'4; intros H'5 H'6; try exact H'6; clear H'5.\nelim H'5; intros H'6 H'7; try exact H'7; clear H'5.\nelim H'5; intros H'6 H'7; try exact H'8; clear H'5.\nelim H'6; intros H'6 H'7; try exact H'8; clear H'5.\nelim H'6; intros H'7; try exact H'8; clear H'5.\nelim H'6; intros H'7; try exact H'8; clear H'5.\nelim H'6; intros H'7 H'8; try exact H'8; clear H'5.\nelim H'6; intros H'7 H'8; try exact H'8; clear H'5.\nelim H'7; intros H'8;Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H.\nelim H.\nintros x y H0.\nelim H0; intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6;\n elim H5; intros H6 H7; elim H7; intros H7 H8; elim H8; intros H9 H10; elim H10;\n intros H11 H12; elim H12; intros H13 H14; elim H15; intros H15 H16; elim H15; intros H16 H17;\n elim H18; intros H18 H20; elim H18; intros H18 H18; elim H18; intros H18 H18;\n elim H18; intros H20 H21; elim H18; intros H18 H20; elim H18; intros H20 H21;\n   elim H18; intros H18 H20 H21; elim H23; intros H26 H5; elim H18; intros H25 H26;\n   elim H18; intros H18 H20 H21; elim H23; intros H26 H25; elim H23; intros H23 H24;\n   elim H26; intros H26Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x y; elim x; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H; elim H; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nsimple induction 1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H; elim H; auto with sets.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x : A, ~ R x x.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (ADefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R y x.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition no_cond (A : Set) (R : A -> Prop) :=\n  forall xDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x.\nelim H.\nintros y H'0.\nelim H'0; intros H'1 H'2; intros H'3 H'4; elim H'4; intros H'5 H'6;\n elim H'7; intros H'6 H'7; intros H'7 H'9; clear H'7.\nsplit; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\n",
                "context_tokens": 203,
                "proof_start_offset": 1485,
                "proof_end_offset": 1628,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/misc.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  misc.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\n\n(****************)\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n(********************)\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\n\nProof.\nsimple induction 1; auto.\nDefined.\n\n(********************)\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\n\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\n(*******************)\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n(************)\n",
                "context_tokens": 313,
                "proof_start_offset": 1781,
                "proof_end_offset": 2050,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros; simpl in |- *; auto.\nexists (S x0); auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nsimple induction 1; intros.\nexists (S x0).\nexists (S x0).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_ind_r with (P := fun y : S => I (S y)).\napply inv_Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nsimple induction 1; intros.\nexists x; auto.\nelim H1; intros.\nexists x0; auto.\nelim H1; intros.\nexists x0; auto.\nexists x1; auto.\nelim H1; intros.\nexists x1; auto.\nelim H1; intros.\nexists x0; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x0; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists x; auto.\nelim H1; intros.\nexists xQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nsimple induction 1; intros; auto.\nelim H1; intros.\nexists x0; auto.\nexists x1; auto.\nexists x2; auto.\nexists x1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; exists x0; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros.\nexists (S x0); exists (S x0); exists (S x0); auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nelim H1; intros.\nexists (fun y : S => I (S y)).\nelim H2; intros.\nexists (fun y : S => I (S y)).\nelim H3; intros.\nexists (fun y : S => I (S y)).\nelim H4; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; intros.\nexists (fun y : S => I (S y)).\nelim H5; introsQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintros x y z H H0.\nelim H0; intros H1 H2; elim H2; intros H3 H4; elim H5; intros H5 H6.\nexists x; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros.\nexists (fun x y : S => I x y).\nelim H; intros.\nexists (fun x y : S => I x y).\nelim H0; intros.\nexists (fun x : S => I x y).\nelim H1; intros.\nexists (fun x y : S => I x y).\nelim H2; intros.\nexists (fun x y : S => I x y).\nelim H3; intros.\nexists (fun x y : S => I (S x y)).\nelim H3; intros.\nexists (fun x y : S => I (S x y)).\nelim H5; intros.\nexists (fun x y : S => I (S x y)).\nelim H5; intros.\nexists (fun x y : S => I (S x y)).\nelim H5; intros.\nexists (fun x y : S => I (S x y)).\nelim H6; intros.\nexists (fun x y : S => I (S x y)).\nelim H6; intros.\nexists (fun x y : S => I (S x y)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction 1; intros.\nexact (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nrewrite H1.\napply sym_not_equal.\napply (Zlt_le_weak _ _ H1).\nintros.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  apply neg_absZ.\n  apply neg_absZ.\n  apply neg_absZ.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x; simple induction x; simple induction x0; simple induction x0; simple induction x0; intros.\nelim (succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ_eq_succ;\n apply (fun n m : nat =>\n   match y with\n   | Eq => True\n     | _ => False\n     end\n  end.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nintros; elim x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros; unfold sign_absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ.\n  elim (dec_Z (Zabs_nat x)); intro.\n  rewrite H0.\n  ring.\n  apply Zle_lt_trans with (Zabs_nat x); auto with zarith.\n  apply Zlt_le_weak.\n  apply Zle_lt_trans with (Zabs_nat x); auto with zarith.\n  apply Zlt_le_weak.\n  apply Zlt_le_weak; apply Zlt_le_weak; apply Zlt_le_weak; assumption.\n  apply Zlt_le_weak; apply Zlt_le_weak; assumption.\n  apply Zlt_le_weak; apply Zlt_le_weak; assumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  simple induction x.\n  simpl in |- *.  intros.  unfold negZ in |- *.  unfold zeroZ in |- *.  simpl in |- *.\n  reflexivity.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros.\napply neg_absZ.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x; simple induction 1; intros.\nauto with arith.\nelim H; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros.\nrefine (fun _ : 0 = 0 => True).\napply zero_zero.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nintros.\nelim (zero_absZ x).\nelim (sign_absZ x).\nelim (sign_absZ x).\nintros.\nelim (sign_absZ x).\napply sym_equal.\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).\napply (f_equal Z).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros x H; elim H; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nexact I.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. introQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n intros; elim H; simpl in |- *.\n intros; elim H; simpl in |- *.\n intros; elim H; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x H; elim H; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros.\n elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros.\n elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold neutral at 1 in |- *; unfold incrZ in |- *; unfold shiftZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold zeroZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold zeroZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold zeroZ in |- *;\n unfold zeroZ in |- *; unfold zeroZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold zeroZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *; unfold zeroZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *;\n unfold zeroZ in |- *; unfold oneZ in |- *;\n unfold oneZ in |- *; unfold zeroZ in |- *;\n unfold oneZ in |- *; unfold zeroZ in |- *;\n unfold oneZ in |- *; unfold oneZ in |- *; \n unfold oneZ in |-Qed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\ngeneralize (plus_zeroZ); intros x; elim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nred in |- *; intros x y H; elim H.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply zero_absZ.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold negZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\napply neg_absZ.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold originZ in |- *; intros x; elim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintros x y; elim x. \nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold neutralZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro x; elim x; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros; elim x; simpl in |- *.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_absZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.\nintros; apply neg_oppZ.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *.\nintros; auto with arith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *.\nreflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nintros x H; elim H.\nintros; auto with arith.\nintros; auto with arith.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H.\nelim H.\n(* (pos n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (pos n) (neg n) *)\nintros; elim H.\n(* (pos n) (neg n) *)\nsimpl in |- *; intros; elim H.\n(* (pos n) (neg n) *)\nintros; elim H0.\n(* (neg n) (neg n) *)\nintros; elim H.\n(* (neg n) (neg n) *)\nintros; elim H.\n(* (pos n) (neg n) *)\nintros; elim H.\n(* (neg n) (neg n) *)\nintros; elim H.\n(* (neg n) (neg n) *)\nintros; elim H.\n(* (neg n) (neg n) *)\nintros; elim H.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H.Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; intros H1 H2; auto.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H.\nintros; right; reflexivity.\nintros; left; reflexivity.\nintros; right; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction 1; intros.\nsimpl in |- *; reflexivity.\nintros n0 H0; elim H0.\nunfold ltZ in |- *; reflexivity.\nintros; elim H0.\nunfold ltZ in |- *; reflexivity.\nintros n0 H1; elim H1.\nunfold ltZ in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": " Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 737,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold gtZ in |- *; unfold ltZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n apply lt_le_trans with (absZ (nat_of_P (posQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintro n; elim n.\n(* pos n *)\nintros; elim n.\n(* (pos n) (pos n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (pos n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (pos n) (neg n) *)\nintros; elim n.\n(* (pos n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (pos n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros; elim n.\n(* (neg n) (neg n) *)\nintros;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintro; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold Divides in |- *; intros.\nelim (le_Sn_O n H).\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; intros; elim H0.\n(*Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *; intros.\nelim (le_Sn_O n H).\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) (pos n) *)\nsimpl in |- *; intros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) (neg nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n intros.\nelim (le_Sn_O n H).\n(* (neg n) *)\nintros; elim (le_Sn_O n H).\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n) *)\nintros; elim H.\n(* (neg n)Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *.\n(* *)\nintros.\nelim (le_Sn_O n H).\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nsimpl in |- *; intros.\nunfold lt in |- *; intros.\nelim H0.\nintros.\nunfold lt_absZ in |- *; intros.\nelim (le_Sn_O n H).\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nrewrite H0.\nrewrite H1.\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; intros.\nelim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_Sn_O n H).\n(* (pos n) (neg n0) *)\nsimpl in |- *; intros; elim H; intros.\nunfold lt_absZ in |- *; intros.\nelim H.\nintros.\nunfold lt_absZ in |- *; intros.\nelim (le_Sn_O n H).\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H2.\nsimpl in |- *; reflexivity.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros.\nelim H; intros.Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n (* pos n *)\nreflexivity.\n (* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *; intros.\nelim (le_Sn_O n H).\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; simpl in |- *; \n unfold ltZ in |- *; simpl in |- *; \n unfold ltZ in |- *; simpl in |- *; \n intros.\nelim (le_Sn_O n H).\n(* (pos n) *)\nintros; elim H.\n(* (pos n) *)\nintros; elim H0.\n(* (0) *)\nintros; elim H0.\n(* (0) (neg n0) *)\nintros; elim H0.\n(* (0) *)\nintros; elim H0.\n(* (0) *)\nintros; elim H0.\n(* (0) (neg n) *)\nintros; elim H0.\n(* (0) (neg n) *)\nintros; elim H0.\n(* (0) (neg n) *)\nintros; elim H0.\n(* (0) (neg n) *)\nintros; elim H0.\n(* (0) (neg n) *)\nintros; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\n",
                "context_tokens": 731,
                "proof_start_offset": 3529,
                "proof_end_offset": 3703,
                "proof": "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\nsimpl in |- *; intros; exact I.\nsimpl in |- *; intros; exact I.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x H.\nelim (le_antisym x 0); intros.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim (le_antisym _ _ H).\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimpl in |- *; intros; elim H0.\n(* (neg n) (neg n) *)\nsimplQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.\nsimpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nintros; apply le_opp_oppK; reflexivity.\nintros; apply le_opp_oppK; reflexivity.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros x; elim x.\nsimpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.",
                    "Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\nProof.\nintros; elim n. simpl in |- *; exact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\n",
                "context_tokens": 726,
                "proof_start_offset": 3722,
                "proof_end_offset": 3902,
                "proof": "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros.\napply (leZ_antisymmetric x OZ).\nrewrite H.\nexact (le_opp_OZ_l y H1).\nexact H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\nintros; left; exact I.\nintros; right; exact I.\nintros; left; exact I.\nintros; right; exact I.\nintros; right; exact I.\nintros; right; exact I.\nintros; right; exact I.\nintros; right; exact I.\nintros; right; exact I.\nintros; left; exact I.\nintros; left; exact I.\nintros; right; exact I.\nintros; right; exact I.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nintros x y H H0; apply lt_le_weak; assumption.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H H0 H1.\nrewrite (mult_comm x y H0); reflexivity.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H1 H2 H3; rewrite (le_opp_Onotbool x H3).\nassumption.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nintros x y H0 H1; elim H1; intros.\n(* pos n *)\nelim H0; intros.\n(* pos n *)\nelim H0; intros.\nunfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *;\n unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *; \n apply eq_nat_eq_nat_eq_nat; elim H1; intros.\n(* pos n *)\nelim H1; intros.\nsplit.\n(* pos n *)\nelim H0; intros.\nrewrite H0; rewrite H1; rewrite H2.\nsplit.\n(* pos n *)\nelim H; intros.\n(* pos n *)\nelim H; intros.\nrewrite H; rewrite H2.\nsplit.\n(* pos n *)\nelim H; intros.\nrewrite H; rewrite H2.\nsplit; auto.\nrewrite H; rewrite H2.\nsplit; auto.\n(* pos n *)\nelim H; intros.\nrewrite H; rewrite H2.\nsplit.\n(* pos n *)\nelim H; intros.\nrewrite H; rewrite H2.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\nintros; elim H.\nintros; auto.\nintros; elim H.\nintros; auto.\nintros; auto.\nintros; auto.\nintros; auto.\nintros; auto.\nintros; auto.\nintros; auto.\nintros; auto.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H; intros; exact I.\nintros; elim H.\nintros; rewrite H;Qed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H H0; rewrite (le_opp_sgnZ x H0); apply lt_opp_sgn.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nintros x y H H0; rewrite <- (inv_opp_antisymmetric x H); reflexivity.\nQed.",
                    "Lemma le_opp_OZ : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\nProof.\nsimple induction x.\n (* pos n *)\nintros; elim H0; simpl in |- *; intros; exact I.\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos n *)\nintros; elim H0.\n(* pos nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\nLemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\n\nProof.\nintros; elim n. simpl in |- *; exact I. simpl in |- *; intros; exact I.\nQed.\n\n(**************)\nLemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.\n\nProof.\nintros x; elim x. simpl in |- *; intros; exact I. simpl in |- *; intros; exact I. \nintros; elim H.\nQed.\n\n(**************)\nLemma le_opp_OZ :\n forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.\n\nProof.\nintros. apply (leZ_antisymmetric x OZ). rewrite H. exact (le_opp_OZ_l y H1).\nexact H0.\nQed.\n\n(***************)\n",
                "context_tokens": 725,
                "proof_start_offset": 3922,
                "proof_end_offset": 4176,
                "proof": "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\nrewrite (le_opp_OZ x y H H0 H1).\nrewrite (opp_opp Z IdZ addZ OZ oppZ Z_group y I); elim H.\nrewrite (le_opp_OZ x y H H0 H1); simpl in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nintros.\napply (le_antisym x)|]. rewrite H.\nexact H.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_antisym x)|].\nexact H.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nintros.\napply (le_antisym x)|].\napply le_opp_inlist.\nexact H0.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_ Renamings x)|].\nexact H0.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\n intros.\n apply (le_antisym (absZ x) (absZ y)); auto.\n apply lt_mult_ZERO; auto.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_antisym x)|].\nexact H.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nintros.\nrewrite H.\napply lt_opp_itself.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros.\napply (le_opp_OZ xeqn). rewrite H.\nexact H0.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nintros x y H H0.\napply (le_antisym (absZ x) (absZ y)).\napply (le_antisym (absZ x) (absZ y)).\nexact H0.\nexact H1.\nexact H1.\nQed.",
                    "Lemma le_opp_OZ2 : forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y.\nProof.\nintros x y H.\napply (le_antisym (absZ x) (absZ y)); trivial.\nexact H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\n",
                "context_tokens": 121,
                "proof_start_offset": 1253,
                "proof_end_offset": 1349,
                "proof": "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\nsimple destruct n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  simple induction n.  simpl in |- *.  intro.  left; assumption.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nintros n; case n.\nintro n; case n.\nintros.\nexists (S n); auto with arith.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n; intros.\nleft; discriminate.\nright; elim n; intros.\nright; right; reflexivity.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nleft; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nleft; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nleft; elim n; intros.\nright; elim n; intros.\nleft; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim n; intros.\nright; elim nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nsimpl in |- *; auto with arith.\nintros n0 H m H; elim H; auto with arith.\nintros n1 H1; elim H1; auto with arith.\nintros n2 H2; elim H2; auto with arith.\nintros n3 H3; elim H2; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n3 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n2 H3; elim H3; auto with arith.\nintros n3 H4; elim H3; auto with arith.\nintros n3 H4; elim H4; auto with arith.\nintros n3 H4; elim H4; auto with arith.\nintros n3 H4; elim H4; auto with arith.\nintros n3 H5; elim H5; auto with arith.\nintros n3 H4; elim H4; auto with arith.\nintros n3 H5; elim H4; auto with arith.\nintros n3 H5; elim H4; auto with arith.\nintrosQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n; simpl in |- *; auto with arith.\nintros n0 H1; elim H1; auto with arith.\nintros n0 H2; elim H2; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n0 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros n1 H3; elim H3; auto with arith.\nintros nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  simple induction n.\n  left. reflexivity.\n  right.\n  right.\n  reflexivity.\n  left.\n  reflexivity.\n  left.\n  reflexivity.\n  left.\n  reflexivity.\n  right.\n  reflexivity.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nsimple induction n.\nintro.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nrewrite H0.\nreflexivity.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nintros n.\nelim n.\nrewrite (plus_comm n 1).\nrewrite (plus_comm n 1).\napply eq_add.\napply eq_add.\napply eq_add.\napply eq_add.\napply eq_add.\napply eq_add.\ntrivial.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  simple induction n.\n  left; reflexivity.\n  right; reflexivity.\nQed.",
                    "Lemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\nProof.\n  simple induction n.\n  simpl in |- *.  intros.  elim (sumbool_of_bool (Neqb n n)).  intro H1.\n  rewrite H1 in H1.  discriminate.  intro H1.  rewrite H1 in H1.  discriminate H1.\n  intro H1.  rewrite H1 in H1.  discriminate.  intro H1.  rewrite H1 in H1.  discriminate H1.\n  intro H1.  rewrite H1 in H1.  discriminate H1.  intro H1.  rewrite H1 in H1.  discriminate H1.\n  intro H1.  rewrite H1 in H1.  rewrite H1 in H1.  discriminate H1.  intro H1.  rewrite H1 in H1.  discriminate H1.\n  intro H1.  rewrite H1 in H1.  rewrite H1 in H1.  discriminate H1.\n  intro H1.  rewrite H1 in H1.  rewrite H1 in H1.  discriminate H1.\n  intro H1.  rewrite H1 in H1.  rewrite H1 in H1.  discriminate H1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\n",
                "context_tokens": 164,
                "proof_start_offset": 1370,
                "proof_end_offset": 1528,
                "proof": "Lemma mult_commut : forall n m : nat, n * m = m * n.\nProof.\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros n m; elim n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros n m; elim n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_commut : forall n m : nat, n * m = m * n.\nintros n m; elim n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 224,
                "proof_start_offset": 1548,
                "proof_end_offset": 1637,
                "proof": "Lemma mult_neutr : forall n : nat, 1 * n = n.\nProof.\nunfold mult in |- *; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nintros; elim n; simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\n\nsimple destruct n; auto with arith.\nQed.",
                    "Lemma mult_neutr : forall n : nat, 1 * n = n.\nsimple destruct n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\n",
                "context_tokens": 261,
                "proof_start_offset": 1662,
                "proof_end_offset": 1875,
                "proof": "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nProof.\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim m; simpl in |- *; auto with arith.\nintros y0 H; elim H; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; elim (plus_O_eq y m); auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nunfold mult in |- *; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros y m.\nelim m; simpl in |- *; auto with arith.\nintros; elim mult_n_Sm; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nsimple induction y; simpl in |- *; auto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros.\nelim (plus_n_O y m); auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *; auto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim n; simpl in |- *.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl inQed.",
                    "Lemma technical_lemma : forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\nintros; elim m; simpl in |- *.\nintros; rewrite H; rewrite H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\n",
                "context_tokens": 352,
                "proof_start_offset": 1894,
                "proof_end_offset": 2016,
                "proof": "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim (plus_comm m (y + m)); auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; intros; auto with arith.\nrewrite H; elim plus_n_Sm; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple destruct n; auto with arith.\nintros n0 H; elim H; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *.\nintros; elim H0; intros.\napply lt_minus.\nelim H; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelimQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nintros m H H0; elim (lt_n_O _ H).\nintros m H H0; elim (le_Sn_O _ H).\nintros m H H0; elim (lt_n_O _ H).\nintros m H H0; elim (lt_O_Sn _ H).\nintros m H0; elim (lt_n_O _ H).\nintros m H H0; elim (lt_n_O _ H).\nintros m H0 H1; elim (le_Sn_O _ H).\nintros m H0; elim (le_Sn_O _ H).\nintros m H H0; elim (le_Sn_O _ H).\nintros m H0; elim (le_Sn_O _ H).\nintros m H H0 H1; elim (le_Sn_O _ H).\nintros m H H1; elim (le_Sn_O _ H).\nintros m H H1; elim (le_Sn_O _ H).\nintros m H H1 H2; elim (le_Sn_O _ H).\nintros m H H2;Qed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; simpl in |- *; auto with arith.\nintros; rewrite H; auto with arith.\nQed.",
                    "Lemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\n",
                "context_tokens": 400,
                "proof_start_offset": 2036,
                "proof_end_offset": 2173,
                "proof": "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nProof.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros n m; elim n; simpl in |- *.\nintros m0 H H0; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros n m; elim n; simpl in |- *.\nintros m0 H' m' H'0; rewrite H'0; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; simpl in |- *; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros.\nsimpl in |- *; elim minus_Sn_m; auto with arith.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction 1; intros; auto with arith.\nQed.",
                    "Lemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\nsimple induction n; intros; simpl in |- *.\nrewrite (plus_comm m n); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Nat_complements.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                            Nat_complements.v                             *)\n(****************************************************************************)\nRequire Import Arith.\nRequire Import Compare_dec.\n\n(****************)\nLemma eq_gt_O_dec : forall n : nat, {n = 0} + {n > 0}.\n\nsimple destruct n; auto with arith.\nQed.\n\n(****************)\nLemma mult_commut : forall n m : nat, n * m = m * n.\n\nintros; elim n; simpl in |- *.\nauto with arith.\nintros; rewrite H; elim mult_n_Sm; auto with arith.\nQed.\n\n(***************)\nLemma mult_neutr : forall n : nat, 1 * n = n.\n\nunfold mult in |- *; auto with arith.\nQed.\n\n(********************)\nLemma technical_lemma :\n forall y m : nat, S (y * m + (y + m) + m) = S y * m + (S y + m).\n\nintros; simpl in |- *; elim (plus_comm m (y * m + (y + m))).\nrewrite (plus_assoc m (y * m) (y + m)); auto with arith.\nQed.\n\n(**************)\nLemma lt_minus2 : forall n m : nat, n < m -> 0 < m - n.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(***************)\nLemma minus_n_Sm : forall n m : nat, m < n -> pred (n - m) = n - S m.\n\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.\n\n(************)\n",
                "context_tokens": 456,
                "proof_start_offset": 2190,
                "proof_end_offset": 2319,
                "proof": "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nProof.\nintros; elim (le_lt_eq_dec n (S m) H); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim (lt_eq_dec n m); elim (plus_comm m n);\n auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction n; intros; elim minus_Sn_m; auto with arith.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros n m; elim n; simpl in |- *; auto with arith.\nintros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros.\nleft; elim minus_Sn_m; auto with arith.\nright; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nintros n m H H0; elim H; simpl in |- *; auto with arith.\nQed.",
                    "Lemma lt_succ : forall n m : nat, n <= S m -> {n <= m} + {n = S m}.\nsimple induction 1; intros; elim minus_Sn_m; auto with arith.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d.\n  destruct a as [[a b] d].\n  destruct b as [[a b] d].\n  destruct d as [[a b] d].\n  simpl.\n  destruct H as [H1 H2].\n  simpl.\n  destruct H2 as [H2 H3].\n  simpl.\n  destruct H3 as [H4 H5].\n  simpl.\n  destruct H4 as [H5 H6].\n  simpl.\n  destruct H5 as [H7 H8].\n  simpl.\n  destruct H7 as [H8 H9].\n  simpl.\n  destruct H10 as [H10 _].\n  simpl.\n  destruct H12 as [H12 H13].\n  simpl.\n  destruct H12 as [H13 H14].\n  simpl.\n  destruct H12 as [H12 H13].\n  simpl.\n  destruct H12 as [H12 H13].\n  simpl.\n  destruct H12 as [H12 H13].\n  simpl.\n  destruct H12 as [H13 H14].\n  simpl.\n  destruct H13 as [H12 H13].\n  simpl.\n  destruct H12 as [H12 H14].\n  simpl.\n  destruct H13 as [HQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct d; simpl in *.\n destruct H; auto.\n apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=H).\n intros; auto.\n intros; apply Zis_gcd_for_euclid with (1:=HQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nunfold Zgcd_bound.\ndestruct b; intuition.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfoldZgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestruct H.\nunfold Zgcd_bound in H.\ndestructQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n apply Zis_gcd_for_euclid with (1:=H) (2:=H) (3:=H) (3:=H) (4:=H) (4:=H) (5:=H) (5:=H) (5:=H) (5:=H) (6:=H) (6:=H) (5:=H) (7:=H) (6:=H) (7:=H) (7:=H) (6:=H) (6:=H) (7:=H) (7:=H) (6:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7:=H) (7Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n apply Zis_gcd_for_euclid.\n apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; apply Zis_gcd_for_euclid.\n intros; applyQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n destruct b; simpl; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct d; simpl; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros.\n  assert (H := Zgcd_correct a (b - a) d).\n  assert (H' := Zgcd_correct b (b - a) d).\n  unfold Zgcd_correct in H.\n  apply Zgcd_correct in H.\n  omega.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H;\n apply Zgcd_is_gcd; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct d as [ | d| d];\n  intros H; destruct d; try discriminate;\n  intros H;\n  destruct H;\n  try solve [apply H; simpl; auto with zarith].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 732,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\n  replace y with (y-x).\n  apply Z.lt_le_trans with (y-x).\n  apply Z.lt_le_trans with (y-x).\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.le_trans with (y-x); auto.\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.le_trans with (y-x); auto.\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.le_trans with (y-x); auto.\n  apply Z.le_trans with (y-x); auto.\n  apply Z.lt_le_trans with (y-x); auto.\n  apply Z.le_trans with (y-x); auto.\n  apply ZQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  generalize (Z.leb_le_iff x y H); intros.\n  generalize (Z.gtb_le x y H0); intros.\n  generalize (Z.gtb_le y x H0); intros.\n  omega.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\n  replace y with (y-x).\n  auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; auto.\n  intros.\n  apply Z.lt_irrefl with x; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; unfold Zneq_bool; simpl; intuition congruence.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z_le_dec x y); intros.\n  subst; auto with zarith.\n  replace y with (x-y).\n  replace y with (y-x).\n  apply Z.mul_reg_l with (y-x).\n  replace (x-y) with (y-y).\n  apply Z.mul_reg_l with (y-x).\n  now ring.\n  rewrite H; auto with zarith.\n  ring.\n  replace (x-y) with (y-x).\n  apply Z.mul_reg_l with (y-x).\n  now ring.\n  rewrite H; auto with zarith.\n  ring.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H H0; case H; constructor; intuition (auto with zarith).\n  replace x with y; auto with zarith.\n  destruct y; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H H0; case H; constructor; intuition (auto with zarith).\n  replace y with (y-x); auto with zarith.\n  replace y with (y-x); auto with zarith.\n  change (Z.of_nat 0) with (Z.of_nat 1).\n  rewrite <- Z.opp_add; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; subst; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zeq_bool_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_true; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zeq_bool_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zgt_lt_bool_iff; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false; generalize H0; clear H0; unfold Zneq_bool. case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zgt_not_eq; generalize H0; unfold Zneq_bool. case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zneq_bool_false; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\n",
                "context_tokens": 702,
                "proof_start_offset": 4191,
                "proof_end_offset": 4728,
                "proof": "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\nintros x0 y0.\napply PHL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e'=> forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nintuition auto with zarith.\ncutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; split; intros H;\n try solve [ now rewrite H0; apply Z.divide_0_l; auto with zarith\n (* left *)\n now apply Z.divide_0_l.\n (* right *)\n now apply Z.divide_0_l.\n (* right *)\n now apply Z.divide_0_l.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divide_0_l.\n (* right *)\n now apply Z.divide_0_r.\n (* right *)\n now apply Z.divideQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold Zeq_bool.\n destruct (Req_dec y0 y0) as [H|H]; [|destruct H as [H0|H0];\n destruct (Z.eq_dec y0 y0) as [H1|H1];\n destruct (Z.eq_dec y0 y0) as [H2|H2];\n [rewrite H2 in H1; discriminate H1 | | | ]; try discriminate; auto.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold gcd; case (Req_dec x0 y0); intros H1;\n rewrite H1 in H; inversion H; subst; auto with zarith.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0; unfold Z.lt, Z.le, Z.le; destruct (Z.eq_dec x0 y0); auto;\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  tryQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; split; intros H1; subst; auto.\n apply Z.lt_le_trans with (Z.gcd x0 y0).\n apply H1.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.gcd_greatest.\n apply Z.Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold Z.le; destruct (Zeq_bool_eq x0 y0); auto.\n apply Z.lt_gt_iff.\n destruct (Z.eq_dec x0 y0); auto.\n apply Z.lt_gt_iff.\n destruct (Z.eq_dec x0 y0); auto.\n apply Z.lt_gt_iff.\n apply Z.lt_gt_iff.\n apply Z.lt_gt_iff.\n apply Z.lt_le_trans with (Z.succ y0); auto.\n now apply Z.lt_le_trans with y0; auto.\n now apply Z.le_lt_trans with y0; auto.\nQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0.\n unfold gcd.\n destruct (Z.eq_dec x0 y0).\n left. split; auto.\n right. intro H.\n destruct H.\n left; auto.\n right. intro H.\n destruct H.\n right. intro H.\n destruct H.\n left.\n reflexivity.\n right. intro H.\n destruct H.\n left.\n reflexivity.\n right. intro H.\n destruct H.\n left.\n reflexivity.\n right. intro H.\n destruct H.\n right. intro H.\n destruct H.\n left.\n left.\n right. intro H.\n destruct H.\n left.\n right. intro H.\n destruct H.\n right. intro H.\n destruct H.\n right. intro H.\n destruct H.\n left.\n right. intro H.\n left.\n left.\n assumption.\n left. intro H.\n destruct H.\n left.\n right. intro H.\n destruct H.\n right. intro H.\n destruct H.\n left.\n left.\n assumption.\n right. intro H.\n destruct H.\n right. intro H.\n destruct H.Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n  intros x0 y0.\n  case (Req_dec y0); intros H1.\n  auto.\n  replace y0 with (y0 - x0) by omega.\n  replace y0 with (y0 - x0) by omega.\n  rewrite (Z.mul_comm y0) in H1.\n  apply Z.lt_le_trans with (y0 - x0) by omega.\n  apply Z.lt_le_trans with (y0 - y0) by omega.\n  apply Z.lt_le_trans with (y0 - y0) by omega.\n  apply Z.lt_le_trans with (y0 - y0) by omega.\n  apply Z.le_trans with (y0 - y0) by omega.\n  apply Z.le_sub_trans with (y0 - y0) by omega.\n  apply Z.le_sub_trans with y0; auto with zarith.\n  apply Z.le_trans with (y0 - y0) by omega.\n  apply Z.le_trans with (y0 - y0) by omega.\n  apply Z.le_trans with (y0 - y0Qed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold gcd.\n destruct (Z_dec x0) as [H|H]; try easy;\n unfold gcd; simpl; split; try discriminate;\n try (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (intros; discriminate);\n (introsQed.",
                    "Lemma gcd_partial_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) |= gcd {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0; unfold Zneq_bool, Zneq_bool in *; case (dec x0?= y0)%Z; intros H1;\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n   try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  try (intros; discriminate);\n  tryQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "var A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\nLemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y; unfold Zneq_bool.\n intros H H0; subst.\n rewrite Zcompare_refl in H.\n discriminate.\nQed.\n\nHint Resolve Zneq_bool_true Zneq_bool_false Zle_bool_imp_le Zis_gcd_intro: zarith.\n\n(** ** Partial correctness proof of [gcd] *)\nLemma gcd_partial_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0) \n   |= gcd  {= fun e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\n",
                "context_tokens": 693,
                "proof_start_offset": 4775,
                "proof_end_offset": 6000,
                "proof": "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\nintros x0 y0.\napply THL.soundness.\nsimpl.\nintros e; intuition subst.\nconstructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\ forall d, (Zis_gcd (VX e') (VY e') d) ->(Zis_gcd (VX e) (VY e) d)); simpl.\nconstructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\nconstructor 1.\napply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\nauto with datatypes.\nunfold Zwf; simpl; (intuition auto with zarith).\ncutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\ncut ((fst e')<=(snd e')); auto with zarith.\ncut ((fst e')<>(snd e')); auto with zarith.\ncut (~(fst e')<=(snd e')); auto with zarith.\nintros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply QL_case_eq; intros.\n apply Zgcd_eq.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_gcd_for_euclid2; auto with zarith.\n apply Zis_Qed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0; unfold gcd, gcd; simpl.\n intros (H1,H2) (H3,H4) (H5,H6) H6.\n destruct (FST_ok x0 y0) as (g,H6).\n destruct (FST_ok y0 y0) as (g,H7).\n destruct (FST_ok y0 y0) as (g,H8).\n destruct (FST_ok y0 y0) as (g,H9).\n destruct (FST_ok y0 y0) as (g,H9).\n destruct (FST_ok y0 y0) as (g,H10).\n destruct (FST_ok y0 y0) as (g,H10).\n destruct (FST_ok y0 y0 y0) as (g,H10).\n destruct (FST_ok y0 y0 y0) as (g,H10).\n destruct (FST_ok y0 y0 y0 y0) as (g,H10).\n destruct (FST_ok y0 y0 y0) asQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply Z.lt_le_trans with (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=z0).\n apply Z.lt_le_trans with (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=z0).\n apply Z.lt_le_trans with (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=x0) (z:=z0).\n apply Z.lt_le_trans with (z:=x0) (z:=x0) (z:=z0) (z:=z0) (z:=x0) (z:=z0).\n apply Z.lt_le_trans with (z:=x0) (z:=z0) (z:=z0) (z:=z0).\n apply Z.lt_le_trans with (z:=x0)Qed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0.\n apply PL.\n intros.\n compute in H; discriminate.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros.\n unfold gcd, gcd.\n rewrite Z.compare_antisym.\n repeat rewrite Z.compare_antisym; repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite Z.compare_antisym;\n  repeat rewrite Z.compare_antisym; try rewrite Z.compare_antisym; try rewrite ZQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n unfold gcd, gcd.\n case_eq (x?= y0)%Z; intros H1.\n destruct (CompSpec2Type (fun e => (VX e)) (VY e)) as (g,(H1,H2)).\n generalize (Z.gcd_finite x0 y0). \n rewrite Z.gcd_for_euclid2.\n generalize (Z.gcd_for_euclid2 x0 y0 (Zpos x) y0). \n rewrite Z.gcd_for_euclid2.\n generalize (Z.gcd_for_euclid2 x0 y0 (Zpos x) y0).\n destruct (Z.gcd_for_euclid2 x0 y0 y0) as (g,(H1,H2)).\n generalize (Z.gcd_for_euclid2 x0 y0 (Zpos x) y0).\n destruct (Z.gcd_for_euclid2 x0 y0 y0) as (g,(H1,H2)).\n generalize (Z.gcd_for_euclid2 x0 y0 y0).\n rewrite Z.gcd_for_euclid2.\n generalize (Z.gcd_forQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply PL_dec; generalize H; clear H; unfold Zneq_bool; auto with zarith.\n intros d; unfold Z.le, Z.le, Z.le in *; simpl in *.\n destruct (Z_le_dec (Z.pos d) (Z.pos d)); simpl; auto with zarith.\n intros d; unfold Z.le, Z.le in *; simpl in *.\n destruct (Z_le_dec (Z.pos d) (Z.pos d)); simpl; auto with zarith.\n intros d; unfold Z.le, Z.lt, Z.le in *; simpl in *.\n destruct (Z_le_dec (Z.pos d) (Z.pos d)); simpl; auto with zarith.\n intros d; unfold Z.le, Z.lt, Z.lt, Z.lt, Z.lt; simpl in *;\n auto with zarith.\n intros d; unfold Z.le, Z.lt in *; simpl in *;\n destruct (Z_le_dec (Z.pos d) (Z.pos d)); simpl; auto with zarith.\n intros d; unfold Z.le, ZQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply PL.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.Qed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply (fun e => (fun e => (VZ_of_P (Zpos e)) (Zpos (Zpos e)) (Zpos (Zpos (Zpos e))); simpl.\n intuition.\n intros e; intuition subst.\n unfold Z_of_P in H0; unfold gcd in H0; simpl in H0; rewrite H0; auto.\nQed.",
                    "Lemma gcd_total_proof: forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0) |= gcd [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n unfold gcd.\n destruct (decompose_informative x0 y0) as [H|H];\n [ try discriminate | auto with zarith].\n replace y0 with (y0 + x0 + x0 + y0)%Z.\n apply H.\n unfold gcd.\n destruct (decompose_informative x0 y0) as [H|H];\n [ try discriminate | auto with zarith ].\n replace y0 with (y0 + x0 + x0 + y0)%Z.\n apply H.\n unfold gcd.\n destruct (decompose_informative x0 y0) as [H'|H'];\n [ try discriminate | auto with zarith ].\n replace y0 with (y0 + x0 + y0)%Z.\n apply H.\n unfold gcd.\n destruct (decompose_informative x1 y0) as [H'|H'];\n [ try discriminate | auto with zarith ].\n replace y0 with (y0 + x0 + y0)%Z.\n apply H.\n unfold gcd.\n destruct (decompose_informative x1 y0) as [H'|H'];\n [ try discriminate | auto with zarith ].\n replace y0 with (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": "un e => (Zis_gcd x0 y0 (VX e)) =}.\nProof.\n intros x0 y0. \n apply PHL.soundness.\n simpl.\n intros e; intuition subst.\n (** after PO generation, I provide the invariant and simplify the goal *) \n constructor 1 with (x:=fun e'=> \n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n intuition auto with zarith.\n (** - invariant => postcondition *)\n cutrewrite <- ((fst e')=(snd e')) in H; auto with zarith.\nQed.\n\n\n(** ** Total correctness proof of [gcd] *)\n\nLemma gcd_total_proof: \n forall x0 y0, (fun e => (VX e)=x0 /\\ (VY e)=y0 /\\ x0 > 0 /\\ y0 > 0)\n  |= gcd  [= fun e => (Zis_gcd x0 y0 (VX e)) =].\nProof.\n intros x0 y0. \n apply THL.soundness.\n simpl.\n intros e; intuition subst.\n (** after simplification, I provide the invariant and then the variant *) \n constructor 1 with (x:=fun e' => (VX e') > 0 /\\ (VY e') > 0 /\\\n  forall d, (Zis_gcd (VX e') (VY e') d)\n              ->(Zis_gcd (VX e) (VY e) d)); simpl.\n constructor 1 with (x:=fun e1 e0 => Zwf 0 ((VX e1)+(VY e1)) ((VX e0)+(VY e0))).\n (** - proof that my variant is a well_founded relation *) \n constructor 1.\n apply wf_inverse_image with (f:=fun e=>(VX e)+(VY e)).\n auto with datatypes.\n (** - other goals *)\n  unfold Zwf; simpl; (intuition auto with zarith).\n (** -- invariant => postcondition \n      --- gcd part like in partial correctness proof \n *)\n  cutrewrite <- ((fst e')=(snd e')) in H5; auto with zarith.\n  (** --- new VY in branch \"then\" is positive *)\n  cut ((fst e')<=(snd e')); auto with zarith.\n  cut ((fst e')<>(snd e')); auto with zarith.\n  (** --- new VX in branch \"else\" is positive *)\n  cut (~(fst e')<=(snd e')); auto with zarith.\n  intros X; rewrite (Zle_imp_le_bool _ _ X) in H4.\n  discriminate.\nQed.\n\n(** ** Another example: infinite loops in partial correctness.\n\nBasic Hoare logic is not well-suited for reasoning about non-terminating programs.\nIn total correctness, postconditions of non-terminating programs are not provable.\nIn partial correctness, a non-terminating program satisfies any (unsatisfiable) postcondition.\n\nFor example, in an informal \"meaning\", the program below enumerates all multiples of 3. But this meaning \ncan not be expressed here (even in partial correctness).\n*)\n\nDefinition enum_3N := \n  (Iseq (Iset VX (const 0))\n        (Iwhile (const true)\n                (Iset VX (PLUS VX (const 3))))).\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6625,
                "proof_end_offset": 6819,
                "proof": "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\napply PHL.soundness.\nsimpl.\nconstructor 1 with (x:=fun _:Env => True).\nintuition (discriminate || auto).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nassert (H:= Hi_nil).\nunfold enum_3N, enum_4 in H.\nset (i:= fun e => nth i (enum_5p e) (enum_5p e)) in *.\nset (i:=fun e => nth i (enum_5p e) (enum_5p e)) in *.\nset (i:= fun e => nth i (enum_5p e)) in *.\nset (i:= fun e => nth i (enum_5p e) (enum_5p e)) in *.\nassert (H1:= Hi_nil).\nassert (H2:= Hi_uniq).\nassert (H3:= Hi_uniq).\nunfold i in H4, H5.\nset (i:= fun e => nth i (enum_5p e) (enum_ 10p e)) in *.\nset (i:= fun e => nth i (enum_ discriminatep e) (enum_5p e)) in *.\nset (i:= fun e => nth i (enum_ 10p e) (enum_ 10p e)) in *.\nset (i:= fun e => nth i (enum_5p eQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nunfold enum_4I.\nsimpl.\nintros.\napply (well_founded_ind (image := base) (fun e => (T2Z (Npos e)) = 0)); auto with arith.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nunfold enum_3M, enum_4, enum_4, enum_8, enum_rankK.\nrewrite enum_rankK_in_eq; auto with arith.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\ninduction e.\nsimpl; tauto.\nsimpl.\ninduction e.\nsimpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e; simpl; tauto.\nsimpl.\ninduction e;Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\nassert (forall i, i < i -> exists i, i < i -> exists i, i < i /\\ i < i) as H; auto with arith.\nintros i Hi.\napply H; clear H; intros.\nset (i := fun e => nth i (enum_4p e) i) in *.\nset (i := fun e => nth i (enum_4p e) i) in *.\nset (i' := fun e => nth i' (enum_4p e) i) in *.\nassert (i = i') as H by (rewrite nth_enum_rank_in in H; destruct H; auto).\nsubst i'.\nexists i', i'; split; auto.\nrewrite nth_enum_rank_in in H; destruct H; auto.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros; simpl.\nintros.\nunfold enum_4I.\nunfold enum_4I.\nrewrite enum_rankK_in_simpl.\nsimpl.\nintros.\ndestruct x; destruct y; simpl; auto with arith.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nintros.\nsimpl.\nintros e; simpl.\napply pred_ext.\napply eq_refl.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nextensionality x; apply pred_ext.\nintros.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:= fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nset (x:=fun e' => eq_nat_dec e' x) in *.\nQed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\ninduction e; simpl; intros.\nsubst.\ndestruct a as [x c].\nunfold enum_3N.\napply enum_in_map_inv in H.\ndestruct H as [??].\ndestruct H as [x [y [H1 H2]]].\nsubst.\nrewrite <- (H2 _ (eq_refl (S x))) in H4.\nsimpl in H4.\ndestruct (eq_nat_dec x x0).\nsubst.\nrewrite <- (H2 _ (eq_refl (S x))) in H4.\nsimpl in H4.\ndestruct H4 as [??].\nsubst.\nrewrite <- (H2 _ (eq_refl (S x)) in H4.\nsimpl in H4.\ndestruct H4 as [??].\nsubst.\nrewrite <- (H2 _ (eq_refl (S x))) in H4.\nsimpl in H4.\ndestruct H4 as [??].\nsubst.\nrewrite <- (H2 _ (eq_refl (S x)) in H4.\nsimpl in H4.\ndestruct H4 as [??].\nsubst.\nrewrite <- (H2 _ (eq_refl (Qed.",
                    "Lemma enum_3N_stupid: (fun e => True) |= enum_3N {= fun e => False =}.\nProof.\nextensionality.\npose (K := list (K * K) * K).\npose (K := list (K * K)).\npose (K := list (K * K) * K).\npose (K := list (K * K)).\npose (K' := list (K * K') * K').\npose (K' := list (K * K') * K').\npose (K' := list (K * K') * K').\npose (K' := list (K * K')).\npose (K' := list (K * K') * K').\npose (K' := list (K * K')).\npose (K' := list (K * K') * K').\npose (K' := list (K * K')).\npose (K' := list (K * K')) in K'.\npose (K' := list (K * K') * K').\npose (K' := list (K * K') * K').\npose (K' := list (K * K') * K').\npose (K' := list (K * K') * K').\npose (K' := list (K * K') * KQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "(** * Generation of Hoare proof obligations in total correctness\n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file gives a syntactic definition of the weakest precondition [wp]\n introduced in #<a href=hoarelogicsemantics.html>#[hoarelogicsemantics]#</a>#.\n We refine here the approach of  #<a href=partialhoarelogic.html>#[partialhoarelogic]#</a>#.\n*)\n\nGlobal Set Asymmetric Patterns.\nSet Implicit Arguments.\nRequire Export hoarelogicsemantics.\nRequire Wf.\n\nModule TotalHoareLogic (HD: HoareLogicDefs).\n\nExport HD.\nModule HLD:=HD.\n\nDefinition sem_wp := wp.\n\nExport Wf.\n\n(** * Syntactic definition of the weakest precondition.\n\n In the following, we show that this definition is logically\n equivalent to [wp].\n *)\nFixpoint synt_wp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n          ((E.eval cond e)=true -> (synt_wp p1 post e))\n       /\\ ((E.eval cond e)=false -> (synt_wp p2 post e))\n  | (Iseq p1 p2) => synt_wp p1 (synt_wp p2 post) e\n  | (Iwhile cond p) =>  \n        exists inv:Pred,\n        exists R:E.Env -> E.Env -> Prop,\n             (well_founded R)\n          /\\ (inv e)\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=false -> post e')\n          /\\ (forall e', (inv e') \n                  -> (E.eval cond e')=true -> synt_wp p inv e')\n          /\\ (forall e0, (inv e0)\n                  -> (E.eval cond e0)=true -> synt_wp p (fun e1 => R e1 e0) e0)\n  end.\n\n(** * Soundness *)\n\n(** Monotonicity is also trivially satisfied by [wp].\n    We need it here to prove the soundness.\n*)\n",
                "context_tokens": 530,
                "proof_start_offset": 1747,
                "proof_end_offset": 1962,
                "proof": "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\ninduction p; simpl; firstorder eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p ps ps1 ps2.\n  apply (ex_intro ps1 ps2).\n  intros e.\n  apply (ex_intro ps2).\n  intros e.\n  apply (ex_intro ps2).\n  intros e.\n  apply (ex_intro ps2).\n  intros e.\n  apply (ex_intro ps2).\n  intros e.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3).\n  intros e'.\n  apply (ex_intro ps3Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p.\n  induction p.\n  + (* F_ind *)\n    simpl; intros.\n    inversion H.\n  + (* F_ind *)\n    simpl; intros.\n    inversion H.\n    + (* F_ind *)\n      simpl; intros.\n      inversion H.\n      + (* F_ind *)\n        simpl; intros.\n        inversion H.\n        + (* F_ind *)\n        simpl; intros.\n          inversion H.\n          * (* F_ind *)\n          simpl; intros.\n          inversion H.\n          * (* F_ind *)\n          simpl; intros.\n          inversion H.\n          * (* F_ind *)\n          simpl; intros.\n            inversion H.\n            * (* F_ind *)\n            simpl; intros.\n            inversion H.\n            * (* F_ind *)\n            simpl; intros.\n            inversion H.\n            * (* F_ind *)\n            simpl; intros.\n            inversion H.\n            * (* F_ind *)\n            simpl; intros.\n            inversion H.\n            * (* F_ind *)\n              simpl; intros.\n              inversion H.\n              * (* F_ind *)\n              simpl; intros.\n              inversion H.\n              * (* F_ind *)\n              simpl; intros.\n              inversion H.\n              * (* F_Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p.\n  induction p.\n  - intros; inversion H; subst; clear H.\n    + intros.\n      inversion H; subst; clear H.\n      destruct p as [p [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [p [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [p [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [x [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [p [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [p [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [x [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [x [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [x [H1 H2]].\n      inversion H2; subst; clear H2.\n      destruct p as [x [H1 H2]].\n     Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p.\n  remember (p _ _ H).\n  apply (p _ _ H0).\nQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros.\n  destruct p as [[e' e'] pr' [e' [e' [e' [e' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [t'' [e'' [e'' [e'' [t'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [e'' [t'' [e'' [t'' [e'' [e'' [e'' [t'' [e'' [e'' [e'' [t'' [e'' [t'' [t'' [e'' [e'' [e'' [tQed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p ps1 ps2.\n  rewrite (pwf_lexprod p ps1) in H.\n  apply H; clear H.\n  apply H; clear H.\n  apply H0; clear H0.\n  apply H0; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H0; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.\n  apply H; clear H0.Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p ps.\n  pose proof (no_release_deterministic p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_stable p ps).\n  pose proof (no_release_Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p.\n  induction p; simpl; intros.\n  destruct st; simpl in *.\n  apply IHp1.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp1.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp1.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp1.\n  apply IHp2.\n  apply IHp1.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp2.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp2.\n  apply IHp2.\n  apply IHp1.\n  apply IHp2.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp2.\n  apply IHp2.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp2.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1.\n  apply IHp2.\n  apply IHp1.\n  apply IHp1.\n  apply IHp1Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros.\n  remember (p (step p post2) e) as q.\n  induction q as [| a xs].\n  - (* A case *)\n    assert (step p (step p post2) e) by (inversion 1; auto).\n    destruct (ex_intro _ _ _ _ _ _ _ _ _ _ H H0) as [R | R].\n    + (* A case *)\n      exists R; split; auto.\n      apply IHre_generalize (no_ refine _ _ _ _ _ _ _ _ H H0); clear H; intro R.\n      destruct H as [R | R].\n      + (* A case *)\n        exists R; split; auto.\n        apply IHre_generalize (no_ refine _ _ _ _ _ H H0); clear H; intro R.\n        destruct H as [R | R].\n        + (* A case *)\n          exists R; split; auto.\n          apply IHre_generalize (no_ refine _ _ _ _ _ H H0); clear H; intro R.\n          destruct H as [R | R].\n          * (* A case *)\n            exists R; split; auto.\n            apply IHre_generalize (no_ refine _ _ _ _Qed.",
                    "Lemma synt_wp_monotonic: forall (p: ImpProg) (post1 post2: Pred), (forall e, post1 e -> post2 e) -> forall e, (synt_wp p post1 e) -> (synt_wp p post2 e).\nProof.\n  intros p.\n  destruct p as [R S].\n  unfold ex_specialize.\n  intros.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "dec2 H2 H.\n generalize Hinv.\n pattern e.\n (* -- here the proof proceeds by induction on the well-founded relation *)\n eapply well_founded_ind; eauto.\n clear Hinv e.\n intros e' X H'.\n set (b:=E.eval cond e').\n cut (E.eval cond e'=b); auto.\n case b; [ idtac | firstorder eauto with hoare ].\n intros H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\n",
                "context_tokens": 707,
                "proof_start_offset": 5789,
                "proof_end_offset": 5976,
                "proof": "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction 1; simpl; try ((firstorder eauto with hoare); fail).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ninduction H; auto.\nintros.\ndestruct e'.\nsimpl in H.\ninversion H.\nintros.\ndestruct H0 as [st [o' J]].\nunfold e'.\nsimpl in H.\ninversion H.\nintros.\ndestruct H0 as [st' [o' J']].\nunfold e'.\nsimpl in H0.\ninversion H0.\nintros.\ndestruct H0 as [st' [o' J']].\nunfold e'.\nsimpl in H0.\ninversion H0.\nintros.\ndestruct H0 as [st' [o' J']].\nunfold e'.\nsimpl in H0.\ninversion H0.\nintros.\ndestruct H0 as [st'' [o' J']].\nunfold e'.\nsimpl in H0.\ninversion H0.\nintros.\ndestruct H0 as [st'' [o'' J''']].\nunfold e'.\nsimpl in H0.\ninversion H0.\nintros.\ndestruct H0 as [st'' [o'' J''']].\nunfold e'.\nsimpl in H0.\ninversion H0.\nintros.\ndestruct H0 as [st'' [Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\nassert (H:=combine_cel _ _ _ _ _ _ _ _ _ _ _ _ H H0).\napply (H0 _ _ _ _ H0).\nunfold update.\nremember (combine_cel _ _ _ _ _ H0) as b; destruct b; intuition.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\nunfold loop2.\ndestruct e; simpl; auto.\ndestruct e; simpl; auto.\ndestruct e; simpl; auto.\ndestruct e'; simpl; auto.\ndestruct e; simpl; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ndestruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destruct e'; try destructQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ninduction H.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nsimpl; auto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ninduction H; auto.\ndestruct e'; auto.\ndestruct H; subst.\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ H H0 H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ H H0 H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ H H0 H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ _ H H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ H H0 H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ _ H H0 H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ H H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ _ H H0 H1).\nsimpl in H.\ndestruct (step_to_steps _ _ _ _ _ _ _ H H1).\nsimpl inQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\ngeneralize (exec_inversion _ _ _ H); clear H; intros H0.\nunfold update in *.\ndestruct (exec_par _ _ _ H H0) as [[i?]?].\nassert (H3:= exec_par _ _ _ _ H3 H4).\nsimpl; unfold update in H2.\ndestruct (exec_par _ _ _ H2 H3) as [[i?]?].\nassert (H3:= exec_par _ _ _ H4).\nsimpl; unfold update in H2.\ndestruct (exec_par _ _ _ H4 H3) as [[i?]?].\nassert (H4:= exec_par _ _ _ H4).\nsimpl; unfold update in H2.\ndestruct (exec_par _ _ _ H2 H3) as [[i?]?].\nassert (H4:= exec_par _ _ _ _ H4).\nsimpl; unfold update in H2.\ndestruct (exec_par _ _ _ H2 H3) as [[i?]?].\nassert (H4:= exec_par _ _ _ _ H4).\nsimpl; unfold update in H2.\ndestruct (exec_par _ _Qed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\nremember (seq_to_label e) as l.\nassert (env_dec l l = true).\napply (H (seq_of_labeled_statement l)).\napply (H (seq_of_labeled_statement l)).\napply (H (seq_of_labeled_statement l)).\nrewrite <- H.\napply (H (seq_of_labeled_statement l)).\nrewrite <- H.\napply (H (seq_of_labeled_statement l)).\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\ninduction e; intros; simpl; auto.\nrewrite exec_left_to_eval_to_eval_to_eval_to_eval; auto.\nrewrite (IHenv e').\nrewrite (IHenv e').\nrewrite (IHenv e').\nauto.\nQed.",
                    "Lemma exec_inversion: forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\nintros.\nassert (env_equiv (subst_env_equiv (subst_env_equiv (subst_env_equiv (subst_env_equiv (subst_env_subst (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_env_eq (subst_envQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "H5.\n case (IHprog (wp (Iwhile cond prog) post) e');\n [ idtac | (unfold wp; firstorder eauto with hoare) ].\n eapply synt_wp_monotonic.\n 2:apply (synt_wp_conj _ _ _ _ (H2 _ H' H5) (H _ H' H5)).\n simpl; unfold wp; intuition auto.\nQed.\n\n(** * Auxiliary lemmas for completeness\n\n   The proof of completeness requires to exhibit a variant. \n   The purpose of the following lemmas is to build this variant.\n*)\n\n(** ** A technical issue: the inversion of [exec]\n\n   If your are not interested in Coq details, you may skip this part\n   which only explains how to avoid the assumption of a (consistent\n   and standard) axiom to prove the completeness.\n\n   Because the use of dependent types in constructor [exec_Iset], the\n   standard inversion of Coq may fail on [exec] (see\n   [exec_test_inversion] below).\n\n   This comes from the fact the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\n",
                "context_tokens": 696,
                "proof_start_offset": 6074,
                "proof_end_offset": 6404,
                "proof": "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\nintros A x expr e e' H.\npattern e'; apply (exec_inversion H); simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x tau e' H.\n  remember (exec e (Abs x expr) e') as e'.\n  remember (exec e' (Abs x expr) e') as e'.\n  remember (exec e' (Abs x expr) e') as e'.\n  remember (exec e' (Abs x expr) e') as e'.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e')) as e''.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e) as e''.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e') as e''.\n  remember (exec e' (Abs x expr) e'') as e''.\n  remember (exec e' (Abs x expr) e'') as e''.\n  remember (exec eQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  rewrite exec_test_inversion in H.\n  destruct (exec e (O.eval e')) as [[e'?] | ].\n  destruct (exec e' (O.eval e')) as [[e'?] | ].\n  - (* E.1 *)\n    destruct (exec e' (O.eval e')) as [[e'?] | ].\n    - (* E.1 *)\n      destruct (exec e' (O.eval e')) as [[e'?] | ].\n      * (* E.1 *)\n        destruct (exec e' (O.eval e')) as [[e''?] | ].\n        * (* E.2 *)\n          subst.\n          rewrite E.\n          rewrite eval_exec_seq_exec_seq_exec_seq_1.\n          rewrite exec_seq_exec_seq_exec_seq_1.\n          rewrite exec_seq_exec_seq_exec_seq_exec_seq_1.\n          rewrite exec_seq_exec_seq_exec_seq_1.\n          rewrite exec_seq_exec_seq_exec_seq_1.\n          rewrite exec_seq_exec_seq_exec_seq_1.\n          rewrite exec_seq_exec_seqQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x tau e' H.\n  induction H; simpl;\n  try (inversion H; clear H; subst; fail).\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\nintros.\ndestruct (exec e (Abs e x)); simpl; auto; intros.\ndestruct (exec e' x); simpl; auto.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros; eapply exec_test_inversion; eauto.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e' H.\n  apply (proj2 (eval_test_inversion A x) H)); auto.\nQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x tau e' H.\n  assert (H1: forall t, eval (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff (O.diff_O.diff (O.diff_O.diff (O.diff (O.diff (O.diff (O.diff_O.diff_O.diff_O_eq(O.diff_O.eq(O.diff_O.diff_O.diff_O).\n  rewrite (O.diff_O_eq(Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros.\n  destruct (exec e' e') eqn:?.\n  + (* E_Skip *)\n    destruct (exec e' e') eqn:?.\n    + (* E_Skip *)\n      exists (E.update (update e' (E.update (E.update e' (E.update (t' ++ e') e')) e')).\n      split.\n        apply (E.update (update (update e' (E.update (update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' e'))) e')).\n        split.\n        apply (E.update (update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.update e' (E.updateQed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e'.\n  remember (eval e' rho) as b.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (eval e' rho) as b'.\n  remember (Qed.",
                    "Lemma exec_test_inversion: forall A (x:E.Var A) expr e e', (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros; subst; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ct the following property is not provable in\n   the core theory of Coq (although it is consistent with it) :\n\n   [forall A (x1 x2:E.Var A) e1 e2, (Iset x1 e1)=(Iset x2 e2) -> x1=x2 /\\ e1=e2.]\n\n   To deal with this problem, we may assume a (consistent) axiom given\n   in #<a href=http://coq.inria.fr/V8.1/stdlib/Coq.Logic.EqdepFacts.html>#\n      [EqdepFacts]#</a>#.\n   But here, we can avoid this axiom.\n\n   Indeed, I define an ad-hoc inversion lemma for [exec] called\n   [exec_inversion] below. This lemma is directly derived from the\n   notion of weakest liberal precondition: [aux_wlp] is an other\n   alternative definition of [wlp].\n\n*)\nDefinition aux_wlp (prog: ImpProg) : Pred -> Pred \n := fun post e =>\n  match prog with\n  | Iskip => post e\n  | (Iset A x expr) => post (E.upd x (E.eval expr e) e)\n  | (Iif cond p1 p2) =>\n       forall e', exec e (if E.eval cond e then p1 else p2) e' \n          -> post e'\n  | (Iseq p1 p2) => forall e1 e2, exec e p1 e1 -> exec e1 p2 e2 -> post e2\n  | (Iwhile cond p) => forall e', exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e' -> post e'\n  end.\n\n(** This lemma is my inversion lemma of [exec]. It expresses the \"soundness\" of [aux_wlp]. *)\nLemma exec_inversion:\n  forall prog e e', (exec e prog e') -> forall post, (aux_wlp prog post e) -> post e'.\nProof.\n  induction 1; simpl;\n  try ((firstorder eauto with hoare); fail).\nQed.\n\n(** Here is the case, where the previous lemma is better than the standard inversion of Coq. *)\nLemma exec_test_inversion:\n  forall A (x:E.Var A) expr e e',\n     (exec e (Iset x expr) e') -> e'=(E.upd x (E.eval expr e) e).\nProof.\n  intros A x expr e e' H.\n  (** Here, try \"[inversion H]\" instead the tactic below. \n      The generated goal is not directly provable. *)\n  pattern e'; apply (exec_inversion H); simpl; auto.\nQed.\n \n(** Below, a little tactic to helps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\n",
                "context_tokens": 712,
                "proof_start_offset": 6917,
                "proof_end_offset": 7168,
                "proof": "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\ninduction 1; intros ef' X; exec_inversion X; eauto.\nintros e1 e2 X1 X2; assert (X3: e'=e1); auto.\nsubst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p. intro H.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_par.\n  apply exec_parQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  induction p; simpl; intros; try congruence.\n  destruct (exec_inversion H0); subst.\n  left; auto.\n  left; auto.\n  right; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  induction ef; intros; try contradiction.\n  inversion H.\n  destruct (exec_inversion H0) as [e' [H1 H2']].\n  destruct (exec_inversion H1) as [e' [H1 H2']].\n  left.\n  exists e'.\n  exists e'.\n  exists e'.\n  auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  apply exec_par_inversion with (exec := exec_par_inversion H); simpl; auto.\nQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p. intros H.\n  destruct op; simpl in *; try discriminate;\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion H; subst; auto);\n  try (inversion HQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  intros.\n  induction H; subst; auto.\n  Case \"exec_inversion H\" as [ exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_inversion H].\n  Case \"exec_inversion H\" as [exec_Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  induction ef; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  try (apply exec_test_inversion; reflexivity || fail).\n  destruct op; simpl;\n  tryQed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  induction 1; intros; auto.\n  Case \"step\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"step\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"loop\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"step\" \"Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  induction H; intros; subst; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p;Qed.",
                    "Lemma exec_deterministic: forall ei p ef, (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  intros until p.\n  induction p; intros; simpl.\n  (* nil *)\n  destruct op; simpl.\n  (* nil *)\n  destruct op; simpl.\n  (* nil *)\n  destruct op; simpl.\n  (* nil *)\n  destruct op; simpl.\n  (* nil *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op0; simpl.\n  (* var *)\n  destruct op1; simpl.\n  (* var *)\n  destruct op1; simpl.\n  (* var *)\n  destruct op1; simpl.\n  (* var *)\n  destruct op1; simpl.\n  (* var *)\n  destruct op2; simpl.\n  (* var *)\n  destruct op2; simpl.\n  (*Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "ps in applying [exec_inversion]. *)\nLtac exec_inversion H :=\n  match type of H with\n  | (exec?e?p?e') => pattern e'; apply (exec_inversion H); simpl; clear H\n  end.\n\n(** ** The programming language is deterministic\n\nThis property is probably not necessary to prove the correctness of my\nvariant, but it simplifies the proof a lot.\n\nThis lemma is a trivial induction over the first [exec] derivation, \nprovided the ad-hoc inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8653,
                "proof_end_offset": 8793,
                "proof": "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\ninduction 1; firstorder (eauto with hoare).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros until p. intro H.\n  assert (H: forall e, eval e (Odo e) = e).\n    induction e; intros; simpl in *; try discriminate.\n    inv H.\n  destruct a as [n e].\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0 e); simpl; auto.\n  (* n e = E0 *)\n  destruct (E0Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros until p. intros H.\n  inversion H. subst. auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros until p.\n  induction p using (well_founded_ind lt_wf lt_wf lt_wf lt_wf).\n  induction p using (well_founded_ind lt_wf lt_wf lt_wf).\n  intros.\n  apply (no_wf (S p) _ H0 H1).\n  destruct H1.\n  apply (no_wf (S p) _ H0 H1).\n  destruct H2.\n  apply (no_wf (S p) _ H1).\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros until p. intros H.\n  generalize dependent p.\n  induction n; intros; simpl; intros; auto.\n  destruct p.\n  (* i *)\n  simpl in H.\n  destruct (execn n p) eqn:?.\n  (* i *)\n  destruct (execn n p) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n p0) eqn:?.\n  (* i *)\n  destruct (execn n pQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\ninduction 1; intros; simpl; auto.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  intros until p.\n  assert (C: e <> Sskip). eauto with rtlg.\n  destruct c; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct p; simpl; auto.\n  destruct pQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\nintros until p.\ndestruct p as [n e' EQ].\ndestruct p as [n e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].\ndestruct e' as [n' e'].Qed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\nintros until p.\ninduction p; intros; simpl; auto.\ndestruct (execn n p) as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n' p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n' p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [n'|] eqn:?.\ndestruct (exec_n n p') as [nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\nintros until p.\ninduction p; simpl; intros.\ninversion H.\nconstructor.\nQed.",
                    "Lemma exec_execn: forall ei p ef, (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\nintros until p.\napply execn_Iseq; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " inversion tactic on the second [exec] derivation.\n*)\nLemma exec_deterministic: forall ei p ef,\n  (exec ei p ef) -> forall ef', (exec ei p ef') -> ef=ef'.\nProof.\n  induction 1; intros ef' X; exec_inversion X; eauto.\n  (* - case [Iseq] *)\n  intros e1 e2 X1 X2; assert (X3: e'=e1); auto.\n  subst; auto.\nQed.\n\n(** ** Definition of the variant \n  Given a program [p] and a boolean expression [cond], the relation on environment \n  \"[reduces cond p]\" is the variant required by \"[synt_wp (Iwhile cond p)]\".\n\n  I prove below that this relation is well-founded.\n*) \nDefinition reduces cond p e1 e0 :=\n  (E.eval cond e0)=true /\\ (exec e0 p e1) /\\ exists ef, (exec e1 (Iwhile cond p) ef).\n\n(** To prove that \"[reduces cond p]\" is well-founded, I want to count  \n    the number of execution of [p] in the computation of \"[Iwhile cond p]\".\n    Indeed, as the language is deterministic, this number is unique.\n\n    Hence, \"[execn n e (Iwhile cond p) e']\" means that \"[exec e (Iwhile cond p) e']\" \n    in a sequence of [n] execution of [p]. \n *)\nInductive execn: nat -> E.Env -> ImpProg -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\n",
                "context_tokens": 739,
                "proof_start_offset": 9000,
                "proof_end_offset": 9914,
                "proof": "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\nunfold well_founded.\nintros cond p e0; apply Acc_intro.\nintros e1 H; unfold reduces in H.\ndecompose [ex and] H; clear H.\nclear H2 H0 e0.\ncase (exec_execn H1).\nintros n.\ngeneralize cond p e1 x; clear cond p e1 x H1.\nelim n.\nintros cond p e0 e1 H; inversion_clear H.\nclear n; intros n HR cond p e0 e1 H.\ninversion_clear H.\ninversion_clear H0.\nset (b:=E.eval cond e0) in * |-.\ncut (E.eval cond e0=b); auto.\ngeneralize H; clear H; case b; simpl.\nintros H; inversion_clear H.\nintros; apply Acc_intro.\nintros e2 H3; unfold reduces in H3.\nintuition.\nrewrite (exec_deterministic H3 H0); eauto.\nintros H H0; apply Acc_intro.\nunfold reduces; rewrite H0.\nintuition.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  intros.\n  induction H.\n  apply (well_founded_ind wf p).\n  apply (well_founded_ind wf p).\n  apply (well_founded_ind wf p).\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold prove_wf; intros; simpl; auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold reduce; intros; simpl.\n  induction p; firstorder.\n  simpl.\n  apply IHm; auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold prove; auto.\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder (eauto with inhabited).\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder (eauto with primitive).\nQed.",
                    "Lemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  induction 1; firstorder (eauto with pair).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "Prog -> E.Env -> Prop :=\n | execn_Iskip:\n    forall e, (execn 0 e Iskip e)\n | execn_Iset:\n    forall (A:Type) e x (expr: E.Expr A),\n     (execn 0 e (Iset x expr) (E.upd x (E.eval expr e) e))\n | execn_Iif:\n    forall n e (cond: E.Expr bool) p1 p2 e',\n       (execn n e (if (E.eval cond e) then p1 else p2) e')\n         -> (execn n e (Iif cond p1 p2) e')\n | execn_Iseq:\n    forall n e p1 p2 e' e'',\n      (exec e p1 e')\n       -> (execn n e' p2 e'')\n         -> (execn n e (Iseq p1 p2) e'')\n | execn_Iwhile:\n    forall n e cond p e',\n     (execn n e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (execn (S n) e (Iwhile cond p) e').\n\nHint Resolve execn_Iskip execn_Iset execn_Iif execn_Iseq execn_Iwhile: hoare.\n\nLemma exec_execn: forall ei p ef,\n  (exec ei p ef) -> (exists n, execn n ei p ef).\nProof.\n  induction 1; firstorder (eauto with hoare).\nQed.\n\n\n(** In the proof below, I mainly use that \"[reduces cond p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\n",
                "context_tokens": 734,
                "proof_start_offset": 10044,
                "proof_end_offset": 11057,
                "proof": "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\nunfold wp.\nintros prog post e H; case H; clear H.\nintros e' H; case H; clear H.\ngeneralize post e e'; clear post e e'; elim prog; clear prog; simpl.\nintros post e e' H; exec_inversion H; auto.\nintros A v expr post e e' H; exec_inversion H; auto.\nintros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\ncase (E.eval cond e); simpl; firstorder auto || discriminate.\nintros p1 Hp1 p2 Hp2 post e e' H.\nexec_inversion H.\neauto.\nintros cond p Hp post e e' H H0.\nconstructor 1 with (x:=wp (Iwhile cond p) post).\nconstructor 1 with (x:=reduces cond p).\nunfold wp; (intuition eauto with hoare); dec2 e1 H1; case H1; clear H1; intros H1; exec_inversion H1; intros e2 H1; exec_inversion H1; rewrite H2; intros e3 H1; exec_inversion H1; unfold reduces; eauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  generalize (step_deterministic _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0); clear H0.\n  pattern st at 1; apply step_deterministic; intros.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; unfold push, us, given.\n  case_eq (step empty nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (S n) nil); intros.\n  case (no_read (SQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; unfold SPEC; simpl.\n  case (is_empty has no_empty); intros.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply hoare_wp; intros.\n  apply H.\n  apply H.\n  apply hoare_seq.\n  apply H.\n  apply hoare_wp;Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; apply hoare_wp; intros; apply hoare_wp; intros;\n    simpl; auto.\n  apply hoare_wp; intros;\n    simpl; auto.\n  apply hoare_wp; intros;\n    simpl; auto.\n  apply hoare_wp; intros;\n    simpl; auto.\n  apply hoare_wp; intros;\n    simpl; auto.\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; apply (H (noInd_Pred st)).\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  do 4 red; intros.\n  apply (box_refl_trans extendM tau).\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; unfold rguards,no_post.\n  destruct (pre_start_stack _ _ H) as [n [??]].\n  destruct n.\n  (* simple case *)\n  simpl; intros.\n  apply (H (S n)).\n  apply (H _ H0).\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros; apply (L_sound st).\n  intros;Qed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros; apply (box_refl _ _ _ _ (box_refl _ _ _ _ _ _)).\n  intros; apply (box_refl _ _ _ _ _ (box_refl _ _ _ _ _ H)).\nQed.",
                    "Lemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n  intros.\n  apply (rel_refl_trans _ _ (box_refl _ _)).\n  apply (rel_refl_trans _ _ _ _ (box_refl _ _ _)).\n  apply (rel_refl_trans _ _ _ (box_refl _ _ _)).\n  apply (rel_refl_trans _ _ _ (box_refl _ _ _)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply H; simpl; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; hnf; intros.\n  destruct H0 as [p' H0].\n  generalize (step_deterministic p' _ _ _ _ _ H0); clear step p.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ _ H0); clear step p.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ H0); clear step p.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ H0); clear step p.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ _ _ H0); clear step p.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ _ _ H0); clear step p'.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ _ _ H0); clear step p'.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ _ H1); clear step p'.\n  intros.\n  generalize (step_deterministic p' _ _ _ _ _ _ _ H1); clear step p.\n  intros.\n  generalize (step_deterministic p' _ _ _ _Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply hoare_fact with (fun p => (EX m:nat, (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <= p)) && (m <= p)).\n  apply hoare_fact with (fun m => (m <=Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; split; intros.\n  destruct H as [i [??]].\n  destruct H as [i [??]].\n  exists i; exists (x::nil).\n  apply stepstar_O with x; auto.\n  apply stepstar_O with x; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; red; intros.\n  apply hoare_wp.\n  apply hoare_wp; auto.\n  apply hoare_wp; auto.\n  apply hoare_weaken; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply hoare_wp; intro;\n    simpl; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_wp; intros.\n  apply hoare_ex; intros.\n  apply hoare_weaken_time; intros.\n  apply hoare_wp; intros.\n  apply hoare_weaken_time; intros.\n  apply hoare_weaken_time; intros.\n  apply hoare_weaken_time; intros.\n  apply hoare_weaken_time; intros.\n  apply hoare_weaken_time; intros.\n  applyQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n intros step st p post H.\nunfold not; intros.\ndestruct st; simpl in H.\ninversion H.\ninversion_clear H.\ninversion_clear H.\n\n(* - case [Istep] *)\nintros s1 st2 H; case H; clear H; intros.\n(* - case [Istep] *)\nintros s1 s2 H; case H; clear H; intros.\n(* - case [Istep] *)\nintros s2 st3 H; case H; clear H; intros.\n(* case [i] *)\nintros s1 s2' H; case H; clear H; intros.\n(* - case [i] *)\nintros s1 s2' H; case H; clear H; intros.\n(* case [i] *)\nintros s1 s2' H; case H; clear H; intros.\n(* case [i] *)\nintros s1 s2' H; case H; clear H; intros.\n(* - case [i] *)\nintros s1 s2' H; case H; clear H; intros.\n(* - case [i] *)\nintros s1 s2' H;Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p.\n  intros; apply hoare_wp; intros.\n  destruct H as [i [i' [? [??]]]].\n  exists i'; exists (i' :: stk'); split; auto.\n  apply hoare_wp; intros.\n  destruct H as [i' [i' [? [??]]]].\n  exists i'; exists (i' :: stk'); split; auto.\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_weaken_time with (i:=i').\n  apply hoare_Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p as [p [r [??]]].\n  generalize (all_ex_intro _ _ H); clear H; case p; intros.\n  apply hoare_weaken with p; auto.\n  apply hoare_weaken with p; auto.\n  apply hoare_weaken with p; auto.\n  apply hoare_weaken with p; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply wp_seq.\n  intros p1 Hp1 p2; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; do 2 rewrite <- box_refl.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros; split; intros.\n  destruct H.\n  apply stepstar_O; auto.\n  apply stepstar_O; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply intro; apply H; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold not; intros.\n destruct (classic (exists l, (forall m, m <= (m /\\ m <= (m <-> m <= (m /\\ m <= (m <-> m <= (m <-> m <= (m <-> m = (m <-> m <= (m <-> m <= (m <-> m))).\nProof.\n  intros [l [l' [H1 H2]]]].\ngeneralize (no_race H1 H2).\nelim H1; clear H1; intros m H2; subst.\napply (H m); auto.\napply (H m); auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct p; simpl; intuition.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct p.\n intros.\n apply step_to_steps with (x:=x); auto.\n apply step_to_steps with (x:=x); auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold ((((In_call_ex, post) & Q); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\n",
                "context_tokens": 556,
                "proof_start_offset": 1603,
                "proof_end_offset": 1825,
                "proof": "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simpl; intros; auto.\n destruct (exec e p1 p2 e'); simplQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\nintros.\nassert (H: (eval e' true) = eval e' false).\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H0.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\neapply exec_Iif_false; eauto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\ninduction e; simpl; intros; auto.\ndestruct a as [x0 x1].\ndestruct H1 as [e'?].\nrewrite H1.\nrepeat rewrite exec_Lif_true; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n eapply exec_Iif_false; eauto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n eapply exec_Iif_false; try eassumption.\n simpl.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply update_o; auto.\n apply updateQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  destruct e; simpl in *; try (discriminate || fail).\n  apply eval_Lif_true; auto.\n  apply eval_Lif_false; auto.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\ndestruct p1; simpl in *; try (rewrite <- beq_correct in *; auto; fail).\napply exec_Lif_true.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros.\ndestruct H.\ndestruct H.\napply Iseq.\napply H.\napply H.\napply H0.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\nQed.",
                    "Lemma exec_Iif_true: forall e cond p1 p2 e', (E.eval cond e)=true -> (exec e p1 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n intros.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iwhile_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_true; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_true; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_true; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; try eassumption.\n eapply exec_Iif_false; tryQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": "(** \n\n This file is part of the \"Tutorial on Hoare Logic\".\n For an introduction to this Coq library,\n see README #or <a href=index.html>index.html</a>#.\n\n This file is mainly verbous. It defines a functor\n \"[HoareLogic: ExprLang -> HoareLogicSem]\".\n It is almost a copy/paste of definitions found in \n #<a href=hoarelogicsemantics.html># \n [hoarelogicsemantics]#</a>#. \n (This is due to the lack of inheritance in the module system of Coq).\n\n\n*)\n  \nSet Implicit Arguments.\n\nRequire Export hoarelogicsemantics.\nRequire Import partialhoarelogic.\nRequire Import totalhoarelogic.\n\nModule HoareLogic(Ex: ExprLang)<: HoareLogicSem with Module E:=Ex.\n\nModule E:=Ex.\n\nModule HLD <: HoareLogicDefs with Module E:=E.\n\nModule E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\n",
                "context_tokens": 646,
                "proof_start_offset": 1829,
                "proof_end_offset": 2053,
                "proof": "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\nintros e cond p1 p2 e' H1 H2.\napply exec_Iif.\nrewrite H1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  rewrite exec_Iif_false; auto.\n  apply exec_Iif.\n  rewrite H2; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H2; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H2; auto.\nQed.",
                    "Lemma exec_Iif_false: forall e cond p1 p2 e', (E.eval cond e)=false -> (exec e p2 e') -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/hoarelogic.v",
                "context": " E:=E.\n\nInductive ImpProg: Type := \n  | Iskip: ImpProg\n  | Iset (A:Type) (v:E.Var A) (expr:E.Expr A): ImpProg\n  | Iif (cond:E.Expr bool) (p1 p2:ImpProg): ImpProg\n  | Iseq (p1 p2:ImpProg): ImpProg\n  | Iwhile (cond:E.Expr bool) (p:ImpProg): ImpProg.\n\nInductive exec: E.Env -> ImpProg -> E.Env -> Prop :=\n | exec_Iskip: \n    forall e, (exec e Iskip e)\n | exec_Iset:\n    forall (A:Type) e x (expr: E.Expr A), \n     (exec e (Iset x expr) (E.upd x (E.eval expr e) e))\n | exec_Iif:\n    forall e (cond: E.Expr bool) p1 p2 e', \n      (exec e (if (E.eval cond e) then p1 else p2) e') \n         -> (exec e (Iif cond p1 p2) e')\n | exec_Iseq:\n    forall e p1 p2 e' e'',\n      (exec e p1 e') \n       -> (exec e' p2 e'')    \n         -> (exec e (Iseq p1 p2) e'')\n | exec_Iwhile:\n    forall e cond p e', \n     (exec e (Iif cond (Iseq p (Iwhile cond p)) Iskip) e')\n        -> (exec e (Iwhile cond p) e').\n\nLemma exec_Iif_true:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=true\n      -> (exec e p1 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nLemma exec_Iif_false:\n  forall e cond p1 p2 e', \n     (E.eval cond e)=false\n      -> (exec e p2 e') \n         -> (exec e (Iif cond p1 p2) e').\nProof.\n  intros e cond p1 p2 e' H1 H2.\n  apply exec_Iif.\n  rewrite H1; auto.\nQed.  \n\nDefinition Pred := E.Env -> Prop.\n\nDefinition wlp: ImpProg -> Pred -> Pred\n := fun prog post e => (forall e', (exec e prog e') -> (post e')).\n\nDefinition wp: ImpProg -> Pred -> Pred\n := fun prog post e => exists e', (exec e prog e') /\\ (post e').\n\n\nNotation \"p |= q\" := (forall e, (p e) -> (q e)) (at level 80, no associativity).\nNotation \"p {= post =}\" := (wlp p post) (at level 70).\nNotation \"p [= post =]\" := (wp p post) (at level 70).\n\nEnd HLD.\n\nExport HLD.\n\nModule PHL<: HoareProofSystem := PartialHoareLogic(HLD). \nModule THL<: HoareProofSystem := TotalHoareLogic(HLD). \n\nImport THL.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 2648,
                "proof_end_offset": 2853,
                "proof": "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\nunfold wp, wlp.\nintros prog post e H e' H'.\ndec2 e0 H.\ndec2 H0 H.\nrewrite (exec_deterministic H' H0).\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n intros; unfold Sskip; reflexivity.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof. intros. induction H; auto. Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  induction vals; simpl; intros; auto.\n  rewrite (H0 nil) at 1.\n  destruct a; simpl; intros.\n  rewrite (H0 nil) at 1.\n  destruct (H0 a); auto.\n  destruct (H0 a); auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros.\n  induction vs; simpl; auto.\n  destruct a; simpl; auto.\n  destruct a0; simpl; auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof. intros; subst; reflexivity. Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof. reflexivity. Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n intros.\n unfold Sskip, Sskip.\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2 H3 H4).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ H0 H1 H2 H4).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1 H3 H4).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ H H0 H1 H2 H3 H4 H5 H6 H7 H8).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ H H1 H3 H4 H5 H6 H7 H8 H8).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1 H2 H3 H4 H5 H6 H7 H8).\n destruct (step_det _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; unfold Sskip; simpl; auto.\nQed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof. intros; reflexivity. Qed.",
                    "Lemma wp_entails_wlp: forall prog post, prog [= post =] |= prog {= post =}.\nProof.\n  intros; unfold Basics.flip, Basics.flip, Basics.flip.\n  apply Refl.\nQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nintros; simpl in |- *; auto with arith.\nintros.\napply sym_equal.\napply (f n n1); auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; auto with arith.\nintros; simpl in |- *; auto with arith.\nintros; simpl in |- *; auto with arith.\nintros; simpl in |- *; auto with arith.\nintros; simpl in |- *; auto with arith.\nintros; simpl in |- *; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto.\nintros; simpl in |- *; auto.\nintros; simpl in |- *; auto.\nintros; simpl in |- *; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto.\nintros; elim n; auto.\nintros; elim n; auto.\nintros; elim n; auto.\nintros; elim n; auto.\nintros; elim n; auto.\nintros; elim n; auto.\nintros; elim n; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with arith.\nintros.\napply (plus_n_O _ _ H0).\nelim plus_n_O; auto with arith.\nintros.\napply (plus_n_O _ _ H0).\nelim plus_n_O; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto.\nintros n0 H.\nelim H; auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with arith.\nintros.\napply sym_equal; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with arith.\nintros; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nintros.\napply le_n_S.\nchange (S (S (S n)) = S (S n)).\napply le_n_S.\nchange (S (S n)) = S (S n)).\napply le_n_S.\nchange (S (S n)) = S (S (S n)).\napply le_n_S.\nchange (S (S n)) = (S (S n)).\napply le_n_S.\nchange (S (S n)) = (S (S n)).\napply le_n_S.\nchange (S (S n)) = S (S n)).\napply le_n_S.\nchange (S (S n)) with (S (S n)).\napply le_n_S.\nchange (S (S n)) = (S (S n)).\napply le_n_S.\nchange (S (S n)) = (S (S n)).\napply le_n_S.\nchange (S (S n)) = (S (S n)).\napply le_n_S.\nchangeSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; intros; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim H; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; intros.\nchange (S (S n)) with (S (n0 + n)); auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim H; auto with arith.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v; pattern t in |- *; rewrite (plus_comm v v); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\npattern t at 1 in |- *; rewrite <- (mult_n_O _ v).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u) (node (node t u) v)).\nrewrite (mult_comm (node t u)Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; apply (double_intro (node t u)); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; pattern t, u, v in |- *; elim u; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v; elim u; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nintros; elim v; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nintros.\nchange (nat_of_P u) with (S (nat_of_P v)).\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plusSave size_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\n",
                "context_tokens": 379,
                "proof_start_offset": 1699,
                "proof_end_offset": 1769,
                "proof": "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros A B C D H.\nelim H.\nelim H0.\nelim H1.\nelim H2.\nelim H2.\nelim H3.\nelim H4.\nelim H1.\nelim H3.\nelim H4.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H6.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H8.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7.\nelim H7Qed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nintro.\napply H.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintro.\napply H.\napply H1.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\nelim (not_le_lt_or_eq A C H H0).\nintros.\napply H.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply (Build_Predicate (P:=A -> B)).\napply (Build_Predicate (P:=A -> B)).\nred; intros; red in |- *; intros; red in |- *; intros.\napply (H4 H1 H2 H3).\nred in |- *; intros; red in H4; apply H4; auto.\nred in |- *; intros; red in H4; apply H5; auto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\nunfold not in |- *; intros.\napply H.\napply H.\napply H.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply (Build_Prop (A -> B) (B -> C)).\nred in |- *; simpl in |- *.\nauto.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros A B C.\nelim H.\nintros.\napply H2.\napply H3.\napply H1.\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros A B C H.\nelim H.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nsplit.\nexact (A2 b).\nexact (A2 b).\nexact (A2 b).\nexact (A1 b).\nQed.",
                    "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nintros.\napply (Build_Prop (A -> B) (B -> C)).\napply (Build_Predicate (A -> B) (B -> C)).\napply (Build_Predicate (A -> B) (B -> C)).\nexact (Build_Predicate (A -> B) (B -> C)).\nexact (Build_Predicate (A -> B) (B -> C)).\nexact (Build_Predicate (A -> B) (B -> C)).\nexact (Build_Predicate (A -> B) (B -> C)).\nexact (Build_Predicate (A -> B) (B -> C)).\nexact (Build_Predicate (A -> B) (B -> C)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 1771,
                "proof_end_offset": 1818,
                "proof": "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \n",
                "context_tokens": 448,
                "proof_start_offset": 1867,
                "proof_end_offset": 1948,
                "proof": "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nProof.\nintro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed.",
                    "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\n",
                "context_tokens": 499,
                "proof_start_offset": 2006,
                "proof_end_offset": 2102,
                "proof": "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\nintro.\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.",
                    "Theorem Ex_Klenne'' : ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\n",
                "context_tokens": 582,
                "proof_start_offset": 2243,
                "proof_end_offset": 2346,
                "proof": "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed.",
                    "Theorem Intu : (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\n",
                "context_tokens": 750,
                "proof_start_offset": 3167,
                "proof_end_offset": 3202,
                "proof": "Lemma NoMember : False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma NoMember : False.\nProof.\ntauto.\nQed.",
                    "Lemma NoMember : False.\napply iff_refl.\nQed.",
                    "Lemma NoMember : False.\nProof.\ntrivial.\nQed.",
                    "Lemma NoMember : False.\nintuition.\nQed.",
                    "Lemma NoMember : False.\nProof.\ntrivial.\nQed.",
                    "Lemma NoMember : False.\nunfold not; intro H; elim H; intros H1; elim H1; intros H2; elim H2; intros H4 H5;\n elim H5; intros H6 H7; elim H7; intros H7 H8; elim H8; intros H9 H10;\n elim H9; intros H10 H11; elim H12; intros H12 H13;\n elim H13; intros H13 H15; elim H15; intros H16 H17; elim H18; intros H17 H18;\n elim H18; intros H18 H20; elim H18; intros H18 H19;\n elim H18; intros H17 H18; elim H18; intros H18 H19;\n elim H18; intros H18 H20; elim H19; intros H20 H20;\n elim H18; intros H18 H18; elim H18; intros H19 H20;\n elim H18; intros H20 H21; elim H23; intros H20 H21;\n elim H20; intros H22 H23; elim H23; intros H24 H24; elim H24; intros H25 H26;\n elim H26;Qed.",
                    "Lemma NoMember : False.\nProof.\nsplit.\nexact (refl_equal _)).\nQed.",
                    "Lemma NoMember : False.\nProof.\nexact (fun x y => ~ x /\\ y).\nQed.",
                    "Lemma NoMember : False.\nunfold not in |- *; intros.\nunfold not in |- *; trivial.\nQed.",
                    "Lemma NoMember : False.\nintro.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Library   V6.3 (July 1999)                    *)\n\n(*-- Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3215,
                "proof_end_offset": 3288,
                "proof": "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros x H.\napply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros.\napply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros.\napply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintuition.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\n  intros.\n  now apply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\ntauto.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros x y.\nunfold not in |- *; intro; assumption.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nProof.\nintros.\napply (H (fun y : nat => x) H (fun _ : nat => x) H).\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\nintros x y H.\napply H.\nQed.",
                    "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Tactics Tauto & Intuition --*)\n\n(*-- Tauto: Tactic for automating proof in Intuionnistic Propositional \n            Caulculus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3290,
                "proof_end_offset": 3326,
                "proof": "Theorem tauto1 : A -> A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed.",
                    "Theorem tauto1 : A -> A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ulus, based on the contraction-free LJT of Dickhoff \n     Ref:   Roy Dyckhoff, The Journal of Symbolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 3328,
                "proof_end_offset": 3393,
                "proof": "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.",
                    "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "bolic Logic Volume 57,\n            Number 3, Sept. 1992                                      --*) \n\nParameter A B C : Prop.\nParameter even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3395,
                "proof_end_offset": 3462,
                "proof": "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.",
                    "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " even : nat -> Prop.\nParameter P : nat -> Prop.\n\n(*-- Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3464,
                "proof_end_offset": 3527,
                "proof": "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.",
                    "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Examples of intuitionistics tautologies \n     Ref: Lincoln Wallen, Automated Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 3529,
                "proof_end_offset": 3565,
                "proof": "Theorem a4 : ~ A -> ~ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.",
                    "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Deduction in Nonclassical Logics, 1990 \n          Sthephen Klenne, Introduction to Metamathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\n",
                "context_tokens": 745,
                "proof_start_offset": 3567,
                "proof_end_offset": 3607,
                "proof": "Theorem e2 : ~ ~ (A \\/ ~ A).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.",
                    "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "amathematics,1952. --*)\n\nTheorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3609,
                "proof_end_offset": 3657,
                "proof": "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.",
                    "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "A \\/ ~ A).\ntauto.\nQed.\n\n(*-- Example with a first ordre formula --*)  \nTheorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\n",
                "context_tokens": 711,
                "proof_start_offset": 3659,
                "proof_end_offset": 3767,
                "proof": "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed.",
                    "Theorem y0 : forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B), A -> False.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3769,
                "proof_end_offset": 3823,
                "proof": "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.",
                    "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ".\n\n(*-- Example with a first ordre tautologic formula --*)\nTheorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3825,
                "proof_end_offset": 3883,
                "proof": "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.",
                    "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "ne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3885,
                "proof_end_offset": 3937,
                "proof": "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.",
                    "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": "s red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\nTheorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4257,
                "proof_end_offset": 4323,
                "proof": "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "s of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\n",
                "context_tokens": 377,
                "proof_start_offset": 2468,
                "proof_end_offset": 2722,
                "proof": "Goal forall n m : nat, {p : nat | Ack n m p}.\nProof.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.",
                "end_command": "Save Ackermann.",
                "generated_proofs": [
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\napply (Z.lt_O_lt n m); auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n; auto with arith.\nintros; elim (O_nat_of_P _ H); auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p.\nelim m.\nexact (A (S n)).\nexact (A (S m)).\nexact (A (S m)).\nexact (A (S m)).\nexact (A (S m)).\nexact (A (S m)).\nexact (A (S m)).\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nauto with arith.\nintros.\napply sym_equal; auto with arith.\nintros.\napply sym_equal; auto with arith.\nintros.\napply sym_equal; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nsimpl in |- *.\nauto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nintros.\nelim H.\nsimpl in |- *; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nauto with arith.\nintros.\nelim H; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nintros.\nelim H0; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m; elim n; elim m.\nintros m p H H0 H1; elim H1; intros m H1; elim H1; intros m H2; elim H2; intros H3 H4;\n elim H4; intros H5 H6; elim H6; intros H6 H7;\n elim H7; intros H8 H9; elim H9; intros H9 H10; elim H10; intros H12 H12;\n elim H12; intros H13 H14; elim H14; intros H14 H15;\n elim H15; intros H15 H16; elim H15; intros H17 H18; elim H17; intros H15 H16;\n elim H17; intros H17 H18; elim H18; intros H17 H18; elim H18; intros H17 H18;\n elim H18; intros H17 H18; elim H18; intros H18 H19;\n elim H18; intros H18 H18; elim H18; intros H20 H18; elim H18; intros H17 H18;\n elim H18; intros H18 H19; elim H18; intros H17 H18Save Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m; elim n; simpl in |- *; auto with arith.\nintros n1 p q H H0.\nelim (S m1); auto with arith.\nintros n2 p q H H0.\nelim (S m2); auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n; auto with arith.\nSave Ackermann.",
                    "Goal forall n m : nat, {p : nat | Ack n m p}.\nintros n m p; elim p.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n | apply sym_equal;\n | apply sym_equal;\n | apply sym_equal;\n | apply sym_equal;\n | apply sym_equal;\n | apply symSave Ackermann."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": " not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\n",
                "context_tokens": 519,
                "proof_start_offset": 3199,
                "proof_end_offset": 3373,
                "proof": "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nProof.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.",
                "end_command": "Save ack_Ack.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; exists p.\nauto.\nintros m p H; elim H; intros.\nelim (H x); intros.\nexists x; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; elim m; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim m; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim m; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim m; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.\nintros m p; elim n; auto with arith.Save ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; exists m; auto.\nintros p q H; elim H; intros; elim H; intros; clear H.\nelim (H n m); intros.\nexists x0; auto.\nintros m' H; elim H; intros.\nexists x; auto.\nelim H; intros.\nexists x0; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; elim p.\nintros m p; exists p; auto.\nintros m' H; elim H; intros.\nelim (H _ H0); intros.\nexists x; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n; intros.\napply sym_equal; trivial.\napply sym_equal; trivial.\napply sym_equal; trivial.\napply sym_equal; trivial.\napply sym_equal; trivial.\napply sym_equal; trivial.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nauto.\nintros m' H; elim H; intros.\nelim (H x); intros.\nexists x; auto.\nintros m' H; elim H; intros.\nelim (H x); intros.\nexists x0; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; exists m; auto.\nintros n m p; exists m; auto.\nintros n m p; exists m; auto.\nintros n m p; exists m; auto.\nintros n m p; exists m; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; elim p.\nintros m; elim p.\nintros m p; exists m.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equal;\n apply sym_equalSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n; simpl in |- *; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim (H5 H6); intros.\nexists x0; auto.\napply H6; auto.\napply H6; auto.\nSave ack_Ack.",
                    "Goal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction n.\nintro m; exists m.\napply sym_equal.\nauto.\n\n(* 2 *)\nintros n m p; exists m.\napply sym_equal.\nauto.\nSave ack_Ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Ack.v",
                "context": "               *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Ack.v                                   *)\n(****************************************************************************)\n\n\nInductive Ack : nat -> nat -> nat -> Prop :=\n  | AckO : forall n : nat, Ack 0 n (S n)\n  | AcknO : forall n p : nat, Ack n 1 p -> Ack (S n) 0 p\n  | AckSS :\n      forall n m p q : nat, Ack (S n) m q -> Ack n q p -> Ack (S n) (S m) p.\n\nHint Resolve AckO AcknO.\n\nGoal forall n m : nat, {p : nat | Ack n m p}.\nsimple induction n.\nintro m; exists (S m); auto.\nsimple induction m.\nelim (H 1); intros.\nexists x; auto.\nintros m' H'; elim H'; intros.\nelim (H x); intros.\nexists x0.\napply AckSS with x; auto.\nSave Ackermann.\n\n(* Functional definition of Ackermann :\n (ack 0 n) = (S n)\n (ack (S n) 0) = (ack n (S 0))\n (ack (S n) (S m)) = (ack n (ack (S n) m)) *)\n \nDefinition ack (n : nat) :=\n  (fix F (n0 : nat) : nat -> nat :=\n     match n0 with\n     | O => S\n     | S n1 =>\n         fun m : nat =>\n         (fix F0 (n2 : nat) : nat :=\n            match n2 with\n            | O => F n1 1\n            | S n3 => F n1 (F0 n3)\n            end) m\n     end) n. \n(* 0 *) \n(* (S n) *)  \n(* 0 *) \n(* S m *) \n\nGoal forall n m p : nat, Ack n m p -> p = ack n m :>nat.\nsimple induction 1; simpl in |- *; trivial.\nintros n1 m1 p1 q1 ASn Eq An Ep; elim Eq; elim Ep; trivial.\nSave ack_Ack.\n\n",
                "context_tokens": 554,
                "proof_start_offset": 3375,
                "proof_end_offset": 3606,
                "proof": "Goal forall n m : nat, Ack n m (ack n m).\nProof.\nsimple induction n.\nsimpl in |- *; auto.\nintros n' H; simple induction m.\nsimpl in |- *; auto.\nintros m' H'; apply AckSS with (ack (S n') m'); auto.\napply (H (ack (S n') m')).\nSave Ack_ack.",
                "end_command": "Save Ack_ack.",
                "generated_proofs": [
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p q1 An p1 q2 An; case n.\nintro m; exists (S m); auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p q1 A0 Eq; elim Eq; elim Eq; elim Eq; elim E; elim E; elim E; elim E; elim E; elim E; elim E; elim E; elim E; elim E;\n intros.\nelim (H x); intros.\nexists x0; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n.\nintro m; exists (S m); auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros m p q; exists (S m); auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros; exists n; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p p; exists (S m); auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p; exists (S m); auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p; exists (S n); trivial.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p; exists m; auto.\nintros n m p; exists m; auto.\nSave Ack_ack.",
                    "Goal forall n m : nat, Ack n m (ack n m).\nsimple induction n; simpl in |- *; trivial.\nintros n m p q p q H; elim H; intros.\nelim (H p); intros.\nelim (H p0); intros.\nelim (H0 q); intros.\nelim (H1 q); intros.\nelim (H2 q); intros.\nelim (H4 q1); intros.\nelim (H4 q2); intros.\nelim (H5 q2); intros.\nelim (H5 q2); intros.\nelim (H5 q2); intros.\nelim (H5 q1); intros.\nelim (H6 q); intros.\nelim (H5 q1); intros.\nelim (H6 q); intros.\nelim (H6 q); intros.\nelim (H6 q); intros.\nelim (H6 q); intros.\nelim (H6 q); intros.\nelim (H6 q); intros.\nelim (H7 q); intros.\nelim (H6 q); intros.\nelim (H7 q); intros.\nelim (H7 q); intros.\nelim (H7 q); intros.\nelim (H7 q); introsSave Ack_ack."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\n",
                "context_tokens": 307,
                "proof_start_offset": 1329,
                "proof_end_offset": 1418,
                "proof": "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nautorewrite with base0 using try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply\n (Build_Setoid (fun m : nat => plus_le_compat_l n m) (S m)\n    (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_r n m)\n       (fun m : nat => plus_le_compat_r n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_r n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_r n m)\n       (fun m : nat => plus_le_compat_r n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plus_le_compat_l n m)\n       (fun m : nat => plusQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply Ap0.\napply Ap0.\napply sym_equal.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\napply Ap0.\nrewrite <- (F1 I) at 1.\nchange (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S (S (S (S (S(S (S (S (S (S (S (S (S (S(S(S(S(S(S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\nunfold 12, S, pred, pred, pred, pred, pred, pred, pred, pred, pred, pred;\n simpl; intros.\ndestruct n; simpl; auto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nunfold pPred in |- *; simpl in |- *.\nauto with base0.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nunfold HI.\napply refl_equal.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nunfold SPEC, F, n, n, pred, pred', pred', pred', pred', pred'.\nintros.\nsimpl in |- *.\napply sym_eq; auto.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\ngeneralize (refl_equal 0).\nauto with base0.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nProof.\napply sym_equal.\napply sym_equal.\napply sym_equal.\napply sym_equal.\nQed.",
                    "Lemma ResAck0 : Ack 3 2 = 29.\nauto with base0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\n",
                "context_tokens": 462,
                "proof_start_offset": 1725,
                "proof_end_offset": 1826,
                "proof": "Lemma Resg0 : g 1 110 = 100.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  rewrite S_pred_plus.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using using g0.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  auto with base0.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.",
                    "Lemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base0.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_AutoRewrite.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Import Arith.\nRequire Import Omega.\n\nSection Ackermann.\n\nVariable Ack : nat -> nat -> nat.\n\nAxiom Ack0 : forall m : nat, Ack 0 m = S m.\nAxiom Ack1 : forall n : nat, Ack (S n) 0 = Ack n 1.\nAxiom Ack2 : forall n m : nat, Ack (S n) (S m) = Ack n (Ack (S n) m).\n\nHint Rewrite Ack0 Ack1 Ack2 : base0.\n\nLemma ResAck0 : Ack 3 2 = 29.\nProof.\n  autorewrite with base0 using try reflexivity.\nQed.\n\nEnd Ackermann.\n\nSection McCarthy.\n\nVariable g : nat -> nat -> nat.\n\nAxiom g0 : forall m : nat, g 0 m = m.\nAxiom g1 : forall n m : nat, n > 0 -> m > 100 -> g n m = g (pred n) (m - 10).\nAxiom g2 : forall n m : nat, n > 0 -> m <= 100 -> g n m = g (S n) (m + 11).\n\nHint Rewrite g0 g1 g2 using omega : base1.\n\nLemma Resg0 : g 1 110 = 100.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1828,
                "proof_end_offset": 1927,
                "proof": "Lemma Resg1 : g 1 95 = 91.\nProof.\nautorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1. apply g1.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using ring.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using ring.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using ring.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base1 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using reflexivity || simpl in |- *.\nQed.",
                    "Lemma Resg1 : g 1 95 = 91.\nProof.\n  autorewrite with base0 using reflexivity || simpl in |- *.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "ense, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\n",
                "context_tokens": 352,
                "proof_start_offset": 2584,
                "proof_end_offset": 2664,
                "proof": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  simple induction y.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction x; auto with arith.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  intros.\n  case x; case y; simpl in |- *; auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction x.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivityQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n  intros; elim x; auto.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction x; simpl in |- *; auto with arith.\nQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nintros.\nchange (S x) in |- *.\napply (P_dec (fun y : bool => X) (fun y : bool => y)).\napply P_rec.\napply (P_dec (fun y : bool => X) (fun y : bool => y)).\napply P_rec.\napply (P_dec (fun y : bool => y)).\napply (P_dec (fun y : bool => P y)).\napply (P_dec (fun y : bool => P y)).\napply P_rec.\napply (P_dec (fun y : bool => P y)).\napply P_rec.\napply (P_dec (fun y : bool => P y)).\napply Q_rec.\napply (P_dec (fun y : bool => P y)).\napply Q_rec.\napply (P_dec (fun y : bool => P y)).\napply Q_rec.\napply (P_dec (fun y : bool => P y)).\napply Q_rec.\napply (P_dec (fun y : bool => P y)).\napply Q_rec.\napply (P_dec (fun y : bool =>Qed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction x.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivity.\nreflexivityQed.",
                    "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nsimple induction x.\nauto.\nintros.\nelim (H1 x0).\nauto.\nintros.\nelim (H2 x0).\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "                                                *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 373,
                "proof_start_offset": 2666,
                "proof_end_offset": 2747,
                "proof": "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.",
                    "Lemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "eceived a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\n",
                "context_tokens": 475,
                "proof_start_offset": 3105,
                "proof_end_offset": 3181,
                "proof": "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n trivial.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n trivial.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n simple induction m; simpl in |- *; auto with arith.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n simple induction m.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n intros m.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "rogram; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 3183,
                "proof_end_offset": 3264,
                "proof": "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\nSet Asymmetric Patterns.\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\n",
                "context_tokens": 501,
                "proof_start_offset": 3267,
                "proof_end_offset": 3361,
                "proof": "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed.",
                    "Lemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "n                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4026,
                "proof_end_offset": 4088,
                "proof": "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n destruct l; simpl; auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n  trivial.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n simpl; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "        *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                Sorting.v                                 *)\n(****************************************************************************)\n\n(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4090,
                "proof_end_offset": 4181,
                "proof": "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n intros.\n revert n.\n induction n.\n simpl; auto.\n simpl; auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "(* These sorting examples have first been compiled by P. Manoury using the  *)\n(* ProPre tool to build recursive functions by cases                        *)\n\n(* == Quelques fonctions utiles == *)\n\n(* Inductive Set bool := true : bool | false : bool. *)\n\nDefinition si (X : Set) (b : bool) (x y : X) :=\n  match b with\n  | true => x\n  | _ => y\n  end.\n\nLemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 4183,
                "proof_end_offset": 4343,
                "proof": "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n functional induction (Nil nat); intros.\n inversion_clear H; subst.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\n inversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversion_clear H.\ninversionQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n functional induction (listn nat n x); intros; simpl; auto.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H; subst.\n inversion H;Qed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n functional induction (nth n m x); intros; trivial.\n inversion H.\n inversion H.\n inversion H.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros; elim n; simpl; auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n rewrite <- (sorted_le_iff_eq2 n m x).\n destruct m; simpl; auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros.\n inversion H.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n induction m as [| n Hrec]; simpl; auto.\n intros; inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\n inversion H.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n functional induction (in_app_1 _ _ _ _ _ H); simpl; auto.\nQed.",
                    "Lemma sorted_eq3 : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) = (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n intros n m x.\n functional induction (O.eq_dec n m); intros.\n - left; auto.\n - right; auto.\n - left; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma si_eq1 : forall (X : Set) (x y : X), si X true x y = x.\nProof.\n auto.\nQed.\n\nLemma si_eq2 : forall (X : Set) (x y : X), si X false x y = y.\nProof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4504,
                "proof_end_offset": 4577,
                "proof": "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n intros; rewrite nocc_eq1; auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n intros.\n induction n; simpl; auto.\n rewrite IHn; auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\n\n(* Inductive Set nat : O:nat | S:nat->nat. *)\n\nFixpoint egal_nat (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 4579,
                "proof_end_offset": 4724,
                "proof": "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros n m x.\n simpl in |- *.\n rewrite H.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n rewrite n elim_comp.\n reflexivity.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n intros.\n rewrite nelim_0.\n reflexivity.\nQed.",
                    "Lemma nocc_eq2 : forall (n m : nat) (x : list nat), nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat =>\n  match n, m with\n  | O, O => true\n  | S n, S m => egal_nat n m\n  | _, _ => false\n  end.\n\n\nFixpoint inf_egal (n : nat) : nat -> bool :=\n  fun m : nat =>\n  match n, m with\n  | O, m => true\n  | S n, O => false\n  | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\n",
                "context_tokens": 746,
                "proof_start_offset": 4780,
                "proof_end_offset": 4846,
                "proof": "Theorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\ngeneralize (le_refl n).\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite minus_diag.\napply le_n_S.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nauto.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\nassert (H := equal_0_l n m H).\ntransitivity (S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (S m) + S (Qed.",
                    "Theorem diff_true_false : true <> false.\nProof.\ngeneralize (le_refl (O:=O)).\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\ntrivial.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\ntrivial.\nQed.",
                    "Theorem diff_true_false : true <> false.\nProof.\ngeneralize (lt_O_nat_O n).\ngeneralize (lt_O_nat_O n).\nrewrite plus_n_O.\nrewrite plus_n_Sm.\nrewrite plus_n_Sm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite (plus_comm (S (n0 + S n0)) at 2.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " | S n, S m => inf_egal n m\n  end.\n\n\nLemma inf_egal_eq1 : forall m : nat, inf_egal 0 m = true.\nProof.\n auto.\nQed.\n\nLemma inf_egal_eq2 : forall n : nat, inf_egal (S n) 0 = false.\nProof.\n auto.\nQed. \n\nLemma inf_egal_eq3 : forall n m : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\n",
                "context_tokens": 698,
                "proof_start_offset": 4879,
                "proof_end_offset": 5155,
                "proof": "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\nintros.\nrewrite si_eq1.\napply H.\ntrivial.\nintros.\nrewrite si_eq2.\napply H0.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros P x y H.\n destruct H as (x0, H1).\n exists (n elim_0_ind _ _ H0); auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros X P x y.\n rewrite (le_n_O _ _ x y b H).\n apply le_n_S.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y.\nassert (H : forall n : nat, n = S n -> P n) by\n [ exact H | exact H0 ].\nassert (H : forall n : nat, n = S n -> P n) by\n [ exact H | exact H0 ].\nassert (H' : forall n : nat, n = S n) by\n [ exact H | exact H' ].\nassert (H' : forall n : nat, n = S n -> P (S n) = S n).\nrewrite H'.\nreflexivity.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros X P x y H.\napply H.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros X P x y b.\ngeneralize b; clear b.\ninduction n.\nintros.\ninversion b.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion HQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros X P x y.\ncase (n elim_eq_0 n); intros.\nrewrite H; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nrewrite H0; auto.\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros; apply (H (S x) (S y) b (S x) b (S x) b (S x) b (S x) b x0 b H0).\nQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros.\napply le_antisym.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.\napply le_antisym.\napply H.Qed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nintros X P x y; elim b; simpl in |- *; auto.\nintros n0 Hrec x y Hrec y Hrec y Hrec y Hrec y.\ncase b; simpl in |- *; auto.\nintros n0 Hrec y Hrec x y Hrec y.\ncase b; simpl in |- *; auto.\nintros n1 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n1 Hrec y.\ncase b; simpl in |- *; auto.\nintros n1 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n2 Hrec y.\ncase b; simpl in |- *; auto.\nintros n1 Hrec y.\ncase b; simpl in |- *; auto.\nintrosQed.",
                    "Theorem si_intro : forall (X : Set) (P : X -> Prop) (x y : X) (b : bool), (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\n intros.\n apply (f_equal nat (fun _ => P (xI X b x) (fun _ => P (xI X b x) b) x).\n apply (f_equal nat (fun _ => P (xI X b x) (fun _ => P (xI X b x) b) x).\n apply (f_equal nat (fun _ => P (xI X b x) (fun _ => P (xO X b x) b x)).\n apply (f_equal nat (fun _ => P (xI X b x) (fun _ => P (xO X b x) b)).\n apply (f_equal nat (fun _ => P (xO X b x) b x) (fun _ => P (xI X b x) b x)).\n apply (f_equal nat (fun _ => P (xI X b x) b x) b x).\n apply (f_equal nat (fun _ => P (xO X b x) b x) b x).\n apply (f_equal nat (fun _ => P (xI X b x) b x) b x).\n apply (f_equal nat (fun _ => P (xIQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : nat, inf_egal (S n) (S m) = inf_egal n m.\nProof.\n auto.\nQed. \n\nInductive list (X : Set) : Set :=\n  | Nil : list X\n  | Cons : X -> list X -> list X.\n\nDefinition cdr (X : Set) (l : list X) :=\n  match l with\n  | Nil => Nil X\n  | Cons _ xs => xs\n  end.\n\nFixpoint length (X : Set) (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\n",
                "context_tokens": 728,
                "proof_start_offset": 5197,
                "proof_end_offset": 5481,
                "proof": "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\nintros.\napply False_ind.\napply diff_true_false.\nassumption.\nsimple induction m.\nintro.\ntrivial.\nintros.\nrewrite inf_egal_eq3.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n case (inf_app_eq n m).\n intro.\n rewrite H0.\n apply (H2 (S n)).\n trivial.\n intro.\n case (le_lt_eq_dec n m).\n intro.\n rewrite e.\n apply (H2 (S n)).\n trivial.\n intro.\n rewrite e.\n apply (H2 (S n)).\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n rewrite H.\n reflexivity.\n intros.\n rewrite H0.\n reflexivity.\n intros.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n simple induction n.\n simpl in |- *.\n rewrite IHn.\n reflexivity.\n simpl in |- *.\n rewrite IHn.\n reflexivity.\n simpl in |- *.\n rewrite IHn.\n reflexivity.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n rewrite inf_nil_end.\n rewrite <- H.\n apply nfix_0.\n intros.\n rewrite H0.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n case H.\n intros.\n rewrite H0.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n case (le_lt_dec m n).\n intro.\n rewrite e.\n apply (le_Sn_m (S n) (S m)).\n rewrite e.\n apply (le_Sn_m (S n) (S m)).\n assumption.\n assumption.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n rewrite inf_eq1.\n apply H.\n trivial.\n intros.\n rewrite H0.\n apply inf_eq2.\n apply H.\n trivial.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n intros.\n case (le_lt_dec n m).\n intro.\n rewrite H.\n apply inf_le_dec.\n assumption.\n intro.\n rewrite H.\n apply inf_le_dec.\n assumption.\nQed.",
                    "Theorem inf_false_true : forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n rewrite H.\n trivial.\n intros.\n rewrite H.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ") (l : list X) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons _ xs => S (length X xs)\n  end.\n\n(* append x y = yx *)\nFixpoint append (X : Set) (ys xs : list X) {struct xs} : \n list X :=\n  match xs with\n  | Nil => ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 5518,
                "proof_end_offset": 5731,
                "proof": "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\nintro.\nunfold sorted in |- *.\ntrivial.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n intros.\n apply le_n_S.\n apply le_trans with (n := x).\n apply lt_n_S.\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply H.\n apply H.\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction n.\n simpl in |- *.\n intro.\n apply False_ind.\n apply (H0 _ H0).\n apply (H0 _ H1).\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n intros.\n rewrite n in H.\n apply (lt_irrefl 0).\n apply H.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n apply H0.\n trivial.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n intros n x.\n induction n.\n simpl.\n apply le_n.\n intros.\n apply le_n.\n intros.\n apply le_n.\n intros.\n apply lt_n.\n intros.\n apply lt_n_S.\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n intros.\n apply lt_trans with (n := x).\n apply lt_trans with (n := x).\n assumption.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n intros.\n induction n.\n simpl.\n apply lt_irrefl.\n intros.\n apply lt_irrefl.\n intros.\n apply lt_irrefl.\n apply le_S_n.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n intros.\n rewrite H0.\n simpl in |- *.\n intros.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_cdr : forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply (H (S x)).\n apply (H (S x)).\n apply H.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " ys\n  | Cons x xs' => Cons X x (append X ys xs')\n  end.\n\n(* == Proprietes d'un tri == *)\n\nFixpoint sorted (l : list nat) : Prop :=\n  match l with\n  | Cons n (Cons m x as l) => inf_egal n m = true /\\ sorted l\n  | _ => True\n  end.\n\nLemma sorted_eq1 : sorted (Nil nat) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq2 : forall n : nat, sorted (Cons nat n (Nil nat)) = True.\nProof.\n auto.\nQed.\n\nLemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \n",
                "context_tokens": 719,
                "proof_start_offset": 5734,
                "proof_end_offset": 5910,
                "proof": "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro.\nintro.\nintro.\nrewrite sorted_eq3.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n rewrite length_inf_nil.\n apply lt_wf.\n trivial.\n intros.\n rewrite length_inf_nil.\n apply lt_wf.\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n intros n m x.\n functional induction n.\n intros.\n trivial.\n intros.\n apply (H n0).\n trivial.\n intros.\n apply (H n0).\n trivial.\n intros.\n apply (H n0).\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n rewrite <- (H (n0 :: m)).\n apply sorted_le_1.\n assumption.\n intros.\n apply H.\n apply H.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n intros n m x.\n functional induction (inf_complete n m x).\n intro.\n apply H.\n trivial.\n intros.\n inversion H.\n inversion H2.\n inversion H3.\n inversion H3.\n inversion H3.\n inversion H3.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n intros.\n case m.\n intro.\n unfold sorted in |- *. trivial.\n intro.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n trivial.\n intros.\n apply False_ind.\n apply (H (S x0)).\n apply le_n_S.\n apply H.\n trivial.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n trivial.\n intros.\n apply lt_trans with (S (n0 + m)).\n apply lt_n_S.\n apply lt_n_S.\n assumption.\n simple induction m.\n intros.\n simpl in |- *.\n trivial.\n intros.\n apply lt_n_S.\n apply lt_n_S.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n apply False_ind.\n apply O_ind.\n apply H.\n assumption.\n intro.\n apply H.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n simpl in |- *.\n apply False_ind.\n apply not_true_is_false.\n assumption.\n intros.\n simpl in |- *.\n apply le_antisym.\n apply H.\n assumption.\nQed.",
                    "Theorem sorted_inf : forall (n m : nat) (x : list nat), sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\n simple induction n.\n intros.\n trivial.\n intro.\n apply H.\n trivial.\n intros.\n apply H.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Lemma sorted_eq3 :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) =\n (inf_egal n m = true /\\ sorted (Cons nat m x)).\nProof.\n auto.\nQed.\n\nFixpoint nocc (n : nat) (l : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 6171,
                "proof_end_offset": 6267,
                "proof": "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n intros.\n rewrite (fun n => plus_comm n (Cons nat (S n)) (S (S n))).\n apply plus_comm.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n intros.\n rewrite <- (inv_inv_inv_head n).\n trivial.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite <- H.\n rewrite H0.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n intros.\n rewrite (plus_comm n (Cons nat n x)).\n apply Cons.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n simple induction n.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n induction n.\n reflexivity.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite IHn.\n reflexivity.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite IHn.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n intros.\n rewrite (Nil_eq n).\n trivial.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n intro.\n rewrite (fun n m => S n).\n rewrite (fun n m => S n).\n rewrite (fun n m => S n).\n reflexivity.\nQed.",
                    "Lemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).\nProof.\n intros.\n induction n.\n simpl in |- *.\n trivial.\n simpl in |- *.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : list nat) {struct l} : nat :=\n  match l with\n  | Nil => 0\n  | Cons m x => si nat (egal_nat n m) (S (nocc n x)) (nocc n x)\n  end.\n\nLemma nocc_eq1 : forall n : nat, nocc n (Nil nat) = 0.\nProof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 6269,
                "proof_end_offset": 6448,
                "proof": "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite <- (minus_n_O n m).\n apply Cons_eq2.\n apply plus_n_Sm.\n apply plus_n_Sm.\n apply plus_n_Sm.\n apply plus_n_Sm.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite plus_comm.\n apply S_n.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n apply Cons_eq2; auto.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite <- (Rec_eq2 n (Cons nat m x)) (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite (Rec_eq2 (Cons nat m x) (Cons nat m x)) at 2.\n rewrite <- (Rec_eq2 (Cons nat m x) (Qed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n unfold ins in |- *.\n rewrite plus_n_Sm.\n rewrite plus_n_Sm.\n rewrite plus_comm.\n rewrite plus_comm.\n apply plus_n_Sm.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n replace (S (pred (S (S n))) with (S (pred (S (S (S n))) (S (S (S m))) (S (S (S (S m)))).\n rewrite pred_of_succ.\n rewrite pred_of_succ.\n rewrite pred_of_succ.\n apply pred_of_succ.\n apply pred_of_succ.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n generalize n.\n clear n.\n induction m.\n intro.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite hd_error_nil.\n reflexivity.\n intros.\n rewrite hd_error_nil.\n reflexivity.\nQed.",
                    "Lemma ins_eq2 : forall (n m : nat) (x : list nat), ins n (Cons nat m x) = si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x)) (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite (append_eq2 n m x) at 2.\n apply Cons_eq.\n apply S_pred.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "Proof.\n auto.\nQed.\n\nLemma nocc_eq2 :\n forall (n m : nat) (x : list nat),\n nocc n (Cons nat m x) = si nat (egal_nat n m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 6573,
                "proof_end_offset": 6640,
                "proof": "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\ntrivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n unfold O in |- *.\n induction l.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n unfold Su_cons, tail, seq_assoc, seq_assoc, seq_assoc.\n simpl.\n rewrite plus_comm.\n rewrite plus_comm.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n trivial.\nQed.",
                    "Lemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " m) (S (nocc n x)) (nocc n x).\nProof.\n auto.\nQed.\n\n(* == Un lemme utile == *)\n(* -- Sur les booleens *)\n\nTheorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n\n(* -- Sur la conditionnelle *)\nTheorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6642,
                "proof_end_offset": 6758,
                "proof": "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n intros.\n unfold Str_ins.\n simpl.\n rewrite <- app_ass.\n reflexivity.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.",
                    "Lemma tri_ins_eq2 : forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x). \nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n\n(* -- Sur la comparaison des entiers *)\nTheorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\n",
                "context_tokens": 711,
                "proof_start_offset": 6851,
                "proof_end_offset": 7541,
                "proof": "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\nintros.\nrewrite ins_eq1.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\nintro.\nrewrite sorted_eq3.\nsplit.\napply inf_false_true.\nassumption.\nrewrite sorted_eq3.\nsplit.\napply H2.\napply (sorted_cdr m).\nassumption.\nintro.\nrewrite sorted_eq3.\nsplit.\napply (sorted_inf m x0 l).\nassumption.\napply H.\nassumption.\napply (sorted_cdr m).\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n induction n.\n simpl in |- *.\n intros.\n simpl in |- *.\n apply lt_irrefl.\n simpl in |- *.\n apply lt_irrefl.\n simpl in |- *.\n apply lt_trans with (n + m); trivial.\n simpl in |- *.\n apply le_n_S.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros.\n apply (Le_lt_wf n x).\n apply lt_wf.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros.\n apply lt_wf_ind with (A := nat) (P := fun x => S (Cons nat m x))).\n apply lt_wf_ind with (P := fun x : nat => S (Cons nat n x)) (P := fun x => S (Cons nat m x)) (P := fun x => x) (P := fun x => x) (P := fun x => x) (P := fun x => x) (P := fun x => x) (P := fun x => x).\n intros.\napply lt_wf_ind with (P := fun x : nat => S (Cons nat n x) n (Cons nat n x) (P := fun x => x) (P := fun x => x) (P := fun x => x).\n assumption.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros.\n generalize n m.\n induction n.\n intros.\n simpl in |- *.\n rewrite S_O.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion H.\n simpl in |- *.\n intros.\n inversion HQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros.\n apply lt_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\n auto.\n apply le_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\n auto.\n apply lt_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\n auto.\n apply lt_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\n auto.\n apply le_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\n auto.\n apply lt_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\n auto.\n apply le_wf_ind with (A := nat) (P := fun n m : nat => length (Cons nat m x) = S n).\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n simple induction n.\n simpl in |- *.\n trivial.\n intros.\n rewrite H.\n simpl in |- *.\n trivial.\n intros.\n simpl in |- *.\n trivial.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros.\napply (lt_wf_ind nat (Cons nat n x)).\nintros.\napply lt_wf_ind_r.\napply (lt_wf_ind_r nat (Cons nat n x)).\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wf_ind_r.\napply lt_wfQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros.\n rewrite (inf_app_inf _ _ H).\n apply lt_irrefl.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nintros.\ninduction n.\n simpl in |- *.\nauto with arith.\nintros.\nrewrite S_INR.\nsimpl in |- *.\napply H.\napply S_n.\nQed.",
                    "Theorem sorted_ins_Cons : forall (x : list nat) (n m : nat), inf_egal n m = false -> sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\n intros.\n generalize n m.\n induction n.\n intros.\n rewrite H.\n simpl.\n intros.\n rewrite S_INR.\n apply lt_trans with n.\n assumption.\n apply lt_trans with n.\n assumption.\n apply lt_trans with n.\n assumption.\n assumption.\n apply lt_le_trans with n.\n assumption.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n  assumption.\nQed.\n\n(* -- Sur le predicat \"sorted\" *)\n\nTheorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n \nTheorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n\n(* == Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 7543,
                "proof_end_offset": 7836,
                "proof": "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply si_intro.\nintros.\nrewrite sorted_eq3.\nsplit.\nassumption.\nassumption.\nintro.\napply sorted_ins_Cons.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n induction n.\n intros.\n simpl.\n intros.\n rewrite (IH (Cons nat m x)).\n rewrite (IH (Cons nat m x)).\n rewrite (IH (Cons nat m x)).\n rewrite (IH (Cons nat m x)).\n trivial.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n apply (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 n x))))\n   (sorted_ind_1 (sorted_ind_2 (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 n x))))\n   (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 (sorted_ind_1 n x))))\n   (sorted_ind_2 (sorted_ind_2 (sorted_ind_1 (sorted_ind_1 n x))).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n induction n.\n intro.\n intro.\n apply sorted_ind with (S (S (S n0)) (Cons nat (S n0)) (Cons nat (S n0) (Cons nat n0))).\n apply sorted_cons.\n assumption.\n apply (sorted_tail_lt1 n0 l).\n apply sorted_cons.\n apply (sorted_cons (list nat) (fun x : list nat => length (Cons nat n0 x)) (Cons nat n0 (Cons nat n0))).\n apply sorted_cons.\n assumption.\n apply (sorted_tail_lt1 n0 l).\n apply sorted_cons.\n apply (sorted_tail_lt2 n0 l).\n apply sorted_cons.\n assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n apply sorted_ind_In.\n apply lt_irrefl.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n assert (H := H).\n apply sorted_ind_r with (cons := fun x : list nat => S x).\n assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n apply (sorted_sort_lt1 n (Cons nat n x)).\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n induction n.\n intros.\n simpl in |- *.\n intro.\n rewrite (IH m x).\n apply sorted_cons with x.\n assumption.\n intros.\n apply (sorted_cons m x).\n assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat n x)).\n apply sorted_ind with (sorted (Cons nat nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n induction x.\n intro.\n inversion_clear H.\n apply lt_irrefl.\n apply lt_trans with (y := S n0).\n apply lt_trans with (y := S n0).\n apply lt_le_trans with (y := S n0).\n apply lt_le_trans with (y := S n0).\n apply lt_le_trans with (y := S n0).\n apply lt_le_trans with (y := S n0).\n apply lt_le_trans with (y := S n0).\n assumption.\n assumption.\nQed.",
                    "Theorem sorted_ins : forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\n intros.\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply sorted_cons_lt1.\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt2 (Cons nat n x)).\n apply (sorted_cons_lt2 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\n apply (sorted_cons_lt2 (Cons nat n x)).\n apply (sorted_cons_lt1 (Cons nat n x)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " Tri par insertion *)\n\nFixpoint ins (n : nat) (l : list nat) {struct l} : \n list nat :=\n  match l with\n  | Nil => Cons nat n (Nil nat)\n  | Cons m x =>\n      si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n        (Cons nat m (ins n x))\n  end.\n\n\nLemma ins_eq1 : forall n : nat, ins n (Nil nat) = Cons nat n (Nil nat).      \nProof.\n auto.\nQed.\n\nLemma ins_eq2 :\n forall (n m : nat) (x : list nat),\n ins n (Cons nat m x) =\n si (list nat) (inf_egal n m) (Cons nat n (Cons nat m x))\n   (Cons nat m (ins n x)).\nProof.\n auto.\nQed.\n\n\nFixpoint tri_ins (l : list nat) : list nat :=\n  match l with\n  | Nil => Nil nat\n  | Cons n x => ins n (tri_ins x)\n  end.\n\nLemma tri_ins_eq1 : tri_ins (Nil nat) = Nil nat.\nProof.\n auto.\nQed.\n\nLemma tri_ins_eq2 :\n forall (n : nat) (x : list nat), tri_ins (Cons nat n x) = ins n (tri_ins x).\nProof.\n auto.\nQed.\n\n\n(* -- Preuve de correction *)\n(* -- 1 : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7983,
                "proof_end_offset": 8871,
                "proof": "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\nintro.\nrewrite nocc_eq2.\napply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite (nocc_eq2 n m x).\napply si_intro.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq1.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite si_eq2.\nrewrite nocc_eq2.\nrewrite H.\nrewrite si_eq2.\napply refl_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n intros.\n apply (nIs_nil (x :: m) (Cons nat m (Cons nat p x))).\n apply (nIs_nil (x :: m) (Cons nat m x)).\n apply (IH (x :: m) (Cons nat p x)).\n apply (IH (x :: m) (Cons nat p x) (Cons nat p x) (Cons nat p x))).\n apply (IH (x :: m) (Cons nat p x) (Cons nat p x) (Cons nat p x)).\n apply (IH (x :: m) (Cons nat p x) (Cons nat p x) (Cons nat p x) (Cons nat p x) (Cons nat p x)).\n apply (IH (x :: m) (Cons nat p x) (Cons nat p x) (Cons nat p x) (Cons nat p x) (Cons nat p x) (Cons nat p x)).\n assumption.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\ninduction n.\nintros.\nrewrite head_cons.\napply tail_list_err.\ntrivial.\nintros.\napply H.\napply (sorted_tail_app_or l n m).\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n simple induction n.\n intros.\n rewrite n.\n simpl.\n rewrite IHm.\n rewrite (IH (n + m) p).\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simpl.\n rewrite (IH (n + m) p).\n simplQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n intros n m p x.\n functional induction (Cons nat m (Cons nat p x)).\n intros.\n rewrite tail_cons.\n rewrite tail_cons.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite head_cons.\n rewrite tail_cons.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewrite tail_cons.\n reflexivity.\n intros.\n rewriteQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n intros.\n rewrite (O_Sn n).\n rewrite (O_Sn n).\n apply eq_S_n.\n apply eq_S_n.\n apply eq_S_n.\n apply eq_S.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n intros n m p.\n pattern n at 2 in |- *.\n pattern m at 2 in |- *.\n pattern m at 2 in |- *.\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm m p).\n rewrite (mult_comm mQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\ninduction n.\n simpl.\nintros.\nrewrite (IH t).\nrewrite (IH t).\ntrivial.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n induction n.\n simpl; intros.\n rewrite IHn.\n apply lt_O_Sn.\n simpl; intros.\n rewrite (IH p).\n rewrite (IH p).\n simpl; trivial.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n induction n.\n simpl.\n intros.\n rewrite (IH p).\n simpl.\n rewrite (IH p).\n simpl.\n reflexivity.\n intros.\n rewrite (IH p).\n simpl.\n reflexivity.\nQed.",
                    "Theorem nocc_Cons_Cons : forall (n m p : nat) (x : list nat), nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\n intros.\n apply nocc_rect.\n apply (IH p).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " : Le resultat de \"tri_ins\" est une liste sorted *)\n\nTheorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 8873,
                "proof_end_offset": 9171,
                "proof": "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\nassumption.\nintro.\nrewrite H0.\nsimpl in |- *.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nCorrect_ind (S n) (S n) (S m) (S m) (S m) (S m) (S m) (S m) H0).\n apply nocc_ind.\n intro.\n rewrite nCorrect_ind.\n apply (tail_intro nat (S m) (S m) (S m) (S m) (S m) (S m) H1).\n assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (ndecomp_eq2 n (fun p : nat => p = S (nConst m x))).\napply nocc_intro.\nintro.\nrewrite nnP_eq2.\napply (tail_intro nat (fun p : nat => p = S (n few n x))).\nintro.\nrewrite nnP_eq2.\napply (tail_intro (list nat) (fun p : nat => p = S (n natBelow p) x)).\nrewrite nnP_eq2.\napply (tail_intro nat (fun p : nat => p = S (n natBelow p) x)).\nrewrite nnP_eq2.\napply (tail_intro (list nat) (fun p : nat => p = S (n natBelow p) x)).\nrewrite nnP_eq2.\nrewrite nb_eq3.\nrewrite nb_val_eq3.\napply sym_equal.\nrewrite H0.\nrewrite S_INR.\nrewrite H0.\nrewrite H0.\nrewrite S_INR.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite S_INR.\nrewrite H0.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nCorrect_ind n (Cons nat m (Cons nat n x) y)).\n apply nocc_ind.\n intro.\n rewrite (nCorrect_ind n x y).\n apply nCorrect_intro.\n intro.\n rewrite nCorrect_ind.\n apply (tail_intro nat (fun p : nat => p = S (nocc n (Cons nat p x)))).\n intro.\n rewrite H0.\n rewrite H0.\n rewrite nocc_eq2.\n reflexivity.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nreal_lt_not_eq n (Cons nat n (Cons nat m x))).\napply sorted_remove_Cons.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nrewrite (nCorrect_ind n (Cons nat m (Cons nat n x)) H0 H).\napply nocc_ind.\nintro.\nrewrite (nocc_eq2 n (Cons nat m (S x))) at 1.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nassumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nCorrect_eq2 n x y).\n apply tail_intro.\n intro.\n rewrite nCorrect_rect.\n assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros n m x y H.\n rewrite (nocc_eq2 n n x y).\n apply tail_ind.\n intro.\n rewrite (nocc_eq2 n n x y H).\n apply tail_ind.\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (tail_ind n x y).\n intro.\n rewrite nprime_eq2.\n apply (Qed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n x y).\n apply nfix_ind.\n intro.\n rewrite (nocc_eq2 n x y).\n apply nfix_ind.\n intro.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n apply nfix_ind.\n intro.\n rewrite nfix_ind.\n apply nfix_ind.\n intros.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n apply nfix_ind.\n intros.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n apply nfix_ind.\n intros.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n rewrite nfix_ind.\n apply nfix_ind.\n intros.\n rewriteQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nfix_0_eq2 n m x y H).\n apply nall_Cons_Cons_Cons with (n := n) (x := n).\n assumption.\nQed.",
                    "Theorem nocc_Cons : forall (n m : nat) (x y : list nat), nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\n intros.\n rewrite (nocc_eq2 n p (Cons nat m x)).\n apply nocc_ind.\n intro.\n rewrite (nelim_2 n p (Cons nat p x)).\n apply nocc_ind.\n intro.\n rewrite (nelim_2 n p (Cons nat p x) (Cons nat p x) n).\n apply nocc_ind.\n intro.\n rewrite nocc_eq2.\n rewrite H0.\n rewrite H1.\n rewrite H0.\n rewrite H0.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 9173,
                "proof_end_offset": 9520,
                "proof": "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite ins_eq2.\napply (si_intro (list nat) (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\ntrivial.\nintro.\nrewrite nocc_Cons_Cons.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nCorrect_dec n (Cons nat m x)).\napply nnP_intro.\nintro.\nrewrite (nCorrect_dec n (Cons nat m x)).\napply nnP_intro.\nintro.\nrewrite (nCorrect_dec n (Cons nat m x)).\napply nnP_intro.\nintro.\nrewrite (nCorrect_dec n m x).\napply nnP_intro.\nintro.\nrewrite (nCorrect_dec n m x).\napply nnP_intro.\nintro.\nrewrite nCorrect_dec.\nrewrite H0.\nrewrite nprime_eq2.\napply refl_equal.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nnP in |- *.\napply (f_equal (fun p => p = S (nCorrect m x))).\nrewrite H.\nrewrite H.\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nunfold nocc in |- *.\napply nocc_intro.\napply (melim_O_eq2 n (fun p : nat => p = S (n :: m) + n)).\napply nocc_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nfix_eq2 n x (fun p : nat => p = S (n :: m) x)).\napply nnP_intro.\nintro.\nrewrite (nfix_eq2 n x).\napply nnP_intro.\nintro.\nrewrite nfix_eq2.\napply nnP_intro.\nintro.\nrewrite nfix_eq2.\napply nnP_intro.\nintro.\nrewrite nfix_eq2.\napply nnP_intro.\nintro.\nrewrite nfix_eq3.\napply nnP_intro.\nintro.\nrewrite nfix_eq3.\napply nnP_intro.\nintro.\nrewrite nfix_eq3.\napply nnP_intro.\napply nnP_intro.\napply nnP_intro.\nintro.\nrewrite nfix_eq3.\napply nnP_intro.\napply nnP_intro.\napply nnP_intro.\napply nnP_intro.\napply nnP_intro.\nintro.\nrewrite nfix_eq3.\napply nnP_intro.\napply nnP_intro.\napply nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nEvar_eq2 n m x).\napply si_intro.\nintro.\nrewrite nocc_eq2.\nrewrite H0.\nrewrite nAdd_eq2.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\nreflexivity.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nCorrect_ind (fun x : list nat => n) n (Cons nat m x)).\napply natBelow_rect.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq2 n n) in H.\nrewrite (nocc_eq2 n (fun p : nat => p = S (nelim p x)) in H.\nrewrite H.\nsimpl in |- *.\napply eq_S.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nCorrect_ind (fun p : nat => p = S (nocc n m x)).\napply rect_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\napply refl_equal.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nfix_0_2 m (fun p : nat => p = S (S n) + S m x)).\napply nCorrect_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\n assumption.\nQed.",
                    "Theorem nocc_ins : forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nintros.\nrewrite (nocc_eq2 n m x).\napply vector_intro.\nintro.\nrewrite H0.\nsimpl in |- *.\nrewrite IHn.\nrewrite IHn.\nrewrite IHn.\nrewrite H0.\nrewrite H0.\nsimpl in |- *.\napply eq_S.\ntrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (sorted_cdr m). assumption.\nQed.\n\nTheorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n\n(* -- 2 : Le resultat de \"tri_ins\" est une permutation de son entree *)\n(*   ie : meme nombre d'occurrences de chaque element                *)\n\nTheorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 9522,
                "proof_end_offset": 9729,
                "proof": "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\ntrivial.\nintros.\nrewrite tri_ins_eq2.\nrewrite nocc_ins.\napply nocc_Cons.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite induction_nil.\n apply IHn.\n intros.\n rewrite (IH x0).\n rewrite (IH x0).\n rewrite (IH x0).\n reflexivity.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n intros.\n induction n.\n trivial.\n simpl in |- *.\n reflexivity.\n intros.\n rewrite (IHn (S x)) at 1.\n rewrite IHn.\n reflexivity.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nintros.\nrewrite (nocc_eq2 n n).\napply nocc_Cons.\napply (H (x :: n)).\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n simple induction x.\n trivial.\n intros.\n rewrite induction_0.\n simpl in |- *.\n rewrite IHn.\n reflexivity.\n intros.\n rewrite (IHn n x0).\n rewrite (IHn n x0).\n rewrite (IHn n x0).\n reflexivity.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n intros.\n unfold nocc in |- *.\n apply natBelow_rect.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n simple induction x.\n trivial.\n intros.\n rewrite (nnR_eq2 n (Cons nat n (Cons nat n x))).\n apply IHn.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nintros.\nrewrite (nelim_rect n (fun p : nat => nine p (Cons nat p x)) n).\napply nocc_rect.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n intros.\n rewrite (nelim_0 n).\n apply nocc_Cons.\nQed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n simpl in |- *.\n apply nocc_rect_r with (n := n) (P := fun p : nat => p = S (nEvar_ins x p)).\n apply nocc_rect_r with (n := n) (P := fun p : nat => p = S (nEvar_ins x p)).\n apply nocc_rect_r with (n := n) (P := fun p : nat => p = S (nEvar_ins x p)).\n apply nnP_rect_r with (n := n) (P := fun p : nat => p = S (nEvar_ins x p)).\n apply nnP_rect_r with (n := n) (P := fun p : nat => p = S (nEvar_ins x p)).\n apply nnP_rect_r with (n := n) (P := fun p : nat => n IHn p).\n apply nnP_rect_r with (n := n) (P := fun p : nat => n IHn p).\n apply nnP_rect_r with (n := n) (P := fun p :Qed.",
                    "Theorem nocc_tri_ins : forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\n simple induction x.\n trivial.\n intros.\n rewrite append_eq2.\n apply Cons_Cons.\n apply (IHn (fun p : nat => p = S (S p)).\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 10123,
                "proof_end_offset": 10190,
                "proof": "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\n intros.\n rewrite bub CompOpp_true.\n reflexivity.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\n destruct b.\n reflexivity.\n simpl.\n apply bubUnify_O.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\ntrivial.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\n intros.\n induction l.\n simpl.\n reflexivity.\n intros.\n simpl.\n rewrite H.\n reflexivity.\n intros.\n simpl.\n apply bub,<-_S.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\n reflexivity.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nreflexivity.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\n case b.\n trivial.\n intros.\n rewrite bub ez_eq1.\n apply bub Hstar_eq1.\n apply bub stepr (bub nr).\n apply bub stepr (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub false).\n apply bub with (bub true).\n apply bub with (bub false).\n apply bub withQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\ntrivial.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\nsimple induction 1.\n trivial.\n intros.\n apply bub Interp_aux.\nQed.",
                    "Lemma bubble_eq1 : bubble (Nil nat) = Nil nat.\nProof.\ninduction n.\ntrivial.\nsimpl.\napply bub eqtype.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 10192,
                "proof_end_offset": 10301,
                "proof": "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  rewrite bubhnb_spec.\n  apply bub INRIA eqtype.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  rewrite buburd_eq2.\n  rewrite bub Constraint bub)@bub)%nat.\n  rewrite bub Constraint bub nd)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub Constraint bub Constraint bub)%nat.\n  rewrite bub ConstraintQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq2 : forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  intros.\n  apply bub ez_eq2.\n  apply bub ez_eq2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": ".\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n\nTheorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n\nTheorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\n",
                "context_tokens": 682,
                "proof_start_offset": 10302,
                "proof_end_offset": 10522,
                "proof": "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  unfold bub LemmaOverloading in |- *.\n  rewrite bubInformatique_l.\n  rewrite bub ez_eq2.\n  rewrite bub abc_eq2.\n  rewrite bubann_refl.\n  trivial.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  apply bub HBCT_eq3.\n  assumption.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  rewrite bub CompOpp_eq2.\n  rewrite bub CompOpp_eq2.\n  apply bub CompOpp_eq2.\n  apply bub CompOpp_eq2.\n  apply bub CompOpp_eq2.\n  apply bub CompOpp_eq2.\n  apply bub CompOpp_eq2.\n  apply bub CompOpp_eq2.\n  apply bub absurd (bub CompOpp (bub _))).\n  apply bub && bub && bub && bub && bub && bub && bub && bub && bub && bub && br).\n  apply bub absurd (bub && bub && bub && bub && bub && bub && bub && bub && bub && bub && bub = bub && bub && bub).\n  apply bub fTgt_eq2.\n  apply bub fTgt_eq2.\n  apply bub CompOpp_eq2.\n  apply bubabsurd_eq2.\n  apply bub CompOpp_eq2.\n  apply bub && bub && bub && bub && bub && bub && bub && bub && bub && bub && bub = bubQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  intros.\n  rewrite bub)@aub Constraintbub}%nat.\n  apply buburd_eq3.\n  apply bubthree.\nQed.",
                    "Lemma bubble_eq3 : forall (n m : nat) (x : list nat), bubble (Cons nat n (Cons nat m x)) = si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x))) (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": " list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 11196,
                "proof_end_offset": 11281,
                "proof": "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  rewrite fusion_eq1.\n  unfold fowhile_r.\n  apply (fusion_eq1 (fun n => n) (fusion_r l0)).\n  intro.\n  rewrite e?.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply fusion_eq3.\n  apply f\n \n  _eq3.\n  apply fusion_eq3.\n  apply fusion_eqQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros; induction ms; simpl; auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  simpl.\n  auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  induction ms; simpl; auto.\n  induction ms; simpl; auto.\n  destruct ms; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\n  destructQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros; unfold fiddle, fgraph, fusion, fusion, fiddle, fusion_l.\n  induction (length (length (length (pred base))); simpl.\n  rewrite H; trivial.\n  destruct (inf_app_or _ _ H); auto.\n  destruct (inf_app_or _ _ H); auto.\n  destruct (inf_app_or _ _ H); auto.\n  destruct (inf_app_or _ _ H); auto.\n  destruct (H O); auto.\n  destruct (H O); auto.\n  destruct (H O); auto.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  simple induction tl.\n  simpl.\n  intros.\n  rewrite (fifth_left_nil (A:=nat)).\n  rewrite (fifth_right_nil (A:=nat)).\n  simpl.\n  rewrite (fifth_left_nil (A:=nat)).\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n  intros.\n  destruct ms.\n  reflexivity.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n intros.\n apply fusion_eq1.\n apply (fusion_eq1 (length nat) (length (fusion_r tl n0 (Nil nat)))).\n apply fiddle_r_eq2.\nQed.",
                    "Lemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n intros.\n functional induction (inf_complete_inf leA_dec leA_dec lt_dec lt_dec).\n intros.\n trivial.\n simpl.\n apply fusion_eq2.\n apply fusion_eq1.\n intros.\n apply fusion_eq2.\n apply fusion_eq2.\n intros.\n apply fusion_eq2.\n apply fusion_eq2.\n apply fusion_eq2.\n intros.\n apply fusion_eq2.\n intros.\n apply fusion_eq2.\n apply fusion_eq2.\n intros.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n intros.\n apply fusion_eq3.\n apply fusion_eq3.\n intros.\n apply fInjective_eq3.\n intros.\n apply fusion_eq3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n\nTheorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 11283,
                "proof_end_offset": 11406,
                "proof": "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  intros.\n  simpl.\n  rewrite fusion_eq2.\n  auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  intros.\n  destruct n.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma fusion_eq2 : forall (n : nat) (ns : list nat), fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n  intros.\n  apply fusion_eq2.\n  apply fusion_eq2.\n  apply fusion_eq3.\n  assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Sorting.v",
                "context": "tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n\n(* == Tri bubble *)\n\nFixpoint bubble_aux (x : list nat) : nat -> list nat :=\n  fun n : nat =>\n  match x with\n  | Nil => Cons nat n (Nil nat)\n  | Cons n0 l =>\n      si (list nat) (inf_egal n n0) (Cons nat n (bubble_aux l n0))\n        (Cons nat n0 (bubble_aux l n))\n  end.\n\nDefinition bubble (x : list nat) : list nat :=\n  match x with\n  | Nil => Nil nat\n  | Cons n l => bubble_aux l n\n  end.\n\nLemma bubble_eq1 : bubble (Nil nat) = Nil nat. \nProof.\n  auto.\nQed.\n\nLemma bubble_eq2 :\n forall n : nat, bubble (Cons nat n (Nil nat)) = Cons nat n (Nil nat).\nProof.\n  auto.\nQed.\nLemma bubble_eq3 :\n forall (n m : nat) (x : list nat),\n bubble (Cons nat n (Cons nat m x)) =\n si (list nat) (inf_egal n m) (Cons nat n (bubble (Cons nat m x)))\n   (Cons nat m (bubble (Cons nat n x))).\nProof.\n  auto.\nQed.\n\n\n\nFixpoint bubble_sort0 (n : nat) : list nat -> list nat :=\n  fun x : list nat =>\n  match n with\n  | O => x\n  | S n0 => bubble_sort0 n0 (bubble x)\n  end.\n\nDefinition bubble_sort (x : list nat) : list nat :=\n  bubble_sort0 (length nat x) x.\n\n\n\n(* == Tri fusion *)\n\nFixpoint fusion (x : list nat) : list nat -> list nat :=\n  fun y : list nat =>\n  match x with\n  | Nil => y\n  | Cons n l0 =>\n      (fix fusion_r (y : list nat) : list nat :=\n         match y with\n         | Nil => x\n         | Cons n0 l2 =>\n             si (list nat) (inf_egal n n0)\n               (Cons nat n (fusion l0 (Cons nat n0 l2)))\n               (Cons nat n0 (fusion_r l2))\n         end) y\n  end.\n\n\nLemma fusion_eq1 : forall ms : list nat, fusion (Nil nat) ms = ms.\nProof.\n auto.\nQed.\n\nLemma fusion_eq2 :\n forall (n : nat) (ns : list nat),\n fusion (Cons nat n ns) (Nil nat) = Cons nat n ns.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 11408,
                "proof_end_offset": 11665,
                "proof": "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n rewrite fusion_eq3.\n rewrite fusion_eq3.\n rewrite fusion_eq3.\n rewrite fusion_eq3.\n rewrite fusion_eq3.\n rewrite fusion_eq3.\n rewrite fusion_eq3.\n rewrite folded_eq3.\n rewrite folded_eq3.\n rewrite folded_eq3.\n rewrite folded_eq3.\n rewrite comp_spec1.\n rewrite comp_spec1.\n rewrite folded_eq3.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec1.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec1.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec1.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.\n rewrite comp_spec2.Qed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n intros.\n rewrite folded_eq2.\n rewrite folded_eq2.\n apply furjective_ind.\n assumption.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed.",
                    "Lemma fusion_eq3 : forall (n : nat) (ns : list nat) (m : nat) (ms : list nat), fusion (Cons nat n ns) (Cons nat m ms) = si (list nat) (inf_egal n m) (Cons nat n (fusion ns (Cons nat m ms))) (Cons nat m (fusion (Cons nat n ns) ms)).\nProof.\n auto.\nQed."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 753,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\nProof.\n(* This is the name of a variable *)\nFail rewrite (TT_left b) by apply: (TT_right b).\n(* The next line is not in the line that makes it is not the same with *)\nFail rewrite (TT_right b) by apply: (TT_right b).\n(* A tactic to solve this:\ntry (rewrite (TT_right b) by apply: (TT_right b).\n(* The next one is used in the name of the form *)\n(* it does not work, but the name of the form *)\nFail rewrite (TT_right b) by apply: (TT_right b).\n(* The next one is not the name of the form *)\nFail rewrite (TT_right b) by apply: (TT_right b).\n(* This is not just before the goal *)\nFail rewrite (TT_right b) by apply: (TT_right b).\n(* This is not used in the goal. *)\nFail rewrite (TT_right b) by apply: (TT_right b).\n(* The next one is not the goal *)\nFail rewrite (TT_right c) by apply: (TT_right cSave solution'_b.",
                    "Goal solvable b.\napply/andP; split;\n[exact H | exact H | exact H | exact H ].\nexact (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w) (F w).\nSave solution'_b.",
                    "Goal solvable b.\n(* A small example *)\n(* It is the line that is the one of the line that is the one of the proof of the\n   side form (reverse) to the side of the condition.\n   Then we have to do the user to get the following: *)\n(*  v1 = v2. E. E. F. G. F. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G. G.Save solution'_b.",
                    "Goal solvable b.\nintro.\nFail apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TT || apply (TTSave solution'_b.",
                    "Goal solvable b.\nFail apply: subset_trans (b + _) _.\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFail apply: subset_trans (c + _)).\nFailSave solution'_b.",
                    "Goal solvable b.\nProof.\nevar (C := 'C_P[a] :&: 'C_P[b] :&: 'C_P[b] :&: 'C_P[b] :&: 'C_P[b].\nchange (P ** 'C_P[b] :&: 'C_P[b] :&: 'C_P[b] :&: 'C_P[b] :&: 'C_P[c]).\nchange (P ** 'C_P[b] :&: 'C_P[c] :&: 'C_P[b] :&: 'C_P[c])!= 0.\nrewrite!inE!negb_or -!andbA.\nhave [_ /andP[/eqP-> _] := and3P n.\napply/commG1P/commG1P/commG1P/commG1P/commG1P/commG1P.\nrewrite!inE!andbA => /and3P[/andP[/eqP->]|[_ /eqP->]|//] => _;\nby rewrite!andbT => /and3P[/eqP-> // /eqP->].\nSave solution'_b.",
                    "Goal solvable b.\nProof.\n  unfold b, b in H.\n  (* We have a new equation in the goal *)\n  apply K.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\n  unfold b, b, b, b, c, b, c, d.\n  unfold unfold unfold unfold unfold unfold unfold unfold, unfold_fold_right; simpl; intros.\n  apply H; auto.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\nrewrite /b /isptr /isptr /isptr /isptr /isptr /isptr /isptr.\nrewrite /isptr /isptr /isptr /isptr /isptr /isptr /isptr /isptr.\nrewrite /isptr /isptr /isptr /isptr /isptr /isptr /isptr.\napply/isptr/isptr/isptr/isptr.\napply/isptr_offset_isptr; auto.\nSave solution'_b.",
                    "Goal solvable b.\n(* Abbarempatical example *)\n\nLtac nra :=\n  match goal with\n  | H: _ |- _ =>\n    let x := fresh \"x\" in\n    pose x as x\n  end.\n\nGoal exists (x y : nat), x = y /\\ y = 0 /\\ y = 0 /\\ x = 0.\nintros; eexists; eexists; eexists; eexists; split;\nmatch goal with |- context [?x] => rewrite H end.\nAbort.\n\n(* Abbarempatical example *)\nLtac nra :=\n  match goal with\n  | H: _ |- _ =>\n    let x := fresh \"x\" in\n    pose x as x\n  end.\n\nGoal exists (x y : nat), x = y /\\ y = 0 /\\ x = 0.\nintros; eexists; eexists; split;\nmatch goal with |- context [?x] => rewrite H end.\nAbort.\n\n(* Abbare the elimination form *)\n\nLtac nra :=\n  match goal with\n  | H: _ |- _ =>\n    let x := fresh \"x\" in\n    pose x as x\n  end.\n\nLtac nra :=\n  match goal with\n  | H: _ |- _Save solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": " ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 748,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nunfold micausal_1.\nunfold mic latestal_1.\nunfold micvecsp in |- *.\nsimpl in |- *.\n(* The problem is to prove that the form is not a problem *)\napply stable with (mic?.\n(* The reason, the bug command is not a problem *)\napply Ke.\n(* The problem is not a problem. *)\napply stable with (mic''').\n(* The goal is not a problem. *)\napply stable with (mim:@opot);\n[apply Nopop].\n(* The reason we can do this here, the proof is not a problem because the\n   conclusion is not a problem. *)\napply Ke.\n(* The following should be the goal, but not the goal is a problem. *)\napply Ke.\n(* The goal is not a problem. *)\napply Ke.\n(* The problem is not a problem. *)\napply Ke.\n(* The goal is to find the goal, but it should be a problem. *)\napply Ke.\n(* The problem is not a problem. *)\napply Ke.\n(* The problem is not a problem. *)\napply Ke.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic''':\nunfold micyour_scope.\nunfold micangular_1, micangular_1, micangular_1.\nunfold micangular_1, mic CTcol_1, micangular_1.\nintros.\nunfold miculation in |- *.\nsimpl in |- *.\n(* First case *)\n(* First case *)\napply STEP with (c := (C_example N)); auto.\n(* First case *)\napply STEP with (c := (C_example N)); auto.\n(* First case *)\napply STEP with (c := (C_example N)); auto.\n(* Second case *)\napply STEP with (c := (C_example N)); auto.\n(* Second case *)\napply STEP with (c := (C_example N)); auto.\n(* Second case *)\napply STEP with (c := (C_example N)); auto.\n(* First case *)\napply STEP with (c := (C_example N)); auto.\n(* Second case *)\napply STEP with (c := (C_example N)); auto.\n(* Second case *)\napply STEP with (c := (C_example N)); auto.\n(*Save microban_1_solution.",
                    "Goal solvable microban_1.\nProof.\nunfold micoth_, micyour_scope.\nunfold micicular_1, micicular_1, micTOR_2.\nunfold micicular_1, mimensional.\nunfold micicular_2.\nunfold mictryif_1, micoth_1, mimensional.\nunfold microp, mimensional.\napply sym_equal.\n\n(* This is not a special case of the cases, the goal is not just as follows *)\napply STEP with (S := S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (f_equal S).\napply (g_equal S).\napply (g_equal S).\napply (f_equal S).\napply (f_equal S).\napply (g_equal S).\napply (g_equal S).\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic finish_1.\nunfold micLocation at 1, mic stsep.\nunfold mic INDEXED_1.\nunfold miclectorer at 2, micmini_1.\nunfold mic9739_1, micmini_1.\nunfold micTOR_2.\nunfold mic9739_1, micpossible_image.\nunfold micGAL_1, mic Common_1.\nunfold micSEPARATION_at, micicular_1.\napply micalyze_general_general_general_general_general_general_general.\napply mic HKDF_general_general_general.\napply micension_general_general.\napply micarithmetic in |- *.\n\n(** We prove that the first occurrence of the two components *)\n\nTheorem paradox : False.\nunfold micomorphicerdifferent_3 in |- *.\nunfold micOdd, miciddle in |- *.\napply Extensionality with (witness := full); auto.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micicular_1.\nunfold micVOL, miciddle in |- *.\nintros.\nFail apply stable with (F := I); simpl in |- *; tauto.\n(* This is the one we have to do the case where the goal is a trops *)\napply STEP with (1 := I); simpl in |- *; tauto.\n(* This is the one we have to do the case where the goal is a requied *)\napply STEP with (1 := I); simpl in |- *; tauto.\n(* The following are not needed to do the case where the goal is a trops *)\napply STEP with (1 := I); simpl in |- *; tauto.\n(* The following are not possible. *)\napply STEP with (1 := I); simpl in |- *; tauto.\n(* The following are not the proof, the following should be not been a special case *)\napply STEP with (1 := I); simpl in |- *; tauto.\n(* the proof is the first case where the goal is a requred. *)\napply STEP with (1 := I); simpl in |- *; tauto.\n(* This is the first case where the goal is a requiring the first case *)\napplySave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micPtrordered at 1 in |- *.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_ret.\napply normal_retSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micicular_1.\nunfold mic?.\nunfold mic?.\nunfold mic_).\nunfold mic?.\nunfold micension at 2 in |- *.\nrewrite <- minus_n.\n(* This is not a compatibility of bug 8.4 *)\nassumption.\n(* This is used to fail because of 8.4 *)\nassumption.\n(* It is not used to fail because the name is not a requiring a proof of\n   8.4, which was not needed. *)\nassumption.\n(* The following lemma is not used to fail because the name is not used. *)\nSave microban_1_solution.",
                    "Goal solvable microban_1.\napply typing_var_c.\n(* We show that we do not need to prove that the\n   \"apply\" the same proof. *)\napply typing_var_c.\n(* Now we do the need to show that the\n   \"apply\" the same proof. *)\napply typing_var_c.\n(* We show that the first case, we do not know that the\n   conclusion is not in the cases, we can do the\n   proof. *)\napply typing_var_c.\n(* Now we do the need to show that the first case, we do the\n   case, the first case where the\n   argument is the same as the same as the same\n   terms.\n\nLemma n_abs : forall e,\n  ~ (exists n, e = n) \\/ ~ (exists n, e = n).\nProof.\nintros e.\napply typing_var_c.\n(* We show that the first case is the\n   proof, since we do it to show that the\n   expression is not in the typing rule. *)\napply typing_var_c.\n(* The tactic [apply] is the same as the next step, we do that\n   the first case, the first case is theSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic stsep, mic ltjer, micomorphicer, miculate at the point\napply relation_equivalence.\nunfold mic latester, micyour at 2 in |- *.\napply relation_equivalence.\nunfold mic ltjer, micgicer, micangularer.\napply relation_equivalence.\nunfold micauser, micangularer, micauser, micner.\napply relation_equivalence.\nunfold micicularer, micgicer, micpliciter.\napply relation_equivalence.\nunfold micgicer, micThreeenter, micgicer, mimentate at the\napply relation_equivalence.\napply relation_equivalence.\napply Equivalence_equivalence.\nunfold micpossible.\napply relation_equivalence.\nunfold micLocation, micured at 1 in |- *.\napply relation_equivalence.\nunfold micauser, mimicsert, micpeter, micicularer, mimentate at the\napply relation_equivalence.\napply Equivalence_equivalence.\nunfold micicularer, mimulation in |- *.\napply relation_equivalence.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic stsep at 1 in |- *.\napply stable with (G := G); simpl in |- *; tauto.\n\n(*\nGoal solvable microp by assumption.\napply stable with (G := G); simpl in |- *; tauto.\nSave microban_1_solution."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\n",
                "context_tokens": 356,
                "proof_start_offset": 1314,
                "proof_end_offset": 1504,
                "proof": "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs.\nsimpl.\napply head_insertion.\nsimpl.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs as [|x xs]; simpl.\nauto.\ndestruct xs as [ | x xs]; simpl.\nauto.\ndestruct xs as [ | x xs]; simpl.\nauto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs as [x xs IHxs].\ntrivial.\ntrivial.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs as [ | x xs IH]; simpl.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\ninversion H.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs; simpl; auto.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs as [ | x xs IHxs]; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; auto.\ndestruct ys; simpl; autoQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs as [|x xs].\nreflexivity.\napply tail_inlist.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs.\nreflexivity.\nintros.\napply head_insertion.\ntrivial.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\n  intros A x xs ys.\n  refine (fix forall_in_list (x:A)(xs:list A) (xs:list A) (xs:list A) {struct xs} :\n forall (xs ys:list A),\nxs = ys ->\nxs = ys ->\nxs = ys ->\n forall (xs ys:list A),\nxs = ys ->\nxs = ys ->\nxs = ys ->\nxs = ys ->\nxs = ys ->\nxs = ys.\nProof.\n  intros A x xs ys ys ys ys.\n  refine (fix forall_in_list (x:A)(xs:list A) (xs:list A) {struct xs} :\n forall (xs ys:list A),\nxs = ys ->\nxs = ys ->\nxs = ys ->\nxs = ys ->\nxs = ys ->\nxs = ys.\nProof.\n  intros.\n  inversion H.\n  subst.\n  reflexivity.\n  simpl in |- *.\n  intros.\n  rewrite H.\n  reflexivity.\n  simpl in |- *.\n  intros.\n  rewrite H0.\n  reflexivity.\n  simpl in |- *.\n  intros.\n  rewrite H0.\n  reflexivity.\nQedQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\nunfold insertion.\nunfold insertion.\nunfold insertion.\nunfold insertion.\nunfold insertion.\nunfold insertion.\nunfold insertion.\nunfold insert.\nunfold insertion.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nunfold insert.\nQed.",
                    "Lemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\nProof.\ninduction xs.\nauto.\nintros.\napply (IH (x::xs) (x::xs) (x::xs) (x::xs) (y::xs) (y::xs) (y::xs) (x::xs) (y::xs)).\nsimpl.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\n",
                "context_tokens": 435,
                "proof_start_offset": 1551,
                "proof_end_offset": 1679,
                "proof": "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\nintros.\ninduction H;simpl;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  unfold insertion.\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort A).\n  apply (xs_preserve_sort AQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n destruct l.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tail_list.\n simpl.\n apply tailQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  unfold insertion.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply head_unfolding.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_pairs.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.\n  simpl.\n  apply tail_insertion.Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\ninduction l.\n  simpl.\n  apply head_reduction.\n  simpl.\n  apply head_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tail_reduction.\n  simpl.\n  apply tailQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  induction l.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_list_append.\n  simpl.\n  apply head_list_append.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\nProof.\n  induction l.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_more.\n  simpl.\n  apply tail_list_Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  Proof.\n    induction l.\n    simpl.\n    apply head_merge.\n  Qed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  apply (IHl (x:=x::l')) (H:=H0).\n  apply (H0 H0).\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  unfold insertion.\n  simpl.\n  apply (incl_trans A).\n  apply incl_refl.\nQed.",
                    "Lemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  unfold List.In.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hd.\n  apply List.In_hdQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\n",
                "context_tokens": 500,
                "proof_start_offset": 1735,
                "proof_end_offset": 1960,
                "proof": "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;simpl;try tauto.\ncase H0;try tauto.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H; simpl; tauto.\n  apply IHl'.\n  apply IHl''.\n  apply (merge_incl A l' l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_app A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_incl A l' l').\n  apply (merge_merge A l' l').\n  apply (merge_incl A l' l').\n  apply (mergeQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H; simpl;tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H; simpl; tauto.\n  destruct H;simpl; tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H.\n  left.\n  apply (IHx y H0).\n  left.\n  apply IHx.\n  right.\n  apply (IHy y H0).\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H;simpl;tauto.\n  left; apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H1).\n  apply (H y H1).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H y H0).\n  apply (H0 y H0).\n  apply (H0 y H1).\n  apply (H y H1).\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H.\n  left.\n  apply IHl.\n  simpl; tauto.\nQed.",
                    "Lemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  intros.\n  induction H.\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0).\n  apply (In_In A H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\n",
                "context_tokens": 603,
                "proof_start_offset": 2029,
                "proof_end_offset": 2310,
                "proof": "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\nProof.\ninduction l;simpl;try tauto;intros.\ncase H;intro.\nrewrite H0;exists l;apply head_insertion.\nelim (IHl H0);intro l';intro.\nexists (a::l');apply tail_insertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction l.\n  simpl; tauto.\n  elim H0; intros.\n  right; auto.\n  apply IHl'.\n  apply in_split with a; auto.\n  elim H1; intros.\n  left; apply in_split with l'; auto.\n  destruct H.\n  left; apply in_split with l'; auto.\n  right; auto.\n  left; apply in_split with l'; auto.\n  elim H; intros.\n  right; apply in_split with l'; auto.\n  elim H; intros.\n  right; apply in_split with l'; auto.\n  elim H; intros.\n  left; apply in_split with l'; auto.\n  left; apply in_split with l'; auto.\n  elim H; intros.\n  right; apply in_split with l'; auto.\n  elim H0; intros.\n  left; apply in_split with l'; auto.\n  right; apply in_split with l'; auto.\n  elim H0; intros.\n  right; apply in_split with l'; auto.\n  elim H0; intros.\n  left; apply in_split with l'; auto.\n  elim H1; intros.\n  left; apply in_Qed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction H.\n  left;inversion H;simpl;try tauto.\n  right;apply in_split; tauto.\n  right;apply in_split; tauto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l; simpl; intros.\n  inversion H.\n  apply (H x0).\n  apply (H x0).\n  apply (H0 x).\n  apply (H x0).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 xQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction H;simpl; tauto.\n  left; apply IHl';trivial.\n  left;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  left;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  left;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl;trivial.\n  left;apply IHl';trivial.\n  right;apply IHl;trivial.\n  right;apply IHl';trivial.\n  right;apply IHl;trivial.\n  left;apply IHl';trivial.\n  left;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl;trivial.\n  left;apply IHl';trivial.\n  left;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  left;apply IHl';trivial.\n  left;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHl';trivial.\n  right;apply IHlQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction H;simpl;tauto.\n  left;apply in_seq;tauto.\n  right;apply in_seq;tauto.\n  right;apply in_seq;tauto.\n  right;apply in_seq;tauto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l; simpl;intros.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]];subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]]; subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]]; subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]]; subst.\n  apply in_map_iff in H.\n  destruct H as [? | [??]]; subst.\n  apply in_map_iff inQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction H;simpl; tauto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction H; simpl;tauto.\n  case H0;try tauto.\n  case H;try tauto.\n  left;auto.\n  case H;try tauto.\n  left;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  intros.\n  induction H; simpl;tauto.\n  left;inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l; simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  right;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "riais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\n",
                "context_tokens": 694,
                "proof_start_offset": 2378,
                "proof_end_offset": 2605,
                "proof": "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\nProof.\nintros.\ninduction H;simpl in H0.\ncase H0;intro H1;try (symmetry in H1);tauto.\ncase H0;simpl;intro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l; simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H;intros.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H0;intros.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H;intros.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H; intros.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H0; intros.\n  rewrite H0;exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H0; intros.\n  rewrite H0; exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H0; intros.\n  rewrite H0; exists l0;apply tail_insertion;trivial.\n  simpl.\n  case H0; intros.\n  rewrite H0; exists l0;apply tail_agree;trivial.\n  simplQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  Proof.\n  intros.\n  induction H;simpl;tauto.\n  case H;intros.\n  rewrite H0;exists l';apply tail_insertion;trivial.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_CompSpec;trivial.\n  rewrite H0;exists l';apply tail_CompSpec;trivial.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  inversion H.\n  left; auto.\n  left; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  left; auto.\n  right; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  Proof.\n  induction l; simpl;try tauto;intros.\n  case H;intro.\n  apply in_seq_iff in H.\n  destruct H.\n  destruct H.\n  apply in_seq_iff in H.\n  destruct H.\n  destruct H.\n  apply in_seq_iff in H.\n  destruct H.\n  subst.\n  simpl in H.\n  simpl in H.\n  case_eq (x::l');intros.\n  exists l';apply in_seq_iff in H.\n  destruct H.\n  subst.\n  simpl in H.\n  case_eq (y::l');intros.\n  exists l';apply in_seq_iff in H.\n  subst.\n  simpl in H.\n  case_eq (x::l');intros.\n  exists l';apply in_seq_iff in H.\n  destruct H.\n  subst.\n  simpl in H.\n  case_eq (y::l');intros.\n  exists l';apply in_seq_iff in H; destruct H.\n  subst.\n  simpl in H.\n  case_eq (y::l'); intros.\n  exists l'';apply in_seq_iff in H0; destruct H0.\n  subst.\n  simplQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intro; case H;intros.\n  left; auto.\n  right; auto.\n  right; auto.\n  right; auto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\ninduction l.\n  simpl.\n  apply in_seq_iff in H0; destruct H0.\n  destruct (In_dec A x l0).\n  left.\n  apply in_seq_iff in H1; destruct H1.\n  right.\n  apply in_seq_iff in H1; destruct H1.\n  destruct H1.\n  left;apply in_seq_iff in H2; destruct H2.\n  right.\n  apply in_seq_iff in H2; destruct H2.\n  right.\n  apply in_seq_iff in H2; destruct H2.\n  left;apply in_seq_iff in H2; destruct H2.\n  left;apply in_seq_iff in H2; destruct H2.\n  right.\n  apply in_seq_iff in H2; destruct H2.\n  left;apply in_seq_iff; left; apply in_seq_iff; left; assumption.\n  right; apply in_seq_iff in H2; destruct H2.\n  right.\n  apply in_seq_iff in H2; destruct H2.\n  right; apply in_seq_iff in H2; destruct H2.\n  rightQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  Proof.\n    induction l; simpl;intros.\n    case H;intro.\n    destruct (In_dec H0 H1).\n    left; auto.\n  Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl;tauto.\n  case H0;intro.\n  rewrite H0;exists l';apply in_map;tauto.\n  right;apply in_map;tauto.\nQed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  Proof.\n   intros.\n   destruct (In_dec A x l'); simpl in *.\n   left;auto.\n   left;auto.\n  Qed.",
                    "Lemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  induction l;simpl;try tauto.\n  case H0;intro.\n  case H0; intro.\n  rewrite H0;exists l;apply tail_insertion;trivial.\n  case H0;intro.\n  rewrite H0; exists l';apply tail_insertion;trivial.\n  case H0;intro.\n  rewrite H0;exists l;apply tail_insertion;trivial.\n  case H1;intro.\n  rewrite H0;exists l;apply tail_insertion;trivial.\n  case H1;intro.\n  rewrite H0;exists l;apply tail_insertion;trivial.\n  case H1;intro.\n  rewrite H0;exists l;apply tail_insertion;trivial.\n  case H1;intros.\n  rewrite H0;exists l;apply tail_insertion;trivial.\n  case H1;intros.\n  rewrite H0; exists l;apply tail_insertion;trivial.\n  case H1;intro.\n  rewrite H1; exists l;apply tail_insertion;trivial.\n  case H1;intro.\n  rewrite H1; exists l;apply tail_insertion;trivial.\n  case H1; intro.\n  rewrite H1; exists l;apply tail_insertion;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(* 02110-1301 USA *)\n\nRequire Import Wf_nat.\nRequire Import missing.\nRequire Export List Permutation.\n\n(** we define some notions on lists such as being a permutation of *)\n\n(** insertion x l l' iff l' is l where x has been inserted somewhere *)\nInductive insertion (A:Set) : A -> list A -> list A -> Prop :=\n  head_insertion : forall (x:A)(l:list A),(insertion A x l (x::l))\n|tail_insertion : forall (x y:A)(l l':list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2890,
                "proof_end_offset": 3177,
                "proof": "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\ninduction 1;intros.\ninversion H;trivial.\ninversion H0.\napply cons_is_set.\napply IHinsertion;trivial.\nintro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  Proof.\n    intros.\n    apply (is_set_non_empty A l x).\n  Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\n  intros.\n  induction H;simpl;try tauto.\n  case H0;try tauto.\n  simpl;intros.\n  case (H0 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H1 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H2 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H2 a).\n  left; exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n  right;exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n  left;exists a;split;trivial.\n  right;intros.\n  case (H3 a).\n Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction H;simpl;tauto.\n  case H0;intros;try (symmetry in H1);tauto.\n  case H0;intros;try (symmetry in H1);tauto.\n  case H0;intros;try (symmetry in H1);tauto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros A l x.\n  case l; simpl;intros.\n  case H;intros.\n  rewrite H0;trivial.\n  case (H x);intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (H x); intros.\n  rewrite H0;trivial.\n  case (HQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\n  intros.\n  induction H;simpl;try tauto;intros.\n  case H0;intro H1;try (symmetry in H2);tauto.\n  case H0;intros H1;try (exfalso;inversion H1;fail);tauto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\nProof.\n induction l; simpl;try tauto;intros.\ninversion H;clear H.\ncase H;intros H1 H2; inversion H2; clear H2.\ncase (in_map_inv _ _ _ H); intros.\napply (H a); auto.\nQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  induction H;simpl;try tauto;intros.\n  case H0;intros;apply H;apply in_app;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map; apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map; apply in_map;apply in_map;apply in_map;apply in_map;apply in_map;apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply in_map; apply inQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  Proof.\n    intros.\n    inversion H; subst; auto.\n  Qed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  intros.\n  inversion H;simpl;try tauto.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case (IHl' H0);intro H2;try (symmetry in H2);tauto.\n  case (IHl' H0);intro H3;try (symmetry in H3); tauto.\n  case (IHl' H3);intro H3; try (symmetry in H3); tauto.\n  case (IHl' H2);intro H3; try (exfalso in H3); tauto.\n  case (IHl' H3);intro H3; try (exfalso in H3); tauto.\n  case (IHl' H3); intro H3; try (exfalso in H3); tauto.\n  case (H3 H4); intro H3; try (exfalso in H3); tauto.\n  case (IHl' H3); intro H3; try (exfalso in H3); tauto.\n  case (IHl' H3); intro H4; try (exfalso in H3); tauto.\n  case (IHl' H3); intro H3; try (exfalso in H3); tauto.\n  case (IHl' H3); intro H4; try (exfalso inQed.",
                    "Lemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\ninduction l; simpl;try tauto;intros.\ncase H;intros.\napply (H0 H1);intro l';intros.\napply (H2 H3);intro l'';intros.\napply (H3 H2);intro l'';intros.\napply (H3 H2);intro l'';intros.\napply (H3 H4);intro l'';intros.\napply (H3 H4);intro l'';intros.\napply (H4 H4);intros.\napply (H4 H2);intro l'';intros.\napply (H3 H4);intro l'';intros.\napply (H4 H3);intro l'';intros.\napply (H4 H2);intro l'';intros.\napply (H4 H3);intro l'';intros.\napply (H4 H2);intro l'';intros.\napply (H4 H3);intros.\napply (H4 H1);intro l'';intros.\napply (H4 H2);intros.\napply (H4 H2);intro l'';intros.\napply (H5 H2);intro l'';intros.\napply (H5 H3);intro l'';intros.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "list A),(insertion A x l l')->(insertion A x (y::l) (y::l')).\n\nLemma insertion_snoc : forall (A:Set)(x:A)(xs:list A),(insertion _ x xs (app xs (cons x nil))).\n  induction xs.\n  simpl.\n  apply head_insertion.\n  simpl.\n  apply tail_insertion.\n  auto.\nQed.\n\n(** if (insertion x l l') then x is in l' *)\nLemma insertion_in : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->(In x l').\n  intros.\n  induction H;simpl;tauto.\nQed.\n\n(** if (insertion x l l') then l is included in l' *)\nLemma insertion_inclusion : forall (A:Set)(x:A)(l l':list A),(insertion A x l l')->forall (y:A),(In y l)->(In y l').\n  induction l;simpl;try tauto;intros.\n  inversion H;simpl;try tauto.\n  case H0;try tauto.\n  right;auto.\nQed.\n\n(** if x is in l, then there is l' such that (insertion x l' l) *)\nLemma in_insertion : forall (A:Set)(x:A)(l:list A),(In x l)->exists l':list A,(insertion A x l' l).\n  induction l;simpl;try tauto;intros.\n  case H;intro.\n  rewrite H0;exists l;apply head_insertion.\n  elim (IHl H0);intro l';intro.\n  exists (a::l');apply tail_insertion;trivial.\nQed.\n\n(** if (insertion x l l') and y is in l' then y=x or y is in l *)\nLemma in_insertion_inv : forall (A:Set)(x y:A)(l l':list A),(insertion A y l l')->(In x l')->(x=y)\\/(In x l).\n  intros.\n  induction H;simpl in H0.\n  case H0;intro H1;try (symmetry in H1);tauto.\n  case H0;simpl;intro;tauto.\nQed.\n\n(** a list is a set iff all the elements are pairwise distinct *)\nInductive is_set (A:Set) : list A->Prop :=\n  nil_is_set : (is_set A nil)\n|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\n",
                "context_tokens": 713,
                "proof_start_offset": 3243,
                "proof_end_offset": 3575,
                "proof": "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\nProof.\ninduction l;simpl;try tauto;intros.\ninversion H;rewrite <- H3 in H0;inversion H0.\nsimpl in H7;trivial.\nintro.\ncase H10;intro.\napply H9;rewrite H11;eapply insertion_in;apply H5.\nelim (IHl l'0 x H5 H8 H11).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  Proof.\n    intros.\n    induction H.\n    left; exact H0.\n  Qed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction H;simpl;tauto.\n  elim (IHl H0);intro l';intros.\n  case H0;intro H1;inversion H1;subst.\n  apply (IHl H1);trivial.\n  apply (IHl H1);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H1);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\n  apply (IHatms H2);trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction H;simpl;tauto.\n  elim H;intros.\n  rewrite H0;exists l';apply (non_empty A l');trivial.\n  elim H;intros.\n  rewrite H0;exists l';apply (non_empty A l');trivial.\n  elim H;intros.\n  rewrite H1;exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H1;exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H1; exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H1; exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H0; exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H0; exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H1; exists l';apply (is_empty A l');trivial.\n  elim H; intros.\n  rewrite H1; exists l';apply (is_empty A l');trivial.\n  elim H; introsQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction H;simpl;try tauto.\n  elim H;intros H1;inversion H1;inversion H2;inversion H3;trivial.\n  apply IHorted.In.\n  apply IHFinite;trivial.\n  apply IHFinite.In_remove;try tauto.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\ninduction l;intros.\ninversion H;inversion H0;try tauto.\ncase H0;intro H1;inversion H1;try tauto.\ncase H1;intros H1;inversion H1;inversion H1;try tauto.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction H;simpl;intros;inversion H0.\n  elim H0;intros.\n  elim H1;intros.\n  left; apply IHl;apply (Permuted_remove_not_set x l');trivial.\n  right;apply IHl;apply (Permuted_remove A x l');trivial.\n  left;apply IHl;apply (Permuted_remove A x l');trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;intros.\n  simpl.\n  apply (In_Add A x l');trivial.\n  apply (In_Add A x l');trivial.\n  apply (In_Add A x l');trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction l;simpl;try tauto.\n  apply IHl;trivial.\n  apply IHl;trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros.\n  induction H;simpl;trivial.\n  apply (H a (In a l'));trivial.\n  apply (H a (In a l'));trivial.\n  apply (H a (In a l'));trivial.\n  apply (H a (In a l'));trivial.\n  apply (H a (In a l'));trivial.\nQed.",
                    "Lemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  intros A l l' x H.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l'));intros.\n  case (A (x::l')); intros.\n  case (A (x::l'));intros.\n  case (A (x::l')); intros.\n  case (A (x::l')); intros.\n  case (A (x::l')); intros.\n  case (A (x::l')); intros.\n  case (A (x::l')); intros.\n  case (A (x::l')); intros.\n  case (A (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "|cons_is_set : forall (x:A)(l:list A),(is_set A l)->~(In x l)->(is_set A (x::l)).\n\n(** if (insertion x l l') and l' is a set then l is a set *)\nLemma is_set_insertion : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->(is_set A l).\n  induction 1;intros.\n  inversion H;trivial.\n  inversion H0.\n  apply cons_is_set.\n  apply IHinsertion;trivial.\n  intro;apply H4;apply (insertion_inclusion A x l l');trivial.\nQed.\n\n(** if (insertion x l l') and l' is a set then x is not in l *)\nLemma is_set_insertion_in : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_set A l')->~(In x l).\n  induction l;simpl;try tauto;intros.\n  inversion H;rewrite <- H3 in H0;inversion H0.\n  simpl in H7;trivial.\n  intro.\n  case H10;intro.\n  apply H9;rewrite H11;eapply insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\n",
                "context_tokens": 697,
                "proof_start_offset": 4672,
                "proof_end_offset": 5534,
                "proof": "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros;simpl in H.\ndestruct l'.\napply nil_is_permutation.\nelim (H a);intros.\nelim H3;simpl;tauto.\ninversion H0.\nsymmetry in H2;rewrite H2 in H;elim (H a);intros.\nrewrite H2 in H6;rewrite H2.\nassert (In x l');auto.\nelim (in_insertion A x l' H8).\nintro l'';intro.\napply cons_is_permutation with l'';trivial.\napply IHl;trivial.\nsplit;intro.\nelim (H x0);intros.\nelim (in_insertion_inv A x0 x l'' l');auto.\nintro;rewrite H13 in H10;rewrite H2 in H5;tauto.\nelim (H x0);intros.\ncase H12;try tauto.\napply (insertion_inclusion A x l'' l');trivial.\nintro;rewrite <- H13 in H10.\nelim (is_set_insertion_in A l'' l' x);trivial.\neapply is_set_insertion;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l;intros.\ninversion H;clear H;inversion H0.\nsimpl in H2;inversion H2.\ninversion H2.\napply (IHis_unique A l l'0 H4).\napply (IHis_unique A l'0 H4).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H4).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0 H5).\napply (IHis_unique A l l'0Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\ninduction l.\nintros.\ninversion H;rewrite H3 in H; inversion H; clear H; auto.\nintros.\ninversion H; rewrite H3 in H; inversion H; clear H; auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\nunfold not; intros.\ncase l'; simpl;intros.\ninversion H;clear H.\ninversion H0;clear H0.\ninversion H0;clear H0;clear H0.\ninversion H0;clear H0;inversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H0;inversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H0;inversion H0;inversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H0;inversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H;inversion H0;inversion H0;clear H0;try tauto.\ninversion H0;inversion H0;clear H0;inversion H0;try tauto.\ninversion H0;clear H;inversion H0;inversion H0;inversion H0;inversion H0;try tauto.\ninversion H0;inversion H0Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n intros.\n rewrite (is_iff_prov_in A l l' l'' H).\n apply (is_iff_prov_in A l l' H0).\n apply (is_iff_prov_in A l l' H0).\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n induction l.\n simpl; tauto.\n simpl; tauto.\n simpl; tauto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  induction l.\n  inversion H; auto.\n  inversion H0.\n  apply (IHl l' l'');trivial.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros A l l' l'' H.\n  case (is_unique_lemma A l l'' H).\n  intros.\n  inversion H.\n  apply (In_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_in_l H0).\n  assumption.\n  apply (In_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_in_l H0).\n  assumption.\n  assumption.\n  apply (In_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_in_l H0).\n  assumption.\n  assumption.\n  intros.\n  apply (In_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_is_iff_in_l H0).\n  assumption.\n  assumption.\n  assumption.\n  apply (In_is_iff_is_Qed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\n  intros.\n  apply (is_well_founded_induction_type A l l');trivial.\n  intros.\n  inversion H0.\n  apply (H a).\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\nintros A l l' H.\ncase (is_unique_non_empty A l');intros.\ninversion H;clear H; auto.\napply (f_is_insert_uniq A l l'); auto.\nQed.",
                    "Lemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\nProof.\ninduction l; simpl; try tauto.\napply IHl';auto.\napply (is_path_non_set A l l' H0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " insertion_in;apply H5.\n  elim (IHl l'0 x H5 H8 H11).\nQed.\n\n(** if l is a set, x not in l and (insertion x l l') then l' is a set *)\nLemma insertion_is_set : forall (A:Set)(l:list A),(is_set _ l)->forall (x:A),~(In x l)->forall (l':list A),(insertion _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\n",
                "context_tokens": 732,
                "proof_start_offset": 5571,
                "proof_end_offset": 5760,
                "proof": "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\nProof.\ninduction l.\napply nil_is_permutation.\neapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros;simpl in H.\n  elim (H a);intros.\n  elim H2; simpl;tauto.\n  elim (H a);intros.\n  elim H3; simpl;tauto.\n  elim (H a);intros.\n  elim H3; simpl;tauto.\n  elim (H a);intros.\n  elim H3; simpl;tauto.\n  elim (H a); intros.\n  elim H3; simpl;tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.\n  elim H3; simpl; tauto.\n  elim (H a); intros.Qed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\ninduction l;intros;simpl in H.\nelim H;simpl;tauto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l;intros.\n  destruct l.\n  apply False_ind;apply (in_split H).\n  elim (H x);intros.\n  elim (H x0);intros.\n  elim (H x);intros.\n  elim (H x0);intros.\n  elim H3; intros.\n  apply H5; auto.\n  elim (H x0); intros.\n  elim (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x1); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H x1); intros.\n  apply (H x0); intros.\n  apply (H x0); intros.\n  apply (H xQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\ninduction l;intros;simpl in H.\ndestruct l.\napply False_ind;auto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  elim (list_is_permutation A l); intros.\n  elim (in_non_empty A l); intros.\n  elim (in_non_empty A l); intros.\n  elim (in_non_empty A l); intros.\n  elim (in_non_empty A l); intros.\n  elim (in_non_empty A l); intros.\n  elim (in_non_empty A l); intros.\n  elim H3; intros.\n  apply H3; simpl; tauto.\n  apply (H4 (A:=A) (a:=A)); simpl; tauto.\n  elim (in_non_empty A l); intros.\n  elim H3; intros.\n  apply H3; simpl; tauto.\n  elim (in_non_empty A l); intros.\n  elim H3; intros.\n  apply H3; simpl; tauto.\n  elim (H x); intros.\n  apply H3; simpl; tauto.\n  elim (H x); intros.\n  apply H3; simpl; tauto.\n  elim (H x); intros.\n  apply H3; simpl; tauto.\n  elim (H x); intros.\n  apply H3; simpl; tauto.\n  elim (HQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\ninduction l;intros;simpl;tauto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\ninduction l;intros;simpl in H.\ndestruct l';simpl in H;inversion H.\napply False_ind.\napply (H (is_true A)).\napply False_ind.\napply (H (is_true A)).\napply (H (is_true A)).\napply (H (is_true A)).\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  intros.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  apply not_in_app_or; apply H.\n  applyQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\ninduction l;intros;simpl in H.\ndestruct l';tauto.\nQed.",
                    "Lemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\ninduction l;intros;simpl in H; tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " _ x l l')->(is_set _ l').\n  induction 1.\n  intros.\n  inversion H0.\n  apply cons_is_set.\n  apply nil_is_set.\n  auto.\n  intros.\n  inversion H2.\n  subst x1.\n  subst l0.\n  subst l'.\n  apply cons_is_set.\n  eapply IHis_set.\n  apply H0.\n  apply head_insertion.\n  auto.\n  subst x1;subst y;subst l0.\n  apply cons_is_set.\n  eapply IHis_set with x0;auto.\n  red;intro.\n  apply H1.\n  simpl.\n  right;auto.\n  red;intro.\n  case (in_insertion_inv _ _ _ _ _ H7 H3);intro.\n  apply H1.\n  simpl.\n  left;auto.\n  apply H0.\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\n",
                "context_tokens": 716,
                "proof_start_offset": 5839,
                "proof_end_offset": 6163,
                "proof": "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\nProof.\ninduction 1.\napply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\napply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H;try discriminate;try discriminate.\n  apply (IHl l');trivial.\n  apply (IHl l');trivial.\n  apply (IHl l');trivial.\n  apply (IHl l');trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H;auto.\n  apply (IHl (x::l')) in H;clear H.\n  apply (IHl (x::l')) in H;clear H.\n  apply (IHl (x::l')) in H;clear H.\n  apply (IHl (x::l')) in H;clear H.\n  apply (IHl (x::l') (x::l')) in H;clear H.\n  apply (IHl (x::l')) in H;clear H.\n  apply (IHl (x::l')) in H;clear H.\n  apply (IHl (x::l') (x::l')) in H;clear H.\n  apply (IHl' (x::l')) in H;clear H.\n  apply (IHl (x::l')) in H; clear H.\n  apply (IHl' (x::l')) in H; clear H.\n  apply (IHl' (x::l')) in H; clear H.\n  apply (IHl' (x::l')) in H; clear H.\n  apply (IHl' (x::l')) in H; clear H.\n  apply (IHl' (x::l')) in H; clear H.\n  apply (Qed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H;try discriminate;try discriminate.\n  simpl;apply IHl;try tauto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;simpl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\n  rewrite IHl;trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\nsimpl; tauto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l.\n  simpl; tauto.\n  simpl; tauto.\n simpl; tauto.\nsimpl; tauto.\nsimpl; tauto.\nsimpl; tauto.\nsimpl; tauto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l;intros;simpl in H.\n  destruct l';simpl in H.\n  inversion H.\n  destruct H as [a1 l'].\n  destruct (split_is_app_or _ _ _ H);simpl in H.\n  contradiction.\n  apply IHl';trivial.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction l.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\ninduction l;intros;simpl in H;try contradiction;try discriminate;try reflexivity.\nQed.",
                    "Lemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  Proof.\n    induction l.\n    simpl; tauto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ".\n  auto.\nQed.\n\n(** l' is a permutation of l *)\nInductive is_permutation (A:Set) : list A->list A->Prop :=\n  nil_is_permutation : (is_permutation A nil nil)\n|cons_is_permutation : forall (l l':list A),(is_permutation A l l')->forall (x:A)(l'':(list A)),(insertion A x l' l'')->(is_permutation A (x::l) l'').\n\n(** if l and l' have the same content and are pairwise distinct then l' is a permutation of l *)\nLemma is_set_eq_impl_permutation : forall (A:Set)(l l':list A),(forall (x:A),(In x l)<->(In x l'))->(is_set A l)->(is_set A l')->(is_permutation A l l').\n  induction l;intros;simpl in H.\n  destruct l'.\n  apply nil_is_permutation.\n  elim (H a);intros.\n  elim H3;simpl;tauto.\n  inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\n",
                "context_tokens": 682,
                "proof_start_offset": 6350,
                "proof_end_offset": 6985,
                "proof": "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\nProof.\ninduction 1;intros.\ninversion H.\nexists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\nexists l';split;[trivial | apply head_insertion].\ninversion H0.\nexists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\nelim (IHinsertion l'0 y0 H5);intro l3;intro.\nelim H6;intros.\nexists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\n  simpl; firstorder.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1.\n  apply (A:=A);try apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H.\n  destruct l3.\n  apply (IHl2 y);auto.\n  simpl in H;rewrite H;apply (H y);auto.\n  simpl in H;rewrite H;apply (H y);auto.\n  simpl;auto.\n  simpl in H;rewrite H;apply (H y);auto.\n  simpl;auto.\n  simpl in H;rewrite H;apply (H y);auto.\n  simpl in H;rewrite H;apply (H y);auto.\n  simpl;auto.\n  simpl in H;rewrite H;apply (H y);auto.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivial.\n  simpl.\n  apply (A:=A);simpl;trivialQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1.\n  apply IHl1.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\n  apply (IHl2 (x::l2)); assumption.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H;inversion H;clear H.\n  destruct l0.\n  apply (IHl1 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\n  apply (IHl2 y);auto.\nQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l0;intros;simpl in H;destruct H;destruct H0;destruct H.\n  apply (IHl1 l2 l3);trivial.\n  apply (IHl2 l2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl1 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l3);trivial.\n  apply (IHl2 l4);trivial.\n Qed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H;try tauto.\n  inversion H;clear H;try tauto.\n  destruct l3.\n  apply cons_is_permutation with l0;simpl;try tauto.\n  inversion H0.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  apply (IHl (x::l3));trivial.\n  applyQed.",
                    "Lemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction l1;intros;simpl in H.\n  left;apply (H y0);apply (H y0);assumption.\n  right;apply (H y0);apply (H y0);assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " inversion H0.\n  symmetry in H2;rewrite H2 in H;elim (H a);intros.\n  rewrite H2 in H6;rewrite H2.\n  assert (In x l');auto.\n  elim (in_insertion A x l' H8).\n  intro l'';intro.\n  apply cons_is_permutation with l'';trivial.\n  apply IHl;trivial.\n  split;intro.\n  elim (H x0);intros.\n  elim (in_insertion_inv A x0 x l'' l');auto.\n  intro;rewrite H13 in H10;rewrite H2 in H5;tauto.\n  elim (H x0);intros.\n  case H12;try tauto.\n  apply (insertion_inclusion A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\n",
                "context_tokens": 690,
                "proof_start_offset": 7110,
                "proof_end_offset": 7644,
                "proof": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\nProof.\ninduction 1;intros.\ninversion H;inversion H0;apply is_permutation_refl.\ninversion H1.\napply cons_is_permutation with l'';trivial.\napply cons_is_permutation with l';trivial.\nelim (insertion_trans A l' l'' x H0 l3 x0 H2).\nintro l4;intro.\nelim H8;intros.\napply cons_is_permutation with l4;trivial.\neapply IHis_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l1.\n  apply permutation_preserve; auto.\n  intros.\n  apply (H l3).\n  apply (H x0).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  apply (H0 x).\n  applyQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l1;intros.\n  inversion H.\n  subst.\n  inversion H0.\n  exists l1;split;[apply sorted_list | apply sorted_list].\n  apply (incl_cons A a l1 l2);apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l1 l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_remove A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l2);trivial.\n  apply (incl_cons A a l3);Qed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l0;intros;simpl.\n  apply (IHl1 x l2);trivial.\n  apply (IHl2 x l1);trivial.\n  apply (IHl2 x l2);trivial.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction l1.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l1;intros.\n  inversion H0.\n  destruct H.\n  exists l1;split;[apply H2 | apply H3].\n  apply (H2 (x::l2));split;[apply H2 | apply H3].\n  apply (H2 (x::l2));split;[apply H3 | apply H4].\n  apply (H3 (x::l2));split;[apply H3 | apply H4].\n  apply (H3 (x::l2));split;[apply H3 | apply H4].\n  apply (H2 (x::l2));split;[apply H4].\n  apply (H3 (x::l2));split;[apply H4|apply H4].\n  apply (H2 (x::l2));split;[apply H4].\n  apply (H2 (x::l2));split;[apply H4|apply H5].\n  apply (H2 (x::l2));split;[apply H4|apply H5].\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l1;intros.\n  inversion H.\n  apply H0.\n  apply H1.\n  apply H3.\n  apply (H x).\n  apply (H x).\n  apply (H2 H3).\n  apply (H1 H3).\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l0;intros; inversion H.\n  destruct l2;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l1;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l1;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l1;simpl;trivial.\n  destruct l3;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct l2;simpl;trivial.\n  destruct lQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l1;intros;simpl in *;intros;inversion H;clear H.\n  inversion H.\n  exists (y0::l1);split;[apply head_insertion;trivial | apply tail_insertion;trivial].\n  elim (IHbol l1 l2);intro l3;intro.\n  elim (H a); intros.\n  elim (H a); intros.\n  elim (H a); intros.\n  elim (H a); intros.\n  elim (H a); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a); intros.\n  elim (H a); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elim (H a0); intros.\n  elimQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\ninduction 1;intros.\ninversion H0.\nexists x0.\nsplit;[apply H1 | apply H2].\nauto.\napply IHpermut.\nQed.",
                    "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction l0;intros.\n  inversion H.\n  destruct l0.\n  simpl;apply H0.\n  simpl;apply H.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.\n  simpl;apply H0.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " A x l'' l');trivial.\n  intro;rewrite <- H13 in H10.\n  elim (is_set_insertion_in A l'' l' x);trivial.\n  eapply is_set_insertion;eauto.\nQed.\n\n(** is_permutation is reflexive *)\nLemma is_permutation_refl : forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\n",
                "context_tokens": 722,
                "proof_start_offset": 7681,
                "proof_end_offset": 7890,
                "proof": "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\ninduction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction l;intros.\ninversion H;clear H0.\nexists (a::l');split;[apply is_true_is_true_is_false].\napply (is_true_is_false_is_false_is_true_is_false_is_false_is_false_is_false_is_false).\napply (is_false_is_false_is_false_is_false_is_false_is_true_is_false_is_false).\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l;intros.\n  inversion H.\n  apply incl_refl.\n  apply incl_trans with l';auto.\n  apply incl_preserve_incl with l';auto.\n  apply incl_preserve_incl with l';auto.\n  apply incl_preserve_incl with l';auto.\n  apply incl_preserve_incl with l';auto.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l);trivial.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l');trivial.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l);trivial.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l);trivial.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l');trivial.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l');trivial.\n  apply is_permutation_intro.\n  apply (is_permutation_intro A l');trivial.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  apply is_permutation;apply NoDup_concat_permutation;apply NoDup_concat_permutation;apply NoDup_concat_permutation;apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation;\n    apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation;\n    apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat;\n    apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation; apply NoDup_concat_permutation;Qed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  unfold is_permutation;auto.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction l.\n  apply is_permutation_intro.\n  apply (is_permutation_intro (is_permutation_1 (is_permutation A l' l'));assumption.\n  apply (is_permutation_intro (is_permutation_1 (is_permutation_2 (is_permutation_2 (is_permutation_2 (is_permutation A l' l)));assumption.\n  apply (is_permutation_intro (is_permutation_2 (is_permutation_3 (is_permutation_3 (is_permutation_1 (is_permutation_2 (is_permutation_2 (is_permutation A l' l))));assumption.\n  apply (is_permutation_1 (is_permutation_3 (is_permutation_3 (is_permutation_2 (is_permutation_2 (is_permutation_1 (is_permutation_2 (is_permutation_3 (is_permutation_2 (is_permutation_4 (is_permutation_4 (is_permutation_5 (is_permutation_2 (only_comm A l' l')))\n   by (apply is_permutation_5_2;assumption).\n  apply (is_permutation_2 (is_permutation_3 (is_permutationQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction l.\n  apply is_permutation_trivial.\n  apply NoDup_Permutation;apply NoDup_Permutation;apply NoDup_Permutation;apply NoDup_Permutation; apply NoDup_Permutation; apply NoDup_Permutation; apply NoDup_Permutation; apply NoDup_Permutation; apply NoDup_Permutation; apply NoDup_Permutation; apply NoDup_Permutation; assumption.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;intros.\n  inversion H;clear H0;apply is_permutation_trans with l';assumption.\n  apply NoDup_Permutation;apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\n  apply NoDup_remove;assumption.\nQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\ninduction 1.\n  apply False_ind;apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_permutation_intro.\n  apply (is_permutation_intro A);apply is_midpoint_id with l;auto.\n  apply (is_permutation_intro A);apply is_midpointQed.",
                    "Lemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\nProof.\n  induction l;intros;auto.\n  apply is_permutation_intro.\n  apply (is_permutation_trans A l);assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " forall (A:Set)(l:list A),(is_permutation A l l).\n  induction l.\n  apply nil_is_permutation.\n  eapply cons_is_permutation;[apply IHl | apply head_insertion].\nQed.\n\n(** if l' is l where x has been inserted then l' is a permutation of x::l *)\nLemma insertion_is_permutation : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(is_permutation A (x::l) l').\n  induction 1.\n  apply cons_is_permutation with l;[apply is_permutation_refl | apply head_insertion].\n  apply cons_is_permutation with (y::l);[apply is_permutation_refl | apply tail_insertion;trivial].\nQed.\n\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\n",
                "context_tokens": 716,
                "proof_start_offset": 7892,
                "proof_end_offset": 8346,
                "proof": "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\nProof.\ninduction l;simpl;intros.\ninversion H;simpl;tauto.\ninversion H;simpl.\nsplit;intro.\ncase H5;intro.\neapply insertion_in;rewrite H6 in H4;apply H4.\nelim (IHl l'0 H2 x);intros.\neapply insertion_inclusion;eauto.\ncase (in_insertion_inv A x a l'0 l' H4 H5);intro.\nrewrite H6;tauto.\nelim (IHl l'0 H2 x);intros.\nright;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros.\n  inversion H.\n  apply in_or_app in H1.\n  apply in_or_app in H1.\n  destruct H1.\n  destruct H.\n  subst.\n  apply in_or_app in H1.\n  destruct H1.\n  subst.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros.\n  inversion H;clear H0.\n  apply in_or_app with l';auto.\n  inversion H1.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l'';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l';auto.\n  apply in_or_app with l'';auto.\n  apply in_or_app with lQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros;apply (is_permutation_intro (A:=A) (l':=l')) : forall l1 l2, NoDup l1 -> NoDup l2 -> NoDup (l1++l2).\n  induction 1;intros; inversion H0;clear H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H;subst;trivial.\n  inversion H0;subst;trivial.\n  inversion H;Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros.\n  apply False_ind;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H0;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H2].\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros;apply NoDup_In;apply NoDup_In;apply NoDup_In;apply NoDup_In;apply NoDup_In;apply NoDup_In;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove;apply NoDup_remove; assumption.\n  inversion H0;apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\n  apply NoDup_remove; apply NoDup_remove; apply NoDup_remove; assumption.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;intros;trivial.\n  apply in_or_app in H;destruct H;subst;trivial.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H;destruct H;subst;tauto.\n  apply in_or_app in H; destruct H;subst;tauto.\n  apply in_or_app in H;Qed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros.\n  apply H.\n  apply in_split with (y::l');auto.\n  apply in_split with (y::l');auto.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction 1.\n  apply False_ind.\n  apply (H (In x l'));auto.\n  left;apply (H (In x l'));auto.\n  right;apply (H (In x l'));auto.\n  right;apply (H (In x l'));auto.\nQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros;apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  applyQed.",
                    "Lemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  intros;apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_In.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "\n(** if l1 is l0 where x has been inserted and l2 is l1 where y has been inserted then there is l3 such that l3 is l0 where y has been inserted and l2 is l3 where x has been inserted *)\nLemma insertion_trans : forall (A:Set)(l0 l1:list A)(x:A),(insertion A x l0 l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\n",
                "context_tokens": 710,
                "proof_start_offset": 8348,
                "proof_end_offset": 8572,
                "proof": "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\nProof.\nintros.\neapply permutation_insertion;eauto.\napply is_permutation_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  left;apply IHl';apply is_true_is_true;assumption.\n  right;apply IHl';apply is_true_is_false;assumption.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\n  simpl; tauto.\nQedQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  left;apply permutation_in;rewrite H6 in H4;apply H4.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H;simpl;tauto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;apply H0.\n  right;apply (H1 x0 H2).\n  left;auto.\n  right;apply (H2 x0 H3).\n  left;auto.\n  left;apply (H1 x0 H3).\n  left;auto.\n  left;auto.\n  right;apply (H2 x0 H2).\n  right;auto.\n  right;apply (H2 x0 H3).\n  right;auto.\n  right;apply (H2 x0 H3).\n  right;auto.\n  left;apply (H2 x0 H3).\n  right;auto.\n  right;auto.\n  right;apply (H2 x0 H3).\n  right;auto.\n  left;apply (H2 x0 H3).\n  right;auto.\n  right;apply (H2 x0 H3).\n  left;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros;trivial.\n  split;intro.\n  case H5;intro.\n  apply H0;auto.\n  left;auto.\n  left;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  left;apply H;apply permutation_remove;apply sorted_remove;apply sorted_remove;apply sorted_remove;apply sorted_remove;apply sorted_remove;apply sorted_remove;apply sorted_remove;apply sorted_remove; apply sorted_remove; assumption.\n  left;apply H;apply sorted_remove;apply sorted_remove;apply sorted_remove; apply sorted_remove; assumption.\n  right;apply H;apply sorted_remove;apply sorted_remove; apply sorted_remove; assumption.\n  right;apply H;apply sorted_remove; apply sorted_remove; assumption.\n  right;apply H;apply sorted_remove; assumption.\n  right;apply H; apply sorted_remove; assumption.\nQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl; tauto.\n  left;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  left;apply NoDup_Permutation with (a::l');trivial.\n  left;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.\n  right;apply NoDup_Permutation with (a::l');trivial.Qed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;simpl; tauto.\n  right;apply IHl';apply (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (fis_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutation (f_is_permutationQed.",
                    "Lemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  induction l;simpl;intros.\n  inversion H;clear H;inversion H0;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  apply (H0 x).\n  apply (H3 x).\n  apply (H1 x).\n  apply (H3 x).\n  apply (H1 x).\n  apply (H2 x).\n  apply (H2 x).\n  apply (H3 x).\n  apply (H2 x).\n  apply (H1 x).\n  apply (H3 x).\n  apply (H3 x).\n  apply (H4 x).\n  apply (H2 x).\n  apply (H2 x).\n  apply (H4 x).\n  apply (H2 x).\n  apply (H4 x).\n  apply (H4 x).\n  apply (H2 x).\n  apply (H2 x).\n  apply (H4 x).\n  apply (H4 x).\n  apply (H3 x).\n  apply (H3 x).\n  apply (H4 x).\n  apply (H4 x).\n  apply (H4 x).\n  apply (H2 x).\n  apply (H4 x).\n  apply (H4Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " l1)->forall (l2:list A)(y:A),(insertion A y l1 l2)->exists l3:list A,(insertion A y l0 l3)/\\(insertion A x l3 l2).\n  induction 1;intros.\n  inversion H.\n  exists (y::l);split;[apply head_insertion | apply tail_insertion;apply head_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 8574,
                "proof_end_offset": 8857,
                "proof": "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\nProof.\nintros.\napply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (length_leA_dec (length a) (length l')); intro.\n  case (In_dec (length a) l'); intro.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  right;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  right;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::l'));simpl.\n  right;apply (In_length (a::l'));simpl.\n  right;apply (In_length (a::l'));simpl.\n  left;apply (In_length (a::Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (H (length_In x) (length_In x)) in H; auto.\n  rewrite (length_In x) in H.\n  rewrite (length_In x) in H.\n  rewrite (length_In x) in H; try assumption.\n  rewrite (length_In x) in H.\n  rewrite (length_In x) in H.\n  simpl in H.\n  apply (H (length x)) in H.\n  omega.\n  apply (H (length x)) in H; auto.\n  omega.\n  apply (H (length x)) in H; auto.\n  omega.\n  apply (H (length x)) in H; auto.\n  omega.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (H (a:=a) (b:=a) (b:=a) (b:=a) (b:=a) H H0).\n  apply (H (a:=a) (b:=a) (b:=a) (b:=a) H H0).\n  apply (H (a:=a) (b:=a) (b:=a) (b:=a) (H:=a) (b:=a) H H0).\n  apply (H (a:=a) (b:=a) (b:=a) H H0).\n  apply (H (a:=a) (b:=b) (b:=a) H H0 H1).\n  apply (H (a:=a) (b:=a) (b:=a) (H:=a) H H0).\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  induction l;simpl;intros.\n  inversion H.\n  inversion H;clear H0;subst.\n  split;intro.\n  case H1;intro.\n  eapply H;apply H2.\n  apply (H a);auto.\n  left;apply IHl';auto.\n  right;apply IHl';auto.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros;induction H;simpl;intros.\n  left;apply H;apply (H a);trivial.\n  right;apply H;apply (H a);trivial.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros; apply NoDup_dec.\n  apply NoDup_incl.\n  apply NoDup_Permutation_sym.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  induction H;simpl;intros.\n  left;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  left;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  left;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\n  right;apply IHl;trivial.\nQed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply NoDup_Permutation with (P:=fun (a:A)(x:A)(l':list A),(forall (y:A)(P y}), P y -> P y) -> forall l, NoDup l -> NoDup l -> forall x, In x l -> P x.\n  intros.\n  induction H;simpl;intros.\n  inversion H;clear H0;subst;inversion H0;apply NoDup_remove in H2.\n  destruct H0 as [x [Ha1 [Ha2 [Ha3 [Ha4 Hc]]]]].\n  apply NoDup_cons in Ha3.\n  destruct Ha3 as [H0 H1].\n  apply NoDup_cons in Ha3.\n  destruct Ha3 as [H1 H2].\n  apply NoDup_remove in Ha3.\n  destruct Ha3 as [H1 H2].\n  apply NoDup_remove in Ha3.\n  destruct Ha3 as [H1 H2].\n  apply NoDup_remove in Ha3.\n  destruct Ha3 as [H1 H2].\n  apply NoDup_remove in Ha3.\n  destruct Ha3 as [H1 H2].\n  apply NoDup_remove in Ha3.\n  destruct Ha3 as [H1 H2].Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply NoDup_dec.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n Qed.",
                    "Lemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros; apply (length_Permutation_length (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (P x)) (fun x => (PQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_insertion].\n  exists l';split;[trivial | apply head_insertion].\n  inversion H0.\n  exists (y0::y::l);split;[apply head_insertion | apply tail_insertion;apply tail_insertion;trivial].\n  elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\n",
                "context_tokens": 720,
                "proof_start_offset": 8859,
                "proof_end_offset": 9031,
                "proof": "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\nProof.\ninduction 1;simpl;trivial.\nrewrite IHinsertion;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (fun l:list A => length l = length l');trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l');trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l'));trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l'));trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l));trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l');trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l);trivial.\n  apply (well_founded_ind (fun l:list A => length l = length l'); firstorder.\nQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = (length l) /\\ length l' = (length l) /\\ length l = (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof A) (fun l:list A => length l = (length l) /\\ length l' = (length l)).\n  intros.\n  apply (well_founded_induction A (length l)); intros.\n  apply (well_founded_ltof A) with (P:=fun l:list A => length l = (length l) /\\ length l' = (length l)).\n  intros.\n  rewrite H2.\n  simpl.\n  apply (well_founded_induction A (length l)); intros.\n  rewrite H2.\n  simpl.\n  apply (well_founded_induction A (length l)); intros.\n  rewrite H3.\n  simpl.\n  apply (well_founded_induction A (length l)); intros.\n  simpl.\n  apply (well_founded_induction A (length l)); intros.\n  rewrite H3.\n  simpl.\n  apply (well_founded_induction A (length l)); intros.\n Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  inversion H;clear H;simpl;intros.\n  apply (H a (S a) (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (S a) (length l'));trivial.\n  apply (H a (S a) (S a) (S a) (S aQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction l;simpl;intros.\n  apply NoDup_nil.\n  apply NoDup_cons.\n  apply NoDup_incl.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  applyQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simpl;intros.\n  apply (well_founded_induction (length l'));simplQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_induction (length l)); simpl; intros.\n  apply (well_founded_ind (length l')); simpl;intros.\n  apply (well_founded_ind (length l')); simpl; intros.\n  apply (well_founded_induction (length l')); simpl; intros.\n  apply (H a x0); simpl;apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.\n  apply (H a y0); simpl;trivial.Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l') (fun l:list A => length l' = S (length l)).\n  apply (well_founded_ltof (list A) (fun l:list A => length l' = S (length l)) (fun l:list A => length l' = S (length l)).\n  apply (well_founded_ltof A (list A) (fun l:list A => length l' = S (length l)).\n  apply (well_founded_ltof A (list A) (fun l:list A => length l' = S (length l)).\n  apply (well_founded_ltof A (list A) (fun l:list A => length l) (fun l:list A => length l = S (length l)).\n  apply (well_founded_ltof A (list A) (fun l:list A => length l) (fun l:list A => length l = S (length l))).\n  apply (well_founded_ltof A (list A) (fun l:list A => length l) (fun l:list A => lengthQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (fun l:list A => length l = length l'); unfold ltof;simpl;intros.\n  apply (well_founded_ind (fun l:list A => length l' = length l')); unfold ltof;simpl;intros.\n  apply (well_founded_ltof (list A) (fun l:list A => length l' = length l')); unfold ltof;simpl;intros.\n  apply (well_founded_ltof A (length l) l' H H0 H1).\n  apply H; auto.\n  case (length l'); simpl; intros.\n  apply (H l'); auto.\n  case (length l'); simpl; intros.\n  apply (H l'); auto.\n  case (In_length l l'); simpl; intros.\n  apply (H l'); auto.\n  apply (H l'); auto.\n  case (In_length l l'); simpl; intros.\n  apply (H l'); auto.\n  case (In_length l l'); simpl; intros.\n  apply (H l'); auto.\n  case (In_length l l'); simpl; intros.\n  apply (H l'); auto.\n  case (In_length l lQed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intro;apply (length_induction _ (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length l'); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length l'); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length l'); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length l'); simpl.\n  apply (length_tail (length l')); simpl.\n  apply (length_Qed.",
                    "Lemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l = S (length l')) (length l')); unfold ltof;auto.\n  case (in_dec (length l) l'); intros.\n  case (in_dec (length l) l'); intros.\n  elim H2; intros.\n  rewrite H2.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl.\n  simpl;auto.\n  apply IHl.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\n  apply IHl.\n  simpl;auto.\n  apply IHl'.\n  simpl;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " elim (IHinsertion l'0 y0 H5);intro l3;intro.\n  elim H6;intros.\n  exists (y::l3);split;[apply tail_insertion | apply tail_insertion];trivial.\nQed.\n\n(** if l1 is a permutation of l0 and then l1 where x has been inserted is a permutation of l0 where x has been inserted *)\nLemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 9033,
                "proof_end_offset": 9234,
                "proof": "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\nProof.\ninduction 1;simpl;trivial.\ngeneralize (insertion_length A l' l'' x H0);intro;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (length l));simpl.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_PermutationQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intro;apply (length_Permutation l);simpl;trivial.\n  rewrite H1;simpl;trivial.\n  rewrite H1;simpl;trivial.\n  rewrite H1;simpl;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (length l) (length l')); intros.\n  apply (well_founded_ind (length l) (length l')); intros.\n  apply (well_founded_induction_type (length l')); intros.\n  apply (well_founded_induction_type (length l')); intros.\n  apply (H y H0 H2).\n  apply (H y H0 H3).\n  apply (H1 y H0 H1).\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_induction (length l'));simpl;trivial.\n  apply (well_founded_induction (length l'));simpl;trivial.\n  rewrite IH:@lt_length (length l'));simpl;trivial.\n  rewrite <- IH:@lt_length (length l'));simpl;trivial.\n  rewrite <- IH:@lt_length (length l'));simpl;trivial.\n  rewrite <- IH:@lt_length (length l'));simpl;trivial.\n  rewrite <- IH;trivial.\n  rewrite <- IH;trivial.\n  rewrite <- IH;trivial.\n  rewrite <- IH;trivial.\n  rewrite <- IH;trivial.\n  rewrite <- IH;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  unfold LS, LS, LS, LS.\n  simpl.\n  induction l;simpl;trivial.\n  rewrite IHPermuted;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (length l) (length l'));simpl;trivial.\n  rewrite <- (app_length l l') at 1.\n  apply (in_map (@app A) (a:=a) (a:=a));simpl;trivial.\n  apply IHl';auto.\n  apply (in_map (@app A) (a:=a) (a:=a));simpl;trivial.\n  apply IHl';auto.\n  apply (in_map (@app A) (a:=a) (a:=a));simpl;trivial.\n  apply IHl';auto.\n  apply (in_map (@app A) (a:=a) (a:=a));simpl;trivial.\n  apply IHl';auto.\n  apply IHl';auto.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (length l)); intros.\n  apply (well_founded_ltof (length l')); intros.\n  apply (well_founded_induction (length l')); intros.\n  apply (well_founded_induction (length l')); intros.\n  apply (H1 (length l')); intros.\n  apply (H2 (length l')); intros.\n  apply (H3 (length l')); intros.\n  apply (H1 (length l')); intros.\n  apply (H3 (length l')); intros.\n  apply (H3 (length l')); intros.\n  apply (H4 (length l')); intros.\n  apply (H5 (length l')); intros.\n  apply (H2 (length l')); intros.\n  apply (H4 (length l')); intros.\n  apply (H3 (length l')); intros.\n  apply (H4 (length l')); intros.\n  apply (H2 (length l')); intros.\n  apply (H4 (length l')); intros.\n  apply (H2 (length l')); intros.\n  apply (H2 (length l')); intros.\n  apply (H4 (length l')); intros.\n  apply (H2 (length l')); introsQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IHorted;trivial.\nQed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  intros.\n  apply (well_founded_ind (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n  apply (well_founded_induction (length l'));simpl.\n Qed.",
                    "Lemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction l;simpl;trivial.\n  rewrite IHCompSpec2;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "Lemma permutation_insertion : forall (A:Set)(l0 l1:list A),(is_permutation A l0 l1)->forall (x:A)(l2 l3:list A),(insertion A x l0 l2)->(insertion A x l1 l3)->(is_permutation A l2 l3).\n  induction 1;intros.\n  inversion H;inversion H0;apply is_permutation_refl.\n  inversion H1.\n  apply cons_is_permutation with l'';trivial.\n  apply cons_is_permutation with l';trivial.\n  elim (insertion_trans A l' l'' x H0 l3 x0 H2).\n  intro l4;intro.\n  elim H8;intros.\n  apply cons_is_permutation with l4;trivial.\n  eapply IHis_permutation;eauto.\nQed.\n\n(** is_permutation is symmetric *)\nLemma is_permutation_sym : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A l' l).\n  induction 1;[apply nil_is_permutation | eapply permutation_insertion;eauto;apply head_insertion].\nQed.\n\nLemma permutation_in : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A),(In x l)<->(In x l').\n  induction l;simpl;intros.\n  inversion H;simpl;tauto.\n  inversion H;simpl.\n  split;intro.\n  case H5;intro.\n  eapply insertion_in;rewrite H6 in H4;apply H4.\n  elim (IHl l'0 H2 x);intros.\n  eapply insertion_inclusion;eauto.\n  case (in_insertion_inv A x a l'0 l' H4 H5);intro.\n  rewrite H6;tauto.\n  elim (IHl l'0 H2 x);intros.\n  right;auto.\nQed.\n\nLemma permutation_insertion_aux : forall (A:Set)(l l' l'':list A)(x:A),(insertion A x l l')->(insertion A x l l'')->(is_permutation A l' l'').\n  intros.\n  eapply permutation_insertion;eauto.\n  apply is_permutation_refl.\nQed.\n\nLemma length_recursion : forall (A:Set),forall (P:list A->Prop),(forall (x:list A),(forall (y:list A),(length y)<(length x)->(P y))->(P x))->(forall (a:list A),(P a)).\n  intros.\n  apply (well_founded_ind (well_founded_ltof (list A) (fun l:list A => length l)));unfold ltof;auto.\nQed.\n\nLemma insertion_length : forall (A:Set)(l l':list A)(x:A),(insertion A x l l')->(length l')=(S (length l)).\n  induction 1;simpl;trivial.\n  rewrite IHinsertion;trivial.\nQed.\n\nLemma permutation_length : forall (A:Set)(l l':list A),(is_permutation A l l')->(length l)=(length l').\n  induction 1;simpl;trivial.\n  generalize (insertion_length A l' l'' x H0);intro;congruence.\nQed.\n\n",
                "context_tokens": 705,
                "proof_start_offset": 9236,
                "proof_end_offset": 10306,
                "proof": "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\nProof.\ninduction l;intros;inversion H.\ninversion H0.\napply is_permutation_refl.\nrewrite <- H4;destruct l.\ninversion H8.\ngeneralize (head_insertion A a0 l);intro.\nassert (In x (a0::l)).\neapply insertion_in;apply H8.\ncase (in_insertion_inv A x a0 l (a0::l) H10 H11);intro.\nrewrite H12;rewrite <- H12 in H10;rewrite <- H12 in H8;rewrite <- H12 in IHl.\nassert (is_permutation A l l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nelim (in_insertion A x l H12);intro l2;intro.\ngeneralize (tail_insertion A x a0 l2 l H13);intro.\nassert (is_permutation A (a0::l2) l1).\neapply IHl;eauto.\napply is_permutation_sym;auto.\neapply cons_is_permutation;eauto.\nrewrite H1 in H3.\ninversion H0.\nrewrite <- H9;apply insertion_is_permutation;trivial.\nassert (is_permutation A l0 l1).\neapply IHl;eauto.\neapply cons_is_permutation;eauto;apply head_insertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (Permutation_length H H0 H1 H2).\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_PermutationQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (partial_length_In A l l' x H0 H1 H2).\n  apply (partial_length_In A l l' x H0 H2).\n  apply (partial_length_In A l' x H0 H2).\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l' = l')); unfold ltof;auto.\n  apply (well_founded_ltof A (fun l:list A => length l' = l')); unfold ltof;auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l' = 0) (length l)); unfold ltof;simpl;auto.\n  apply (well_founded_ltof A (length l')); auto.\n  apply (well_founded_ltof A (length l')); auto.\n  apply (well_founded_ltof A (length l')); auto.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;tauto.\n  generalize (insertion_length A l' l' x H0);intro;omega.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros;apply permutation_permutation_eq; apply Permutation_length;apply Permutation_length; assumption.\n  rewrite IHl';apply Permutation_length; assumption.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction 1;simpl;trivial.\n  rewrite (app_length l l' l'') at 1.\n  apply (in_map l l');simpl.\n  rewrite (app_length l l') at 1.\n  apply (in_map l l');simpl.\n  rewrite (app_length l l''); simpl.\n  rewrite (app_length l l') at 1.\n  rewrite (app_length l l''); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewrite (app_length l l'); simpl.\n  rewriteQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  intros.\n  apply (well_founded_ind (list A) (fun l:list A => length l' = 0) (fun l:list A => length l' = 0) l' x H0).\n  apply (well_founded_ltof (list A) (fun l:list A => length l' = 0) l' x H0).\n  intros.\n  rewrite (permut_nil (x:=x)) in H0.\n  apply (H0 H1 (x:=x) H1 (x:=x) H2 H3 H4 H5)).\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;tauto.\n  generalize (insertion_length A l' x H0);intro;congruence.\nQed.",
                    "Lemma insertion_permutation_eq : forall (A:Set)(l l':list A)(x:A),(insertion A x l' l)->forall (l'':list A),(insertion A x l'' l)->(is_permutation A l' l'').\n  induction l;simpl;trivial.\n  rewrite <- IHl';apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in;apply Permutation_sym.\n  apply Permutation_in;apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in;apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in;apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in; apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in; apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in;apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in;apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "1 l2.\n  generalize l1;clear l1.\n  induction l2;intros.\n  inversion H.\n  inversion H.\n  subst a.\n  subst x0.\n  subst l.\n  subst l2.\n  inversion H0.\n  subst x0.\n  subst l.\n  subst l''.\n  exists l'.\n  tauto.\n  subst x0.\n  subst l'.\n  subst a.\n  subst l1.\n  inversion H0.\n  subst x0.\n  subst l''.\n  subst l0.\n  elim (IHl2 l x H4 l' H3).\n  intro l3;intros.\n  elim H1;clear H1;intros.\n  elim (insertion_trans A l3 l' x H2 l4 y H6).\n  intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 12697,
                "proof_end_offset": 12967,
                "proof": "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\nProof.\nintros.\napply is_permutation_reverse_impl_is_permutation.\nrewrite rev_involutive.\nrewrite rev_involutive.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_or.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply H.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply H.\n  apply is_permutation_5.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_trivial.\n  apply is_permutation_2.\n  apply is_permutation_4.\n  apply is_permutation_4.\n  apply H.\n  apply not_same_permutation_1.\n  apply H.\n  apply (is_permutation_1 (A:=A)).\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_1.\n  apply is_permutation_2.\n  apply is_permutation_2.\n  apply is_true_is_permutation_2.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_identity.\n  apply is_permutation_symmetry.\n  apply is_permutation_identity.\n  apply is_permutation_2.\n  apply is_permutation_2.\n  apply is_permutation_1.\n  apply is_permutation_1.\n  apply is_permutation_1.\n  apply is_true_is_permutation_1.\n  assumption.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_2.\n  apply is_permutation_2.\n  apply is_permutation_1.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply is_true_is_permutation.\n  apply not_true_is_permutation.\n  apply not_true_is_permutation.\n  apply not_false_is_permutation.\n  apply not_true_is_permutation.\n  apply not_true_is_permutation.\n  apply not_true_is_false.\n  apply not_true_is_permutation.\n  apply not_false_is_permutation.\n  apply not_true_is_permutation.\n  apply not_true_is_false.\n  apply not_true_is_permutation.\n  apply not_false_is_permutation.\n  apply not_false_is_permutation.\n  apply not_true_is_permutation.\n  apply not_true_is_permutation.\n  apply not_false_is_false.\n  apply not_true_is_permutation.\n  apply not_true_is_permutation.\n  apply not_true_is_false.\n  apply not_false_is_permutation.\n  apply notQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_5.\n  apply not_true_is_permutation.\n  apply is_permutation_5.\n  apply is_true_is_permutation.\n  apply is_permutation_5.\n  apply is_true_is_permutation.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  eapply is_permutation_4.\n  apply is_permutation_4.\n  apply is_permutation_4.\n  apply is_permutation_1.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply is_permutation_5.\n  apply H.\nQed.",
                    "Lemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_1.\n  apply is_permutation_1.\n  apply is_permutation_1.\n  apply is_permutation_1.\n  apply is_permutation_1.\n  apply not_is_permutation_1.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation_1.\n  apply H.\n  apply is_permutation_1.\n  apply not_is_permutation_1.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply l; apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply (is_permutation_1 (A:=A)).\n  apply not_is_permutation_1.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply H.\n  apply not_is_permutation.\n  apply l; applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro l5;intros.\n  elim H5;clear H5;intros.\n  exists l5.\n  split;trivial.\n  eapply cons_is_permutation.\n  apply H1.\n  trivial.\nQed.\n\nLemma permutation_insertion_permutation : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (x:A)(l'':list A),(insertion A x l' l'')->forall (l''':list A),(is_permutation A l'' l''')->(is_permutation A (x::l) l''').\n  induction 1;intros.\n  inversion H.\n  rewrite <- H3 in H0.\n  trivial.\n  elim (permutation_insertion_comm A l'' l''0 x0 H1 l''' H2).\n  intro l1;intro.\n  elim H3;clear H3;intros.\n  eapply cons_is_permutation.\n  eapply IHis_permutation.\n  apply H0.\n  apply H3.\n  trivial.\nQed.\n\n(** is_permutation is transitive *)\nLemma is_permutation_trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 13186,
                "proof_end_offset": 13460,
                "proof": "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\nProof.\ninduction 1.\nsimpl.\nintros.\napply head_insertion.\nintros.\nsimpl.\napply tail_insertion.\napply IHinsertion.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_l (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_2 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_2 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_2 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutation_2 (remove x ss)).\n  apply (is_permutation_1 (remove x ss)).\n  apply (is_permutationQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_remove H).\n  apply (is_permutation_remove H).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  apply (is_permutation_remove H0).\n  applyQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_1).\n  apply List.NoDup_app_assoc.\n  apply (is_permutation_1).\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply Permutation_Permutation.\n  apply Permutation_sym.\n  apply PermutationQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_trans (app (x:=xs) (app (x:=xs) (x:=xs) (app (x:=xs) (x:=xs) (app xss yss))).\n  apply (is_permutation_trans (app (x:=xs) (x:=xs) (x:=xs) (app xss yss))).\n  apply (is_permutation_trans (app (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (app xss yss)).\n  apply (is_permutation_trans (app (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (y:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (list_is_permutation_1 H).\n  apply permut.\nQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_1).\n  apply (is_permutation_3).\n  apply (is_permutation_4 (remove x ss)).\n  apply (is_permutation_4 (remove x ss)).\n  apply (is_permutation_4 (remove x ss)).\n  apply (is_permutation_4 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_4 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n  apply (is_permutation_5 (remove x ss)).\n Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (my_app_comm (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_app_assoc (x:=s)).\n  apply (my_appQed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_2).\n  apply NoDup_map.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply NoDup_Permutation.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_2 (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (only_one (in_sing xms)))))));\n    [apply (is_permutation_2 (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (only_one (is_permutation (only_one (is_permutation (only_one (in_sing xms xms))))|].\n  rewrite (is_permutation (is_permutation (is_permutation (is_permutation (is_permutation (only_one (is_permutation (is_permutation (is_permutation (only_one (is_permutation (only_one (only_one (in_sing xms xms))) (only_one (only_one (only_one (only_one (only parsing))) (only_one (only parsing)))\n    | [ |- context [(is_permutation (only_one (only_one (only parsing))) ] ]Qed.",
                    "Lemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  intros.\n  apply (is_permutation_trans (app xss) (app yss) (app (xss:=rev sigma) (xss:=rev sigma) (xss:=rev sigma))).\n  apply is_permutation_trans.\n  apply is_permutation_1.\n  apply (is_permutation_1 (rev (l++yss)) (rev (l++yss))).\n  apply add_app.\n  apply rev_involutive.\n  apply (is_permutation_1 (rev (l++yss)) (rev (xss ++ yss)) (rev (xss ++ yss))).\n  apply add_app.\n  apply (is_permutation_2 (rev (l++yss)) (rev (xss ++ yss))).\n  apply add_app.\n  apply (is_permutation_1 (rev (l++yss)) (rev (xss ++ yss))).\n  apply add_app.\n  apply (is_app (rev (l++yss)) (rev (xss ++ yss))).\n  apply add_app.\n  apply (is_permutation_2 (rev (l ++ yss)) (rev (xss ++ yss))).\n  apply add_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "trans : forall (A:Set)(l l':list A),(is_permutation A l l')->forall (l'':list A),(is_permutation A l' l'')->(is_permutation A l l'').\n  induction l.\n  intros.\n  inversion H.\n  rewrite <- H2 in H0;trivial.\n  intros.\n  inversion H.\n  induction H5;inversion H0.\n  eapply cons_is_permutation;try (apply IHl with l1;eauto);trivial.\n  eapply permutation_insertion_permutation.\n  apply H3.\n  apply tail_insertion.\n  apply H5.\n  eapply cons_is_permutation.\n  apply H8.\n  apply H10.\nQed.\n\nLemma is_permutation_reverse : forall (A:Set)(l:list A),(is_permutation A l (rev l)).\n  induction l.\n  simpl.\n  apply nil_is_permutation.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHl.\n  apply insertion_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\n",
                "context_tokens": 672,
                "proof_start_offset": 13801,
                "proof_end_offset": 14387,
                "proof": "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\nProof.\ninduction 1;intros.\nexists (cons x0 xs).\nsimpl.\nsplit.\nsubst x;subst l;auto.\napply head_insertion.\ndestruct xs.\ndiscriminate H1.\nsimpl in H1.\ninjection H1;clear H1;intros.\nelim (IHinsertion _ _ _ H0 _ H1).\nintro xss;intros.\nelim H3;clear H3;intros.\nexists (cons a xss).\nsimpl.\nsplit.\nsubst y;subst l';auto.\napply tail_insertion.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros.\n  simpl.\n  auto.\n  destruct (is_permutation_or_app H0).\n  apply IHs.\n  apply IHs.\n  apply IHs.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros; simpl.\n  destruct xs.\n  simpl.\n  split; auto.\n  destruct (app_or_app_or _ _ _ _ H1).\n  destruct H2.\n  subst.\n  assert (In x (xs ++ ys)).\n  apply in_or_app_or.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_appQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  apply (insert_preserves_insert_In A x y zs (x::xs) (x::xs) (y::ys) (y::ys) (x::ys) (ys ++ zs) (x::ys) (y::ys) (y::ys) (x::ys) (y::ys) (ys ++ zs) (y::ys) (y::ys) (y::ys) (ys ++ zs)).\n  intros.\n  apply (insert_preserves_insert A x y zs (x::xs) (y::xs) (y::ys) (x::ys) (x::ys) (y::ys) (x::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (y::ys) (x::ys) (y::ys) (y::ys) (x::ys) (y::ys) (y::ys) (y::ys) (y::ys) (z::ys) (y::ys) (y::ysQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs; intros.\n  auto.\n  simpl.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_or _ _ _ H); clear H.\n  destruct (app_or_app_orQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  eapply (well_founded_induction_type (fun a:A => a = f (f a)) (fun xss:list A => f (f xss) (f xss) (f xss))).\n  intros.\n  eapply (well_founded_induction_type (fun a:A => a = f (f a)) (fun xss:list A => f (f xss) (f xss) (f xss) (f xss))).\n  intros.\n  eapply (well_founded_induction_type (fun a:A => a = f (f xss) (f xss))).\n  intros.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply acc_list_app.\n  simpl.\n  apply accQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  apply (fold_right (fun acc : list B => forall x, ys = map f xs->f xss) (fun acc : list B => acc = map f xs->f xss)).\n  intros.\n  rewrite H0 in H.\n  simpl in H.\n  destruct (is_permutation_1 H).\n  exists x.\n  split.\n  simpl.\n  apply map_NoDup.\n  apply H.\n  apply H0.\n  simpl.\n  apply map_NoDup.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros B x xs ys.\n  induction xs.\n    simpl.\n    intros.\n    apply (H (xs, ys)).\n  simpl.\n  apply (H (xs, ys)).\n  simpl.\n  apply (H (xs, ys)).\n  simpl.\n  apply (H (xs, ys)).\n  simpl.\n  apply (H (xs, ys)).\n  simpl.\n  apply (H (xs, ys)).\nQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  intros.\n  destruct (list_to_list (fun x => f xss) (xs ++ zs) (xs ++ zs) (x :: zs)) as [x [xs' xs'] [xs'' [y'xs'' [y'' [xs' [H [H' [H' H'']]]]]]]]|].\n  destruct (list_to_list xs' (xs ++ zs) (x :: zs') (x :: zs')) as [x [ys' [ys' [H' [H' H'']]]].\n  exists (xs ++ zs' ++ zs').\n  simpl.\n  apply H'.\n  apply (app_assoc_reverse (A:=A) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs') (x:=xs') (x:=xs) (x:=xs') (x:=xs) (x:=xs) (x:=xs) (x:=xs) (y:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (x:=xs) (y:=xs) (x:=xs)Qed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs.\n    simpl.\n    intros.\n    exists nil.\n    split; auto.\n    simpl.\n    split; auto.\n    simpl.\n    split; auto.\n  destruct xs.\n    simpl.\n    auto.\n  destruct ys.\n    simpl.\n    intros.\n    apply IHacc.\n    apply (H H0).\n    apply IHacc.\n    apply (H H0).\n    apply IHacc.\n    apply (H H1).\n    apply (H H1).\n    apply (H H2).\n    apply (H H2).\n    apply (H H3).\n    apply (H H2).\n    apply (H0 H3).\n    apply (H H3).\n    apply (H H3).\n    apply (H H2).\n    apply (H0 H3).\n    apply (H0 H1).\n    apply (H0 H1).\n    apply (H H3).\n    apply (H0 H1).\n    apply (H H3).\n    apply (H H3).\n    apply (H H2).\n    apply (H H3).\n    apply (H H3).\n    apply (H H3).\n    apply (H0 H3).\n    apply (H0 H3).\n    apply (HQed.",
                    "Lemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction xs.\n  simpl.\n  intros.\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equal f).\n  apply (f_equalQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": "_snoc.\nQed.\n\nLemma is_permutation_reverse_impl_is_permutation : forall (A:Set)(l l':list A),(is_permutation A (rev l) (rev l'))->(is_permutation A l l').\n  intros.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  eapply is_permutation_trans.\n  apply is_permutation_reverse.\n  apply is_permutation_sym.\n  trivial.\nQed.\n\nLemma is_permutation_impl_is_permutation_reverse : forall (A:Set)(l l':list A),(is_permutation A l l')->(is_permutation A (rev l) (rev l')).\n  intros.\n  apply is_permutation_reverse_impl_is_permutation.\n  rewrite rev_involutive.\n  rewrite rev_involutive.\n  trivial.\nQed.\n\nLemma is_permutation_cons_snoc : forall (A:Set)(x:A)(xs:list A),(is_permutation A (cons x xs) (app xs (cons x nil))).\n  intros.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply insertion_snoc.\nQed.\n\nLemma insertion_append : forall (A:Set)(x:A)(xs xss:list A),(insertion A x xs xss)->forall (yss:list A),(insertion A x (app xs yss) (app xss yss)).\n  induction 1.\n  simpl.\n  intros.\n  apply head_insertion.\n  intros.\n  simpl.\n  apply tail_insertion.\n  apply IHinsertion.\nQed.\n\nLemma is_permutation_append : forall (A:Set)(xs ys:list A),(is_permutation A xs ys)->forall (xs' ys':list A),(is_permutation A xs' ys')->(is_permutation A (app xs xs') (app ys ys')).\n  induction 1;intros.\n  simpl.\n  auto.\n  simpl.\n  eapply cons_is_permutation.\n  apply IHis_permutation.\n  apply H1.\n  apply insertion_append.\n  auto.\nQed.\n\nLemma insertion_map : forall (B:Set)(y:B)(ys yss:list B),(insertion _ y ys yss)->forall (A:Set)(f:A->B)(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\n",
                "context_tokens": 677,
                "proof_start_offset": 14389,
                "proof_end_offset": 15125,
                "proof": "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\nProof.\ninduction 1.\nintros.\ndestruct xs1;try (discriminate H).\nexists (nil (A:=A)).\nsplit.\napply nil_is_permutation.\nreflexivity.\nintros.\ndestruct xs1;try (discriminate H1).\nsimpl in H1.\ninjection H1;clear H1;intros.\nsubst x.\nelim (IHis_permutation _ _ _ H1).\nintro xs2.\nintros.\nelim H2;clear H2;intros.\nsubst l'.\nelim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\nintros.\nelim H3;clear H3;intros.\nexists x.\nsplit;auto.\neapply cons_is_permutation;eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply (is_permutation_rec_app_or_app (or_app xs1) (is_permutation_rec (or_app xs2) (is_permutation A (rev xs1))).\n  apply list_ind_app.\n  apply (is_permutation_rec_app_or_app xs1).\n  apply (is_permutation_rec_app_or_app xs2).\n  apply (is_permutation_rec_app xs2).\n  apply (is_permutation_rec_app_or_app xs1).\n  apply (is_permutation_rec_app xs1).\n  apply (is_permutation_rec_app xs2).\n  apply (is_permutation_rec_app xs1).\n  apply (is_permutation_rec_app xs2).\n  apply (is_permutation_rec xs2).\n  apply (is_permutation_rec_app xs1).\n  apply (is_permutation_rec_app xs2).\n  apply (is_permutation_rec xs2).\n  apply (is_permutation_rec_app xs2).\n  apply (is_permutation_rec_app xs2).\n  apply (is_permutation_rec l2).Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1.\n  simpl.\n  intros.\n  apply (is_permutation_cons_right A xss1).\n  apply (is_permutation_cons_right A xss2).\n  apply (is_permutation_remove_app_or A xs1).\n  apply (is_permutation_remove_app_or B xs2).\n  apply (is_permutation_remove_app_or B xs2).\n  apply (is_permutation_remove_mid B xs1).\n  apply (is_permutation_remove_mid B xs1).\n  apply (is_permutation_remove_mid B xs2).\n  apply (is_permutation_remove_mid B xs2).\n  apply (is_permutation_remove_mid B xs1).\n  apply (is_permutation_remove_mid B xs2).\n  apply (is_permutation_remove_mid B xs2).\n  apply (is_permutation_remove_mid B xs1).\n  apply (is_permutation_remove_mid B xs2).\n  apply (is_permutation_remove_mid B xs2).\n  apply (is_permutation_remove_mid B xs1).\n  apply (is_permutation_remove_mid B xs2Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  auto.\n  apply IHis_permutation.\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ _ H0).\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply IHis_permutation.\n  apply (in_map_iff_app_or _ _ _ H0).\n  apply IHis_permutation.\n  apply IHis_permutation.\n  apply IHQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply (is_permutation_rec_app_length xs ys1 ys2).\n  auto.\n  apply (is_permutation_rec_app_or xs ys2).\n  auto.\n  apply (is_permutation_rec_app_or xs ys2).\n  auto.\n  apply (is_permutation_rec_app_or xs ys1).\n  auto.\n  apply (is_permutation_rec_app_or xs ys2).\n  auto.\n  apply (is_permutation_rec_app_or xs ys1).\n  auto.\nQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply is_permutation_rec.\n  apply is_permutation_rec.\n  apply is_permutation_rec.\n  apply is_permutation_rec.\n  apply is_permutation_rec.\n  apply H.\n  apply (is_permutation_rec _ _ (is_permutation_set _ _ _)).\n  apply (is_permutation_rec _ _ (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ H0))).\n  apply H.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ H0))).\n  apply is_permutation_rec.\n  apply H.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ _ H0)).\n  apply H.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ H0))).\n  apply H.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ H0))).\n  apply H.\n  apply (is_permutation_rec _ _ _Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  inversion H; clear H; subst.\n  simpl.\n  auto.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nilQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros A xs1 ys2.\n  apply List.Forall2_impl_is_permutation.\n  apply is_permutation_NoDup.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_removeQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  intros.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ H2))); auto.\n  intros a H; inversion H; clear H; subst.\n  simpl.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ (is_permutation_rec _ _ (is_permutation_rec _ _ H2))); auto.\n  intros a H; inversion H; clear H; subst.\n  simpl.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ (is_permutation_rec _ _ (is_permutation_rec _ _ H2)))); auto.\n  intros a H; inversion H; clear H; subst.\n  simpl.\n  apply (is_permutation_rec _ _ _ (is_permutation_rec _ _ _ (is_permutation_rec _ _ (is_permutation_rec _ _ (is_permutation_rec _ _ H2)))); auto.\n  intros a H; inversion H; clear H; subst.\n  simpl.\n  apply (is_permutation_rec _ _ (is_permutation_rec _ _ _ (is_permutation_rec _Qed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  apply (in_map_inv H0).\n  destruct xs2; destruct ys2; simpl in *; auto.\n  apply (f_equal_cons H1).\n  apply (f_equal_cons H2).\n  apply (f_equal_cons H2).\n  apply (f_equal_cons H1).\n  apply (f_equal_cons H2).\n  apply (f_equal_cons H1).\n  apply (f_equal_cons H2).\n  apply (f_equal_cons H2).\n  apply (f_equal_cons H2).\n  apply (f_equal_cons H3).\n  apply (f_equal_cons H3).\n  apply (f_equal_cons H3).\n  apply (f_equal_cons H3).\n  apply (f_equal_cons H4).\n  apply (f_equal_cons H4).\n  apply (f_equal_cons H4).\n  apply (f_equal_cons H4).\n  apply (f_equal_cons H4).\n  apply (f_equal_cons H4).\n  apply (f_equal_cons H4).\n  apply (fQed.",
                    "Lemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction xs1; intros.\n  discriminate H.\n  simpl.\n  apply IHis_permutation; auto.\n  apply IHis_permutation; auto.\n  apply IHis_permutation; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": ")(x:A),y=f x->forall (xs:list A),ys = map f xs->exists xss:list A,yss = map f xss /\\ insertion _ x xs xss.\n  induction 1;intros.\n  exists (cons x0 xs).\n  simpl.\n  split.\n  subst x;subst l;auto.\n  apply head_insertion.\n  destruct xs.\n  discriminate H1.\n  simpl in H1.\n  injection H1;clear H1;intros.\n  elim (IHinsertion _ _ _ H0 _ H1).\n  intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 15959,
                "proof_end_offset": 16380,
                "proof": "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\nProof.\ninduction 1.\nexists (nil (A:=A)).\nexists l.\nsplit;try reflexivity.\nelim IHinsertion.\nintro l1.\nintro.\nelim H0.\nintro l2;intros.\nelim H1;clear H1;intros.\nexists (cons y l1).\nexists l2.\nsubst l;subst l'.\nsplit;try reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists l0.\n  apply (IHPermutation_sym l' l0).\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction l; intros; simpl.\n  destruct H; destruct H0; firstorder.\n  exists (l1 ++ x :: l').\n  split.\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply IHl.\n  intros.\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=x0)).\n  apply (IHl (x:=xQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction l.\n  simpl; intros.\n  inversion H.\n  subst l'.\n  exists (l1 ++ l2).\n  simpl.\n  split; auto.\n  apply (permut_nil _ _ H0).\n  simpl; auto.\n  apply IHl1.\n  auto.\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply IHl1.\n  auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ _ H0).\n  simpl; auto.\n  apply (permut_cons _ _ H0).\n  simpl; autoQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction l.\n  intros; exists l'.\n  apply (app_nil_or_app l' H0).\n  rewrite app_length.\n  apply Permutation_app.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_sym.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_app_tail.\n  apply Permutation_appQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists (app l l0).\n  apply NoDup_cons.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction l; intros.\n  destruct l'; simpl.\n  inversion H.\n  exists (nil (A:=A)).\n  split.\n  apply incl_app.\n  eapply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.\n  apply incl_tl.Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  intros.\n  destruct l; [left|right];\n  intros; destruct H;\n  [left|right];\n  intros;\n  generalize (H x l' x0 l' H); clear H; intro H;\n  generalize (H x l' x0 l' H); clear H; intro H;\n  generalize (H x0 l' x0 l' H0); clear H; intro H0;\n  generalize (H x0 l' x1 l' H0); clear H; intro H;\n  generalize (H x0 l' x0 l' H1); clear H; intro H;\n  generalize (H x0 l' x0 l' H1); clear H; intro H0;\n  generalize (H0 x1 l' x0 l' H1); clear H; intro H0;\n  generalize (H x0 l' x1 l' H0); clear H; intro H0;\n  generalize (H x0 l' x1 l' H1); clear H; intro H0;\n  generalize (H x1 l' x1 l' H1); clear H; intro H0;\n  generalize (H x1 l' x1 l' H1); clearQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  intros A x l l' Hl.\n  elim Hl; clear Hl; intros.\n  exists (app l l').\n  simpl.\n  split; subst l'.\n  apply (H (app l l')).\n  simpl.\n  split.\n  subst.\n  apply (H (app l l')).\n  apply (H (app l l')).\n  apply (H (app l l')).\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split; auto.\n  apply (H (app l l')).\n  simpl.\n  split;Qed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  intros; apply Permutation_app.\n  apply NoDup_app.\n  apply NoDup_app.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  apply NoDup_remove.\n  applyQed.",
                    "Lemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  intros.\n  inversion H1.\n  exists l.\n  split; auto.\n  destruct H1 as [l1 [l2 [l3 [l4 [l4 [l5 [l6 [l7 [l6 [l7 [l6 [l7 [l7 [l7 [l8 [l9 [l10 [l10 [l11 [l13 [l14 [l15 [a [l15 [a [l17 [a [l15 [a [l1 [l1 [l1 [l1 [l2 [l2 [l1 [l2 [l3 [l2 [l3 [l4 [l6 [l6 [l6 [l1 [l1 [l2 [l2 [l3 [l6 [l3 [l6 [l2 [l3 [l4 [l5 [l6 [l3 [l6 [l6 [l6 [l7 [l8 [l9 [l10 [l1 [l13 [l7 [l8 [l10 [l10 [l10 [l11 [l13 [l15 [l15 [l15 [l15Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/permutation.v",
                "context": " intro xss;intros.\n  elim H3;clear H3;intros.\n  exists (cons a xss).\n  simpl.\n  split.\n  subst y;subst l';auto.\n  apply tail_insertion.\n  auto.\nQed.\n\nLemma is_permutation_map : forall (B:Set)(ys1 ys2:list B),(is_permutation B ys1 ys2)->forall (A:Set)(f:A->B)(xs1:list A),(ys1 = map f xs1)->exists xs2:list A,(is_permutation A xs1 xs2)/\\ys2 = map f xs2.\n  induction 1.\n  intros.\n  destruct xs1;try (discriminate H).\n  exists (nil (A:=A)).\n  split.\n  apply nil_is_permutation.\n  reflexivity.\n  intros.\n  destruct xs1;try (discriminate H1).\n  simpl in H1.\n  injection H1;clear H1;intros.\n  subst x.\n  elim (IHis_permutation _ _ _ H1).\n  intro xs2.\n  intros.\n  elim H2;clear H2;intros.\n  subst l'.\n  elim (insertion_map _ _ _ _ H0 _ f a (refl_equal (f a)) xs2 (refl_equal (map f xs2))).\n  intros.\n  elim H3;clear H3;intros.\n  exists x.\n  split;auto.\n  eapply cons_is_permutation;eauto.\nQed.\n\n(** if l' is a permutation of l and the elements of l are pairwise distinct, then so are those of l' *)\nLemma is_permutation_set : forall (A:Set)(l l':list A),(is_permutation _ l l')->(is_set _ l)->(is_set _ l').\n  induction 1.\n  auto.\n  intros.\n  inversion H1.\n  subst x0;subst l0.\n  eapply insertion_is_set.\n  apply IHis_permutation.\n  auto.\n  elim (permutation_in _ _ _ H x).\n  intros.\n  red;intro.\n  apply H5.\n  apply H3.\n  apply H6.\n  auto.\nQed.\n\nLemma Permutation_impl_permutation : forall (A:Set)(l l':list A),(Permutation l l')->(is_permutation _ l l').\n  induction 1.\n  apply nil_is_permutation.\n  eapply cons_is_permutation.\n  apply IHPermutation.\n  apply head_insertion.\n  eapply cons_is_permutation.\n  apply is_permutation_refl.\n  apply tail_insertion.\n  apply head_insertion.\n  eapply is_permutation_trans;eauto.\nQed.\n\nLemma insertion_append_decompose : forall (A:Set)(x:A)(l l':list A),(insertion _ x l l')->exists l1:list A,exists l2:list A,l=(app l1 l2)/\\l'=(app l1 (cons x l2)).\n  induction 1.\n  exists (nil (A:=A)).\n  exists l.\n  split;try reflexivity.\n  elim IHinsertion.\n  intro l1.\n  intro.\n  elim H0.\n  intro l2;intros.\n  elim H1;clear H1;intros.\n  exists (cons y l1).\n  exists l2.\n  subst l;subst l'.\n  split;try reflexivity.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 16382,
                "proof_end_offset": 16713,
                "proof": "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\nProof.\ninduction 1.\napply perm_nil.\nelim (insertion_append_decompose _ _ _ _ H0).\nintro l1;intros.\nelim H1.\nintro l2;intros.\nelim H2;clear H2;intros.\nsubst l';subst l''.\napply Permutation_cons_app.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_sym.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\n  apply Permutation_in_app;try assumption.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply NoDup_cons.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction l; simpl; intros; auto.\n  elim IHorted.\n  apply IHl.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_sym; apply Permutation_middle.\n  apply Permutation_sym; apply Permutation_middleQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction l.\n  apply Permutation_refl.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_trans with (fst (partition_partition _ _ l l')) (snd (partition_partition _ _ l l')).\n  intros.\n  simpl in H1.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_symQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists (l++l').\n  split.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Permutation; auto.\n  apply NoDup_Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  exists (l1++l2).\n  split;try reflexivity.\n  elim (classic (l1=l2)).\n  intro l'.\n  elim (classic (l1=l2)).\n  intro l'.\n  elim (classic (l2=l')).\n  intro l'.\n  elim (classic (l1=l')).\n  intro l''.\n  elim (classic (l2=l')).\n  intro l''.\n  elim (classic (l'=l')).\n  intro l''.\n  elim (classic (l'=l')).\n  intro l''.\n  elim (classic (l'=l')).\n  intro l''.\n  elim (classic (l'=l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n  intro l''.\n  elim (classic (l' = l')).\n Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\n  rewrite <- IHl; apply NoDup_Permutation; simpl; auto.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction l.\n  apply NoDup_Permutation; try apply Permutation_sym; assumption.\n  destruct (Permutation_in_app_or _ _ _ H) as [l' [l' [??]]].\n  exists l';split; try reflexivity.\n  apply Permutation_sym; assumption.\n  apply Permutation_sym; assumption.\n  apply Permutation_sym; assumption.\nQed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction l.\n  apply Permutation_refl.\n  apply Permutation_sym.\n  apply Permutation_app_swap.\n  apply Permutation_sym.\n  apply Permutation_app_swap.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_app_swap.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_trans.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.Qed.",
                    "Lemma permutation_impl_Permutation : forall (A:Set)(l l':list A),(is_permutation _ l l')->(Permutation l l').\n  induction 1.\n  apply permutation_skip.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_middle.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_middle.\n  apply Permutation_sym.\n  apply Permutation_sym.\n  apply Permutation_middle.\n  apply Permutation_middle.\n  apply Permutation_sym.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; elim n; auto.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nset (m:=m).\nassert (H:=O_n).\nset (m:=n).\nset (m:=m).\nassert (H:=O_n).\nset (m:=m).\nset (m:=m).\nset (m:=m).\nassert (H':=O_n).\nset (m:=m).\nset (m:=m).\nset (m':=m).\nassert (H':=O_n).\nset (m':=m).\nset (m:=m).\nset (m':=m').\nset (m:=m).\nassert (H':=O_n).\nset (m:=m).\nset (m:=m).\nset (m':=m).\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nset (m':=m').\nsetQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nsimple induction n.\n simpl in |- *.\nintros.\napply mult_comm.\nsimpl in |- *.\napply mult_n_Sm.\napply mult_le_reg_l with (p:=p).\nrewrite <- mult_assoc.\napply mult_le_reg_l with (p:=p).\nrewrite mult_comm.\napply mult_le_reg_l with (p:=p).\nrewrite mult_comm.\napply mult_le_reg_l with (p:=p).\nrewrite <- mult_assoc.\napply mult_le_compat_l.\napply le_plus_trans with (m := p).\napply plus_le_compat_l.\napply le_plus_trans with (p:=p).\nrewrite mult_comm.\napply plus_le_compat_l.\napply le_plus_trans with (p:=p).\nrewrite <- mult_assoc.\napply mult_le_compat_l.\napply le_plus_trans with (p:=p).\nrewrite mult_comm.\napply mult_le_compat_l.\napply le_plus_trans with (p:=p).\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m.\ninduction  n as [| n Hrecm]; simpl; trivial.\nintros; apply le_n_S; trivial.\nintros; apply le_n_S; trivial.\nintros; apply le_n_S; trivial.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; elim n.\nsimpl in |- *; auto with arith.\nintros p Hp; elim Hp; auto with arith.\nintros p Hp; elim Hp; auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m; elim n; elim m; auto.\nintros m IHm; elim n; auto.\nintros m IHm; elim n; auto.\nintros m IHm; elim n; auto.\nintros m IHm; elim n; auto.\nintros m IHm; elim n; auto.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\ninduction n.\n simpl in |- *.\nauto with *.\nintros.\napply nat_of_P_lt_Lt_compare_morphism.\napply nat_of_P_lt_Lt_compare_morphism.\napply nat_of_P_lt_Lt_compare_morphism.\napply nat_of_P_lt_Lt_compare_morphism.\napply nat_of_P_gt_Gt_compare_morphism.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; elim n; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  pattern (S m) at 2.\n  rewrite <- (plus_n_Sm m).\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite <- (plus_Snm_nSm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_comm.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewriteQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction n;simpl;auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim HQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  elim H0; auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  case (le_gt_dec n m); intros.\n  rewrite mult_comm.\n  replace (m - m) with m by omega.\n  rewrite mult_comm.\n  replace (m - m) with m by omega.\n  rewrite mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm m n).\n  ring.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H0; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H0; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.\n  elim H1; auto.Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction n; simpl;intros.\n  auto with arith.\n  elim H0; auto with arith.\n  intros.\n  apply mult_n_Sm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite <- (mult_comm n m); auto with arith.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm n m); auto with arith.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm n m); auto with arith.\n  rewrite mult_assoc.\n  rewrite (mult_comm n m); auto with arith.\n  rewrite mult_assoc.\n  rewrite <- (mult_comm m n); auto with arith.\n  rewrite (mult_comm m n); auto with arith.\n  rewrite mult_assoc.\n  rewrite (mult_comm m n); auto with arith.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm m n); auto with arith.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm n m); auto with arith.\n  rewrite mult_plus_distrQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite multQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;intros;auto with arith.\n  elim H0;trivial.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H0; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  left.\n  simpl in H.\n  right.\n  assert (m = 0); try omega.\n  rewrite <- H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_lemma3; auto with arith.\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite mult_plus_distr_l.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl in H.\n  right.\n  split; try omega.\n  omega.\n  simpl in H.\n  right.\n  assert (m <= S n); try omega.\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H0;auto with arith.\n  simpl in H.\n  right.\n  assert (m + S m = S n + S m); [ rewrite mult_comm; auto | omega ].\n  rewrite H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  inversion H.\n  simpl in H.\n  right.\n  rewrite H.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  apply mult_prefix1.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix1.\n  apply mult_prefix2.\n  apply mult_prefix1.\n  apply mult_prefix2.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix2.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix2.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix2.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n  apply mult_prefix1.\n Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  rewrite mult_comm.\n  rewrite H.\n  rewrite mult_comm.\n  rewrite H.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_assoc.\n  induction n.\n  auto with arith.\n  simpl in H.\n  right.\n  apply mult_le_compat_r.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_r.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.\n  apply le_trans with m; auto with arith.\n  simpl in H.Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H;trivial.\n  simpl in H.\n  elim H; trivial.\n  simpl in H.\n  elim H; trivial.\n  simpl in H.\n  elim H; trivial.\n  simpl in H.\n  elim H; trivial.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\n",
                "context_tokens": 502,
                "proof_start_offset": 1721,
                "proof_end_offset": 2052,
                "proof": "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nProof.\nintros n m.\ncase n.\nleft;trivial.\nintros.\nright.\ndestruct m.\nrewrite mult_comm in H.\ndiscriminate.\ndestruct m;trivial.\nassert ((S n0)<(S n0)*(S (S m))).\napply mult_lemma3;intros;auto with arith.\nrewrite <- H in H0.\nelim (lt_irrefl (S n0) H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  tauto.\n  simpl in H.\n  replace (S (S n)) with (S (S n)).\n  apply plus_n_Sm.\n  omega.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto withQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  intuition.\n  destruct m.\n  simpl.\n  intuition.\n  destruct m.\n  simpl in *.\n  intuition.\n  destruct m.\n  destruct m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl.\n  intuition.\n  destruct m.\n  simpl.\n  intuition.\n  inversion H0.\n  subst m.\n  simpl.\n  intuition.\n  destruct m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl.\n  intuition.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simpl in *.\n  inversion H0.\n  subst m.\n  simplQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  intro.\n  inversion H.\n  inversion H0.\n  simpl.\n  inversion H0.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H2.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H2.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H2.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H2.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H3.\n  simpl.\n  inversion H2.\n  simpl.\n  inversionQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm n m).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm n m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite mult_assoc.\n  rewrite (mult_comm m n).\n  rewrite (mult_comm mQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\nintros.\nrewrite mult_comm.\ninduction m.\nsimpl.\nrewrite mult_comm.\ninduction m.\nsimpl;auto with arith.\nsimpl in H.\nreplace (S n) with (S (S m)).\napply H.\nsimpl;auto with arith.\nrewrite H.\nauto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  elim H.\n  simpl;auto with arith.\n  inversion H1.\n  simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  simpl in H.\n  assert (m + S m = S m); try omega.\n  inversion H; try omega.\n  inversion H0; try omega.\n  assert (m + S m = S m); try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1; try omega.\n  inversion H1Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n Qed.",
                    "Lemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  auto with arith.\n  simpl;auto with arith.\n  destruct m.\n  simpl.\n  auto with arith.\n  simpl;auto with arith.\n  destruct m.\n  simpl.\n  auto with arith.\n  simpl.\n  auto with arith.\n  simpl;auto with arith.\n  destruct m.\n  simpl.\n  auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\n",
                "context_tokens": 628,
                "proof_start_offset": 2054,
                "proof_end_offset": 2503,
                "proof": "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\nProof.\ninduction n;simpl;intros;try discriminate.\ninduction m.\nrewrite mult_comm in H.\nsimpl in H;discriminate.\nassert ((S n)<=((S n)*(S m))).\napply mult_lemma1;discriminate.\nassert (((S n)*(S m))=((S m)+n*(S m))).\nreflexivity.\nrewrite H1 in H0.\nrewrite H in H0.\nassert ((S n)=1).\nomega.\nsplit;trivial.\ninversion H2.\nrewrite H4 in H.\nsimpl in H.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  case n.\n  left;trivial.\n  left;trivial.\n  right.\n  right.\n  destruct m.\n  rewrite mult_comm.\n  right.\n  intro.\n  rewrite mult_comm.\n  rewrite mult_1_r in H.\n  discriminate.\n  inversion H0;try omega.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  case n.\n  left;trivial.\n  left;trivial.\n  right; auto.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  intro.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m;trivial.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  left.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  left.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  left.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction n;simpl;auto with arith.\n  elim H0;auto.\n  simpl;intros.\n  rewrite mult_comm in H.\n  discriminate.\n  elim H0;auto.\n  simpl;intros.\n  rewrite mult_comm in H.\n  discriminate.\n  elim H0;auto.\n  simpl;intros.\n  rewrite mult_comm in H.\n  discriminate.\n  elim H0;auto.\n  simpl;intros.\n  rewrite mult_comm in H.\n  discriminate.\n  elim H0;auto.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  case n.\n  left;trivial.\n  intros.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl.\n  destruct (plus_comm n0 (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  simpl.\n  case (plus_comm (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  case (plus_comm (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  case (plus_comm (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl.\n  case (plus_comm n0 (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  simpl.\n  case (plus_comm n0 (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  case (plus_comm (S m)) as [? [??]].\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  induction n.\n  simpl;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  simpl;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m; rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  case m.\n  rewrite mult_comm;auto with arith.\n  intros.\n  rewrite mult_comm.\n  rewrite (mult_comm m m).\n  rewrite (mult_comm m m).\n  rewrite (mult_comm m m).\n  rewrite (mult_comm m m).\n  rewriteQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl;auto with arith.\n  simpl in H.\n  case (le_dec n m);intros.\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  case (le_dec m n); intros.\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  case (le_dec n m); intros.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  case (le_dec m n); intros.\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  case (le_dec n m); intros.\n  rewrite mult_comm in H.\n  discriminate.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  case (le_dec n m); intros.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  case (le_dec m n); intros.\n  rewrite multQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  trivial.\n  trivial.\nQed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  case m;auto.\n  case m;auto.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;intros.\n  case m;auto.\n  simpl;Qed.",
                    "Lemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl;auto with arith.\n  elim H0;auto with arith.\n  right; auto with arith.\n  intros.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m;auto with arith.\n  intros.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n  discriminate.\n  simpl in H.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  simpl in H.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2505,
                "proof_end_offset": 2662,
                "proof": "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\ninduction y;intros;rewrite plus_comm;simpl.\nauto with arith.\nrewrite plus_comm.\napply IHy.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  simpl.\n  induction y;simpl;intros;auto.\n  destruct y;simpl;intros;auto.\n  destruct y;simpl;intros;auto.\n  destruct y;simpl;intros;auto.\n  destruct (IHn _ H H0).\n  subst.\n  inversion H0.\n  simpl;auto.\n  simpl;auto.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  destruct (plus_lt_dec y x).\n  left.\n  simpl.\n  left.\n  inversion H0.\n  simpl.\n  left.\n  inversion H0.\n  simpl.\n  left.\n  inversion H0.\n  simpl.\n  right.\n  left.\n  inversion H0.\n  simpl.\n  left.\n  inversion H0.\n  simpl.\n  right.\n  inversion H0.\n  simpl.\n  right.\n  inversion H0.\n  simpl.\n  left.\n  inversion H1.\n  simpl.\n  right.\n  inversion H1.\n  simpl.\n  right.\n  inversion H1.\n  simpl.\n  left.\n  inversion H1.\n  simpl.\n  right.\n  inversion H1.\n  simpl.\n  right.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  left.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  right.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H1.\n  simpl.\n  inversion H1Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  case x;simpl;intros;rewrite mult_comm;try discriminate.\n  elim H;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0;auto.\n  rewrite mult_comm in H0; discriminate.\n  elim H0Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n rewrite mult_plus_distr_l.\n simpl.\n rewrite mult_comm.\n simpl.\n replace (S (S m)) with (S (S m)).\n rewrite plus_comm.\n rewrite (mult_comm x y).\n trivial.\n apply mult_assoc.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat; apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.\n apply S_pred.\n apply plus_le_compat.Qed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  unfold x, x.\n  rewrite mult_comm.\n  replace ((S x) + S (S y)) with (S (y+y)).\n  apply plus_n_Sm; omega.\n  rewrite mult_assoc.\n  replace ((S x) + S (y + y)) with (S (y+y)).\n  apply plus_n_Sm; omega.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm x).\n  rewrite mult_plus_distr_r.\n  reflexivity.\n  rewrite (mult_comm y).\n  rewrite (mult_comm y).\n  reflexivity.\n  rewrite (mult_comm x).\n  rewrite (mult_comm x).\n  reflexivity.\n  rewrite mult_plus_distr_r.\n  reflexivity.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  destruct (plus_assoc x y y) as (y,(z,(z,(z,(z,(z,(z,(z,(z,(z,(z,(z,(z,z))))))))).\n  rewrite mult_assoc.\n  replace ((S n0) + S n0) with (S n0 + S n0) by omega.\n  rewrite mult_assoc.\n  replace ((S n0 + S n0) + n0) with (S n0 + S n0) by omega.\n  rewrite mult_assoc.\n  replace ((S n0 + S n0) + n0) with (S n0 + S n0) by omega.\n  rewrite mult_assoc.\n  replace ((S n0 + n0) + (S n0)) with (S n0 + S n0) by omega.\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n0)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n0)).\n  rewrite mult_assoc.\n  replace ((S n0 + n0) + n0) with (S n0 + S n0) by omega.\n  rewrite mult_assoc.\n  replace ((S nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n rewrite mult_comm.\n replace (S x)*(S y)) with ((S x)+(S y)+1) by auto with *.\n replace (S x)*(S y)+1 with (S x)+(S y)+1) by auto with *.\n replace (S x)*(S x)+(S y)+1) with (S x)*(S y)+1) by auto with *.\n replace (S x)*(S y)+1) with (S x)+(S y)+1) by auto with *.\n replace (S x)+(S y)+1) with (S y)+1) by auto with *.\n replace (S x)+(S y)+1) with (S y)+1) by auto with *.\n replace (S x)+(S y)+1) with (S x)+(S y)+1) by auto with *.\n rewrite H1.\n reflexivity.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\nProof.\n intros.\n rewrite mult_comm in H.\n omega.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  rewrite mult_comm.\n  apply mult_assoc.\nQed.",
                    "Lemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  intros.\n  destruct (eq_nat_dec x y).\n  subst.\n  simpl.\n  destruct (eq_nat_dec x y).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (eq_nat_dec y x0).\n  subst.\n  simpl.\n  destruct (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2664,
                "proof_end_offset": 2918,
                "proof": "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\nProof.\nintros.\ninduction a.\nsimpl.\ntrivial.\nreplace (S a*n) with (n+a*n);try (auto with arith).\nrewrite plus_comm.\nrewrite plus_minus_lemma1.\nsimpl.\nrewrite <- minus_n_O;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  replace (S (a-1)) with (S (a-1)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm a (S n0)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm a (S n0)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (mult_comm (a-1)).\n  rewrite (Qed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  replace (a-1) with (a-1).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  replace (S (a+1)) with (a-1).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  reflexivity.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl;auto with arith.\n  rewrite mult_comm.\n  rewrite mult_1_r.\n  rewrite mult_1_r.\n  rewrite mult_1_r.\n  rewrite mult_1_r.\n  rewrite mult_1_l.\n  rewrite mult_1_r.\n  rewrite mult_1_l.\n  rewrite mult_1_l.\n  rewrite mult_1_l.\n  rewrite mult_1_r.\n  rewrite mult_1_r.\n  rewrite mult_1_l.\n  reflexivity.\n  rewrite mult_1_r.\n  rewrite mult_1_l.\n  rewrite mult_1_l.\n  rewrite mult_1_l.\n  reflexivity.\n  rewrite mult_1_r.\n  reflexivity.\n  rewrite mult_1_l.\n  rewrite mult_1_r.\n  rewrite mult_1_l.\n  reflexivity.\n  rewrite mult_1_l.\n  rewrite mult_1_l.\n  reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  induction n;simpl;intros;try discriminate.\n  destruct (IHn a n);simpl;intros;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;\n  auto with arith.\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm a n).\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm a n).\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm a n).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm a n).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm a n).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm a n).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm a n).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_plus_distr_r.\n  rewriteQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction n;intros.\n  simpl.\n  auto with arith.\n  simpl.\n  auto with arith.\n  simpl.\n  replace (S n) with (S (S n)).\n  apply mult_n_Sm.\n  apply IHn.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_1_r.\n  rewrite mult_comm.\n  rewrite mult_1_r.\n  rewrite mult_comm.\n  trivial.\n  simpl.\n  rewrite mult_1_r.\n  trivial.\n  simpl.\n  rewrite mult_1_r.\n  trivial.\n  simpl.\n  rewrite mult_1_r.\n  trivial.\n  simpl.\n  rewrite mult_1_r.\n  trivial.\n  simpl.\n  rewrite mult_1_r.\n  trivial.\n  simpl.\n  rewrite mult_1_r.\n  trivial.\n  simpl.\n  rewrite mult_1_l.\n  trivial.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm a 1).\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  rewrite (mult_comm 1).\n  reflexivity.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite multQed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  induction a.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_l.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm 1).\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n Qed.",
                    "Lemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  rewrite mult_comm.\n  induction n;intros;rewrite plus_comm.\n  simpl.\n  auto with arith.\n  rewrite mult_comm.\n  simpl.\n  auto with arith.\n  simpl.\n  auto with arith.\n  rewrite mult_comm.\n  simpl.\n  auto with arith.\n  auto with arith.\n  rewrite mult_comm.\n  simpl.\n  auto with arith.\n  auto with arith.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\nLemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  inversion H0.\n  simpl.\n  assert (O < m*n);try omega.\n  inversion H0;try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 2920,
                "proof_end_offset": 3619,
                "proof": "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\nProof.\ninduction a.\nintros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\nintros b n H.\nrewrite mult_comm;simpl;rewrite mult_comm;intro.\nassert (n*a = n*b-n).\napply plus_minus;auto.\nassert (a*n=(b-1)*n).\nrewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\nassert (a=(b-1)).\napply (IHa (b-1) n);trivial.\nrewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\ndestruct b;simpl in H3.\nrewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\nrewrite <- minus_n_O in H3;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction n.\n  simpl;trivial.\n  rewrite mult_comm.\n  apply plus_n_O.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction n.\n  simpl.\n  trivial.\n  replace (S a*n) with (S (a-1)).\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  destruct (IHn a).\n  simpl.\n  trivial.\n  destruct (IHn a).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  simpl.\n  destruct (IHn a0).\n  simpl.\n  trivial.\n  destruct (IHn a0Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl;auto with arith.\n  replace (S a*n) with (S (a-1)).\n  rewrite <- (plus_n_Sm a b n).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (plus_comm (S n)).\n  rewrite (Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a;simpl;intros;try discriminate.\n  simpl.\n  destruct (IHn a0).\n  destruct (IHn a0).\n  destruct (IHn b0).\n  destruct (IHn a1).\n  destruct (IHn a2).\n  destruct (IHn a0).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a1).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a0).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a3).\n  destruct (IHn a2).\n  destruct (IHn a0).\n  destruct (IHn a2).\n  destruct (IHn a0).\n  destruct (IHn a0).\n  destruct (IHn a2).\n  destruct (IHn a2).\n  destruct (IHn a1).\n  destruct (IHn a1).\n  destruct (IHn a2).\n  destruct (IHn a1).\n  destruct (IHn a2).\n Qed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction n;simpl;intros;auto with arith.\n  apply H;auto.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  replace (a+b) with (S (a-1)).\n  apply mult_integral_l.\n  simpl.\n  trivial.\n  replace (S (a-1)) with (S (a-1)).\n  apply mult_integral_l.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  destruct (IHn a b).\n  simpl.\n  trivial.\n  simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  trivial.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (S a*n); try omega.\n  rewrite plus_comm.\n  simpl.\n  rewrite plus_comm.\n  rewrite plus_Sn_m.\n  replace (S b) with (S (S b)).\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  apply mult_le_compat.\n  apply le_n.\n  replace (S b) with (S (S b)).\n  rewrite mult_comm.\n  simpl.\n  rewrite (mult_comm (S b)).\n  reflexivity.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S b)).\n  reflexivity.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S b)).\n  reflexivity.\n  rewrite mult_comm.\n  reflexivity.\n  rewrite mult_plus_distr_r.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (S (a-1)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S n)).\n  rewrite (mult_comm (S n)).\n  rewrite mult_plus_distr_r.\n  simpl.\n  rewrite <- minus_n_O.\n  trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x;intros;rewrite mult_comm;simpl.\n  auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simplQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y;intros;rewrite mult_n_O in H; generalize (mult_correct x y); intros Hl2; elim Hl2; intros;\n  rewrite mult_n_O in H0; generalize (mult_comm x (b*z)); intros Hl3; elim Hl3; intros;\n  rewrite mult_n_O in H0; elim H0;\n  rewrite mult_n_O in H1; elim H1; rewrite mult_n_O in H0; elim H0;trivial.\n  rewrite mult_0_l in H0; rewrite mult_n_O in H0; elim H0; trivial.\n  rewrite mult_0_r in H1; rewrite mult_n_O in H1; elim H1; trivial.\n  rewrite mult_1_l in H1; rewrite mult_n_O in H1; elim H1; trivial.\n  rewrite mult_1_l in H1; rewrite mult_n_O in H1; elim H1; trivial.\n  rewrite mult_0_r in H1; rewrite mult_n_O in H1; elim H1; trivial.\n  rewrite mult_0_rQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite mult_n_O in H; generalize (mult_assoc x y z);intros;\n rewrite mult_n_O in H; generalize (mult_assoc x y z); intros;\n rewrite mult_n_O in H; generalize (mult_assoc x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;\n rewrite mult_n_O in H; generalize (mult_comm x y z); intros;Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x;intros;rewrite mult_n_O in H; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H0; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H0; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H0; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H1; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H0; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H0; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in H0; generalize (mult_n_O x y); intros Hp; elim Hp; intros;\n (rewrite mult_n_O in HQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x.\nsimpl;auto with arith.\nrewrite plus_comm.\nrewrite mult_assoc;rewrite (mult_comm x (y * z)).\nrewrite mult_assoc;rewrite (mult_comm z (x*z)).\nrewrite mult_assoc;rewrite (mult_comm (x*z));\nrewrite mult_assoc;rewrite (mult_comm (x*z)).\nrewrite mult_assoc;rewrite (mult_comm x (x*z)).\nrewrite (mult_comm (x*z)).\nrewrite mult_assoc; rewrite (mult_comm (x*z)).\nrewrite mult_assoc; rewrite (mult_comm (x*z)).\nrewrite (mult_comm x (y*z)).\nrewrite mult_assoc; rewrite (mult_comm (x*z)).\nrewrite (mult_comm (x*z)).\nrewrite mult_assoc;rewrite (mult_comm (x*z)).\nrewrite (mult_comm (x*z)).\nrewrite (mult_comm (x*z)).\nrewrite mult_assoc; rewrite (mult_comm x (x*z)).\nrewrite (mult_comm (x*z)).\nrewrite (mult_Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y;intros;rewrite plus_comm;simpl.\n  omega.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  apply mult_le_reg_l with (a:=a) (a:=y) (a:=y) (a:=y) (a:=y) (a:=y) (a:=y) (a:=y) (a':=y) (a':=z) (a':=a) (z:=a').\n  unfold mult at 1; simpl; auto.\n  rewrite mult_comm; rewrite (mult_comm n (a:=a) (a:=b) (a:=y) (a':=z) (a':=a) (a':=y) (a:=a); auto.\n  rewrite mult_comm; rewrite (mult_comm n (a:=a) (a':=a) (a:=y) (a':=a) (a':=y) (a':=a'); auto.\n  rewrite mult_comm; rewrite (mult_comm n (a:=a) (a':=a) (a':=a') (a':=a'); auto.\n  rewrite mult_comm; rewrite (mult_comm n (a':=a) (a':=a') (a':=a') (a':=a'); auto.\n  rewrite mult_comm; rewrite (mult_comm nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction y;intros;rewrite plus_comm;simpl.\nauto with arith.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction x;intros;rewrite mult_n_O in H; generalize (mult_prefix3 x y t);intros Hx.\nrewrite mult_n_O in H; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t);intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_prefix3 x y t); introsQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x.\nsimpl;rewrite mult_n_O in H; generalize (mult_integral_l _ _ x y);intros Hp; elim Hp; intros; auto.\nassert (0 < 0); auto with arith.\nelim (mult_integral_r _ _ x y); intros Hp; elim Hp; intros; auto.\nassert (0 <= 0); auto with arith.\nelim (mult_integral_l _ _ x y); intros Hp; elim Hp; intros; auto.\nassert (0 <= (1-1)+1).\n  apply mult_integral_r; auto with arith.\n  rewrite mult_comm; simpl;rewrite mult_comm; simpl; auto with arith.\n  replace (S (S (y+1)) with (S (y-1)).\n  apply mult_integral_r; auto with arith.\n  replace (S (y-1)) with (S (y-1)).\n  apply mult_integral_r; auto with arith.\n  rewrite mult_comm; simpl; auto with arith.\n  replace (S (y-1)) with (S (y-1)).\n  apply mult_integral_l; auto with arith.\n  replace (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply le_trans with (S a).\n  apply plus_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply S_le_compat; assumption.\n  apply SQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  rewrite plus_comm.\n  apply plus_comm.\n  apply plus_le_compat.\n  apply S_le.\n  apply S_le.\n  apply S_le.\n  apply S_le.\n  apply le_O_n.\n  apply S_le.\n  apply le_O_n.\n  apply S_le.\n  apply le_trans with (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  case (le_or_le (a+b) (S b)).\n  rewrite (mult_comm a b);trivial.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;autoQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  destruct (le_gt_dec 0 n).\n  left; auto.\n  right; auto.\n  right; auto.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply le_S.\n  apply le_S.\n  apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl; apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl; apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl;apply le_O_n.\n  simpl; apply le_O_n.\n  simpl; apply le_O_n.\n  simpl; apply le_O_n.\n  simpl; apply le_O_n.\n  simpl;Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  unfold S.\n  rewrite minus_n_O in H; generalize (mult_lemma2 a b);intros H; elim H; intros;\n    apply mult_n_O in H; generalize (mult_n_O a b);\n      intros; rewrite mult_comm;simpl;rewrite mult_comm;\n      rewrite mult_comm;rewrite mult_comm;\n      rewrite (mult_comm (S b) (b-1)).\n  rewrite mult_comm.\n  rewrite (mult_comm b (S b)).\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm b n);trivial.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S b)).\n  rewrite mult_comm.\n  rewrite (mult_comm (S b)).\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S b)).\n  rewrite mult_plus_distr_l.\n  rewrite (mult_comm b (S b)).\n  rewrite mult_comm.\n  rewrite (mult_comm b (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm b (S b)).\n  rewrite mult_comm.\n  rewrite (mult_commQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  case b;simpl;intros.\n  case b;simpl;intros.\n  case b;simpl;intros.\n  apply H.\n  omega.\n  omega.\n  rewrite mult_comm;simpl;auto.\n  apply IHn.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  rewrite <- (plus_n_Sm a b n) at 1.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S a) b n) at 1.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S a) (S b)); trivial.\n  apply mult_le_compat.\n  apply le_trans with (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply (mult_integral (S a) b (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S a) b (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S b)).\n  apply (mult_integral (S b) (S bQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 725,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_diff_1 x y z l);rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_2;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff_Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_2 y z);rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  replace (x*y) with (x*(y-x)) by ring.\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial;auto with arith.\n  replace (x*y) with (x*(y-y)).\n  rewrite mult_comm;rewrite minus_plus_distr_l;rewrite minus_plus;auto with arith.\n  replace (x*y) with (x*(y-y)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm x (y-x)).\n  replace (x*y) with (x*(y-x)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  replace (x*y) with (x*(y-x)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec z z);intro.\n  rewrite (minus_diff_2 x y z l);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x (y + z));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm (x + z));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm (x + z));rewrite mult_comm;simpl;rewrite minus_plus_distr_l;auto with arith.\n  rewrite (mult_comm (x + z));rewrite mult_comm;simpl;rewrite minus_plus_distr_r;auto with arith.\n  rewrite (mult_comm (x + z));rewrite (mult_comm (x + z));rewrite mult_comm;simpl;rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm (x + z));rewrite (mult_comm (x + z));rewrite mult_comm;simpl;auto withQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_zero y z l);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  replace (y+z) with (y*(z-y)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto with arith.\n  replace (x*y) with (x*y).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto with arith.\n  rewrite <- H0;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_zero x y z);rewrite mult_comm;simpl;rewrite minus_diff_zero;trivial;auto with arith.\n  rewrite <- (minus_diff_zero x y z);rewrite mult_comm;simpl;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite (mult_comm y z);rewrite (mult_comm y z);rewrite (mult_comm z y);rewrite (mult_comm z z);\nrewrite (mult_comm z x);rewrite (mult_comm y z);\nrewrite (mult_comm x z); rewrite (mult_comm x z);\nrewrite (mult_comm x z); rewrite (mult_comm y z);\nrewrite (mult_comm y z); rewrite (mult_comm x z);\nrewrite (mult_comm x z);\nrewrite (mult_comm x z); rewrite (mult_comm x z);\nrewrite (mult_comm x z);\nrewrite (mult_comm x z); rewrite (mult_comm x);Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intros.\n  rewrite (minus_prefix2 z z l);rewrite mult_comm;simpl;rewrite minus_diag_r;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;trivial.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_lt x y z);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus_distr_r;rewrite minus_plus_distr_r;rewrite minus_plus_distr_r;auto with arith.\n  replace (x*y) with (x*y).\n  rewrite mult_comm;rewrite (mult_comm x (y+z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus_distr_r;rewrite minus_plus;auto with arith.\n  replace (x*y) with (x*(y-x)).\n  rewrite mult_comm;rewrite (mult_comm y (y+z)).\n  rewrite mult_plus_distr_r;rewrite mult_plus_distr_r;auto with arith.\n  replace (x*y) with (x*y).\n  rewrite mult_comm;rewrite (mult_comm x (y+z)).\n  rewrite mult_plus_distr_r;rewriteQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_prefix2 x z l);rewrite mult_comm;simpl;rewrite minus_diag_r;auto with arith.\n  apply mult_le_compat_r;auto.\n  apply mult_le_compat_r;auto.\n  apply plus_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply mult_le_compat_l;auto.\n  apply plus_le_compat_l;auto.\n  apply plus_le_compatQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_1 x y z l);rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  apply plus_le_compat.\n  apply le_O_n.\n  apply le_O_n.\n  omega.\n  omega.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_eq x y z);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arithQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ";rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec z z);intro.\n  rewrite (minus_diff_1 x y z);rewrite mult_comm;simpl;rewrite plus_comm;simpl;auto with arith.\n  apply le_trans with (y+z).\n  apply le_trans with (y+z).\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_l.\n  apply plus_le_compat_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z); intro.\n  rewrite (minus_diff_le_dec x y);try (auto with arith).\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite mult_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite minus_plus;trivial.\n  rewrite minus_plus;trivial.\n  rewrite plus_comm; rewrite minus_plus;trivial.\n  rewrite minus_plus;trivial.\n  rewrite minus_plus;trivialQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_1 y z);rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  replace (x*y) with (x*(y-y)).\n  rewrite mult_plus_distr_l;rewrite mult_comm;simpl;rewrite minus_plus_distr_l;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm y z);rewrite mult_comm;simpl;rewrite minus_plus_distr_r;auto with arith.\n  rewrite (mult_comm y z);rewrite mult_comm;simpl;rewrite minus_plus_distr_l;auto with arith.\n  rewrite (mult_comm x (y + y));rewrite (mult_comm x (y + y));rewrite (mult_comm x (y + y));rewrite (mult_comm x (y + y));\n    rewrite (mult_comm x (y + y));rewrite (mult_comm x (y + y));\n      rewrite (mult_comm x (y + y));rewrite (mult_comm y (y + y));\n      rewrite (mult_comm xQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_1 y z l);rewrite mult_comm;simpl;rewrite plus_comm;rewrite plus_comm;simpl;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;trivial.\n  rewrite mult_comm;simpl;rewrite plus_comm;simpl;auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto withQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_prefix2 x y z);rewrite mult_comm;simpl;rewrite minus_plus_assoc;auto with arith.\n  replace (x+y) with (x*(z-y)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  replace (x+y) with (x*(z-x)).\n  rewrite mult_comm;simpl;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  replace (x+(y-z)) with (x*(z-x)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec z z);intros.\n  rewrite (minus_diff_1 x y z l);rewrite mult_comm;simpl;auto with arith.\n  replace (x*y) with (x*y).\n  replace (x*y) with (x*y).\n  rewrite mult_comm.\n  apply plus_minus_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  apply mult_le_compat; auto.\n  applyQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (plus_comm z (x+z)); try (auto with arith).\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;simpl;rewrite minus_diag_reverse;auto with arith.\n  replace (x*z) with (x*(z-x)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_reverse;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_reverse;auto with arith.\n  replace (x*z) with (x*(z-y)).\n  replace (x*y) with (x*(z-x)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_reverse;auto with arith.\n  rewrite plus_comm; simpl;rewrite minus_diag_reverse;auto with arith.\n  replace (x * (y - x)) with (x*y).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite <- plus_assoc;simpl;rewrite minus_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_eq x y z);rewrite mult_comm;simpl;rewrite minus_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_diff_lt_eq_iff _ _ H H0 H1).\n  replace (x*y) with (x*(y-y)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto.\n  replace (x*y) with (x*(y-y)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto.\n  rewrite mult_comm;simpl;auto.\n  replace (x*y) with (x*(y-y)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto.\n  rewrite mult_comm;simpl;auto.\n  replace (x*y) with (x*(y-x)).\n  rewrite mult_comm;simpl;auto.\n  replace (x*y) with (x*y).\n  rewrite mult_comm.\n  replace (x*y) with (x*y).\n  rewrite mult_comm.\n  replace (x*y) with (x*y).\n  rewrite mult_comm.\n  replace (x*y) with (x*y).\n  rewrite mult_comm.\n  replace (Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec z x); intro.\n  rewrite (minus_prefix2 z z);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm z (y-z));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm z (y-z));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm z (y-z));rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite (mult_comm z (y+z));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm z (y+z));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm z (y+z));rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite (mult_comm z (y-z));rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite (mult_comm z (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus x y);trivial.\n  rewrite minus_minus;rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;simpl;rewrite minus_plus_distr_r;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_diff_lt_eq_dec x y z);rewrite mult_comm;simpl;rewrite minus_plus_diff;trivial;auto with arith.\n  rewrite minus_plus;rewrite minus_plus;rewrite minus_plus_diff;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite minus_minus_diff;rewrite plus_comm;rewrite minus_plus_simpl_r;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (plus_comm x y);rewrite (plus_comm y y);rewrite (plus_comm y z);rewrite (plus_comm y z);rewrite (plus_comm y z);rewrite (plus_comm x y z);rewrite (plus_comm x y z);reflexivity.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;reflexivity.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_plus_minus z x);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;reflexivity.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (minus_plus_minus z x);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto.\n  apply minus_minus_le_weak;auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_1 x y z);rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  replace (x+(y-z)) with (x+(y-z)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;rewrite minus_plus;rewrite minus_plus;rewrite minus_diff;trivial;auto with arith.\n  apply le_antisym.\n  omega.\n  apply le_antisym.\n  omega.\n  apply minus_le_weak.\n  omega.\n  apply plus_le_compat_l.\n  omega.\n  apply minus_le_weak.\n  omega.\n  apply minus_le_weak.\n  omega.\n  apply minus_le_weak; auto with arith.\n  omega.\n  apply le_antisym.\n  omega.\n  omega.\n  omega.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b.\n  intro;simpl;omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_diff_1 a b a H);rewrite (plus_comm b a H);trivial.\n  case (le_lt_dec b a);intros.\n  rewrite (minus_diff_2 b a H);rewrite (plus_comm b b H);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_diff_2 a b H);rewrite (plus_comm b a H);trivial.\n  case (le_lt_dec b a);intros.\n  rewrite (minus_diff_2 b a H);rewrite (minus_diff_2 a b H);trivial.\n  case (le_lt_dec b a);intros.\n  rewrite (minus_diff_1 a b H);rewrite (plus_comm b b H);trivial.\n  case (le_lt_dec b a);intros.\n  rewrite (minus_diff_2 b a H);rewrite (plus_comm b a H);trivial.\n  case (le_lt_dec b a);intros.\n  rewrite (minus_diff_2 b a H);rewriteQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  case (le_lt_dec a b);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec a b);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a); simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a); simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_lt_dec b b);simpl;trivial.\n  case (le_lt_dec b a); simpl;omega.\n  case (le_lt_dec b a);simpl;trivial.\n  case (le_Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec a b);intro.\n  rewrite (le_plus_minus _ _ H);trivial.\n  replace (a+b) with (a+a+a+a+b).\n  apply plus_lt_compat_l;trivial.\n  apply le_n_S;trivial.\n  replace (a+b) with (a+a+a+a).\n  apply plus_lt_compat_l;trivial.\n  apply le_n_S;trivial.\n  replace (a+b) with (a+b).\n  apply plus_lt_compat_l;trivial.\n  apply le_n_S;trivial.\n  replace (a+b) with (a+b).\n  apply plus_lt_compat_l;trivial.\n  apply le_n_S;trivial.\n  replace (a+b) with (a+a+b).\n  apply plus_lt_compat_l;trivial.\n  apply le_n_S;trivial.\n  apply le_n_S;trivial.\n  replace (a+b) with (a+a+b).\n  apply plus_lt_compat_l;trivial.\n  replaceQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_comm a b);trivial.\n  case (le_lt_dec b a);intro.\n  rewrite (minus_comm a b);trivial.\n  case (le_lt_dec b a);intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_comm b b);trivial.\n  case (le_lt_dec b b); intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec b a); intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec b a); intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec b a);intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec b a); intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec b a); intro.\n  rewrite (minus_comm b a);trivial.\n  case (le_lt_dec b a); intro.Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case b;simpl;trivial.\n  intros.Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case (le_lt_dec a b);intro.\n  rewrite H0.\n  rewrite mult_comm.\n  apply le_trans with (a+b).\n  apply le_antisym; assumption.\n  apply minus_lt_compat; trivial.\n  apply le_trans with (a+b).\n  apply le_antisym; assumption.\n  apply minus_le_compat; trivial.\n  apply minus_lt_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply le_trans with (a+b).\n  apply le_antisym; assumption.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply minus_le_compat; trivial.\n  apply le_trans with (a+b).\n  apply le_antisym; assumption.\n  apply minus_le_compat; trivial.\n  applyQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec a b);intro.\n  rewrite H;simpl;trivial.\n  rewrite H0;simpl;trivial.\n  rewrite H0;simpl;trivial.\n  rewrite H0;simpl;trivial.\n  rewrite H0;simpl;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\n",
                "context_tokens": 375,
                "proof_start_offset": 1374,
                "proof_end_offset": 1542,
                "proof": "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nunfold is_gcd.\nintros.\nelim H;elim H0;intros.\napply divides_antisym;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b c.\nintro H.\nelim (gcd_unique d' a b c); intros.\nelim (gcd_unique d' a b c); intros.\nelim (gcd_unique d' a b c); intros.\nrewrite H1; rewrite H2; rewrite H1; rewrite H2; reflexivity.\nrewrite H1; rewrite H2; rewrite H2; reflexivity.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b H H0; generalize (gcd_unique d d' a H0); intros;\n generalize (gcd_unique d' d' a H0); intros; \n generalize (gcd_unique d' d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H0); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros; \n generalize (gcd_unique d' a H1); intros;Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros.\nunfold is_gcd.\nrepeat split; intros.\napply gcd_unique with d; auto with arith.\napply gcd_unique with d; auto with arith.\napply gcd_unique with d; auto with arith.\napply gcd_unique with d'; auto with arith.\napply gcd_unique with d'; auto with arith.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b.\nunfold is_gcd in |- *.\napply (gcd_for_euclid (d' * (d' * a/q')) (gcd_for_euclid d' a b)).\ncase (gcd_for_euclid d' a b); intros.\napply (gcd_for_euclid (d' * (d' * b/q')) (gcd_for_euclid d' a b)).\ncase (gcd_for_euclid d' a b); intros.\napply (gcd_for_euclid (d' * (d' * a/q')) (gcd_for_euclid d' a b).\ncase (gcd_for_euclid d' a b); intros.\napply (gcd_for_euclid (d' * (d' * a/q')) (gcd_for_euclid d' a b).\napply (gcd_for_euclid (d' * (d' * a/q')) (gcd_for_euclid d' a b).\ncase (gcd_for_euclid d' a b); intros.\napply (gcd_for_euclid (d' * (d' * a/q')) (gcdQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b H H0.\ngeneralize (gcd_unique d a b H0); intros H1.\nelim (gcd_unique d' b H1); intros H2.\nrewrite H3; auto with zarith.\nelim (gcd_unique d' a H2); intros H3.\nrewrite H3; auto with zarith.\nelim (gcd_unique d' a H3); intros H4.\nrewrite H3; auto with zarith.\nrewrite H4; auto with zarith.\nintros H H0; apply H; auto with zarith.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintro d; unfold is_gcd;simpl.\nintros H H0; elim H0; intros H1 H2; clear H H0.\nexists (S n); auto.\nQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\n  intros.\n  destruct (gcd_unique d a b H) as (g,(H1,H2)).\n  destruct (gcd_unique d' b b H1) as (g,(H1,H2)).\n  destruct (gcd_unique d' b b H1) as (g,(H3,H4)).\n  destruct (gcd_unique d' b b H4) as (g,(H5,H6)).\n  destruct (gcd_unique d' b b H5) as (g,(H7,H9)).\n  rewrite H9 in H8.\n  rewrite H9 in H8.\n  apply gcd_unique with g.\n  apply gcd_unique with g.\n  apply gcd_unique with g.\n  apply gcd_unique with g.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivial.\n  apply gcd_unique with g; trivialQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b c.\napply gcd_unique with (q:=a) (q:=a) (q:=a) (q:=a) (q:=a) (r:=a) (r:=b) (r:=a) (r:=a) (r:=b) (r:=a) (r:=a) (r:=b) (r:=a) (r:=b) (r:=a) (r:=a) (r:=b) (r:=a) (r:=b) (r:=a) (r:=b) (r:=b) (r:=a) (r:=a) (r:=b) (r:=a) (r:=a) (r:=a) (r:=a) (r:=b) (r:=a) (r:=a) (r:=a) (r:=b) (r:=b) (r:=a) (r:=a) (r:=a) (r:=a) (r:=a) (r:=a) (r:=a) (r:=a) (r:=a) (r:=b) (r:=a) (r:=Qed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b c.\nelim (gcd_unique d' a b c); intros.\nelim (gcd_unique d' a b c); intros.\nelim (gcd_unique d' a b c); intros.\nelim (gcd_unique d' a b c); intros.\nexists (gcd_intro a b).\nsplit; auto.\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique with (gcd d' a).\napply gcd_unique withQed.",
                    "Theorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\nProof.\nintros d d' a b c H H0 H1.\napply gcd_unique with d'; trivial.\napply gcd_unique with d'; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\n",
                "context_tokens": 457,
                "proof_start_offset": 1571,
                "proof_end_offset": 1763,
                "proof": "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim H;intros.\nsplit.\nred;red in H0;tauto.\nintros.\napply H1.\nred;red in H2;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim H; elim H0; intros.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H11; intros.\nelim H11; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim HQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply gcd_unique with (1:= H1) (2:= H3).\n  apply gcd_intro; auto with *.\n  elim H1; intros.\n  apply gcd_unique with (1:= H1) (2:= H3).\n  apply gcd_intro; auto with *.\n  elim H2; intros.\n  apply gcd_unique with (1:= H3) (2:= H4).\n  apply gcd_intro; auto with *.\n  elim H1; intros.\n  apply gcd_unique with (1:= H4) (2:= H5).\n  apply gcd_intro; auto with *.\n  elim H1; intros.\n  apply gcd_unique with (1:= H1) (2:= H3).\n  apply gcd_intro; auto with *.\n  elim H1; intros.\n  apply gcd_unique with (1:= H5) (2:= H5).\n  apply gcd_intro; auto with *.\n  elim H1; intros.\n  apply gcd_unique with (1:= H5) (2:= H5).\n  apply gcd_intro; auto with *.\n  elim H1; introsQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n  apply gcd_sym; auto.\n  apply gcd_trans with (gcd a b) (gcd a b); auto with zarith.\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply gcd_unique with (1:=H0) (2:=H1).\n  apply gcd_unique with (1:=H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:=H1).\n  apply gcd_unique with (1:=H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:=H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (2:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (1:= H1).\n  apply gcd_unique with (2:= H1).\n  apply gcd_unique with (2:= H2).\n  apply gcd_unique with (1:= H1).\n  apply gcdQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim (gcd_unique d a b); intros.\nelim H0; intros.\napply gcd_intro; auto with arith.\napply gcd_intro; auto with arith.\napply gcd_intro; auto with arith.\napply gcd_intro; auto with arith.\napply gcd_intro; auto with arith.\napply gcd_intro; auto with arith.\nQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_unique with b; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto with *.\n  apply gcd_unique with d'; auto withQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_intro.\n  elim H0; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H2; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n  elim H1; intros.\n  apply gcd_intro.\n Qed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply H0; auto with arith.\n  apply (gcd_sym (gcd_comm (gcd d a) b)); auto with arith.\n  apply (gcd_sym (gcd_comm (gcd d a) b)); auto with arith.\n  apply (gcd_sym (gcd_comm (gcd d a) b)); auto with arith.\n  apply gcd_sym; apply gcd_sym; apply gcd_comm; auto with arith.\n  apply (gcd_comm (gcd d a) b); auto with arith.\n  apply gcd_sym; apply gcd_opp; apply gcd_opp; auto with arith.\n  apply (gcd_sym (gcd d a) b); auto with arith.\n  apply gcd_sym; apply gcd_opp; apply gcd_opp; auto with arith.\n  apply (gcd_sym (gcd d a) b); auto with arith.\n  apply gcd_sym; apply gcd_opp; apply gcd_opp; auto with arith.\n  apply (gcd_sym (gcd d a) b); auto with arith.\n  apply gcd_sym; apply gcd_opp; apply gcd_opp; autoQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H; elim H0; intros.\n  apply gcd_intro; auto with zarith.\n  elim H0; intros.\n  elim H1; intros.\n  apply H1; auto with zarith.\n  elim H2; intros.\n  elim H2; intros.\n  elim H3; intros.\n  apply H3; auto with zarith.\n  elim H3; intros.\n  apply H3; auto with zarith.\n  elim H3; intros.\n  elim H3; intros.\n  apply H1; auto with zarith.\n  elim H4; intros.\n  apply H1; auto with zarith.\n  elim H4; intros.\n  elim H5; intros.\n  apply H1; auto with zarith.\n  elim H5; intros.\n  elim H5; intros.\n  apply H3; auto with zarith.\n  elim H5; intros.\n  apply H1; auto with zarith.\n  elim H5; intros.\n  apply H1; auto with zarith.\n  elim H5; intros.\n  apply H1; auto with zarith.\n  elim H5; intros.\n  apply H1; auto with zarith.\n  elim H5; intros.\n  applyQed.",
                    "Lemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\nProof.\nunfold is_gcd.\nintros.\nelim H; elim H0; intros.\n  apply Zis_gcd_intro; auto.\n  apply Zis_gcd_intro; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\n",
                "context_tokens": 545,
                "proof_start_offset": 1783,
                "proof_end_offset": 1947,
                "proof": "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\nunfold is_gcd.\nintro.\nsplit.\nred;split;[apply zero_max_div | apply divides_refl].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; simpl in |- *.\n  elim H; intros.\n  split.\n  simpl in |- *.\n  elim H; intros.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *.\n  elim H; intros.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  elim H; intros.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *.\n  elim H; intros.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  simpl in |- *; auto.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.\n  simpl in |- *; auto.\n  split.Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro; auto withQed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; red in H; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  red; red in H0; tauto.\n  red in H0; tauto.\n  intros.\n  apply H1.\n  red;Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.\n  simpl in H; tauto.Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply gcd_intro.\n  apply H; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro.\n  apply H; auto.\n  apply gcd_intro.\n  apply H; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro.\n  apply H; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro.\n  apply H; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro.\n  apply H; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro.\n  apply gcd_intro; auto.\n  apply gcd_Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_intro.\n  apply H.\n  split.\n  simpl in |- *; auto.\n  simpl in |- *; auto.\n  elim H; intros.\n  apply gcd_intro.\n  apply H; auto.\n  split.\n  simpl in |- *; auto.\n  elim H; intros.\n  apply gcd_intro.\n  apply H; auto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red in H0; tauto.\n  elim H; intros.\n  apply gcd_intro.\n  apply H; auto.\n  split.\n  red in H0; tauto.\n  elim H; intros.\n  apply H0; auto.\n  split.\n  red in H0; tauto.\n  elim H; intros.\n  apply H; auto.\n  split.\n  red in H; tauto.\n  elim H; intros.\n  apply H; auto.\n  split.\n  red in H0; tauto.\n  elim H; intros.\n  apply H; auto.\n  split.\n  red in H0; tauto.\n  elim H; intros.\n  apply H; auto.\n  split.\n  red in H0Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  exists (gcd a O).\n  exists (gcd a O).\n  split.\n  split.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n  simpl;auto.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red in H0; tauto.\n  split.\n  red; red in H0; tauto.\n  split.\n  red in H0; tauto.Qed.",
                    "Lemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H0; intros.\n  apply gcd_intro.\n  elim H0; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H0; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H0; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim H; intros.\n  apply gcd_intro.\n  elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\n",
                "context_tokens": 615,
                "proof_start_offset": 1967,
                "proof_end_offset": 2130,
                "proof": "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\nProof.\nunfold is_gcd.\nintros.\nsplit.\nred;split;[apply divides_refl | apply one_min_div].\nunfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red; intro; apply H.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; elim H0; intros; auto.\n  apply gcd_opp; auto.\n  elim H0; intros; auto.\n  apply gcd_opp;Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto with zarith.\n  apply gcd_intro; auto withQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  rewrite H; rewrite H0; ring.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tautoQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intro.\n  elim H; intros.\n  split; auto.\n  unfold is_gcd in H0;tauto.\n  unfold is_gcd in H0;tauto.\nQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  applyQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_unique with (1:=a).\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro; auto.\n  apply gcd_intro;Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply divides_antisym;auto.\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 a).\n  apply (gcd_intro 1 aQed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  unfold is_gcd.\n  split.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  split.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  split.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red in H0; tauto.\n  red in H0; tauto.\n  red in H;Qed.",
                    "Lemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; apply (gcd_comm 0 a).\n  red; red in H0;tauto.\n  apply (gcd_comm 1 a).\n  red; red in H0;tauto.\n  elim H0; intros.\n  split.\n  red; apply (gcd_comm 0 a).\n  red; red; red in H0; tauto.\n  red; red in H0; tauto.\n  elim H0; intros.\n  split.\n  red; apply (gcd_comm 0 a).\n  red; red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  red; red in H0; tauto.\n  redQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\n",
                "context_tokens": 697,
                "proof_start_offset": 2174,
                "proof_end_offset": 2759,
                "proof": "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\nintros.\nunfold is_gcd.\nsplit;intro.\nelim H0;intros.\nsplit.\nred in H1;red.\nelim H1;intros.\nsplit;try tauto.\napply divides_minus;trivial.\nunfold is_cd;intros.\napply H2;red;elim H3;intros.\nsplit;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nelim H0;unfold is_cd;intros.\nsplit.\nsplit;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\nintros.\nelim H3;intros;apply H2.\nsplit;try (apply divides_minus);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; auto.\n  red; simpl in H; tauto.\n  intros.\n  apply H.\n  apply gcd_opp_r.\n  apply H.\n  apply H.\n  apply H1.\n  apply gcd_opp_r.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H.\n  apply H.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n Qed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim H; intros.\n  split.\n  red; red in H0; tauto.\n  intros.\n  apply H1.\n  simpl; apply gcd_nonneg.\n  apply gcd_nonneg.\n  apply (gcd_nonneg_nonneg a).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg b).\n  apply (gcd_nonneg_nonneg bQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  split.\n  red; intro.\n  elim H; intros.\n  elim H0; intros.\n  apply H1.\n  apply gcd_intro.\n  apply H1.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcd_intro.\n  apply H.\n  apply gcdQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  intros.\n  elim (gcd_unique d a b); intros.\n  apply gcd_unique with b; auto.\n  unfold is_gcd;tauto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; red in H; tauto.\n  intros.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\n  apply H; auto.\nQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; red; intro; apply H.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H2.\n  apply H4.\n  apply HQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split.\n  red; intro; apply H1; tauto.\n  split.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; intro; apply H1; tauto.\n  red; introQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply divide_antisym;auto.\n  apply (gcd_nonneg_nonneg a);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg a);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  apply (gcd_nonneg_nonneg b);auto.\n  applyQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  split.\n  red; intro; elim H0; intros.\n  split.\n  red; intro; elim H2; intros.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H0.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H2.\n  apply H3.\n  apply H0.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H0.\n  apply H3.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H1.\n  applyQed.",
                    "Lemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply gcd_intro.\n  apply H1; auto.\n  rewrite <- H2; auto.\n  apply gcd_intro.\n  apply H1; auto.\n  apply gcd_intro;\n  apply H1; auto.\n  apply gcd_intro;\n  apply H2; auto.\n  apply gcd_intro.\n  apply H1; auto.\n  apply gcd_intro;\n  apply H2; auto.\n  apply gcd_intro;\n  apply H2; auto.\n  apply gcd_intro;\n  apply H2; auto.\n  apply gcd_intro;\n  apply H2; auto.\n  apply gcd_intro;\n  apply H2; auto.\n  apply gcd_intro;\n  apply H3; auto.\n  apply gcd_intro;\n  apply H3; auto.\n  apply gcd_intro;\n  apply H4; auto.\n  apply gcd_intro;\n  apply H3; auto.\n  apply gcd_intro.\n  apply H4; auto.\n  apply gcd_intro.\n  apply H4; auto.\n  apply gcd_intro;\n  apply H4; auto.\n  apply gcd_intro;\n  apply H4; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import power.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\n",
                "context_tokens": 739,
                "proof_start_offset": 2781,
                "proof_end_offset": 2923,
                "proof": "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\nintros.\nunfold is_cd.\nsplit;try tauto.\nsplit;apply divides_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split;intro.\n  split; try tauto.\n  elim H0; intros.\n  split; try tauto.\n  elim H0; intros.\n  split; try tauto.\n  elim H0; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; introsQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nintros.\napply gcd_unique with a; auto with *.\napply gcd_sym.\nrewrite <- (gcd_opp a).\nrewrite <- (gcd_opp a).\nrewrite <- (gcd_opp b).\napply gcd_opp; tauto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim (gcd_unique a).\n  intros.\n  split;intro.\n  split; try tauto.\n  apply gcd_sym; apply gcd_refl.\n  apply gcd_opp; tauto.\n  unfold is_gcd.\n  intros.\n  rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_opp; rewrite <- gcd_opp; rewrite <- gcd_opp;\n  rewrite <- gcd_oppQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; try tauto.\n  apply divide_intro; apply gcd_refl.\n  apply gcd_sym; apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  unfold is_comm;tauto.\n  tauto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  intros.\n  elim (gcd_unique a 0); intros.\n  split;intros.\n  split;try tauto.\n  split;try tauto.\n  unfold is_gcd;simpl;tauto.\n  unfold is_gcd;simpl;tauto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split;try tauto.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n  apply gcd_intro.\n Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; try tauto.\n  apply (gcd_refl_equal a (b-a) (b-a)); try tauto.\n  apply (gcd_sym a (b-a)); try tauto.\n  apply (gcd_sym a (b-a)); try tauto.\n  apply (gcd_sym b (a-a)); try tauto.\n  apply (gcd_sym b (a-a)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-a)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.\n  apply (gcd_sym b (a-b)); try tauto.Qed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; try tauto.\n  apply gcd_sym; tauto.\n  apply gcd_intro; tauto.\n  apply gcd_intro; tauto.\nQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\nProof.\nunfold is_gcd.\nsplit.\nred;intro.\nelim H;intros.\nsplit;intros.\nelim H;intros.\nsplit;intros.\nsplit;intros.\nelim H0; intros.\nsplit;intros.\nelim H2; intros.\nsplit;intros.\nelim H3; intros.\nsplit; intros.\nelim H3; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nsplit; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nelim H4; intros.\nsplit; intros.\nelim H5; intros.\nsplitQed.",
                    "Lemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split;intro.\n  elim H0;intros.\n  split;intro.\n  split;intro.\n  split;intro.\n  split;intro.\n  split;intro.\n  simpl in |- *; tauto.\n  split;intro.\n  rewrite (le_plus_minus a b H); apply gcd_comm; assumption.\n  elim H0; intros; apply H2.\n  split;intro.\n  split;intro.\n  split;intro.\n  split; intro.\n  split; intro.\n  split;intro.\n  split;intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  split; intro.\n  splitQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " Names.\n\n(** d is a common divisor of a and b if d | a and d | b *)\nDefinition is_cd (d a b : nat) := (divides a d)/\\(divides b d).\n\n(** d is a greatest common divisor of a and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 2965,
                "proof_end_offset": 3080,
                "proof": "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\n  unfold is_gcd.\n  intros.\n  split.\n  red in H.\n  elim H; intros.\n  split; try tauto.\n  elim H0; intros; apply H; clear H0.\n  split; try tauto.\n  split; try tauto.\n  apply H; clear H0.\n  split; try tauto.\n  apply H; clear H0.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H0.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H0.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tauto.\n  apply H; clear H.\n  split; try tautoQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; try tauto.\n  apply gcd_comm; auto.\n  apply (gcd_nonneg_nonneg a b); auto.\n  apply gcd_comm; auto.\n  apply (gcd_nonneg_nonneg b b); auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply gcd_comm; auto.\n  apply gcd_nonneg_nonneg; auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply gcd_nonneg_nonneg; auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply gcd_nonneg_nonneg; auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply gcd_nonneg_nonneg; auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply gcd_nonneg_nonneg; auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply gcd_nonneg_nonneg; auto.\n  apply (gcd_nonneg_nonneg b); auto.\n  apply (gcd_Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  destruct (gcd_unique d a b) as [H|H].\n  elim H; intros.\n  rewrite <- H0; rewrite <- H0; apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros; rewrite (le_plus_minus a b H); apply gcd_gcd; tauto.\n  elim H0; intros;Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  apply gcd_unique with (1:=H).\n  apply gcd_sym; tauto.\n  apply gcd_sym; tauto.\n  apply gcd_sym; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_sym; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_opp; tauto.\n  apply gcd_Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\n  intros.\n  split.\n  red; split;intros.\n  apply (gcd_abs a b); tauto.\n  apply (gcd_comm a b); tauto.\n  apply (gcd_nonneg a b); tauto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\n unfold is_gcd.\n intros.\n split.\n red; split;intro; try tauto.\n apply divide_intro; try tauto.\n apply divide_intro; try tauto.\n apply divide_intro; try tauto.\nQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd.\n  intros.\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcd_intro a b).\n  apply (gcdQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  intros.\n  unfold is_gcd.\n  split.\n  red; split;[apply gcd_opp_r | apply gcd_opp_r].\n  unfold is_gcd.\n  split.\n  red; unfold is_gcd.\n  split.\n  red; unfold is_gcd.\n  split.\n  red;intro; apply H; try apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_l.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  apply gcd_opp_r.\n  applyQed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\n  unfold is_gcd.\n  intros.\n  split;apply gcd_unique with (gcd a b) (gcd b a) (gcd b b).\n  unfold is_gcd.\n  intros.\n  split.\n  red; split;try tauto.\n  apply gcd_sym; apply divide_refl.\n  apply divide_trans with (gcd a b) (gcd b b).\n  apply gcd_mul_r; trivial.\n  apply gcd_comm; apply gcd_comm; apply gcd_opp_l.\n  apply gcd_opp_l; trivial.\n  unfold is_gcd.\n  intros.\n  apply H1; red; split; try tauto.\n  apply gcd_sym; apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.\n  apply gcd_opp_r; trivial.Qed.",
                    "Lemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; try tauto.\n  apply gcd_comm; auto.\n  apply gcd_sym; auto.\n  apply gcd_comm; auto.\n  apply gcd_comm; auto.\n  apply gcd_comm; auto.\n  apply gcd_comm; auto.\n  apply gcd_comm; auto.\n  apply gcd_comm; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " and b if it is a maximal common divisor *)\nDefinition is_gcd (d a b:nat) := (is_cd d a b)/\\(forall (d':nat),(is_cd d' a b)->(divides d d')).\n\n(** there is at most one gcd of a and b *)\nTheorem gcd_unique : forall (d d' a b:nat),(is_gcd d a b)->(is_gcd d' a b)->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\n",
                "context_tokens": 731,
                "proof_start_offset": 3102,
                "proof_end_offset": 3217,
                "proof": "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\nProof.\nunfold is_gcd;unfold is_cd;intros;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;intros;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;simpl;tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\nProof.\n  unfold is_gcd.\n  intros.\n  destruct (gcd_dec a b) as [H|H].\n  rewrite <- (gcd_0_l a b) at 1.\n  rewrite <- (gcd_0_l a b) at 1.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tauto.\n  apply gcd_greatest; tautoQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  apply gcd_unique with (1:=H).\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_sym;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_comm;auto.\n  apply gcd_Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;intros;tauto.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_gcd;unfold is_gcd; intros.\n  apply H; auto with *.\n  unfold is_gcd.\n  split;try tauto.\n  apply (gcd_for_euclid a b d a); auto with *.\n  unfold is_gcd.\n  split;try tauto.\n  apply (gcd_for_euclid a b d a); auto with *.\n  unfold is_gcd.\n  split; try tauto.\n  apply (gcd_for_euclid a d b a); auto with *.\n  unfold is_gcd.\n  split; try tauto.\n  apply (gcd_for_euclid a d b a); auto with *.\n  unfold is_gcd.\n  split; try tauto.\n  apply (gcd_for_euclid a d a); auto with *.\n  unfold is_gcd.\n  split; try tauto.\n  apply (gcd_for_euclid a d a); auto with *.\n  unfold is_gcd.\n  split; try tauto.\n  apply (gcd_for_euclid a d a); auto with *.\n  unfold is_gcd.\n  split; try tauto.\n  apply (gcd_for_euclid a d a); auto with *.\n  unfold is_gcd.\n  split; try tautoQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply gcd_unique with (1:=H) (1:=H) (2:=H0);\n    apply gcd_gcd; assumption.\n  unfold is_gcd in |- *; tauto.\nQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd; unfold is_gcd;intros;tauto.\n  unfold is_gcd.\n  split;try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split;try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n  unfold is_gcd.\n  split; try tauto.\n  apply gcd_divide; tauto.\n Qed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd.\n  intros.\n  destruct (gcd_dec a b) as [q|q].\n  simpl.\n  apply gcd_eq; try apply gcd_0_l; try apply gcd_0_r; try tauto.\n  apply gcd_gcd; try apply gcd_0_l; try tauto.\n  apply gcd_divide; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; try tauto.\n  apply gcd_greatest; tryQed.",
                    "Lemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\nProof.\n  unfold is_gcd;intros;tauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->d=d'.\n  unfold is_gcd.\n  intros.\n  elim H;elim H0;intros.\n  apply divides_antisym;auto.\nQed.\n\n(** gcd(a,b) = gcd(b,a) *)\nLemma gcd_sym : forall (d a b:nat),(is_gcd d a b)->(is_gcd d b a).\n  unfold is_gcd.\n  intros.\n  elim H;intros.\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3393,
                "proof_end_offset": 3478,
                "proof": "Lemma Rwf : well_founded R.\nProof.\nunfold R.\napply (well_founded_ltof (nat*nat) f).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Rwf : well_founded R.\nProof.\ninduction x; simpl;try tauto.\nintros.\ndestruct (eq_nat_dec x x0).\nsubst;apply (IHn (fun _ => True)).\nQed.",
                    "Lemma Rwf : well_founded R.\n  intros.\n  destruct (completeness R H) as (x,p).\n  exists (f x).\n  unfold R in p.\n  rewrite <- (p (f x)).\n  rewrite H0.\n  rewrite H0.\n  ring.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold R; firstorder.\nQed.",
                    "Lemma Rwf : well_founded R.\n  unfold R.\n  unfold R;simpl; tauto.\n  unfold R.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n  apply H0.\n Qed.",
                    "Lemma Rwf : well_founded R.\n  intros.\n  apply (Build_nat_age_l (fun x => x) (fun x => x) (fun x => x)).\n  intros.\n  unfold R in H.\n  destruct (le_gt_dec x x).\n  elim H; intros.\n  apply H.\n  omega.\n  apply H.\n  omega.\n  apply H.\n  omega.\nQed.",
                    "Lemma Rwf : well_founded R.\nProof.\nsplit.\nintros x y Hxy.\nunfold f; apply (Build_Map (A:=Z)); auto.\nintros x y Hxy.\nunfold f; apply (Build_Map (A:=Z)); auto.\nintros y Hxy.\nunfold f; apply (Build_Map (A:=Z)); auto.\nintros x y Hxy.\nunfold f; apply (Build_Map (A:=Z)); auto.\nQed.",
                    "Lemma Rwf : well_founded R.\nProof.\nsplit;intros.\napply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj2 (proj2 (proj3 (proj2 (proj2Qed.",
                    "Lemma Rwf : well_founded R.\n  unfold well_founded;intros.\n  apply (H (fun a:nat => exists n, x = n)).\n  exists (fun a:nat => (f a) n).\n  split.\n  unfold R;apply (H (fun a:nat => x = n)).\n  split.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\n  apply H0.\n  apply H.\n  apply H.\nQed.",
                    "Lemma Rwf : well_founded R.\nProof.\n  unfold R; simpl; auto with *.\n  intros.\n  destruct (le_gt_dec (f x) (g y)); auto.\n  rewrite H; auto.\nQed.",
                    "Lemma Rwf : well_founded R.\napply (Build_Map (fun _ => True)).\napply (Build_Map (fun _ => True)).\napply (Build_Map (fun _ => True)).\napply (Build_Map (fun _ => False)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ".\n  split.\n  red;red in H0;tauto.\n  intros.\n  apply H1.\n  red;red in H2;tauto.\nQed.\n\n(** gcd(0,a)=a *)\nLemma gcd_zero : forall (a:nat),(is_gcd a O a).\n  unfold is_gcd.\n  intro.\n  split.\n  red;split;[apply zero_max_div | apply divides_refl].\n  unfold is_cd;tauto.\nQed.\n\n(** gcd(1,a)=1 *)\nLemma gcd_one : forall (a:nat),(is_gcd 1 1 a).\n  unfold is_gcd.\n  intros.\n  split.\n  red;split;[apply divides_refl | apply one_min_div].\n  unfold is_cd;tauto.\nQed.\n\n(** if a <= b then gcd(a,b)=gcd(a,b-a) *)\nLemma gcd_minus : forall (d a b:nat),(a <= b)->((is_gcd d a b)<->(is_gcd d a (b-a))).\n  intros.\n  unfold is_gcd.\n  split;intro.\n  elim H0;intros.\n  split.\n  red in H1;red.\n  elim H1;intros.\n  split;try tauto.\n  apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\n",
                "context_tokens": 724,
                "proof_start_offset": 3573,
                "proof_end_offset": 4309,
                "proof": "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nexists (snd x);apply gcd_zero.\nelim (H (S n,snd x-S n)).\nsimpl;intro d;intro.\nexists d.\nelim (gcd_minus d (S n) (snd x));try (auto with arith).\nsimpl.\nomega.\nrewrite e;exists (snd x);apply gcd_refl.\ndestruct (snd x).\nexists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n)).\nsimpl;intro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_minus d (S n) (fst x));try (auto with arith).\nsimpl.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (fun x y => (f x)=(g x)).\n  split; try apply (well_founded_ltof (nat*nat) f).\n  apply (well_founded_ltof (nat*nat) f (fun x:nat => (f x) <> (g x))).\n  intros.\n  split; try apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  intros.\n  exists (fun x:nat => (g x) * (g x)).\n  split; try apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  apply (well_founded_ltof (nat*nat) f x).\n  intros.\n  exists (fun x:nat => (f x) * (Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (1%nat).\n  rewrite <- (gcd_comm x (Zpos x)).\n  apply gcd_intro.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.\n  apply gcd_comm.Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (1%nat).\n  apply Zis_gcd_for_euclid with (1:=x) (1:=x) (2:=x).\n  destruct (gcd_dec (gcd x (gcd x y))); intuition.\n  left.\n  exists (gcd x y).\n  apply Zis_gcd_for_euclid with (1:=x) (1:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (2:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (2:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (3:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (3:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (3:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (3:=x) (3:=x).\n  apply Zis_gcd_for_euclid with (1:=x) (3:=x)Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (fun x y => x + y).\n  intros.\n  apply (gcd_intro (x,d)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (fun x y:nat => x + y)).\n  apply (gcd_uniqueness (Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (fun x y => x = y).\n  split.\n  red; intros.\n  case (gcd_dec x y); intros.\n  destruct (gcd_dec y y); intros.\n  left; apply H; rewrite H0; auto.\n  right; split; auto.\n  right; split; auto.\n  apply H; auto.\n  left; split; auto.\n  apply H; auto.\n  right; split; auto.\n  apply H; auto.\n  right; split; auto.\n  right; split; auto.\n  apply H; auto.\n  left; auto.\n  right; split; auto.\n  apply H; auto.\n  right; split; auto.\n  right; split; auto.\n  apply H; auto.\n  left; auto.\n  right; split; auto.\n  left; auto.\n  apply H; auto.\n  right; split; auto.\n  apply H; auto.\n  right; split; auto.\n  right; split; auto.\n  apply H; auto.\n  right; split; auto.\n  right; split; auto.\n  right; split; auto.\n  apply H; auto.\n  right; split; auto.\n  right; split; autoQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (f x).\n  apply (well_founded_ltof (fun x:nat => (d (fst x) (snd x))); intros.\n  exists (d x).\n  apply (H (fun x:nat => (d (fst x) (snd x))); auto.\n  intros.\n  exists (f x).\n  apply (H (fun x:nat => (d (fst x))); auto.\n  intros.\n  exists (d x).\n  apply (H (fun x:nat => d (snd x))); auto.\n  intros.\n  exists (d x).\n  apply (H (fun x:nat => (d (fst x))); auto.\n  intros.\n  exists (d x).\n  apply (H (fun x:nat => (d (fst x) (snd x))); auto.\n  intros.\n  exists (d x).\n  apply (H (fun x:nat => d (fst x))); auto.\n  intros.\n  apply (H (fun x:nat => (d (fst x))); auto.\n  intros.\n  exists (d x).\n  apply (H (fun x:nat => d (snd x))); auto.\n  intros.\n  exists (d (sndQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (fun n => n).\n  split.\n  apply (Build_Z_gcd_l x).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_for_euclid with d (d:=d).\n  apply Zis_gcd_Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  case (gcd_exists_prod (fun x:nat*nat => (fst x) (snd y))).\n  intros.\n  exists (snd (fst x)).\n  apply (well_founded_induction_type (fun x:nat => (fst x) (snd x))).\n  intros.\n  exists (snd x).\n  apply (lt_wf_ind (fst x) (snd (snd x))).\n  apply (lt_wf_ind (fst x) (snd (fst x))); auto.\n  intros.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H3.\n  apply H0.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H1.\n  apply H4.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H3.\n  apply H4.\n  apply H5.\n  apply H4.\n  apply H4.\n  apply H4Qed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  unfold is_gcd.\n  intros.\n  exists (x,d).\n  split.\n  apply H;auto.\n  apply H;auto.\n  unfold is_gcd.\n  exists (x,d).\n  split.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  unfold is_gcd.\n  exists (x,d).\n  split.\n  apply H;auto.\n  apply H;auto.\n  apply H;auto.\n  exists (x,d).\n  split.\n  apply H;auto.\n  apply H;auto.\nQed.",
                    "Lemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (fun x:nat*nat => x).\n  split; try assumption.\n  exists (fun x:nat => x).\n  split.\n  red; intros.\n  split; [apply (H x (conj (conj (conj (conj (H x))) (conj (conj (H x))) (conj (conj (conj (conj (H x))) (conj (conj (conj (conj (conj (conj (H x))) (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj x))) (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj (conj x))) (conj (conj (conj x))) (conj (conj (conj (conj (conj (conj (conj (conj (conj x))))).\n  apply (conj_nat (conj (conj (conj (conj (conj x))) (conj (conj (conj (conj (conj (conj x))) (conj (conj (conj (conj (conj (conj (conj (conj x))) (conj (conj (conj (conj x))) (conj (conj (conj (conj x))))).\n  apply (conj_nat (conj (conj (conj (conj (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " apply divides_minus;trivial.\n  unfold is_cd;intros.\n  apply H2;red;elim H3;intros.\n  split;[tauto | rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  elim H0;unfold is_cd;intros.\n  split.\n  split;[tauto | elim H1;intros;rewrite (le_plus_minus a b H);apply divides_plus;trivial].\n  intros.\n  elim H3;intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4346,
                "proof_end_offset": 4496,
                "proof": "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod (a,b)).\nsimpl;intro d;intro;exists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (Z.gcd a b).\n  split.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_sym; auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_sym; auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:= H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=H);auto with *.\n  apply gcd_unique with (1:=HQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  destruct a; destruct b; destruct 1;try (left; assumption).\n  right.\n  exists (fst a0).\n  apply gcd_intro;apply gcd_intro.\n  apply gcd_intro;apply gcd_intro;apply gcd_intro; apply gcd_intro; apply gcd_intro;\n  apply gcd_intro; apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  apply gcd_intro;\n  applyQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  exists (fun x:nat*nat => a+b).\n  intros.\n  case (gcd_dec a b); intros.\n  exists (g x).\n  rewrite H0.\n  rewrite H1.\n  ring.\n  simpl.\n  omega.\n  simpl.\n  omega.\n  simpl.\n  omega.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (Zabs_nat (S (Zabs_nat (S a))) + Zabs_nat (S b)).\n  unfold is_gcd.\n  exists (Zabs_nat (S b)).\n  split.\n  apply gcd_unique with (Zabs_nat (S b)); auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b)); auto with arith.\n  apply gcd_sym; auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b))); auto with arith.\n  apply gcd_sym; auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b)); auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b))); auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b)); auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b)); auto with arith.\n  apply gcd_sym.\n  apply gcd_unique with (Zabs_nat (S b)); auto with arith.\n Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (f a).\n  apply gcd_unique with (gcd d a).\n  apply gcd_unique with (gcd d a).\n  apply gcd_sym; auto with *.\n  rewrite <- H; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H1; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; auto with *.\n  rewrite <- H0; autoQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (exists n, a).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  omega.\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  omega.\n  exists (S n).\n  exists (S n).\n  omega.\nQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  applyQed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  Proof.\n    intros.\n    exists (fun x:nat*nat => x).\n    split; try omega.\n    intros.\n    apply (gcd_exists_prod (fun x:nat => x) x (fun y:nat => x) H0).\n  Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_sym.\n  apply gcd_unique with (g a).\n  apply gcd_sym.\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_sym.\n  apply gcd_sym.\n  apply gcd_unique with (g a).\n  apply gcd_sym.\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_unique with (g a).\n  apply gcd_Qed.",
                    "Theorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (gcd_exists_prod _ _ (gcd_aux a b)).\n  intros.\n  exists (gcd a b).\n  split.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  apply gcd_divide_l.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n  rewrite <- gcd_div_r.\n  unfold gcd.\n  exists (gcd a b).\n  split; auto.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "intros;apply H2.\n  split;try (apply divides_minus);trivial.\nQed.\n\n(** gcd(a,a) = a *)\nLemma gcd_refl : forall (a:nat),(is_gcd a a a).\n  unfold is_gcd.\n  intros.\n  unfold is_cd.\n  split;try tauto.\n  split;apply divides_refl.\nQed.\n\n(** two trivial lemmas: gcd(a,b) | a *)\nLemma gcd_div_l : forall (d a b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\n",
                "context_tokens": 732,
                "proof_start_offset": 4634,
                "proof_end_offset": 4785,
                "proof": "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\nintros.\nunfold gcd.\ngeneralize (gcd_exists a b).\nintro;elim s;intro d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd.\n  intros.\n  destruct H.\n  left.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_sym; auto with arith.\n  rewrite <- gcd_gcd.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_intro; auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (gcd_greatest a b); auto with arith.\n  elim (Qed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  unfold gcd; intros; apply gcd_unique with b; auto with zarith.\n  elim (gcd_bezout_r a b).\n  intros.\n  replace (gcd a b) with (gcd a b).\n  rewrite (gcd_comm a b).\n  rewrite (gcd_comm b c).\n  apply gcd_unique with d; auto with zarith.\n  rewrite <- gcd_assoc; apply gcd_nonneg.\n  elim (gcd_bezout_r a b).\n  intros.\n  replace (gcd a b) with (gcd a b).\n  rewrite <- gcd_gcd_r; apply gcd_gcd; auto with zarith.\n  intros.\n  replace (gcd a b) with (gcd a b).\n  rewrite <- gcd_gcd_r; apply gcd_gcd; auto with zarith.\n  rewrite <- gcd_gcd; apply gcd_nonneg.\n  elim (gcd_bezout_r a b).\n  intros.\n  replace (gcd a b) with (gcd a b).\n  rewrite (gcd_comm b c).\n  rewrite gcd_gcd_l; apply gcd_gcd; auto with zarith.\n  intros.\n  replace (gcd a b) with (gcd a b).\n  rewrite gcd_gcd_rQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  intros.\n  apply gcd_unique with (gcd a b); auto with arith.\n  intros.\n  assert (gcd (gcd a b) (gcd a b)).\n    apply gcd_unique with (gcd a b); auto with arith.\n  intros.\n  assert (gcd (gcd a b) (gcd a b)).\n    apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique with (gcd a b); auto with arith.\n  apply gcd_unique withQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  apply (gcd_unique a b); auto.\n  apply gcd_intro.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_intro; auto with arith.\n  apply gcd_intro.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_intro; auto with arith.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_sym; apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a b); auto.\n  apply gcd_unique with (gcd a bQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\nintros.\nexists (gcd a b).\nsplit;try assumption.\nintro d;exists d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro with d;\n apply gcd_intro with d;\n apply gcd_intro with d;\napply gcd_intro with d;\napply gcd_intro withQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  intros.\n  destruct (gcd_dec a b) as [H|H].\n  left;apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  left; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; auto with arith.\n  right; apply gcd_intro; simpl; autoQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  unfold gcd.\n  exists (gcd a b).\n  apply gcd_unique with (gcd a b).\n  apply gcd_sym; auto with arith.\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcd_for_euclid with (gcd a b).\n  apply gcdQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  intros.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_unique_prod; auto.\n  exists (gcd a b).\n  apply gcd_uniqueQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  intros.\n  assert (H: gcd a b = 1%Z).\n    apply gcd_unique with (gcd a b); auto with arith.\n  rewrite H; auto.\n  generalize (gcd_unique a b H).\n  intros.\n  rewrite H; auto with arith.\nQed.",
                    "Lemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\nProof.\n  intro.\n  case (gcd_dec a b); intros; auto.\n  elim (gcd_dec (gcd a b) (gcd a b)); intros; auto.\n  elim (gcd_dec (gcd a b) (gcd a b)); intros; auto.\n  elim (gcd_gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.\n  elim (gcd_greatest a b); intros; auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " b:nat),(is_gcd d a b)->(divides a d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** gcd(a,b) | b *)\nLemma gcd_div_r : forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\n",
                "context_tokens": 731,
                "proof_start_offset": 4948,
                "proof_end_offset": 5077,
                "proof": "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n  apply rel_prime_intro; auto with arith.\n Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  intros.\n  generalize (gcd_nonneg a b).\n  intro; elim (rel_prime_divisors a b); intros.\n  left; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.\n  right; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.\n  elim (rel_prime_divisors a b); intros.\n  left; apply rel_prime_sym; auto.\n  right; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.\n  left; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.\n  elim (rel_prime_divisors a b); intros.\n  right; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.\n  right; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.\n  elim (rel_prime_divisors a b); intros.\n  left; apply rel_prime_sym; auto.\n  elim (rel_prime_divisors a b); intros.Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  intros.\n  assert (rel_prime a b) by apply rel_prime_intro with b; auto with *.\n  generalize (gcd_gcd_nonneg a b H).\n  intro; elim H0; intro.\n  rewrite H1; rewrite H2; auto.\n  rewrite H2; rewrite H1; auto.\n  rewrite H2; rewrite H2; auto.\nQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  unfold rel_prime.\n  intros.\n  apply rel_prime_intro; simpl;auto.\n  generalize (gcd_nonneg a b).\n  intro;apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b).\n  intro;apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b).\n  intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b).\n  intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg b b); intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b); intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b); intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b); intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b).\n  intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b); intro; apply (gcd_intro a b); auto.\n  generalize (gcd_nonneg a b).\n  intro; apply (gcd_introQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  intros a b.\n  unfold rel_prime.\n  generalize (rel_prime_intro a b).\n  intro;elim H; intro.\n  unfold rel_prime in H; elim H; intro; clear H; intros.\n  elim H; intro; clear H; intros.\n  generalize (gcd_nonneg_nonneg a b H1).\n  rewrite H1; rewrite H2; rewrite H3; reflexivity.\n  generalize (gcd_nonneg_nonneg b (gcd a b) H1).\n  rewrite H1; rewrite H2; rewrite H3; reflexivity.\n  generalize (gcd_nonneg a b H1).\n  rewrite H1; rewrite H3; rewrite H3; rewrite H3; reflexivity.\n  generalize (gcd_nonneg_nonneg b (gcd a b) H1).\n  rewrite H1; rewrite H3; rewrite H3; rewrite H3; reflexivity.\n  generalize (gcd_nonneg_nonneg a b H1).\n  rewrite H1; rewrite H3; rewrite H3; reflexivity.\n  generalize (gcd_nonneg_nonneg a b H1).\n  rewrite H1; rewrite H3; rewrite H3; rewrite H4; reflexivity.\n  generalize (gcd_nonneg_nonnegQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  intros.\n  assert (H:=rel_prime_intro a b).\n  destruct H;clear H;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros;try tauto.\n  elim (rel_prime_intro a b);intros; try tauto.\n  elim (rel_prime_intro a b);intros; try tauto.\n  elim (rel_prime_intro a b); intros; try tauto.\n  elim (rel_prime_intro a b); intros; try tauto.\n  elim (rel_prime_intro a b); intros; try tauto.\n  elim (rel_prime_intro a b); intros; try tauto.\n  elim (rel_prime_intro a b); intros; try tauto.\n  elim (Qed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\nProof.\n  intros.\n  unfold rel_prime in H.\n  apply rel_prime_sym; apply rel_prime_sym.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarith.\n  apply rel_prime_sym; apply rel_prime_sym; auto with zarithQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  unfold rel_prime.\n  generalize (rel_prime_intro a b).\n  intro; elim H0; intro;\n    case (gcd_divide_r a b);intro;\n    try (right; reflexivity);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (right; assumption);\n    try (rightQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  intros.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_primeQed.",
                    "Lemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime;intros;split.\n  intros.\n  case (gcd_gcd_bezout a b H1).\n  intros.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H2.\n  apply H4.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H1.\n  apply H3.\n  apply H4.\n  apply H2.\n  apply H4.\n  apply H1.\n  apply H3.\n  apply H4.\n  apply H4.\n  apply H3.\n  apply H4.\n  apply H1.\n  apply H4.\n  apply H4.\n  apply H4.\n  apply H3.\n  apply H4.\n  apply H4.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (d a b:nat),(is_gcd d a b)->(divides b d).\n  unfold is_gcd;unfold is_cd;intros;tauto.\nQed.\n\n(** we now show that gcd(a,b) exists for all a and b (we even have an algorithm) *)\nDefinition f (x:nat*nat) := (fst x)+(snd x).\n\nDefinition R (x y:nat*nat) := (f x)<(f y).\n\nLemma Rwf : well_founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\n",
                "context_tokens": 738,
                "proof_start_offset": 5126,
                "proof_end_offset": 5240,
                "proof": "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\nunfold rel_prime.\nintros;apply gcd_sym;apply gcd_one.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros;apply rel_prime_1.\n  intros.\n  apply (rel_prime_2 a).\n  intros.\n  apply (rel_prime_2 a).\n  apply rel_prime_2.\n  intros.\n  apply (rel_prime_3 a).\n  apply rel_prime_3; auto.\n  apply rel_prime_1; auto.\n  apply rel_prime_1; auto.\n  apply rel_prime_1; auto.\n  apply rel_prime_2; auto.\n  apply rel_prime_2; auto.\n  apply rel_prime_2; auto.\n  apply rel_prime_2; auto.\n  apply rel_prime_2; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_2; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_3; auto.\n  apply rel_prime_4; auto.\n  apply rel_prime_3; autoQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\n  unfold rel_prime.\n  intros; apply rel_prime_1.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\n  assumption.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  split.\n  apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_1; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.\n  intros; apply rel_prime_2; auto with zarith.Qed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros.\n  apply (rel_prime_1 (rel_prime a 1) (rel_prime_1 (rel_prime a 1))).\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_alt.\n  apply rel_prime_1_altQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\n  intros a;induction a;simpl;trivial.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\n  unfold rel_prime.\n  intros; apply rel_prime_1.\n  intros.\n  apply rel_prime_1.\n  intros;apply rel_prime_2.\n  intros;apply rel_prime_2.\n  intros;apply rel_prime_2.\n  intros;apply rel_prime_2.\n  intros;apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros;apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_prime_3.\n  intros; apply rel_Qed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  unfold rel_prime.\n  simpl;intros;auto with *.\n  intros;apply (rel_prime_1 a);auto with *.\n  intros;apply (rel_prime_1 (a,b)).\n  apply rel_prime_1;auto with *.\n  intros;apply (rel_prime_1 (a,b)).\n  apply rel_prime_1;auto with *.\n  intros;apply (rel_prime_1 (a,b)).\n  apply rel_prime_1;auto with *.\n  apply rel_prime_1;auto with *.\n  intros;apply (rel_prime_1 (a,b)).\n  apply rel_prime_2;auto with *.\n  apply rel_prime_1;auto with *.\n  intros; apply (rel_prime_1 (a,b)).\n  apply rel_prime_1;auto with *.\n  apply rel_prime_1;auto with *.\n  apply rel_prime_1;auto with *.\n  intros;apply (rel_prime_1 (a,b)).\n  apply rel_prime_1;auto with *.\n  intros; apply (rel_prime_1 (a,b)).\n  apply rel_prime_1;autoQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intro;apply rel_prime_intro; tauto.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\nProof.\n  unfold rel_prime.\n  intros.\n  apply rel_prime_1.\n  generalize (gcd_nonneg a 1);intro; omega.\nQed.",
                    "Lemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  intros.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_2.\n  apply rel_prime_1.\n  apply rel_prime_1.\n  apply rel_prime_2.\n  apply rel_prime_2.\n  apply rel_prime_1.\n  apply rel_prime_2.\n  apply rel_prime_1.\n  apply rel_primeQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "founded R.\n  unfold R.\n  apply (well_founded_ltof (nat*nat) f).\nQed.\n\n(** proof of existence of gcd(a,b): it relies on the relation gcd(a,b)=gcd(a,b-a) if a<=b *)\nLemma gcd_exists_prod : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  exists (snd x);apply gcd_zero.\n  elim (H (S n,snd x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  elim (gcd_minus d (S n) (snd x));try (auto with arith).\n  simpl.\n  omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  destruct (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\n",
                "context_tokens": 696,
                "proof_start_offset": 5309,
                "proof_end_offset": 6031,
                "proof": "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (quo_is_quo a d (gcd_div_l d a b H));intro.\ngeneralize (quo_is_quo b d (gcd_div_r d a b H));intro.\nunfold is_gcd;split;unfold is_cd.\nsplit;apply one_min_div.\nintros.\nelim H3;intros.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H6 in H1.\nrewrite H7 in H2.\nassert (divides d (d*d')).\nred in H;elim H;intros.\napply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\nelim H8;intros.\nexists x.\napply mult_lemma6 with d;trivial.\nrewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros; apply gcd_unique with (gcd a b); auto.\n  apply gcd_gcd; apply gcd_nonneg.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_intro;apply gcd_opp_r.\n  apply gcd_nonneg.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n  apply gcd_greatest.\n Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_unique.\n  apply (gcd_greatest_correct (gcd_divide_l d a b) (gcd_divide_r d b) (gcd_divide_r d b) H).\n  simpl; intros; elim H; apply gcd_sym; apply gcd_nonneg; assumption.\n  apply (gcd_greatest_correct (gcd_divide_r d b) (gcd_divide_r d b) (gcd_divide_r d b) H).\n  simpl; intros; elim H; apply gcd_nonneg; assumption.\n  apply (gcd_greatest_correct (gcd_divide_r d b) (gcd_divide_r d b) H).\n  simpl; intros; elim H; apply gcd_nonneg; assumption.\n  apply (gcd_greatest_correct (gcd_divide_r d b) (gcd_divide_r d b) H).\n  simpl; intros; elim H; apply gcd_nonneg; assumption.\n  apply (gcd_greatest_correct (gcd_divide_r d b) (gcd_divide_r d b) H).\n  simpl; intros; elim H; apply gcd_nonneg; assumption.\n  apply (Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros; apply gcd_unique with (gcd a b).\n  rewrite <- H; auto with arith.\n  apply gcd_unique with (gcd a b).\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- H; auto with arith.\n  Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  apply rel_prime_1; apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_2; auto with *.\n  apply rel_prime_1; auto with *.\n  apply rel_prime_1; auto with *.\n Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  apply rel_prime_1; auto.\n  intros; apply gcd_comm; apply gcd_sym; apply gcd_nonneg; auto.\n  intros; apply gcd_comm; apply gcd_opp; auto.\n  intros; apply gcd_comm; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.\n  intros; apply gcd_opp; auto.Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros; apply gcd_nonneg; auto.\n  apply rel_prime_2.\n  apply rel_prime_2; auto.\n  apply rel_prime_2.\n  apply rel_prime_2.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply rel_prime_3.\n  apply relQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  intros.\n  apply rel_prime_intro; apply gcd_sym; apply gcd_sym; apply gcd_nonneg.\n  omega.\n  apply rel_prime_trans with (gcd a b); auto with zarith.\n  apply gcd_divide_r; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatest; auto with zarith.\n  apply gcd_greatestQed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros; apply gcd_sym; apply gcd_opp; auto.\n  generalize (gcd_nonneg a b H).\n  intro; elim H; intro d; auto with zarith.\n  Qed.",
                    "Lemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\nProof.\n  unfold rel_prime.\n  intros; apply gcd_unique with (1:=H).\n  apply gcd_intro; apply gcd_sym;apply gcd_nonneg.\n  apply gcd_divide_r; trivial.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.\n  apply gcd_divide_r.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " (snd x).\n  exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n)).\n  simpl;intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_minus d (S n) (fst x));try (auto with arith).\n  simpl.\n  omega.\nQed.\n\n(** here we are: the gcd exists *)\nTheorem gcd_exists : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod (a,b)).\n  simpl;intro d;intro;exists d;trivial.\nQed.\n\n(** take the first projection of the proof *)\nDefinition gcd (a b:nat) := let (d,_):=(gcd_exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 6065,
                "proof_end_offset": 6268,
                "proof": "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nunfold is_gcd.\nintros.\nelim H0;intros.\nintro.\nelim H1;intros.\nelim H5;intros.\nrewrite H3 in H6;simpl in H6;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\nsplit;intro.\napply gcd_sym;apply gcd_sym;apply gcd_comm;auto with *.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros d p q.\nunfold rel_prime in H.\ngeneralize (gcd_correct (gcd p q) (gcd q q)).\nintro; generalize (gcd_correct (gcd p q) (gcd q q)).\nintro; generalize (gcd_correct q q);intro.\nelim (gcd_divide_l p q); intros; clear H; intros; clear H; intros.\nrewrite H1 in H2.\nrewrite H3 in H3.\nrewrite H7 in H3; auto with arith.\nrewrite <- H1; auto with arith.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold rel_prime.\n  intros.\n  elim H; intro q; elim q; intros.\n  rewrite H6 in H0; rewrite H8 in H0; discriminate.\n  elim H0; intros.\n  rewrite H7 in H0; rewrite H8 in H0; discriminate.\n  elim H0; intros.\n  rewrite H7 in H0; rewrite H8 in H0; discriminate.\n  elim H0; intros.\n  rewrite H8 in H0; rewrite H8 in H0; discriminate.\n  elim H0; intros.\n  rewrite H7 in H0; rewrite H9 in H0; discriminate.\n  elim H0; intros.\n  rewrite H8 in H0; rewrite H8 in H0; discriminate.\n  elim H0; intros.\n  rewrite H8 in H0; rewrite H8 in H0; discriminate.\n  elim H0; intros.\n  rewrite H8 in H0; rewrite H9 in H0; discriminate.\n  elim H0; intros.\n  rewrite H9 in H0; rewrite H9 in H0; discriminate.\n  elim H0; intros.\n  rewrite H9 in H0; rewrite H9 in H0; discriminate.\n  elimQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  intros.\n  elim H; intros.\n  exists (gcd p q).\n  rewrite H2; rewrite H3; ring.\n  elim H2; intros.\n  exists (gcd p q).\n  rewrite H3; rewrite H3; ring.\n  elim H3; intros.\n  exists x.\n  apply mult_reg_l with d;trivial.\n  rewrite H3; ring.\n  elim H2; intros.\n  exists x.\n  apply mult_reg_l with d;trivial.\n  rewrite mult_comm; rewrite H3; ring.\n  elim H3; intros.\n  exists x.\n  apply mult_reg_l with d;trivial.\n  rewrite mult_comm; rewrite H4; ring.\n  elim H3; intros.\n  exists x.\n  apply mult_reg_l with d;trivial.\n  rewrite mult_comm; rewrite H4; ring.\n  elim H4; intros.\n  exists x.\n  apply mult_reg_l with d;trivial.\n  rewrite mult_comm; rewrite H4; ring.\n  elim H4; intros.\n  exists x.\n  apply mult_reg_l with d;trivial.\n  rewrite mult_comm; rewrite H4; ringQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\nunfold rel_prime.\nintros.\ngeneralize (gcd_correct1 q q (gcd p q) H).\nintro; elim H; intros; clear H; intros.\nrewrite H1; rewrite H2; ring.\nelim H; intros; clear H; intros.\nrewrite H2; rewrite H3; ring.\nelim H; intros; clear H; intros.\nrewrite H3; rewrite H4; ring.\nelim H; intros; clear H; intros.\nrewrite H3; ring.\nelim H0; intros; clear H; intros.\nrewrite H4; ring.\nelim H0; intros; clear H0; intros.\nrewrite H4; ring.\nelim H; intros; clear H; intros.\nrewrite H4; ring.\nelim H0; intros; clear H; intros.\nrewrite H4; ring.\nelim H0; intros; clear H0; intros.\nrewrite H4; ring.\nelim H0; intros; clear H0; intros.\nrewrite H4; ring.\nelim H0; intros; clear H0; intros.\nrewrite H4; ring.\nelim HQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros.\n  case (gcd_dec p q); intro.\n  apply gcd_unique with d;auto.\n  apply gcd_intro; apply gcd_abs; auto.\n  apply gcd_intro; apply gcd_abs; auto.\n  elim H1;intros.\n  exists x.\n  apply gcd_intro; apply gcd_abs; auto.\n  exists x; auto.\n  apply gcd_intro; apply gcd_opp; auto.\n  exists x; auto.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_intro q p);intro;elim H;intros;\n    elim H;intro q;intro.\n  elim H1;intro q;intro.\n  rewrite H7 in H1; rewrite H7 in H1.\n  rewrite H8 in H1; rewrite H8 in H1; discriminate H1.\n  elim H1;intro q;intro.\n  rewrite H8 in H1; rewrite H7 in H1; discriminate H1.\n  elim H1; intro q;intros.\n  rewrite H8 in H1; rewrite H8 in H1; discriminate H1.\n  elim H1; intros.\n  exists x.\n  rewrite H8 in H1; rewrite H8 in H1; discriminate H1.\n  elim H1; intro q;intros.\n  rewrite H8 in H1; rewrite H9 in H1; discriminate H1.\n  elim H1; intros.\n  exists x.\n  rewrite H9 in H1; rewrite H9 in H1; discriminate H1.\n  elim H1; intros.\n  exists x.\n  rewrite H9 in H1; rewrite H9 in H1; discriminate H1.\n Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros; apply gcd_unique with d; auto.\n  apply gcd_sym; apply gcd_nonneg.\nQed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\nintros.\ndestruct q; destruct q; simpl in *.\ndestruct p0; destruct q0; simpl in *.\ndestruct p0; simpl in *.\ndestruct q0; destruct q; simpl in *.\ndestruct q0; simpl in *.\ndestruct q0; destruct q; simpl in *.\ndestruct (gcd_0_l p0 q); destruct q; simpl in *.\ndestruct (gcd_0_l p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0 q); destruct q; simpl in *.\ndestruct (gcd_0_l p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0 q); destruct q; simpl in *.\ndestruct (gcd_0_l p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0 q); destruct q; simpl in *.\ndestruct (gcd_0_r p0Qed.",
                    "Lemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\nProof.\n  intros.\n  exists (gcd p q).\n  split.\n  apply gcd_sym;apply gcd_sym;apply gcd_opp_r.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  rewrite H7 in H2.\n  rewrite H7 in H2.\n  assert (gcd (gcd p q) (gcd p q)).\n  red in H;elim H; intros.\n  rewrite H7 in H2.\n  assert (gcd (gcd p q) (gcd p q)).\n  red in H; elim H; intros.\n  rewrite H7 in H2; rewrite H7 in H2.\n  assert (gcd (gcd p q) (gcd p q)).\n  red in H; elim H; intros.\n  rewrite H8 in H2; rewrite H7 in H2.\n  assert (gcd (gcd p q) (gcd p q)).\n  red in H; elim H; intros.\n  rewrite H8 in H2; rewrite H7 in H2; rewrite H7 in H2.\n  apply gcd_divide_l.\n  intros.\n  elim H1; intros.\n  rewrite H8 in H2; rewrite H9 in H2;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "exists a b) in d.\n\n(** the gcd is the gcd! *)\nLemma gcd_is_gcd : forall (a b:nat),(is_gcd (gcd a b) a b).\n  intros.\n  unfold gcd.\n  generalize (gcd_exists a b).\n  intro;elim s;intro d;trivial.\nQed.\n\n(** a and b are relatively prime if gcd(a,b)=1 *)\nDefinition rel_prime (a b:nat) := (is_gcd 1 a b). \n\n(** if a and b are relatively prime then so are b and a *)\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\n",
                "context_tokens": 700,
                "proof_start_offset": 6472,
                "proof_end_offset": 6772,
                "proof": "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\nelim (gcd_minus ((u+v)*x-v*y) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nunfold is_gcd.\nintros x y u v.\nrewrite <- (Ropp_mult_distr_l (u*x) (-v*y) (-v*y) x y).\nrewrite <- (Ropp_mult_distr_l_reverse (u*x) (-v*y) (-v*y) x y).\nrewrite <- (Ropp_mult_distr_l_reverse (u*x) (-v*y) x y).\nrewrite <- (Ropp_mult_distr_l_reverse (u*y) (-v*y) (-v*y)).\nrewrite <- (Ropp_mult_distr_r_reverse (u*x) (-v*y)).\nrewrite <- (Ropp_mult_distr_r_reverse u (-v)).\nrewrite <- (Ropp_mult_distr_r (u*y) (-v*y) (-v*y)).\nrewrite <- (Ropp_mult_distr_r_reverse (u*x) (-v*y)).\nrewrite <- (Ropp_mult_distr_l_reverse u (-v)).\nrewrite <- (Ropp_mult_distr_r_reverse u (-v)).\nrewrite <-Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  unfold rel_prime.\n  intros.\n  generalize (gcd_gcd_correct u x y u v H);intro.\n  generalize (gcd_gcd_correct u y u v H);intro.\n  unfold is_gcd in H;destruct H as [H'|H']; [|omega].\n  elim H';intro H;intros.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H1 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite H0 in H1; simpl in H1;auto.\n  rewrite HQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros x y u v.\nunfold is_gcd.\ndestruct (gcd_dec (u*x) (u*y)) as (q,(r,r)).\ndestruct (gcd_dec (u*x) (u*y)) as (q,(r,r)).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r)).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y)) as ((r,r).\ndestruct (gcd_dec (u*x) (u*y))Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u) as (x,(y,Hxy)).\ndestruct (gcd_bezout x y u) as (y,(y,Hxy)).\ndestruct (gcd_bezout x y u v).\ndestruct (gcd_bezout x y u) as ((z,Hxy).\ndestruct (gcd_greatest x y u v) as ((z,Hxy).\ndestruct (gcd_bezout x y u) as ((z,Hxz).\ndestruct (gcd_bezout x y u) as ((z,Hxz).\ndestruct (gcd_bezout x y u) as ((z,Hxz).\ndestruct (gcd_greatest x y u) as ((z,Hyz).\ndestruct (gcd_bezout x y u) as ((z,Hxz).\ndestruct (gcd_greatest x y u) as ((z,HxQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nunfold is_gcd.\nintros.\ngeneralize (gcd_bezout_divisors x y u v);intro.\ngeneralize (gcd_bezout_divisors x y u v);intro.\nunfold is_gcd;split;unfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\nunfold is_gcd;\n unfold is_gcd;\n unfold is_gcd;\n unfold isQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\ndestruct (gcd_bezout u x y v) as (x,(y,u)) as ((y,u),(y,u)),v).\ndestruct (gcd_bezout u x y v) as ((y,u),v),v).\ndestruct (gcd_bezout u x y v) as ((y,u),v).\ndestruct (gcd_bezout u x y v) as ((y,v),v); simpl in *; intros.\napply gcd_div_l with (q:=gcd_greatest x y v); try assumption.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- mult_assoc.\nrewrite <- (mult_comm x).\nrewrite mult_assoc.\nrewrite <- (mult_comm x u).\nrewrite <- mult_assoc.\nrewrite (mult_comm x u).\nrewrite (mult_comm x u).\nrewrite mult_assoc.\nrewrite <- (mult_comm x u).\nrewrite mult_assoc.\nrewrite <- (mult_comm x u).\nrewrite mult_assoc.\nrewrite <- (mult_comm x u).\nrewrite mult_assoc.\nrewriteQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nunfold is_gcd.\nintros (b,u) (H1,H2).\ndestruct (gcd_cross_prod _ _ _ _ H1) as (u,v).\ndestruct (gcd_cross_prod _ _ _ _ H2) as (u,v).\ndestruct (gcd_cross_prod _ _ _ _ H H1) as (u,v).\ndestruct (gcd_cross_prod _ _ _ _ H H0) as (u,v).\ndestruct (gcd_cross_prod _ _ _ _ H H1) as (u,v).\ndestruct (gcd_cross_prod _ _ _ H H0) as (u,v).\ndestruct (gcd_cross_prod _ _ _ H H1) as (u,v).\ndestruct (gcd_cross_prod _ _ _ H H0) as (u,v).\ndestruct (gcd_cross_prod _ _ _ H H0) as (u,v).\ndestruct (gcd_cross_prod _ _ _ H H0) as (u,v).\ndestruct (gcd_cross_prod _ _ _ H H0) as (u,vQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\n  intros.\n  apply gcd_unique with (gcd u (gcd u (gcd v (gcd v x))).\n  apply gcd_unique with (gcd u (gcd v (gcd v y))).\n  apply gcd_gcd_r.\n  apply gcd_gcd_l.\n  apply gcd_greatest; auto with zarith.\n  intros.\n  elim H1; intros.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H7; simpl in H7; discriminate.\n  rewrite H3 in H6; simpl in H6; discriminate.\n  rewrite H3 in H7; simpl in H7; discriminate.\n  rewrite H3 in H6; simpl in H6Qed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros.\ndestruct (gcd_bezout_l x y u v) as ((u',v'),_).\nexists (u',v').\nsplit.\nrewrite H;simpl;ring.\nrewrite H;simpl;ring.\nrewrite H;simpl;ring.\nQed.",
                    "Lemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\nProof.\nintros [|a|a] [|b|b] [|c|d] [|d|d] [|d] [|d] [|d|d] [|d] [|d] [|d|d] [|d] [|d] [|d|d] [|d] [|d] [|d|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|d] [|Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "\nLemma rel_prime_sym : forall (a b:nat),(rel_prime a b)->(rel_prime b a).\n  unfold rel_prime.\n  intros;apply gcd_sym;trivial.\nQed.\n\n(** for all a, a and 1 are relatively prime *)\nLemma rel_prime_1 : forall (a:nat),(rel_prime a 1).\n  unfold rel_prime.\n  intros;apply gcd_sym;apply gcd_one.\nQed.\n\n(** we have that a/gcd(a,b) and b/gcd(a,b) are relatively prime *)\nLemma gcd_rel_prime : forall (d a b:nat)(H:(is_gcd d a b)),(d <> O)->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n",
                "context_tokens": 700,
                "proof_start_offset": 6774,
                "proof_end_offset": 7070,
                "proof": "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\nProof.\nintros.\nelim (gcd_minus (v*y-(u+v)*x) x y H);intros.\napply H2.\nrewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_div ((u+v)*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;trivial.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_bezout ((u+v)*x+v) x y H);intros.\n  apply H2.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r;rewrite <- mult_minus_distr_r;simpl;auto with arith.\nQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_bezout ((u+v))+u*y) x y H);intros.\n  apply H2.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;ring.\n  apply mult_complete;auto with arith.\n  rewrite mult_comm;Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_gcd_greatest ((u+v)*y) x y H); intros.\n  apply H3.\n  rewrite mult_comm.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;try (auto with arith);rewrite <- mult_minus_distr_r;assumption.\n  elim H4; intros.\n  exists x.\n  apply mult_complete_conv_r with b;auto.\n  rewrite mult_comm;rewrite mult_minus_distr_r;try (auto with arith);rewrite <- mult_minus_distr_r;assumption.\n  elim H4; intros.\n  exists x.\n  apply mult_complete_conv_r with (c*x);auto.\n  rewrite mult_comm;rewrite mult_minus_distr_r;rewrite mult_minus_distr_r;reflexivity.\n  elim H4; intros.\n  exists x.\n  apply mult_complete_conv_r with (c*x);auto.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_minus_distr_r;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;assumption.\n  elim H4;Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u + v) -y) x (y-x)); intros.\n  apply H3.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n  rewrite mult_comm; apply mult_comm; auto with arith.\n Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_div_mod ((u+v)*x-v) x y H);intros.\n  apply H2.\n  rewrite mult_comm;rewrite mult_minus_distr_r;rewrite <- minus_minus_diag_r;trivial.\n  rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;auto.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;auto.\n  rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_l;auto.\n  rewrite <- mult_minus_distr_l;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;auto.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_l;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distrQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u + v)*u) x y H);intros.\n  apply H2.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_l;ring.\n  rewrite mult_comm;rewrite mult_minus_distr_l;rewrite <- mult_minus_distr_r;ring.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;ring.\n  rewrite mult_comm;rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;ring.\n  rewrite mult_minus_distr_r;rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;ring.\n  ring.\n  Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_div_mod ((u+v)*x-v) x y H);intros.\n  apply H2.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;try (auto with arith);rewrite mult_minus_distr_l;try (auto with arith);\n  rewrite mult_comm;rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_l;try (auto with arith);rewrite mult_minus_distr_l;try (auto with arith);\n  rewrite mult_comm;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_l;try (auto with arith);rewrite <- mult_minus_distr_r;try (auto with arith);\n  rewrite mult_comm;rewrite <- mult_minus_distr_r;try (auto with arith); rewrite mult_minus_distr_r;try (auto with arith);\n  rewrite mult_comm; rewrite <- mult_minus_distr_l;try (auto with arith);\n  rewrite mult_comm; rewrite <- mult_minus_distr_r;try (auto with arithQed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus ((u + v)*y+v) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_l; rewrite <- mult_minus_distr_r;try (auto with arith);rewrite plus_minus_distr_r;trivial.\n  rewrite mult_plus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_l;trivial.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;trivial.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;trivial.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;trivial.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;trivial.Qed.",
                    "Lemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_div_mod ((u+v)*y) x y H); intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_distr_r;rewrite <- minus_minus_diff2;try (auto with arith); rewrite <- mult_minus_distr_r;trivial.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_diff2;rewrite <- minus_minus_diff2;try (auto with arith);rewrite <- mult_minus_distr_l;trivial.\n  rewrite mult_minus_distr_r;rewrite <- minus_minus_distr_r;rewrite <- minus_minus_diff2;try (auto with arith);rewrite <- mult_minus_distr_r;trivial.\n  rewrite mult_minus_distr_r;rewrite <- minus_minus_diff2;rewrite <- minus_minus_diff2;try (auto with arith);rewrite <- mult_minus_distr_l;trivial.\n  rewrite mult_minus_distr_r;rewrite <- minus_minus_distr_r;rewrite <- minus_minus_diff2;trivial.\n  rewrite mult_minus_distr_rQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": ")->(rel_prime (quo a d (gcd_div_l d a b H)) (quo b d (gcd_div_r d a b H))).\n  unfold rel_prime.\n  intros.\n  generalize (quo_is_quo a d (gcd_div_l d a b H));intro.\n  generalize (quo_is_quo b d (gcd_div_r d a b H));intro.\n  unfold is_gcd;split;unfold is_cd.\n  split;apply one_min_div.\n  intros.\n  elim H3;intros.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H6 in H1.\n  rewrite H7 in H2.\n  assert (divides d (d*d')).\n  red in H;elim H;intros.\n  apply H9;red;split;[exists q;rewrite H1;ring | exists q';rewrite H2;ring].\n  elim H8;intros.\n  exists x.\n  apply mult_lemma6 with d;trivial.\n  rewrite mult_assoc;rewrite <- H9;auto with arith.\nQed.\n\n(** if q<>0 then gcd(p,q)<>0 *)\nLemma gcd_non_zero : forall (d p q:nat),(q<>O)->(is_gcd d p q)->(d<>O).\n  unfold is_gcd.\n  intros.\n  elim H0;intros.\n  intro.\n  elim H1;intros.\n  elim H5;intros.\n  rewrite H3 in H6;simpl in H6;auto.\nQed.\n\n(** we now exhibit an algorithm that computes Bezout coefficient: for all a b, there is u and v such that a*u-b*v = gcd(a,b) or b*v-a*u = gcd(a,b) *)\n(** the 4 lemmae gives the idea of the algorithm *)\nLemma bezout_aux1 : forall (x y u v:nat),(x<=y)->(is_gcd (u*x-v*(y-x)) x (y-x))->(is_gcd ((u+v)*x-v*y) x y).\n  intros.\n  elim (gcd_minus ((u+v)*x-v*y) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite <- minus_minus_lemma1;try (auto with arith);rewrite <- mult_minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\n",
                "context_tokens": 677,
                "proof_start_offset": 7098,
                "proof_end_offset": 8538,
                "proof": "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\nunfold ltof.\nunfold f.\nintros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ndestruct (fst x).\nright;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\nelim (H (S n,snd x-S n));try (intro;simpl).\nelim a;intro y;intro.\nleft;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nright;exists ((fst y)+(snd y),(snd y)).\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nrewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\ndestruct (snd x).\nleft;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\nelim (H (S n,fst x-S n));try (intro;simpl).\nelim a;intro y;intro.\nright;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux1;try (auto with arith).\nelim b;intro y;intro.\nleft;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\nsimpl;apply bezout_aux2;try (auto with arith).\nsimpl;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_cross_prod _ _ (fun _ => True) _ H); clear H H0; intros.\n  elim H0; intros.\n  rewrite mult_comm; rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;\n    rewrite mult_plus_distr_r; rewrite mult_comm; rewrite <- mult_minus_distr_r;rewrite mult_minus_distr_r;\n    rewrite <- mult_minus_distr_r; rewrite <- mult_minus_distr_l;\n    rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;\n    rewrite <- mult_minus_distr_r; rewrite <- mult_minus_distr_r;\n    rewrite <- mult_minus_distr_r; rewrite <- mult_minus_distr_r;\n    rewrite <- mult_minus_distr_r; rewrite <- mult_minus_distr_l;\n    rewrite <- mult_minus_distr_r; rewrite <- mult_minus_distr_l;\n    rewrite <- mult_minus_distr_r; rewrite <- mult_minus_distr_r;\n    rewrite <-Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_bezout (snd y) (snd x) (snd y)); intros.\n  apply H2.\n  rewrite mult_comm; rewrite mult_plus_distr_r;rewrite mult_minus_distr_r;rewrite mult_minus_distr_r;rewrite mult_minus_distr_r; reflexivity.\n  exists (fst (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  reflexivity.\n  symmetry ; apply mult_comm.\n  rewrite mult_minus_distr_r; rewrite mult_minus_distr_l;rewrite mult_minus_distr_r; reflexivity.\n  exists (fst (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  replace (snd (x+y)) with (snd (x+y)).\n  replace (snd (xQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_bezout (v*y) (fst x)); intros.\n  apply H3.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_minus_distr_l;rewrite mult_minus_distr_l;trivial.\n  ring.\n  ring.\n  ring.\n  apply (proj1 (H0 x)).\n  apply div_intro;trivial.\n  apply div_intro;trivial.\n  ring.\n  apply div_intro;trivial.\n  ring.\n  ring.\n  apply div_intro;trivial.\n  ring.\n  apply div_intro;trivial.\n  ring.\n  ring.\n  apply div_intro;trivial.\n  ring.\n  apply div_intro;trivial.\n  ring.\n  ring.\nQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_minus ((snd y)*(fst x)+(snd y),(snd x)+( snd y))).\n  simpl;intros.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r;rewrite <- mult_minus_distr_r.\n  rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r.\n  rewrite mult_assoc.\n  rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;rewrite <- mult_minus_distr_r;reflexivity.\n  rewrite mult_minus_distr_r;rewrite plus_minus_distr_r;rewrite <- mult_minus_distr_r;reflexivity.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;reflexivity.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;reflexivity.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;reflexivity.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_l;reflexivity.\n  rewrite mult_minus_distr_r;rewrite <- mult_minus_distr_r;reflexivityQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H0; intros.\n  elim H1; intros.\n  rewrite H2 in H1; simpl in H1; rewrite H1 in H2.\n  rewrite <- H2 in H1; simpl in H1;rewrite H1 in H1;rewrite H2 in H2.\n  rewrite H1 in H1; simpl in H1;rewrite H1 in H1;rewrite H2 in H2.\n  rewrite H1 in H1; simpl in H1;rewrite H1 in H2.\n  rewrite H1 in H1; simpl in H1; rewrite H1 in H1; rewrite H2 in H2.\n  rewrite H2 in H1; simpl in H1; rewrite H1 in H1;rewrite H2 in H2.\n  rewrite H1 in H1; simpl in H1; rewrite H1 in H1; rewrite H2 in H2.\n  rewrite H1 in H1; simpl in H1; rewrite H1 in H1; rewrite H2 in H1.\n  rewrite H1 in H1; simpl in H1; rewrite H1 in H1; rewrite H2 in H1.\n  rewrite H1 in H1; simplQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  rewrite H3; simpl;auto.\n  rewrite H3; simpl;auto.\n  rewrite H3; simpl;auto.\n  rewrite H4; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simpl;auto.\n  rewrite H5; simplQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_opp_r (fst x) (snd y)); intros.\n  apply H2.\n  rewrite mult_1_l;rewrite mult_comm;trivial.\n  rewrite mult_1_l;rewrite <- mult_minus_distr_r;rewrite mult_comm;trivial.\n  replace (fst x) with (fst (snd x)); simpl.\n  replace (snd (snd x)) with (snd (snd (snd x))); simpl.\n  replace (snd (snd x)) with (snd (snd x)); simpl; ring.\n  rewrite mult_1_l; rewrite mult_comm;trivial.\n  rewrite mult_1_l;rewrite mult_comm;trivial.\n  replace (snd x) with (snd (snd x)); simpl.\n  replace (snd (fst x)) with (snd (snd x)); simpl.\n  replace (snd (snd (snd x))); simpl.\n  replace (snd (snd x)) with (snd (snd (snd x))); simpl; ring.\n  replace (snd (snd (snd x)) + snd (snd (snd x))); simpl.\n  replace (snd (snd (snd x)) + snd (snd (snd (snd x))); simpl.Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_div_l x y); intros.\n  elim H2; intros.\n  rewrite H3 in H6; simpl in H6;auto.\n  rewrite mult_comm; simpl;rewrite mult_minus_distr_l;rewrite mult_minus_distr_r;try (auto with arith);rewrite plus_minus_distr_r;try (auto with arith);\n  rewrite mult_minus_distr_r;try (auto with arith);rewrite plus_minus_distr_r;try (auto with arith);rewrite plus_minus_distr_r;try (auto with arith);\n  rewrite mult_minus_distr_r;try (auto with arith);rewrite mult_minus_distr_r;try (auto with arith);\n  rewrite mult_minus_distr_r;try (auto with arith);\n  rewrite mult_minus_distr_r;try (auto with arith);rewrite mult_minus_distr_r;try (auto with arith);\n  rewrite mult_minus_distr_r;try (auto with arith);rewrite plus_minus_distr_l;try (auto with arith);\n  rewrite mult_minus_distr_r;try (auto with arith);Qed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim (gcd_div_l x y);intros.\n  rewrite H2 in H0;simpl in H0;auto.\n  rewrite mult_0_r in H0;simpl in H0;omega.\n  rewrite mult_0_r in H0;simpl in H0;omega.\n  elim H0; intros.\n  exists y; exists x0.\n  exists (fst y); repeat split.\n  apply mult_complete_conv;auto with arith.\n  rewrite mult_0_r in H0;simpl in H0;omega.\n  rewrite mult_0_l in H0;simpl in H0;omega.\n  rewrite mult_0_r in H0;simpl in H0;omega.\n  rewrite mult_0_l in H0;simpl in H0;omega.\n  rewrite mult_0_r in H0;simpl in H0;omega.\n  elim H0; intros.\n  exists y; exists x0.\n  exists (x0 * y); repeat split.\n  apply mult_complete_conv;auto with arith.\n  rewrite mult_0_r in H0;simpl in H0;omega.\n  rewrite mult_0_lQed.",
                    "Lemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  intros.\n  elim H0; intros.\n  elim H2; intros.\n  rewrite H3 in H6; simpl in H6;auto.\n  elim H6; intros.\n  rewrite H3 in H7;simpl in H7;auto.\n  rewrite H2 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H4 in H7; simpl in H7;auto.\n  elim H7; intros.\n  rewrite H3Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "minus_lemma2;trivial.\nQed.\n\nLemma bezout_aux2 : forall (x y u v:nat),(x<=y)->(is_gcd (v*(y-x)-u*x) x (y-x))->(is_gcd (v*y-(u+v)*x) x y).\n  intros.\n  elim (gcd_minus (v*y-(u+v)*x) x y H);intros.\n  apply H2.\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite <- minus_minus_lemma2;rewrite <- mult_minus_lemma2;trivial.\nQed.\n\n(** Bezout coefficient *)\nLemma bezout_exists_prod : forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\n",
                "context_tokens": 690,
                "proof_start_offset": 8563,
                "proof_end_offset": 8967,
                "proof": "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros.\nelim (bezout_exists_prod (a,b));intro.\nelim a0;destruct x;simpl;intros.\nleft;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\nelim b0;destruct x;simpl;intros.\nright;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros a b Hrec.\n  case (non_gcd (a*v) (b*v)); intros.\n  case (gcd_gcd a b); intros.\n  case (gcd_gcd a b); intros.\n  case (gcd_gcd a b); intros.\n  case (gcd_gcd a b); intros.\n  case (gcd_gcd a b); intros.\n  left; exists (1, b).\n  rewrite H; ring.\n  exists (a,(1,b)).\n  rewrite H; ring.\n  exists (a,(1,b)).\n  rewrite H; ring.\n  exists (a,(1,b)).\n  rewrite H; ring.\n  exists (a,(1,b)).\n  rewrite H; ring.\n  exists (a,(1,0)).\n  rewrite H; ring.\n  exists (a,(1,b)).\n  rewrite H; ring.\n  exists (a,(1,0)).\n  rewrite H; ring.\n  exists (a,(1,b)).\n  rewrite H; ring.\n  exists (a,(1,0)).\n  rewrite H; ring.\n  exists (a,(1,0)).\n  rewrite H; ring.\n  exists (a,(1,0)).Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  case (gcd_bezout a b);intros.\n  left; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  right; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  left; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  right; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  right; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  left; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  right; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  right; exists (2,0).\n  simpl;apply (is_gcd_for_euclid2 a b);auto with arith.\n  right; exists (2,0).\n Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros.\n  elim (gcd_bezout2 (a/a) a b); intros.\n  left; exists (1,v); simpl;rewrite <- plus_n_O;rewrite plus_comm; simpl;apply gcd_0_r.\n  left; exists (0,v); simpl; rewrite <- plus_n_O; rewrite plus_comm; simpl; apply gcd_0_l.\n  left; exists (1,v); simpl; rewrite <- plus_n_Sm; simpl; apply gcd_0_l.\n  right; exists (1,v); simpl; rewrite <- plus_n_Sm; simpl; apply gcd_0_l.\n  left; exists (1,v); simpl; rewrite <- plus_n_Sm; simpl; apply gcd_0_l.\n  left; exists (1,v); simpl; rewrite <- plus_n_Sm; simpl; apply gcd_0_l.\n  left; exists (0,v); simpl; rewrite <- plus_n_Sm; simpl; apply gcd_0_r.\n  right; exists (1,v); simpl; rewrite <- plus_n_Sm; simpl; apply gcd_0_lQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\n  intros.\n  elim (gcd_bezout_inf a b H); intros.\n  elim (gcd_bezout_inf a b H0); intros.\n  elim H; intro.\n  left; exists (1, a); repeat split;try assumption.\n  right; apply (gcd_bezout_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  right; apply (gcd_greatest_inf a b H0).\n  right; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  right; apply (gcd_greatest_inf a b H0).\n  right; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  left; apply (gcd_greatest_inf a b H0).\n  right; apply (Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n \nTheorem bezout_rec_prod : forall a b, {u:nat & {v:nat & {v:nat & {v:nat | (is_gcd (a*v) a b) b}}} + {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat | (is_gcd (a*v) a b) b}).\n  intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezout_prod a b); intros.\n  elim (gcd_bezoutQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintro.\nelim (rel_prime_dec a (gcd b a)).\nintro.\nexists (gcd b a);split.\napply Zis_gcd_for_euclid with (1:=a) (2:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (4:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (4:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (4:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=a) (3:=aQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros.\nelim (gcd_greatest a b); intros.\nelim (gcd_greatest a b); intros.\nelim (gcd_greatest a b); intros.\nelim (gcd_greatest a b); intros.\nleft;exists (1, a); simpl;rewrite <- minus_n_O; rewrite <- plus_n_O; rewrite plus_comm; simpl; ring.\nright; exists (1, a); simpl;rewrite <- minus_n_O; rewrite <- plus_n_O; simpl; ring.\nright; exists (1, a); simpl; rewrite <- minus_n_O; rewrite plus_n_O; ring.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\nProof.\nintros a b.\ngeneralize (div_mod_eq a b);intros.\ndestruct (gcd_div_dec a b) as [H|H].\nleft;exists a;auto with arith.\nright;exists a;auto with arith.\nright; exists a;auto with arith.\nright; exists b;auto with arith.\nQed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  apply (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b) })).\n  apply (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b) })).\n  intros.\n  elim (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b)}).\n  intros.\n  elim (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b)).\n  intros.\n  elim (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b}).\n  intros.\n  elim (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b}).\n  intros.\n  elim (gcd_for_euclid (fun a b:nat => {v:nat | (is_gcd a b) a b}).\n  intros.\n  elim (gcd_for_euclid (fun a b:nat => {v:nat | (is_Qed.",
                    "Theorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (gcd_bezout_inf a b); intros.\n  elim H; intro.\n  left; exists a; exists b; auto with arith.\n  right; exists (1, b); auto with arith.\n  right; exists (1, a); exists (1, a); exists (1, a); exists (1, a); exists (1, a); exists (1, a); exists (1, a);\n  simpl; apply ch_);\n  apply (is_gcd_for_euclid1 a b).\n  elim (gcd_bezout_inf a b); intros.\n  elim H; intro.\n  left; exists (1, a); exists (1, a); exists (1, a); exists (1, a);\n  simpl; apply ch ]);\n  apply chNormal_gcd_for_euclid2; try (auto with arith).\n  elim b; intro.\n  right; exists a; exists (1, a); exists (1, a); exists (1, a);\n  simpl; apply ch ]);\n  apply chNormal_gcd_for_euclid2; try (auto with arith).\n  elim H; intro.\n  left; exists a; exists (1, a); existsQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " forall (x:nat*nat),{y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => ({y:nat*nat | (is_gcd ((fst y)*(fst x)-(snd y)*(snd x)) (fst x) (snd x))}+{y:nat*nat | (is_gcd ((snd y)*(snd x)-(fst y)*(fst x)) (fst x) (snd x))})%type)).\n  unfold ltof.\n  unfold f.\n  intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\n",
                "context_tokens": 708,
                "proof_start_offset": 9005,
                "proof_end_offset": 9380,
                "proof": "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\nelim (bezout_exists a b);intro.\nelim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\nelim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (is_gcd (a*v) (a/b)).\n  intro; exists (a-b);intros.\n  left;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  intro; exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  left;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  left;exists (a-b);intros.\n  left; exists (a-b);intros.\n  right; exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  left;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (a-b);intros.\n  right;exists (Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  case (Req_dec a b);intros.\n  left; exists a; auto.\n  right; exists a; auto.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  case (ex_least_prod (a,b) b b);intros.\n  exists (a,(b,(c,(d,(H1,H2)))).\n  apply (H1 (S n,H2));simpl;trivial.\n  elim (H (S n,H2));simpl;intro.\n  left;exists (S n0);rewrite mult_comm;rewrite (mult_comm a);trivial.\n  elim (H (S n0,H2)); simpl;intro.\n  left;exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right;exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right;exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  left;exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right;exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewriteQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim H; clear H; intro.\n  left;exists (1,a).\n  rewrite <- (is_gcd_for_euclid d a b c);rewrite <- mult_comm;trivial.\n  elim H; clear H; intro.\n  right; exists (1,a).\n  simpl;apply div_exists;trivial.\n  elim H; clear H; intro.\n  left; exists (1,a).\n  simpl; apply div_exists;trivial.\n  elim H; clear H; intro.\n  right; exists (1,a).\n  simpl; apply div_exists;trivial.\n  elim H0; clear H0; intro.\n  left; exists n; exists (1,a).\n  simpl; apply div_exists;trivial.\n  elim H; clear H; intro.\n  left; exists (1,a).\n  simpl; apply div_exists;trivial.\n  elim H; clear H; intro.\n  right; exists (1,a).\n  simpl; apply div_exists;trivial.\n  elim H; clear H; intro.\n  right; exists (S n0).\n  simpl; apply div_exists;trivial.\n  elim H; clear H; intro.\n Qed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim H; clear H; intro.\n  left; exists n0;rewrite mult_comm;rewrite mult_comm;rewrite H;ring.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm a);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  left; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  left; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S n0);rewrite mult_comm;rewriteQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  elim H.\n  left; exists a;auto.\n  left; exists a;auto.\n  right; exists b;auto.\n  right;exists a;auto.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (classic (exists v:nat,d=a*u)).\n  intro; exists (a*u);intros.\n  left; exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim (H (a*u));intros.\n  left; exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  elim (H (a*u)); intros.\n  left; exists n0; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists n0; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  left; exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  right; exists n0; rewrite mult_comm;rewrite (mult_comm a);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  left; exists n0; rewrite mult_comm;rewrite (mult_comm a);trivial.\n  left; exists n0;rewrite mult_comm;rewrite (multQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\nintros.\ninduction H; intros.\nexists a.\nsplit;intros.\nsplit;intros.\ndestruct (ex_intro _ H0) as (u,H0).\nexists u.\nsplit.\nrewrite mult_comm;trivial.\napply (is_gcd (a*v) (gcd b (gcd a b)));intros;auto.\nexists u.\nsplit.\nrewrite mult_comm;trivial.\napply (is_gcd (a*v) (gcd b (gcd a b)));intros;auto.\nrewrite H0;apply div_gcd;try (auto with arith).\nsplit.\nrewrite mult_comm;trivial.\nsplit.\nrewrite mult_comm;trivial.\nsplit.\nrewrite mult_comm;trivial.\nsplit.\nrewrite mult_comm;trivial.\nsplit.\nrewrite mult_comm;trivial.\nrewrite mult_comm;trivial.\nsplit.\nrewrite mult_comm;trivial.\nsplit.\nrewrite mult_comm;trivial.\nQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\nProof.\n  intros.\n  destruct H as (a,b).\n  apply Zis_gcd_for_euclid with (1:=a*v);try (intro;simpl).\n  elim (gcd_for_euclid (a,b) (a,c) H0).\n  intros a b c.\n  elim H1; intro.\n  left; exists a; exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim H1; intro.\n  left; exists a; exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (S a); exists b; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists a; rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists (SQed.",
                    "Theorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (is_gcd (gcd a b) (gcd b c));intros.\n  elim H.\n  left; exists a; exists b;split;trivial.\n  right; exists b;split;trivial.\n  right; exists a; exists b; auto.\n  right; exists b; auto.\n  right; exists a; exists b; auto.\n  right; exists a; exists b; auto.\n  right; exists a; exists b; auto.\n  right; exists a; exists b; auto.\n  right; exists b; auto.\n  right; exists b; exists b; auto.\n  right; exists b; exists b; auto.\n  right; exists b; auto.\n  right; exists b; exists b; auto.\n  right; exists b; exists b; exists b; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  destruct (fst x).\n  right;exists (0,1);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_zero.\n  elim (H (S n,snd x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  left;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  right;exists ((fst y)+(snd y),(snd y)).\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\n  rewrite e;left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_refl.\n  destruct (snd x).\n  left;exists (1,0);simpl;rewrite <- minus_n_O;rewrite plus_comm;simpl;apply gcd_sym;apply gcd_zero.\n  elim (H (S n,fst x-S n));try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\n",
                "context_tokens": 704,
                "proof_start_offset": 9434,
                "proof_end_offset": 10062,
                "proof": "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro.\napply bezout;trivial.\nelim H;intro u;intro H0.\nelim H0;intro v;intro.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H2;intros.\nelim H3;intro q;intro.\nelim H4;intro q';intro.\nrewrite H5 in H1;rewrite H6 in H1.\ncase H1;intro.\nexists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nexists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (non_prime_dec a b);intro.\n  left; exists n;rewrite mult_comm;assumption.\n  left; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\n  right; exists n;rewrite mult_comm;assumption.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (classic (has_prime a b));intro.\n  left; exists (a*u);trivial.\n  elim (classic (has_prime a b)); intro.\n  left; exists (a*u); auto.\n  right; exists (a*u); auto.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (rel_prime_dec a b);intro.\n  elim H; intro u; exists v;assumption.\n  elim H; intro u; exists u; elim H; intro u; exists v; elim H; intros.\n  left; exists (a,(1,0)); apply (gcd_for_euclid a b (a*v) a b); tauto.\n  elim H; intro u; exists v; elim H; intro; exists u; elim H; intros.\n  right; exists (a,(1,0)); apply (gcd_for_euclid a b (a*v) a b); tauto.\n  elim H; intro u; exists u; elim H; intros.\n  left; exists (a,(1,0)); apply (gcd_for_euclid a b (a*v)); tauto.\n  elim H; intro u; exists u; elim H; intros.\n  right; exists (a,(1,0)); apply (gcd_for_euclid a b (a*v) a b); tauto.\n  elim H; intro u; exists u; elim H; intros; exists u; elim H; intros.\n  left; exists (a,(1,0));Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim b; intro b;intro;\n    right; exists (a*v);simpl;apply (gcd_intro a b);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim b; intro b;intro;\n    right; exists (a*v);simpl;apply (gcd_intro a b);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim b; intro b0; intro;\n    right; exists (a*v); simpl;apply (gcd_intro a b);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim b; intro b;intros;\n    right; exists (a*v); simpl;apply (gcd_intro a b);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elimQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  elim (non_prime_dec a b); intro.\n  elim (non_prime_dec a b); intro.\n  elim (non_prime_dec b (a*v) H0).\n  intro.\n  elim (non_prime_dec a (b*v) H0).\n  intro.\n  elim (non_prime_dec a (b*v) H1).\n  intro.\n  elim (non_prime_dec a (b * v) H1).\n  intro.\n  elim (non_prime_dec a (b*v) H2).\n  intro.\n  elim (non_prime_dec a (b * v)).\n  intro.\n  elim (non_prime_dec a (b * v) H3).\n  intro.\n  elim (non_prime_dec a (b * v) H4).\n  intro.\n  elim (non_prime_dec a (b * v) H4).\n  intro.\n  elim (non_prime_dec a (b * v) H4).\n  intro.\n  elim (non_prime_dec b (a*v) H4).\n  intro.\n  elim (non_prime_Qed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros.\nelim (non_prime_decomp_aux (fun a b:nat => {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat & {v:nat | (v = 0}) a b}).\nintro a; exists (div a b);trivial.\nintro a; exists (div a b); exists (div a b); ring.\nintro a; exists (div a b); exists (div a b); ring.\nintro b; exists (div a b); exists (div a b); ring.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\nintros a b H.\nelim (constructive_definite_description a b); intro.\nelim H; intro x; intros; exists x0; rewrite <- H0;ring.\nelim H; intro x; intros; exists x0; rewrite <- H1; ring.\nQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  elim (non_prime_dec (a*u) (rel_prime a b));intro.\n  elim b;intro v;intro; elim p; intro; exists v;split;trivial.\n  elim H; intro; exists (S v);split;trivial.\n  elim (rel_prime_dec (a*u) (rel_prime a b));intro.\n  elim (rel_prime_dec (a*u) (rel_prime a b)); intro.\n  elim H2; intro; exists v;split;trivial.\n  elim (rel_prime_dec (a*u) (rel_prime a b)); intro.\n  elim (rel_prime_dec (a*u) (rel_prime a b)); intro.\n  elim (rel_prime_dec (a*u) (rel_prime a b)); intro.\n  elim H1; intro H0.\n  left; exists (S v); rewrite mult_comm; rewrite (mult_comm a); rewrite (mult_comm b);\n    rewrite (mult_comm b); rewrite (mult_comm b); ring.\n  elim (rel_prime_dec (a*u) (rel_prime aQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros a b; elim (rel_prime_dec a b);intro.\n  elim (rel_prime_dec a b);intro.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim H1; intro; exists a; assumption.\n  elim H1; intro H1; exists a; assumption.\n  elim H1; intro H1; exists a; assumption.\n  elim H1; intro H2; exists a; assumption.\n  elim H1; intro H2; exists a; assumption.\n  elim H1; intro H2; exists a; assumption.\n  elim H1; intro H3; exists a; assumption.\n  elim H1; intro H4; exists a; assumption.\n  elim H1; intro H4; exists a; assumption.\n  elim H1; intro H4; exists a; assumption.\n  elim H1; intro H4; exists a; assumption.\n  elim H1; intro H4; exists a; assumption.\n  elim H0; intro H4; exists a; assumption.\n  elim H4; intro HQed.",
                    "Theorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\nProof.\n  intros.\n  elim (rel_prime_dec a b);intro.\n  elim (rel_prime_dec a b); intro.\n  elim H1; intro H; exists a0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim H1; intro H2; exists a0; rewrite mult_comm;rewrite (mult_comm a);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim (rel_prime_dec a b); intro.\n  elim H2; intro H3; exists a0; rewrite mult_comm; rewrite (mult_comm a); ring.\n  elim (rel_prime_dec a b); intro.\n  elim H3; intro H4; exists a0; rewrite mult_comm; rewrite (mult_comm a);trivial.\n  elim (rel_prime_dec a b); intro.\n  elim H4; intro H5; exists a0; rewrite mult_comm; rewrite (mult_comm a);trivial.\n  elim H5; intro H5; exists a0; rewrite mult_comm; rewrite (mult_comm a);Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try (intro;simpl).\n  elim a;intro y;intro.\n  right;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux1;try (auto with arith).\n  elim b;intro y;intro.\n  left;exists ((snd y),(fst y)+(snd y));apply gcd_sym.\n  simpl;apply bezout_aux2;try (auto with arith).\n  simpl;omega.\nQed.\n\n(** Bezout' theorem *)\nTheorem bezout_exists : forall (a b:nat),{u:nat & {v:nat | (is_gcd (a*u-b*v) a b)}}+{u:nat & {v:nat | (is_gcd (b*v-a*u) a b)}}.\n  intros.\n  elim (bezout_exists_prod (a,b));intro.\n  elim a0;destruct x;simpl;intros.\n  left;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim b0;destruct x;simpl;intros.\n  right;exists n;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\nQed.\n\n(** Bezout' theorem reformulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 10097,
                "proof_end_offset": 10866,
                "proof": "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nunfold is_gcd;unfold is_cd.\nintros.\nelim H;intros.\nelim H0;intros.\nsplit.\nelim H2;intro q;intro.\nelim H3;intro q';intro.\nrewrite H4;rewrite mult_assoc.\nrewrite H5;rewrite mult_assoc.\nsplit;[exists q;trivial | exists q';trivial].\nintros.\nelim H4;intros.\nelim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\nintro u;intro.\nelim H7;intro v;intro.\nelim H5;intro q;intro.\nelim H6;intro q';intro.\ncase H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b); intro.\n  elim H; intro r; elim r; intro.\n  rewrite H5 in H1; rewrite H6 in H1.\n  case H1; intro.\n  rewrite H6 in H1; rewrite H6 in H1.\n  case H1; intro.\n  exists (q'*p).\n  rewrite H5 in H1; rewrite H6 in H1; rewrite H6 in H1.\n  case H1; intro.\n  rewrite H5 in H1; rewrite H7 in H1; rewrite H7 in H1.\n  case H1; intro.\n  exists (q'*p).\n  rewrite H5 in H1; rewrite H6 in H1; rewrite H7 in H1.\n  case H1; intro.\n  rewrite H7 in H1; rewrite H7 in H1; rewrite H7 in H1; discriminate H1.\n  exists (q'*p).\n  rewrite H5 in H1; rewrite H7 in H1; rewrite H7 in H1; discriminate H1.\n  exists (q'*p).\n  rewrite H5 in H1; rewrite H7 in HQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b);intro.\n  elim H; intro p;intro; elim p;intro q;intro; elim p.\n  simpl; rewrite mult_comm; rewrite (mult_comm a);trivial.\n  elim (gcd_bezout_exists a b);intro.\n  elim H0; intro q;intro; elim p;intro q; intros; elim p; intro; elim p; intros;\n    elim H1; intro q; intros;\n      elim H2; intro q;\n        rewrite H2 in H2; elim (mult_comm a (q*a) q);\n          clear H H1 H2; intros;\n            elim H2; intro q;\n            rewrite H3 in H1; elim (mult_comm a (q*a) q);\n              clear H2 H2; intros;\n              elim H2; intro q;\n              rewrite H3 in H2; elim (mult_comm a (q*a) q);\n                clear H2 H3; intros;\n                  elim H2; intro q;\n                  rewrite H3 in H2; elim (mult_comm b (q*a) q);\n                  clear H2 H2 H2Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b);intro.\n  elim b; intro v;intros; elim n; intro v; elim n; intro n; intros.\n  elim b; intro v;intros.\n  simpl; apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro with b; trivial.\n  elim b; intro b; intros; elim n; intros.\n  simpl; apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_intro with b; trivial.\n  elim b; intro b; intros; elim n; intros.\n  simpl; apply is_gcd_intro.\n  apply is_gcd_intro.\n  apply is_gcd_Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nintros.\nunfold rel_prime.\nexists (S n).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,b) (S n)).\napply (is_gcd_for_euclid (a,bQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b);intro.\n  elim b; intro b;intro H0.\n  rewrite H1 in H; rewrite H2 in H; rewrite H2 in H.\n  elim (gcd_bezout_exists a b); intro.\n  elim b; intro b;intro H0.\n  rewrite H1 in H0; rewrite H2 in H; rewrite H2 in H.\n  elim (gcd_bezout_exists a b); intro.\n  elim b; intro b;intro H0.\n  rewrite H1 in H0; rewrite H2 in H0; rewrite H2 in H.\n  case H0; intro.\n  exists (q'*v);rewrite mult_minus_prefix; rewrite mult_assoc; rewrite (mult_comm a); ring.\n  exists (q'*v); rewrite mult_minus_prefix; rewrite mult_assoc; rewrite (mult_comm a); ring.\n  exists (q'*v); rewrite mult_minus_prefix; rewrite (mult_comm b); ring.\n  exists (q'*v); rewrite mult_minus_prefix; rewrite (mult_comm a); ring.\n  exists (q'*u);Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\nProof.\nintros.\nelim (gcd_bezout_exists a b); intro.\n  elim H; intro q;intros.\n  unfold is_gcd in |- *.\n  split.\n  apply (gcd_bezout a b);auto with algebra.\n  elim H; intro q; intros.\n  unfold is_gcd in |- *.\n  split.\n  apply (gcd_bezout a b);auto with algebra.\n  elim H; intro q; intros.\n  elim H; intro q; intros.\n  rewrite H6 in H1; rewrite H6 in H1.\n  elim (gcd_bezout a b); intros.\n  elim H1; intro q; intros.\n  elim H1; intro q; intros.\n  rewrite H6 in H1; rewrite H6 in H1.\n  elim (gcd_bezout a b); intros.\n  elim (gcd_bezout a b); intros.\n  elim H1; intro q; intros.\n  elim H1; intro q; intros.\n  rewrite H6 in H1; rewrite H7 in H1; rewrite H7 in H1.\n  elim (gcd_bezout a b); intros.\n  elim H1; intros.\n  rewrite H6 in H2; rewrite HQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b); intro.\n  elim H; intro H1; elim H1; intro H2; elim H2; intro H4.\n  split; apply (gcd_for_euclid a b); assumption.\n  elim H; intro H2; elim H2; intro H4; elim H4; intro H4;\n    elim H4; intro H5;\n      rewrite H5 in H2; rewrite H6 in H1.\n  case H1; intro H5; elim H5; intro H5;\n      rewrite H5 in H1; rewrite H5 in H1.\n  case H1; intro H5;\n      rewrite H5 in H1; rewrite H5 in H1.\n  case H1; intro H5;\n      rewrite H5 in H1; rewrite H6 in H1.\n  case H1; intro H5;\n      rewrite H5 in H1; rewrite H6 in H1.\n  case H1; intro H6;\n      rewrite H6 in H1; rewrite H6 in H1.\n  case H1; intro H5;\n      rewrite H5 in H1; rewrite H6 in H1.\n Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_gcd a b);intro.\n  elim H0; intro q;intros; elim p;intro q;intros; elim q; intros; elim p; intro;\n    rewrite <- H1; rewrite H2; rewrite H4;\n      reflexivity.\n  elim H0; intro q; intros; elim p; intro q; intros;\n    rewrite <- H1; rewrite H2; rewrite H4;\n      reflexivity.\n  elim H0; intro q; intros;\n    rewrite <- H2; rewrite H3; rewrite H4;\n      reflexivity.\n  elim H0; intro q; intros;\n    rewrite <- H1; rewrite H4; rewrite H4;\n      reflexivity.\n  elim H0; intro q; intros;\n    rewrite <- H0; rewrite H0; rewrite H4;\n      reflexivity.\n  elim H0; intro q; intros;\n    rewrite <- H1; rewrite H0;\n      reflexivity.\n  elim H0; intro q; intros;\n    rewrite <- H0; rewrite H1; rewrite H4;\n      reflexivity.\n  elim H0; intro q; intros;\n    rewrite <- H0; rewrite H0;\n      reflexivity.\n  elim H0; intro q;Qed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b);intro.\n  elim H;intro n;intros n0 H.\n  left;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  elim H;intro n;intros n0 H.\n  right;exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  elim H;intro n;intros n0 H.\n  right;exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  left; exists n0;rewrite mult_comm;rewrite (mult_comm b);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (mult_comm a);trivial.\n  right; exists n0;rewrite mult_comm;rewrite (multQed.",
                    "Lemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  intros.\n  elim (gcd_bezout_exists a b);intro.\n  elim (gcd_bezout_exists_prod (a,b) b);intro.\n  elim H2;intro r;intro.\n  unfold is_gcd;unfold is_gcd;unfold is_gcd in |- *.\n  split.\n  apply (is_gcd_for_euclid a b); intros.\n  elim H2; intro r; elim H4; intro.\n  apply (is_gcd_for_euclid a b); intros.\n  elim H4; intro r; elim H4; intro r; elim H4; intro.\n  rewrite H4 in H1; rewrite H6 in H1; elim H1; intro.\n  exists (a*b); rewrite mult_minus_assoc; rewrite (mult_comm a); ring.\n  exists (a*b); rewrite mult_minus_assoc; rewrite (mult_comm b); ring.\n  exists (a*b); rewrite mult_minus_distr_r; ring.\n  exists (a*b); rewrite mult_minus_distr_r; ring.\n  exists (a*b); rewrite mult_minus_distr_r; ring.\n  exists (aQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "formulated *)\nTheorem bezout : forall (d a b:nat),(is_gcd d a b)->exists u:nat,exists v:nat,d=a*u-b*v \\/ d=b*v-a*u.\n  intros.\n  elim (bezout_exists a b);intro.\n  elim a0;intro u;intro;elim p;intro v;intro;exists u;exists v;left;apply (gcd_unique d (a*u-b*v) a b);trivial.\n  elim b0;intro u;intro;elim p;intro v;intro;exists u;exists v;right;apply (gcd_unique d (b*v-a*u) a b);trivial.\nQed.\n\n(** Bezout' theorem and relatively prime numbers *)\nTheorem bezout_rel_prime : forall (a b:nat),(rel_prime a b)<->(exists u:nat, exists v:nat, 1=a*u-b*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 10903,
                "proof_end_offset": 11396,
                "proof": "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nintros.\nelim (bezout 1 a d H);intro u;intro.\nelim H1;intro v;intro.\nelim H0;intro q;intro.\ncase H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintro d.\nunfold rel_prime;\nintros.\nelim H; intros; clear H; intros H0; elim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro H;\n elim H; intro H0;\n elim H0; intro q; elim H1; intro H1;\n elim H2; intro H2;\n elim H3; intro H4;\n elim H4; intro H5;\n elim H5; intro H5;\n elim H5; intro H6;\n elim H5; intro H5;\n elim H5; intro H5;\n elim H5; intro H5;\n elim H5; intro H6;\n elim H6; intro H6;\n elim H5; intro H6;\n elim H6; intros H7 H8;\n elim H8; intro H9;\n elim H9; intro H9;\n elim H9; intros H9 H10; elim H9; intros H12 H13;\n elim H12; intros H13 H14; elim H13; intros H14 H14;\n elim H14; intros H15 H16; elim H10; intros H14 H15; \n elim H15; intros H17 H16; elim H17; intros H17 H18;\n elimQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold rel_prime;intros.\n  elim H;intro n;intro n;intros n0 H; elim H;intros n0 H; elim H; intros n1 H; elim H; intros n2 H0; elim H; intros n2 H0;\n    clear H H0; intros n1 H; elim H; intros n2 H0; elim H0; intros n3 H1;\n    clear H; intros n3 H0; elim H0; intros n3 H0; elim H0; intros n3 H2;\n    clear H0; intros n4 H1; elim H2; intros n4 H2; elim H2; intros n4 H2;\n      clear H2; intros n4 H3; elim H2; intros n4 H2;\n      clear H2; intros n3 H4; elim H2; intros n4 H2;\n        clear H2; intros n4 H2; elim H2; intros n4 H2; elim H2; intros n4 H2;\n          clear H2; intros n4 H2; elim H2; intros n4 H2;\n          clear H2; intros n5 H2; elim H2Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nunfold rel_prime.\nunfold rel_prime.\nintros.\nelim H; intros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelimQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n \nProof.\n  unfold rel_prime; intros; apply rel_prime_pos.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_primeQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros.\nunfold rel_prime.\nexists (fun n:nat => a*b).\nsplit;intro.\nelim H;intro p;intro; elim p;intro.\n  unfold is_gcd;unfold is_gcd;unfold is_gcd in H; simpl in H.\n  elim H; intros.\n  exists (q*u); split; auto.\n  rewrite H5; simpl; ring.\n  elim H1; intro q; elim q; intro; elim H1; intro; elim H1; intro; elim H2;\n intros q H2; elim H2; intro.\n  rewrite H4; simpl; rewrite H4; rewrite mult_comm; rewrite mult_comm; rewrite H3;\n    rewrite (mult_comm a b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b d).\n  rewrite (mult_comm b d).\n  rewrite (mult_comm b d).\n  rewrite (mult_comm b d).\n  rewrite (mult_comm b d).\n  rewrite (mult_comm b d).Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nintros.\nunfold rel_prime.\nsplit.\nintro H0; elim H0; intro q; elim H0; intro q; elim H0; intro H1; elim H1; intro q; elim H1; intros q q;\n elim H1; intros q H1; elim H2; intros q H3; clear H3;\n elim H3; intros q H4; elim H4; intros q H5; elim H5; intros q H5;\n elim H5; intros q H5; elim H5; intros q H6; elim H6; intros q H7;\n elim H6; intros q H7; elim H7; intros q H8; elim H7; intros q H7;\n elim H7; intros q H9; elim H9; intros q H9; elim H9; intros H10 H11;\n elim H7; intros q H9; elim H9; intros q H9; elim H9; intros q H9; \n clear H9; intros H10 H11; elim H10; intros q H11; elim H10; intros q H11;\n elim H12; intros q H12Qed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nunfold rel_prime.\nintros d a b c d H.\napply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*c*d);\n[apply rel_prime_intro with (a*cQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros.\nunfold rel_prime.\nsplit;intro.\nelim H;intro.\nelim H;intro q;intro; elim H; intros.\nelim H0; intro q; intros.\nelim H1; intro q; intros; elim H2; intros.\nelim H5; intro q; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; introsQed.",
                    "Theorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\nProof.\nintros d a b.\nunfold rel_prime.\nsplit;intro H; elim H; intro H0; clear H H0.\nelim (rel_prime_dec (gcd a b) (gcd b d)); intro H1;\n elim H1; intro H2; clear H2.\nelim H1; intro H2; clear H2.\nelim H2; intro H3; clear H3.\nelim H3; intro H4; clear H4.\nelim H4; intro H5; clear H5.\nelim H5; intro H6; clear H6.\nelim H5; intro H6; clear H5.\nelim H5; intros H7 H8; clear H6.\nelim H6; intro H7; clear H5.\nelim H7; intro H7; clear H7.\nelim H7; intro H7; clear H7.\nelim H7; intros H7 H8; clear H7.\nelim H7; intros H7; clear H7.\nelim H7; intros H7 H8; clear H7.\nelim H7; intro H7; clear H7.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "*v \\/ 1 = b*v-a*u).\n  intros.\n  unfold rel_prime.\n  split;intro.\n  apply bezout;trivial.\n  elim H;intro u;intro H0.\n  elim H0;intro v;intro.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H2;intros.\n  elim H3;intro q;intro.\n  elim H4;intro q';intro.\n  rewrite H5 in H1;rewrite H6 in H1.\n  case H1;intro.\n  exists (q*u-q'*v);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\n  exists (q'*v-q*u);rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** gcd(n*a,n*b) = n*gcd(a,b) *)\nLemma gcd_mult : forall (d a b:nat),(is_gcd d a b)->(forall (n:nat),(is_gcd (n*d) (n*a) (n*b))).\n  unfold is_gcd;unfold is_cd.\n  intros.\n  elim H;intros.\n  elim H0;intros.\n  split.\n  elim H2;intro q;intro.\n  elim H3;intro q';intro.\n  rewrite H4;rewrite mult_assoc.\n  rewrite H5;rewrite mult_assoc.\n  split;[exists q;trivial | exists q';trivial].\n  intros.\n  elim H4;intros.\n  elim (bezout d a b);try (unfold is_gcd;unfold is_cd;trivial).\n  intro u;intro.\n  elim H7;intro v;intro.\n  elim H5;intro q;intro.\n  elim H6;intro q';intro.\n  case H8;intro;[exists (q*u-q'*v) | exists (q'*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H9;rewrite <- H10;rewrite H11;rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;trivial.\nQed.\n\n(** Gauss' theorem (use Bezout) *)\nTheorem gauss : forall (d a b:nat),(rel_prime a d)->(divides (a*b) d)->(divides b d).\n  unfold rel_prime.\n  intros.\n  elim (bezout 1 a d H);intro u;intro.\n  elim H1;intro v;intro.\n  elim H0;intro q;intro.\n  case H2;intro;[exists (q*u-b*v) | exists (b*v-q*u)];rewrite mult_minus_lemma2;rewrite mult_assoc;rewrite mult_assoc;rewrite <- H3;rewrite (mult_comm a b);rewrite (mult_comm d b);rewrite <- mult_assoc;rewrite <- mult_assoc;rewrite <- mult_minus_lemma2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 11456,
                "proof_end_offset": 13305,
                "proof": "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nintros.\ngeneralize (quo_rem_euclide a b H);intro.\nred;split;intro.\nrewrite H0 in H1.\nelim H1;intros.\nunfold is_gcd;unfold is_cd.\nelim H2;intros.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nreplace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\nassert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\nrewrite <- H6;rewrite minus_plus;trivial.\nrewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\nexists (q-q'*(quotient_euclide a b H));trivial.\nrewrite <- H7;trivial.\nintros.\nelim H6;intros.\napply H3.\nunfold is_cd;split;try tauto.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nrewrite H10.\nreplace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H9;trivial.\nunfold is_gcd;unfold is_cd.\nunfold is_gcd in H1;unfold is_cd in H1.\nelim H1;intros.\nelim H2;intros.\nrewrite H0.\nsplit.\nsplit;try tauto.\nelim H4;intro q;intro.\nelim H5;intro q';intro.\nrewrite H7.\nreplace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\nrewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\nexists (q*(quotient_euclide a b H)+q');trivial.\nrewrite <- H6;trivial.\nintros.\napply H3.\nsplit;try tauto.\nelim H6;intros.\nelim H7;intro q;intro.\nelim H8;intro q';intro.\nassert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\nrewrite minus_plus;trivial.\nrewrite H9 in H11.\nexists (q-q'*(quotient_euclide a b H)).\nrewrite mult_minus_lemma2;rewrite mult_assoc.\nrewrite <- H10;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros.\nelim (gcd_gcd a b H); intros; clear H.\nelim H; intro H.\nelim H0; intro H1;intro H2; elim H2; intros q H1; elim H2; intros q H2;\n elim H3; intro H4; elim H4; intros q H5; elim H5; intros q H5;\n elim H5; intros q H5; elim H5; intros q H6; clear H5;\n elim H5; intros q H5; elim H5; intros q H5; elim H5; intros q H6;\n elim H5; intros q H5; elim H5; intros q H5;\n elim H5; intros q H5; elim H5; intros q H6; elim H5; intros q H6;\n elim H6; intros q H6; elim H6; intros q H6; elim H6; intros q H6;\n elim H6; intros q H7; elim H6; intros q H7; elim H7; intros q H7;\n elim H7; intros q H7;Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H);intro p;intro.\n  elim (gcd_bezout 1 a b H); intro p;intro.\n  elim (gcd_bezout 1 a b H); intro p; intro.\n  elim (gcd_bezout 1 a b H); intro p; intro.\n  elim (gcd_bezout 1 a b H); intro p; intros.\n  elim (gcd_bezout 1 a b H); intro p; intros.\n  elim (gcd_bezout 1 a b H); intro p; intros.\n  elim (gcd_bezout 1 a b H); intro p; intros.\n  elim (gcd_bezout 1 a b H); intro p; intros.\n  elim (gcd_bezout 1Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nunfold rel_prime.\n  intros.\n  elim H;intro p;intro.\n  elim H0;intro r;intro.\n  elim H1;intro r;intros; elim H2;intro H3;clear H3 H4.\n  elim H3;intros.\n  elim H4;intro r; intros.\n  elim H4; intros; elim H5; intros.\n  elim H4; intros.\n  elim H5; intros; elim H6; intros.\n  elim H6; intros; elim H7; intros.\n  elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros.\n  elim H7; intros; elim H7; intros; elim H8; intros.\n  elim H6; intros; elim H7; intros; elim H8; intros; elim H7; intros; elim H7; intros.\n  elim H7; intros; elim H8; intros.\n  elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n    elim H8; intros; elim H9; intros; elim H10Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold rel_prime.\n  intros.\n  elim H;intros; elim H0;intros; elim H1;intros; elim H2;intros;\n    elim H3;intro p;intro; elim H4;intros; elim H4;intros;\n    elim H4;intro p;intro; elim H4; intros; elim H4; intros;\n    elim H4;intro H5; intros; elim H5; intros; elim H5; intros;\n      elim H5; intros; elim H5; intros;\n      elim H5; intros; elim H6; intros; elim H6; intros;\n      elim H6; intros; elim H6; intros;\n      elim H6; intros; elim H6; intros;\n      elim H6; intros; elim H6; intros;\n      elim H6; intros; elim H6; intros;\n        elim H6; intros; elim H7; intros;\n        elim H6; intros; elim H6; intros; elim H7; intros;\n        elim H6; intros; elim H7; intros;\n        elim H7; intros; elim H6; intros; elim H7; intros;\n        elim H7; intros; elimQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd.\n  intros.\n  elim H;intro p.\n  elim H0;intro q;intro.\n  case H0;intro q;intro.\n  case H2;intro H3;intro H4.\n  rewrite H4; rewrite mult_comm;rewrite mult_comm;rewrite (mult_comm b a); rewrite (mult_comm a b);\n    rewrite (mult_comm b a); rewrite (mult_comm b b); rewrite (mult_comm b a);\n    rewrite (mult_comm b a); rewrite (mult_comm b b); rewrite (mult_comm b a);\n    rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b b);\n      rewrite (mult_comm b a); rewrite (mult_comm b b); rewrite (mult_comm b b);\n      rewrite (mult_comm b a); rewrite (mult_comm b a); rewrite (mult_comm b b);\n      rewrite (mult_comm b a); rewrite (mult_comm b b);\n      rewrite (mult_comm b b); rewrite (mult_comm b a);\n      rewrite (mult_comm b a); rewrite (mult_comm b b);Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros.\nelim (gcd_dec (gcd d a) (gcd d a) H);intro.\nelim (gcd_dec (gcd d a) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcd d b) (gcd d b)); intros.\nelim (gcd_dec (gcdQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros.\nelim (gcd_uniqueness_for_euclid (a/b) (a/b) H); intros.\nexists (b*(c/b)).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b)).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b)).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) (a/b)).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) (a/b)).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) (a/b) H).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) H).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) (a/b) H).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) H).\nrewrite (gcd_uniqueness_for_euclid (a/b) (a/b) H).\nQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros.\ndestruct (gcd_bezout a b H) as (q,H1).\nrewrite H1;rewrite H2;ring.\nQed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  unfold is_gcd.\n  intros.\n  elim H;intro v;intro;elim H;intro H0;intros; elim H0;intros;\n    rewrite H1;rewrite mult_comm;rewrite (mult_comm a b); rewrite <- mult_minus_assoc;\n    rewrite (mult_comm (a * b)); rewrite (mult_comm a b); rewrite (mult_comm a b);\n    rewrite (mult_comm a b); rewrite (mult_comm b (a * b)); rewrite (mult_comm b a);\n    rewrite (mult_comm a b); rewrite (mult_comm b b); rewrite (mult_comm b b);\n    rewrite (mult_comm a b); rewrite (mult_comm a b); rewrite (mult_comm b b);\n    rewrite (mult_comm a b); rewrite (mult_comm b a); rewrite (mult_comm b b);\n    rewrite (mult_comm b a); rewrite (mult_comm b b); rewrite (mult_comm b b);\n    rewrite (mult_comm b b); rewrite (mult_comm b b); rewrite (mult_comm b b);\n    rewrite (mult_comm b b); rewrite (mult_comm b b);Qed.",
                    "Lemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\nProof.\nunfold rel_prime.\nintros (b,H).\ndestruct b;intros.\nunfold Bezout in H.\nelim H; intro q;intro.\nelim H;intro q;intro.\nelim (Hrec_cor2 q (a*v) H0); intro.\nelim H; intro q; intros; clear H H0; intro.\nelim H1; intro q; intros.\nelim H2; intros.\nelim (Hrec_cor2 q (a*v) H0); intros.\nelim H2; intros.\nelim H2; intro q; intros; clear H H2; intro.\nelim H2; intro q; intros; clear H2; intro.\nelim H2; intros.\nelim (Hrec_cor2 q (a*v) H0); intros.\nelim H2; intros.\nelim H2; intros.\nelim (Hrec_cor2 q (a*v) H0); intros.\nelim H2; intros.\nelim H2; intros.\nelim H2; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelimQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "2;rewrite <- H4;auto with arith.\nQed.\n\n(** we show that if b<>0, then gcd(a,b)=gcd(b,a mod b) *)\nLemma gcd_euclide : forall (d a b:nat)(H:(b<>0)),(is_gcd d a b)<->(is_gcd d b (remainder_euclide a b H)).\n  intros.\n  generalize (quo_rem_euclide a b H);intro.\n  red;split;intro.\n  rewrite H0 in H1.\n  elim H1;intros.\n  unfold is_gcd;unfold is_cd.\n  elim H2;intros.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  replace (b*(quotient_euclide a b H)) with (d*q'*(quotient_euclide a b H)) in H6.\n  assert ((remainder_euclide a b H)=(d*q-d*q'*(quotient_euclide a b H))).\n  rewrite <- H6;rewrite minus_plus;trivial.\n  rewrite <- mult_assoc in H8;rewrite <- mult_minus_lemma2 in H8.\n  exists (q-q'*(quotient_euclide a b H));trivial.\n  rewrite <- H7;trivial.\n  intros.\n  elim H6;intros.\n  apply H3.\n  unfold is_cd;split;try tauto.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  rewrite H10.\n  replace (b*(quotient_euclide a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 13371,
                "proof_end_offset": 14277,
                "proof": "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\napply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\nunfold ltof;unfold f;intros.\ncase (lt_eq_lt_dec (fst x) (snd x));intro.\ncase s;intro.\ncase (eq_nat_dec (fst x) 0);intro.\nrewrite e;exists (snd x);apply gcd_zero.\nelim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\nintro d;intro.\nexists d.\napply gcd_sym.\nelim (gcd_euclide d (snd x) (fst x) n);auto.\ngeneralize (rem_euclide (snd x) (fst x) n);try omega.\nrewrite e;exists (snd x);apply gcd_refl.\ncase (eq_nat_dec (snd x) 0);intro.\nrewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\nelim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\nintro d;intro.\nexists d.\nelim (gcd_euclide d (fst x) (snd x) n);auto.\ngeneralize (rem_euclide (fst x) (snd x) n);try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_nonneg x 0) (gcd_nonneg x 0) H).\n  generalize (gcd_nonneg x 0) (gcd_nonneg x 0) H).\n  generalize (gcd_nonneg x 0) (gcd_nonneg x 0) H).\n  destruct (gcd_dec x 0) as [H|H].\n  simpl; split; try tauto.\n  elim H; intro q;intro.\n  replace (b*(gcd a b H)) with (b*(gcd a b H)).\n  rewrite <- H; rewrite <- H; rewrite <- H0; auto with arith.\n  rewrite <- H0; rewrite <- H0; auto with arith.\n  apply gcd_gcd_l with (d*(gcd a b H)).\n  apply gcd_gcd_r with (d*q).\n  apply gcd_gcd_l with (d*q).\n  apply gcd_gcd_l with (d*q).\n  apply gcd_gcd_greatest; auto with arith.\n  apply gcd_greatest; auto with arith.\n  apply gcd_greatest; auto with arith.\n  apply gcd_greatest; auto with arith.\n  apply gcd_greatest; auto with arith.\n  apply gcd_greatest; auto withQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_gcd_nonneg x).\n  generalize (gcd_nonneg x).\n  generalize (gcd_gcd_nonneg x).\n  generalize (gcd_nonneg x).\n  generalize (gcd_nonneg x).\n  destruct (gcd_nonneg x) as (q,r).\n  generalize (gcd_nonneg x).\n  generalize (gcd_nonneg x).\n  destruct (gcd_nonneg x) as (q,r).\n  destruct (gcd_nonneg x) as (q,r).\n  generalize (gcd_nonneg x).\n  destruct (gcd_nonneg x) as (q,r).\n  exists (q*q+r).\n  split.\n  split.\n  apply Zis_gcd_for_euclid with (1:=H).\n  red;split;intro; red; intros.\n  rewrite H1 in H1.\n  elim H1; intros.\n  split.\n  apply Zis_gcd_for_euclid with (1:=H).\n  red;split;intro; red; intros.\n  rewrite H2 in H2.\n  elim H2; intros.\n  rewrite H3 in H1.\n  elim H3; intros.\n  elim H3; intros.\n  rewrite H4 in H2Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_gcd_gcd x (fst x) (snd y));intro.\n  generalize (gcd_gcd x (fst x) (snd y));intro.\n  generalize (gcd_gcd x (snd y) H);intro.\n  generalize (gcd_gcd x (fst y) H0);intro.\n  generalize (gcd_gcd x (fst y) H1);intro.\n  generalize (gcd_gcd x (snd y) H1);intro.\n  generalize (gcd_gcd x (snd y) H0);intro.\n  generalize (gcd_gcd x (snd y) H0);intro.\n  generalize (gcd_gcd x (fst y) H1);intro.\n  generalize (gcd_gcd x (fst y) H0);intro.\n  generalize (gcd_gcd x (snd y) H1);intro.\n  generalize (gcd_gcd x (snd y) H0);intro.\n  generalize (gcd_gcd x (Zpos y) H1);intro.\n  generalize (gcd_gcd x (Zpos y) H1);intro.\n  generalize (gcd_gcd x (Zpos y) H0);intro.\n  generalize (gcd_gcd x (Zpos yQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | {d:nat | {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness x d H);intro.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness (fun x:nat => {d:nat | x = d}).\n  intros.\n  generalize (gcd_uniqueness x d H);intro.\n  generalize (Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros.\nexists (fun x:nat => match x with | 0 => 0 | S x => x end).\nsplit.\napply Zis_gcd_for_euclid with (a:=a) (b:=a) (c:=d).\napply Zis_gcd_for_euclid with (a:=a) (c:=c).\napply Zis_gcd_for_euclid with (a:=a) (c:=d).\napply Zis_gcd_for_euclid with (a:=a) (c:=c) (c:=c).\napply Zis_gcd_for_euclid with (a:=c) (c:=c) (c':=d).\napply Zis_gcd_for_euclid with (a:=c) (c:=d) (c':=d).\napply Zis_gcd_for_euclid with (a:=a) (c:=c) (c:=d).\napply Zis_gcd_for_euclid with (a:=a) (c:=c) (c':=d).\napply Zis_gcd_for_euclid with (a:=a) (c:=d) (c':=d).\napply Zis_gcd_for_euclid withQed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros; exists (fst x).\n  split.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  rewrite mult_comm; auto with arith.\n  Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  exists (fun (a:nat*nat) (H:a=a) => exist _ _ (H a H)).\n  split; try tauto.\n  intros.\n  destruct (gcd_uniqueness_aux x a H) as [H|H].\n  exists (a,(a,(b,H))).\n  rewrite H.\n  rewrite mult_1_l.\n  exists (a,(b,H)).\n  split; try tauto.\n  split; try tauto.\n  destruct (gcd_uniqueness_aux x a H) as [H|H].\n  exists (a,(b,H)).\n  split; try tauto.\n  split; try tauto.\n  elim H; intros.\n  elim H; intros.\n  split; try tauto.\n  elim H; intros.\n  split; try tauto.\n  elim H; intros.\n  split; try tauto.\n  elim H0; intros.\n  split; try tauto.\n  elim H; intros.\n  split; try tauto.\n  elim H0; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split; try tauto.\n  elim H1; intros.\n  split;Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_uniqueness_correct x (fst x) (snd x));intro.\n  generalize (gcd_uniqueness_correct x (snd x) (snd x));intro.\n  generalize (gcd_uniqueness_correct x (snd x) (snd x));intro.\n  generalize (gcd_uniqueness_correct x (snd x) (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (fst x) (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) H1);intro.\n  generalize (gcd_uniqueness_correct x (snd x) H1);intro.Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  intros.\n  generalize (gcd_gcd_nonneg x x H);intro.\n  generalize (gcd_gcd_nonneg x x H);intro.\n  generalize (gcd_gcd_nonneg x x H);intro.\n  generalize (gcd_gcd_nonneg x x H);intro.\n  generalize (gcd_nonneg x x H);intro.\n  generalize (gcd_gcd_nonneg x x H);intro.\n  generalize (gcd_nonneg x x H);intro.\n  generalize (gcd_gcd_nonneg x x H);intro.\n  generalize (gcd_nonneg x H);intro.\n  generalize (gcd_nonneg x x H);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_gcd_nonneg x x H0);intro.\n  generalize (gcd_nonneg x x H0);intro.\n  generalize (gcd_gcd_nonneg x x H0);intro.\n Qed.",
                    "Lemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\nProof.\nintros.\nexists (Z.of_nat (Z.of_nat (Z.of_nat (Z.of_nat (Z.of_nat (Z.of_nat (S n)))).\napply Z.lt_gt_dec.\napply is_gcd_for_euclid with (1:=Z.of_nat (Z.of_nat (Z.of_nat (Z.of_nat (S n)))).\napply is_gcd_for_euclid with (1:=Z.of_nat (Z.of_nat (S n))).\napply is_gcd_for_euclid with (1:=Z.of_nat (Z.of_nat (Z.of_nat (S n)))).\napply is_gcd_for_euclid with (1:=Z.of_nat (Z.of_nat (Z.of_nat (S n)))).\napply is_gcd_for_euclid with (1:=Z.of_nat (Z.of_nat (Z.of_nat (S n)))).\napply is_gcd_for_euclid with (1:=Z.of_nat (Z.of_nat (S n))).Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": " a b H)) with (d'*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H9;trivial.\n  unfold is_gcd;unfold is_cd.\n  unfold is_gcd in H1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\n",
                "context_tokens": 730,
                "proof_start_offset": 14326,
                "proof_end_offset": 14485,
                "proof": "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros.\nelim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\nexists d;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\nintros a b.\nexists (g,(Build_Z (a,b))).\nsplit; try tauto.\nintros; generalize (gcd_correct a b); clear H.\ncase (gcd_bezout a b H) as (g,(H1,H2)).\nexists g; simpl; auto.\nintros; generalize (gcd_correct b c); clear H.\ncase (gcd_bezout a b H) as (g,(H1,H2)).\nexists g; simpl; auto.\nrewrite <- H1; ring.\nexists g; simpl; auto.\nintros; generalize (gcd_correct b c); clear H.\ncase (gcd_bezout a b H) as (g,(H1,H2)).\nexists g; simpl; auto.\nintros; generalize (gcd_correct b c); clear H.\ncase (gcd_bezout a b H) as (g,(H1,H2)).\nexists g; simpl; auto.\nintros; generalize (gcd_correct b c); clear H.\ncase (gcd_bezout a b H) as (g,(H1,H2)).\nexists g; simpl; auto.\nintros;Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (gcd_exists_prod_bis (fun x:nat*nat => {d:nat | (is_gcd d x) (snd x)) 0).\n  intros.\n  case (gcd_linear_gcd a b H).\n  intros.\n  case (gcd_linear_gcd_aux a b H).\n  intros.\n  exists (b,(1,1)).\n  exists (b,(1,1)).\n  exists (1,(1,1)).\n  split.\n  apply gcd_sym.\n  split;try tauto.\n  split;try tauto.\n  apply gcd_for_euclid with (1:= H).\n  apply gcd_for_euclid with (1:= H).\n  intros.\n  case (gcd_linear_gcd_aux a b H).\n  intros.\n  exists (b,(1,1)).\n  split.\n  apply gcd_gcd_for_euclid with (1:= H).\n  apply gcd_gcd_for_euclid with (1:= H).\n  intros.\n  case (gcd_linear_gcd_aux a b H).\n  intros.\n  exists b.\n  split.\n  apply gcd_intro; auto.\n  apply gcd_for_Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  exists (a*b).\n  apply gcd_exists_prod_bis;auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (gcd_dec a b); intros.\n  case (gcd_dec a b); intros.\n  case (gcd_dec b b); intros.\n  case (gcd_dec b b); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec a b); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec a c); intros.\n  case (gcd_dec a c); intros.\n  rewrite e; exists (Zpos a); apply gcd_sym;apply gcd_refl.\n  elim (gcd_even_dec a b); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec b c); intros.\n  rewrite e; exists (Zpos a); apply gcd_sym; apply gcd_refl.\n  elim (gcd_odd_dec b c); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec b c); intros.\n  case (gcd_dec b cQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros a b.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  rewrite e; exists (Zpos x); rewrite <- H; simpl; ring.\n  rewrite <- H; ring.\n  rewrite <- H; ring.\n  exists (Zpos x); apply gcd_even_0.\n  elim (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  case (gcd_bezout a b); intros.\n  rewrite e; exists (Zpos x); rewrite <- H; simpl; ring.\n  rewrite <- H; ring.\n  exists (Zpos x); apply gcd_even_0.\n  elim (gcd_bezout a b); intros.\n  rewrite e; exists (Zpos x); apply gcd_even_0.\n  elim (gcd_bezout a bQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  exists (a, b).\n  apply gcd_unique with d; auto.\n  apply gcd_sym; apply gcd_gcd; auto.\nQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a b H).\n  intros.\n  case (gcd_bezout_aux a bQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  case (gcd_bezout a b H).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout b b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b H0).\n  case (gcd_bezout a b HQed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  case (gcd_bezout a b H).\n  exists (d*q).\n  rewrite <- mult_1_l.\n  replace (a/b) with (a/b).\n  rewrite <- mult_1_l.\n  replace (a/b) with (a/b).\n  rewrite <- mult_1_l.\n  replace (a/b) with (a/b).\n  rewrite <- mult_1_l.\n  replace (a/b) with (a/b).\n  rewrite <- mult_1_l.\n  rewrite <- mult_1_l.\n  ring.\n  rewrite <- H2.\n  ring.\n  change (a/b) with (a/b).\n  rewrite <- mult_1_l.\n  ring.\n  ring.\n  unfold gcd; exists (b/b).\n  rewrite <- mult_1_l.\n  ring.\n  exists (b/b).\n  rewrite <- mult_1_l.\n  ring.\n  exists (a/b).\n  rewrite <- mult_1_l.\n  ring.\n  exists (b/b).\n  rewrite <- mult_1_l.\n  ring.\n  exists (b/b).\n Qed.",
                    "Theorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\nProof.\n  intros.\n  case (gcd_dec a b); intros.\n  exists (fst (fst (fst (snd (snd (snd a))) (snd (snd (snd b))); simpl.\n  intro d; intro.\n  exists (fst (fst (fst (fst a))) (snd (fst (snd a))); simpl.\n  intro.\n  replace (snd (fst (snd a))) with (snd (snd (snd a))); auto.\n  rewrite H0.\n  replace (snd (snd (snd (snd a))) (snd (snd (snd (snd a)))); auto.\n  rewrite H0.\n  simpl.\n  destruct (gcd_dec a b) as [H|H].\n  case (gcd_dec a b); intros.\n  exists (fst (fst (snd (snd a))) (snd (snd (snd (snd a)))).\n  rewrite H0.\n  auto.\n  simpl.\n  destruct (gcd_dec a b) as [H'|H'].\n  case (gcd_dec a b) as [H'|H'].\n  case (gcd_dec a b) as [H'|H'].\n  rewrite e; exists (Zpos a); auto.\n  rewrite H0.\n  exists (ZposQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "1;unfold is_cd in H1.\n  elim H1;intros.\n  elim H2;intros.\n  rewrite H0.\n  split.\n  split;try tauto.\n  elim H4;intro q;intro.\n  elim H5;intro q';intro.\n  rewrite H7.\n  replace (b*(quotient_euclide a b H)) with (d*q*(quotient_euclide a b H)).\n  rewrite <- mult_assoc;rewrite <- mult_plus_distr_l.\n  exists (q*(quotient_euclide a b H)+q');trivial.\n  rewrite <- H6;trivial.\n  intros.\n  apply H3.\n  split;try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\n",
                "context_tokens": 729,
                "proof_start_offset": 14549,
                "proof_end_offset": 14831,
                "proof": "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\nintros.\nunfold rel_prime.\ngeneralize (gcd_is_gcd a b);intro.\ncase (eq_nat_dec (gcd a b) 1);intro.\nleft;rewrite e in H;trivial.\nright;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\nintros a b.\ndestruct (rel_prime_dec a b) as [H|H].\nexists (exist (fun x:nat => {d:nat | (a - x) / a < b}).\n  intro; unfold rel_prime; simpl.\n  case (gcd_dec a b) as [H'|H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H]; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H']; [|destruct H]; [|destruct H]; [|destruct H']; [|destruct H]; [|destruct H'; [|destruct H]; [|destruct H]; [|destruct H]; [|destruct H]; [|Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\n  intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec a b); intros.\n  elim H; intros.\n  rewrite e; rewrite e; auto with zarith.\n  elim H; intros.\n  rewrite e; rewrite e; auto with zarith.\n  elim H; intros.\n  rewrite e; rewrite e; auto with zarith.\n  elim H; intros.\n  rewrite e; rewrite e; auto with zarith.\n  elim H; intros.\n  rewrite e; rewrite e; auto with zarith.\n  elim H; intros.\n  rewrite e; rewrite e; auto with zarith.\n  elim H; intros.\n  rewrite e; auto with zarith.\n  elim H;Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_primeQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\n  intros.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a b); intro.\n  case (Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\n  intros a b.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n  case (rel_prime_dec b a); intro.\n Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  elim (rel_prime_dec a b);intros.\n  left;exists a;intros.\n  right;exists a;intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  left; exists b;intros.\n  right;exists (S a);auto.\n  right; exists a;intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  left; exists (S a);auto.\n  right; exists a;intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  left; exists (S a);auto.\n  left; exists a;intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  left; exists a;intros.\n  right; exists a;intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  left; exists a;intros.\n  left;exists (S a);auto.\n  left; exists a;intros.\n  destruct (rel_prime_dec a b) as [H|H].\n  left; exists a;intros.\n  destruct (rel_prime_dec a bQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\n  intros a b.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec a b); intros.\n  rewrite e;rewrite e0; auto.\n  apply rel_prime_dec with b; auto.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec a b); intros.\n  rewrite e; rewrite e0; auto.\n  apply rel_prime_dec with b; auto.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec a b); intros.\n  case (rel_prime_dec aQed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\nintros.\ndestruct (rel_prime_dec a b) as [[H|H]|H].\napply rel_prime_dec; auto.\ndestruct (rel_prime_dec a b) as [[H|H]|H].\n(* a <-> b is a *)\ndestruct (rel_prime_dec a b) as [[H|H]|H].\napply rel_prime_dec; auto.\ndestruct (rel_prime_dec a b) as [[H|H]|H].\n(* a -> b *)\ndestruct (rel_prime_dec a b) as [[H|H]|H].\napply rel_prime_dec; auto.\ndestruct (rel_prime_dec a b) as [[H|H]|H].\n(* a -> b *)\ndestruct (rel_prime_dec a b) as [[H|H]|H].\napply rel_prime_dec; auto.\ndestruct (rel_prime_dec a b) as [[H|H]|H].\n(* a -> b *)\ndestruct (rel_prime_dec a b) as [[H|H]|H].\n(* a -> b *)\ndestruct (rel_prime_Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\nProof.\n  intros.\n  case (rel_prime_dec a b);intros.\n  case (rel_prime_dec b a);intros.\n  case (rel_prime_dec b a);intros.\n  case (rel_prime_dec b a);intros; try discriminate.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_prime_dec b a); intros.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_prime_dec b a); intros; try discriminate.\n  case (rel_Qed.",
                    "Lemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros a b.\n  case (rel_prime_dec a b); intros; simpl;intros;\n  case (rel_prime_dec a b); intros; simpl; intros;\n  case (rel_prime_dec b a); intros; simpl; intros;\n  case (rel_prime_dec a b); intros; simpl; \n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl; intros;\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminate.\n  case (rel_prime_dec a b); intros; simpl;\n  try discriminate;\n  try discriminateQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "try tauto.\n  elim H6;intros.\n  elim H7;intro q;intro.\n  elim H8;intro q';intro.\n  assert ((remainder_euclide a b H)=b*(quotient_euclide a b H)+(remainder_euclide a b H)-b*(quotient_euclide a b H)).\n  rewrite minus_plus;trivial.\n  rewrite H9 in H11.\n  exists (q-q'*(quotient_euclide a b H)).\n  rewrite mult_minus_lemma2;rewrite mult_assoc.\n  rewrite <- H10;trivial.\nQed.\n\n(** we give a \"more efficient\" algorithm to compute gcd(a,b) *)\nLemma gcd_exists_prod_bis : forall (x:nat*nat),{d:nat | (is_gcd d (fst x) (snd x))}.\n  apply (induction_ltof2 (nat*nat) f (fun x:nat*nat => {d:nat | (is_gcd d (fst x) (snd x))})).\n  unfold ltof;unfold f;intros.\n  case (lt_eq_lt_dec (fst x) (snd x));intro.\n  case s;intro.\n  case (eq_nat_dec (fst x) 0);intro.\n  rewrite e;exists (snd x);apply gcd_zero.\n  elim (H ((fst x),(remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\n",
                "context_tokens": 721,
                "proof_start_offset": 14887,
                "proof_end_offset": 15621,
                "proof": "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\nintros.\nsplit.\nsplit;try (apply one_min_div).\nintros.\nelim H1;intros.\ncase (rel_prime_dec b d');intro.\nassert (divides c d').\napply gauss with b;trivial.\nelim H0;intros.\napply H6;unfold is_cd;tauto.\ngeneralize (gcd_is_gcd b d');intro.\nassert ((gcd b d')<>1).\nintro;apply n.\nunfold rel_prime;rewrite <- H5;trivial.\ngeneralize (gcd_div_l (gcd b d') b d' H4);intro.\ngeneralize (gcd_div_r (gcd b d') b d' H4);intro.\nassert (divides a (gcd b d')).\napply divides_trans with d';[apply H2 | apply H7].\nelim H5.\napply divides_antisym.\napply one_min_div.\nelim H;intros;apply H10;unfold is_cd;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  elim (rel_prime_dec a (gcd a b) c); intros.\n  left;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;ring.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  left;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  left;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  left;apply n;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  right;intro;apply n;apply (gcd_intro a b);trivial.\n  right;intro;Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  unfold rel_prime.\n  generalize (rel_prime_dec a c);intro.\n  case (rel_prime_dec a c);intros.\n  left;apply rel_prime_dec; auto.\n  right; intro;apply n;apply (gcd_sym (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_sym (gcd a b) 1 a b);trivial.\n  right; intro; apply n; apply (gcd_sym (gcd a b) 1 a b);trivial.\n  right; intro; apply n; apply (gcd_sym (gcd a b) 1 a b); tauto.\n  right; intro; apply n; apply (gcd_sym (gcd a b) 1 a b); tauto.\n  right; intro; apply n; apply (gcd_sym (gcd a b) 1 a b); tauto.\n  left; intro; apply n; apply (gcd_sym (gcd a b) 1 a b); tauto.\n  right; intro; apply n; apply (gcd_sym (gcd a b) 1 a b); tauto.\n  right; intro; apply n; apply (gcd_sym (gcd a bQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  apply rel_prime_mult; auto.\n  generalize (rel_prime_mult a b c);intro.\n  case (rel_prime_dec (gcd a b) 1); intro.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  rewrite e in H;rewrite e in H; tauto.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  rewrite e in H; rewrite e in H; tauto.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  rewrite e in H; rewrite e in H; tauto.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  rewrite e in H; rewrite e in H; tauto.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  rewrite e in H; rewrite e in H; tauto.\n  elim (rel_prime_dec (gcd a b) 1 a); intro.\n  rewrite e in H; rewrite e in H; tauto.\n  elim (rel_Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_mult a b);intro.\n  generalize (rel_prime_mult b c);intro.\n  case (rel_prime_dec (gcd a b) 1); intro.\n  left;rewrite e;rewrite e;trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_intro (gcd a b) 1 a b);trivial.\n  right;intro;apply nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  case (rel_prime_dec a b); intro.\n  case (rel_prime_dec a (gcd b c) 1); intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_trans a b c);trivial.\n  right;intro;apply n;apply (gcd_divide_r a b c);trivial.\n  right;intro;apply n;apply (gcd_divide_r b c);trivial.\n  right;intro;apply n;apply (gcd_divide_r a b c);trivial.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  apply rel_prime_mult.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  applyQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  generalize (rel_prime_dec a b);intro.\n  case (rel_prime_dec a (gcd b c) 1); intro.\n  left;apply (gcd_for_euclid (a,b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  left;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (a,c) 1 a b);Qed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\nintros a b c.\nelim (rel_prime_dec a b); intro.\nelim (rel_prime_dec a (gcd a b)); intro.\nelim (rel_prime_dec (gcd a b) 1 a); intros.\nrewrite e in H;trivial.\nright;intro;apply n;apply (gcd_for_euclid a 1 b); trivial.\nrewrite e;exists (b*c).\nrewrite <- e;rewrite <- e; ring.\nrewrite <- e; ring.\nQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  apply rel_prime_dec.\n  applyQed.",
                    "Lemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\nProof.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_divisors a b) (gcd_divisors a c) (gcd_divisors a c) (gcd_divisors a c) (gcd_divisors a c) (gcd_divisors a c H).\n  intros.\n  rewrite H;rewrite <- H;rewrite (gcd_comm a c);rewrite <- H0;auto.\n  left;intro;apply n;apply (gcd_intro a c);trivial.\n  right;intro;apply n;apply (gcd_intro a c);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "remainder_euclide (snd x) (fst x) n)));simpl.\n  intro d;intro.\n  exists d.\n  apply gcd_sym.\n  elim (gcd_euclide d (snd x) (fst x) n);auto.\n  generalize (rem_euclide (snd x) (fst x) n);try omega.\n  rewrite e;exists (snd x);apply gcd_refl.\n  case (eq_nat_dec (snd x) 0);intro.\n  rewrite e;exists (fst x);apply gcd_sym;apply gcd_zero.\n  elim (H ((snd x),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\n",
                "context_tokens": 718,
                "proof_start_offset": 15677,
                "proof_end_offset": 15983,
                "proof": "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\nintros.\nsplit;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\nProof.\n  intros.\n  elim (gcd_dec a c); intro.\n  elim (gcd_dec a c); intro.\n  elim (gcd_nonneg a c); intro.\n  assert (gcd a c = a) by (apply gcd_unique; apply gcd_sym; assumption).\n  elim H0; intros.\n  apply H6; unfold is_gcd;tauto.\n  generalize (gcd_gcd a c); intro.\n  assert (gcd a c = a) by (apply gcd_unique; apply gcd_sym; assumption).\n  destruct (gcd_gcd a c) as [H|H];\n  [ rewrite H; rewrite H; rewrite H0; reflexivity | rewrite H0; ring ].\n  elim H0; intros.\n  rewrite H; rewrite H0; rewrite H; rewrite H; rewrite H0; reflexivity.\n  elim H0; intros.\n  rewrite H; rewrite H0; rewrite H0; rewrite H0; rewrite H0; reflexivity.\n  elim H0; intros.\n  rewrite H; rewrite H; rewrite H0; rewrite H0; reflexivity.\n  elim H0; intros.\n  rewrite H; rewrite H0; rewrite H0; rewrite H; rewrite H; reflexivityQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split.\n  apply rel_prime_dec.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  apply H5; unfold is_gcd in |- *; tauto.\n  elim H0; intros.\n  elim H4; intros.\n  elim H4; intros.\n  apply H5; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H5; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n  apply H6; unfold is_gcd in |- *; tauto.\n  elim H4; intros.\n Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  apply rel_prime_dec; auto.\n  split; try (apply one_max_div).\n  intros.\n  elim H2; intros.\n  apply H6; unfold is_nan; tauto.\n  elim H0; intros.\n  apply H6; unfold is_nan; tauto.\n  elim H0; intros.\n  apply H6; unfold is_nan; tauto.\n  elim H0; intros.\n  apply H6; unfold is_nan; tauto.\n  elim H0; intros; apply H6; unfold is_nan; tauto.\n  elim H0; intros; apply H6; unfold is_nan; tauto.\n  elim H0; intros; apply H6; unfold is_nan; tauto.\n  elim H0; intros.\n  apply H7; unfold is_nan; tauto.\n  elim H0; intros; apply H7; unfold is_nan; tauto.\n  elim H0; intros; apply H7; unfold is_nan; tauto.\n  elim H0; intros; apply H7; unfold is_nan; tauto.\n  elim H0; intros; apply H7; unfold is_nan; tauto.\n  elim H0; intros;Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  apply rel_prime_sym; apply rel_prime_mult; apply rel_prime_mult; assumption.\n  elim H; intros.\n  apply H1; unfold is_dist;tauto.\n  elim H1; intros.\n  apply H1; unfold is_dist;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd;tauto.\n  elim H1; intros; apply H2; unfold is_gcd; tauto.\n  elim H1; intros; apply H2; unfold is_gcd; tauto.\n  elim H1; intros; apply H2; unfold is_gcd; tauto.\n  elim H1; intros; apply H2; unfoldQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_gcd_bezout a b c); intros.\n  apply rel_prime_dec.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim H1; intros.\n  apply H7; unfold is_gcd;tauto.\n  elim HQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  elim H; intros.\n  assert (gcd a (gcd b c) = (gcd a c) \\/ (gcd b c) = (gcd a c) /\\ (gcd a c) = (gcd a c).\n  split.\n  apply (gcd_for_euclid a b c);auto.\n  split.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  apply (gcd_for_euclid a b c);auto.\n  applyQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_dec a c); intro.\n  rewrite e in H.\n  elim (gcd_gcd_gcd_greatest a b c); intro.\n  assert (gcd a (gcd b c) > 0).\n  apply Zdivide_gcd_gcd_greatest.\n  apply Zis_gcd_sym.\n  apply Zis_gcd_for_euclid with a; auto with zarith.\n  elim H0; intros.\n  elim (gcd_gcd_greatest a b c); intro.\n  assert (gcd a (gcd b c) > 0).\n  apply Zis_gcd_gcd_greatest.\n  apply Zis_gcd_greatest.\n  apply Zis_gcd_greatest; auto with zarith.\n  elim H0; intros.\n  elim H1; intros.\n  rewrite H2 in H; rewrite H2 in H; discriminate.\n  elim H0; intros.\n  rewrite H2 in H; rewrite H2 in H; discriminate.\n  elim H0; intros.\n  rewrite H2 in H; rewrite H2 in H; discriminate.\n  elim H0; intros.\n  rewrite H2 in H; rewrite H2 in H; discriminate.\n  elim H0; intros.\n  rewrite H2 in H;Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  elim (gcd_dec a c); intro.\n  assert (gcd a c) by apply gcd_nonneg_nonneg.\n  apply rel_prime_intro with a; auto.\n  elim H1; intros.\n  assert (gcd a (gcd b c) \\/ (gcd a b c) = gcd (gcd a b) c).\n  apply gcd_gcd_greatest; tauto.\n  elim H1; intros.\n  apply H6; unfold is_nan;tauto.\n  generalize (gcd_gcd_r (gcd a b) c); intro.\n  apply gcd_gcd_greatest; tauto.\n  elim H1; intros.\n  rewrite H6; rewrite H6; rewrite H6; rewrite H7; ring.\n  elim H1; intros.\n  rewrite H6; rewrite H7; rewrite H7; rewrite H7; ring.\n  elim H1; intros.\n  rewrite H7; rewrite H7; rewrite H7; rewrite H7; ring.\n  elim H1; intros.\n  rewrite H7; rewrite H7; rewrite H7; ring.\n  elim H1; intros.\n  rewrite H7; rewrite H8; rewrite H8; ring.\n  elim H1Qed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  unfold rel_prime in H.\n  generalize (gcd_nonneg_nonneg a b);intro.\n  case (gcd_gcd a c); intro.\n  assert (gcd a (gcd b c) \\/ (gcd b c) \\/ (gcd a c) \\/ (gcd b c) \\/ (gcd a c) \\/ (gcd a c) \\/ (gcd a c) \\/ (gcd a c) \\/ (gcd a c).\n  apply rel_prime_mult; try assumption.\n  generalize (gcd_gcd_gcd a c);intro.\n  elim H0; intros.\n  left; rewrite e in H; tauto.\n  elim H0; intros.\n  left; rewrite e in H; tauto.\n  elim H0; intros.\n  right; rewrite e in H; tauto.\n  elim H0; intros.\n  left; rewrite e in H; tauto.\n  elim H0; intros.\n  right; rewrite e in H; tauto.\n  elim H0; intros.\n  right; rewrite e in H; tauto.\n  elim H0; intros.\n  right; rewrite e in H; tauto.\n  elim H0; intros.\n  left; rewrite e in H; tauto.\n  elim HQed.",
                    "Lemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split.\n  unfold rel_prime;simpl.\n  rewrite <- rel_prime_mult.\n  apply rel_prime_dec.\n  generalize (gcd_nonneg a b);intro.\n  case (gcd_dec a b) as [H|H].\n  left;rewrite e in H;trivial.\n  right; intro; apply n;apply (gcd_greatest a b c H).\n  apply rel_prime_dec; auto.\n  elim H; intros; auto.\n  right; intro; apply n; apply (gcd_greatest a b c H).\n  apply rel_prime_dec; auto.\n  elim H; intros; auto.\n  right; intro; apply n; apply (gcd_greatest a b c H).\n  apply rel_prime_dec; auto.\n  elim H; intros; auto.\n  right; intro; apply n; apply (gcd_greatest a b c H).\n  apply rel_prime_dec; auto.\n  elim H; intros; auto.\n  right; intro; apply n; apply (gcd_greatest a b c H).\n  apply rel_prime_dec; auto.\n  elim H; intros; auto.\n  right; intro; apply n; applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "),(remainder_euclide (fst x) (snd x) n)));simpl.\n  intro d;intro.\n  exists d.\n  elim (gcd_euclide d (fst x) (snd x) n);auto.\n  generalize (rem_euclide (fst x) (snd x) n);try omega.\nQed.\n\n(** efficient algorithm to compute gcd(a,b) *)\nTheorem gcd_exists_bis : forall (a b:nat),{d:nat | (is_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\n",
                "context_tokens": 727,
                "proof_start_offset": 16024,
                "proof_end_offset": 16251,
                "proof": "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\ninduction n;simpl;intros.\nunfold rel_prime;apply gcd_sym;apply gcd_one.\ngeneralize (IHn H);intro.\napply rel_prime_mult;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply rel_prime_dec.\n  intros.\n  elim H1; intros.\n  elim H2; intros.\n  apply rel_prime_mult; auto.\n  apply rel_prime_pos.\n  apply rel_prime_dec.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\nintros.\nsplit;try (apply (rel_prime_mult_divisors_correct (rel_prime a (rel_prime a (rel_prime a (rel_prime a (b*c)))).\nintros.\ndestruct (rel_prime_dec a (rel_prime a (rel_prime a (rel_prime a (rel_prime a (rel_prime a (rel_prime a)))).\nintros.\nelim H1; intros.\nelim H2; intros.\nelim H4; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelimQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\nintros d a n H.\nelim (rel_prime_dec (rel_prime a (rel_prime a (rel_prime a n))));\n [ intros | intros; apply (rel_prime_mult_r (rel_prime a (rel_prime a (rel_prime a (rel_prime a (rel_prime a (a*n)))))].\nintros d' H.\nelim H.\napply rel_prime_mult_strong.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply rel_prime_mult.\napply relQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\nintros.\nelim (gcd_cross_correct d a); intros.\nelim (gcd_bezout_correct d a); intros.\nelim H1; intros.\napply H6; unfold is_cd;tauto.\nelim H1; intros; apply H6;unfold is_cd;tauto.\nelim H1; intros; apply H6;unfold is_cd;tauto.\nelim H1; intros; apply H6;unfold is_d;tauto.\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\nintros.\napply rel_prime_mult;\n [ intros| intros; apply rel_prime_dec].\nintros; apply rel_prime_dec; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nintros; apply rel_prime_mod; auto.\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\n  intros.\n  replace (rel_prime a (rel_prime a (rel_prime a (rel_prime a b)))).\n  apply rel_prime_gcd.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  apply rel_prime_factor.\n  applyQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\nintros.\nsplit;try (apply rel_prime_mult_rel_prime; split;intros;apply H;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial);\ntry (apply rel_prime_mult_rel_prime;simpl;trivial).\nQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\nProof.\nintros.\nsplit.\nsplit;try apply rel_prime_mult_strong; apply rel_prime_mult_strong; apply rel_prime_mult_strong;\napply rel_prime_mult_strong; apply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_mult_strong;\napply rel_prime_multQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split;try (apply all_prime_mult_rel;assumption).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec a (gcd a b) && (gcd a b));intro.\n  left;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;ring.\n  right;intro; apply n;apply (gcd_for_euclid (gcd a b) 1 a b);trivial.\n  left;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;ring.\n  right;intro;apply n;apply (gcd_for_euclid (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (gcd a b) 1 a b);trivial.\n  left;rewrite e;rewrite e;rewrite e;rewrite e;rewrite e;ring.\n  right;intro; apply n;apply (gcd_for_euclid (gcd a b) 1 a b);trivial.\n  right;intro;apply n;apply (gcd_for_euclid (gcd a b) 1 a b);trivial.\n  right;intro;apply n;applyQed.",
                    "Lemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  intros.\n  split.\n  apply rel_prime_mult.\n  apply rel_prime_dec; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus;apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus;apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus;apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus; apply rel_prime_dec; auto.\n  rewrite <- rel_prime_minus;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_gcd d a b)}.\n  intros.\n  elim (gcd_exists_prod_bis (a,b));intro d;simpl;intros.\n  exists d;trivial.\nQed.\n\n(** it is decidable to say if a and b are relatively prime *)\nLemma rel_prime_dec : forall (a b:nat),{rel_prime a b}+{~(rel_prime a b)}.\n  intros.\n  unfold rel_prime.\n  generalize (gcd_is_gcd a b);intro.\n  case (eq_nat_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\n",
                "context_tokens": 723,
                "proof_start_offset": 16300,
                "proof_end_offset": 16486,
                "proof": "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\ndestruct n;simpl;intros.\ninversion H.\nelim (mult_rel_prime a d (power d n));auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  destruct n; simpl;intros.\n  unfold rel_prime.\n  generalize (gcd_div_r (gcd d a) n n);intro.\n  destruct (gcd_gcd_gcd_l (gcd d a) n n) as [H1|H1];\n  rewrite H1;rewrite H2;rewrite H1;rewrite H2;ring.\n  generalize (gcd_greatest a (gcd d a) n n);intro.\n  destruct (gcd_gcd_greatest a b n) as [H2|H2];\n  rewrite H1;rewrite H2;rewrite H2;ring.\n  generalize (gcd_greatest a (gcd d a) n n);intro.\n  destruct (gcd_greatest a b n) as [H3|H3];\n  rewrite H3;rewrite H4;rewrite H4;ring.\n  generalize (gcd_greatest a (gcd d a) n n);intro.\n  destruct (gcd_greatest a (gcd d a) n) as [H4|H4];\n  rewrite H4; rewrite H4;rewrite H4;rewrite H4;ring.\n  generalize (gcd_greatest a (gcd d a) n n);introQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  intros.\n  split;try (apply (rel_prime_mult_l (rel_prime a (rel_prime a d) (rel_prime a d))).\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  left;apply rel_prime_mult;apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_primeQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros.\n  unfold rel_prime in H;unfold rel_prime in H.\n  destruct H;destruct H;destruct H;destruct H;destruct H;destruct H0;destruct H0;destruct H0;destruct H;destruct H0;destruct H0;\ndestruct H;destruct H;destruct H;destruct H;destruct H;destruct H;destruct H0;destruct H1;destruct H0;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1;\ndestruct H1;destruct H1;destruct H1;destruct H1;destruct H2;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1;destruct H1; destruct H1; destruct H1;\ndestruct H1;destruct H1;destruct H1; destruct H1; destruct H1;destruct H1; destruct H1;destruct H1;\ndestruct H1; destruct H1; destruct H1; destruct H1; destruct H1;destruct H1; destruct H1;\ndestruct H1; destruct H1; destruct H1Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros.\n  split;try (apply prime_div);auto.\n  apply (rel_prime_mult (rel_prime a (rel_prime a (rel_prime a (rel_prime a (n*n)))).\n  apply rel_prime_dec.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_prime_dec; auto.\n  apply rel_primeQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\n  intros.\n  elim (gcd_greatest a b n); intros.\n  assert(H1:=H).\n  apply rel_prime_mult;try assumption.\n  elim H1; intros; apply H2;unfold is_divide;apply rel_prime_mult;\n  try assumption.\n  generalize (gcd_divide_r a (gcd a b) H1); intro.\n  generalize (gcd_greatest a b n H2);intro.\n  rewrite (gcd_gcd a b n H2); intro.\n  generalize (gcd_greatest a b n H2);intro.\n  rewrite (gcd_gcd a b n H2);intro.\n  generalize (gcd_greatest a b n H1);intro.\n  rewrite (gcd_gcd a b n H1);intro.\n  rewrite (gcd_greatest a b n H2); intro.\n  rewrite (gcd_gcd a b n H2); intro.\n  rewrite (gcd_gcd a b n H2); intro.\n  rewrite (gcd_gcd a b n H2); intro.\n  rewrite (gcd_greatest a b n H3); intro.\n  rewrite (gcd_gcd a b n H3); intro.\n  rewrite (gcd_Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\ninduction n.\nsimpl;intros;apply prime_mult_div;apply prime_sym;apply prime_sym;apply prime_sym;apply prime_sym;apply prime_sym;apply prime_sym;assumption.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\nintros.\nsplit;intro;clear n.\nunfold rel_prime;apply rel_prime_dec.\nintro n.\napply rel_prime_dec; auto.\nrewrite <- H0; apply rel_prime_dec; auto.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\ninduction n.\nsimpl;intros.\nrewrite H;rewrite H0;apply rel_prime_mult;trivial.\nQed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  induction n;simpl;intros;\n    apply (rel_prime_mult (rel_prime a (rel_prime a (rel_prime a (Z_of_nat n)))).\n  intros.\n  elim H1; intros.\n  apply (rel_prime_mult (rel_prime a (rel_prime a (Z_of_nat n)))).\n  apply rel_prime_mult.\n  split; try assumption; apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;auto.\n  apply rel_prime_mult;Qed.",
                    "Lemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\nProof.\n  intros.\n  apply rel_prime_mult.\n  generalize (rel_prime_divisors (a, b) (rel_prime a (rel_prime a (prime n)))).\n  apply rel_prime_divisors.\n  generalize (rel_prime_divisors a d) (rel_prime_divisors a d) H;intro.\n  generalize (rel_prime_divisors a d) H0;intro.\n  generalize (rel_prime_divisors a d) H1;intro.\n  generalize (rel_prime_divisors a d) H1;intro.\n  generalize (rel_prime_divisors a d) H2;intro.\n  generalize (rel_prime_divisors a d) H1;intro.\n  generalize (rel_prime_divisors a d) H1;intro.\n  generalize (rel_prime_divisors a d) H2;intro.\n  generalize (rel_prime_divisors a d) H2;intro.\n  generalize (rel_prime_divisors a d) H1;intro.\n  generalize (rel_prime_divisors a d) H0;intro.\n  generalize (rel_prime_divisors a d) H1;intro.\n  generalize (rel_prime_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/gcd.v",
                "context": "_dec (gcd a b) 1);intro.\n  left;rewrite e in H;trivial.\n  right;intro;apply n;apply (gcd_unique (gcd a b) 1 a b);trivial.\nQed.\n\n(** if gcd(a,b)=1 and gcd(a,c)=1 then gcd(a,b*c)=1 *)\nLemma rel_prime_mult : forall (a b c:nat),(rel_prime a b)->(rel_prime a c)->(rel_prime a (b*c)).\n  intros.\n  split.\n  split;try (apply one_min_div).\n  intros.\n  elim H1;intros.\n  case (rel_prime_dec b d');intro.\n  assert (divides c d').\n  apply gauss with b;trivial.\n  elim H0;intros.\n  apply H6;unfold is_cd;tauto.\n  generalize (gcd_is_gcd b d');intro.\n  assert ((gcd b d')<>1).\n  intro;apply n.\n  unfold rel_prime;rewrite <- H5;trivial.\n  generalize (gcd_div_l (gcd b d') b d' H4);intro.\n  generalize (gcd_div_r (gcd b d') b d' H4);intro.\n  assert (divides a (gcd b d')).\n  apply divides_trans with d';[apply H2 | apply H7].\n  elim H5.\n  apply divides_antisym.\n  apply one_min_div.\n  elim H;intros;apply H10;unfold is_cd;tauto.\nQed.\n\n(** if gcd(a,b*c)=1 then gcd(a,b)=1 and gcd(a,c)=1 *)\nLemma mult_rel_prime : forall (a b c:nat),(rel_prime a (b*c))->((rel_prime a b)/\\(rel_prime a c)).\n  intros.\n  split;split;[split | intros | split | intros];try (apply one_min_div);elim H0;intros;elim H;intros;apply H4;split;trivial;elim H2;intro q;intro;rewrite H5;[exists (q*c) | exists (q*b)];ring.\nQed.\n\n(** if gcd(a,d)=1 then gcd(a,d^n)=1 *)\nLemma rel_prime_power : forall (d a n:nat),(rel_prime a d)->(rel_prime a (power d n)).\n  induction n;simpl;intros.\n  unfold rel_prime;apply gcd_sym;apply gcd_one.\n  generalize (IHn H);intro.\n  apply rel_prime_mult;trivial.\nQed.\n\n(** if n>0 and gcd(a,d^n)=1 then gcd(a,d)=1 *)\nLemma power_rel_prime : forall (d a n:nat),(n>0)->(rel_prime a (power d n))->(rel_prime a d).\n  destruct n;simpl;intros.\n  inversion H.\n  elim (mult_rel_prime a d (power d n));auto.\nQed.\n\n(** if n>0 and m>0 then gcd(a^n,b^m)=1 iff gcd(a,b)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 16545,
                "proof_end_offset": 16906,
                "proof": "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\nsplit;intro.\napply power_rel_prime with m;trivial;apply rel_prime_sym;apply power_rel_prime with n;trivial;apply rel_prime_sym;trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power;apply rel_prime_sym;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).\n  replace (rel_prime a (div b m)) with (rel_prime a (div b m)).Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  split;try (apply prime_div;apply prime_div;auto with zarith).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_l with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_l with (1:=H).\n  apply rel_prime_factor_r with (1:=H).\n  apply rel_prime_factor_rQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  rewrite <- H0.\n  generalize (gcd_div_l (gcd a b) (gcd b m));intro.\n  rewrite <- H;intros.\n  rewrite <- H0;auto.\n  generalize (gcd_div_l (gcd a b) (gcd b m));intro.\n  rewrite H0.\n  rewrite <- H0;auto.\n  generalize (gcd_div_l (gcd a b) (gcd b m));intro.\n  rewrite <- H0;intros.\n  rewrite <- H1;rewrite <- H2;auto.\n  generalize (gcd_gcd_greatest a b (gcd b m) (gcd b m));intro.\n  rewrite <- H1;intros.\n  rewrite <- H2;intros.\n  rewrite <- H1;rewrite <- H2;auto.\n  generalize (gcd_greatest a b (gcd b m) (gcd b m));intro.\n  rewrite <- H1;intros.\n  rewrite <- H2;intros.\n  rewrite <- H1;intros.\n  rewrite <- H2;rewrite <- H2;rewrite <- H3;auto.\n  generalize (gcd_greatest a b (gcd a b) (gcd b m));intro.\n  rewrite <- H1Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  split;try (apply prime_div_mod).\n  intros.\n  elim H;intros.\n  case (rel_prime_dec a (rel_prime b n));intros.\n  assert (H:n<=m) by omega.\n  destruct H0.\n  subst m.\n  assert (H1:=H1 n).\n  apply rel_prime_mult;trivial.\n  elim H1; intros.\n  assert (H3:=H2 n).\n  apply rel_prime_mult;trivial.\n  elim H3; intros.\n  assert (H4:=H4 n).\n  apply rel_prime_sym;apply gcd_sym;apply gcd_opp;trivial.\n  elim H4; intros.\n  assert (H5:=H2 n).\n  apply rel_prime_sym;apply gcd_abs;trivial.\n  elim H5; intros.\n  assert (H6:=H4 n).\n  apply rel_prime_sym; apply gcd_opp;trivial.\n  elim H5; intros.\n  assert (H6:=H2 n).\n  apply rel_prime_trans with n; [|apply rel_prime_sym].\n  apply rel_prime_sym; apply gcdQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  split;try (apply (rel_prime_mult_rel_prime a (rel_prime a (rel_prime a (power b m))));\n  repeat split;try (apply not_rel_prime_mult_rel; assumption).\n  generalize (rel_prime_mod (rel_prime a (rel_prime a (rel_prime a b))));\n  intro.\n  apply rel_prime_minus.\n  generalize (rel_prime_mod a (rel_prime a (rel_prime a b))).\n  generalize (rel_prime_mod (rel_prime a (rel_prime a (rel_prime a b))).\n  intros.\n  apply rel_prime_dec; auto.\n  generalize (rel_prime_mod (rel_prime a (rel_prime a (rel_prime a b))).\n  generalize (rel_prime_mod (rel_prime a (rel_prime a (rel_prime a b))).\n  intros.\n  apply rel_prime_mult.\n  generalize (rel_prime_mod (rel_prime a (rel_prime a (rel_prime a (rel_prime a b))).\n  intros.\n  apply rel_prime_mod; auto.\n  generalize (Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\nProof.\nintros.\nunfold rel_prime in |- *.\ndestruct (rel_prime_dec a (power b n)) as [H|H];\n [ left;rewrite e in H; discriminate | left; apply (gcd_greatest a b m H)].\nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  split;try (apply (rel_prime_rel_prime (rel_prime a b) (rel_prime a b) (rel_prime a b) (rel_prime a b) (rel_prime b m)).\n  intros.\n  elim H1; intros.\n  apply H5;unfold rel_prime;apply rel_prime;apply rel_prime;apply rel_prime; apply rel_prime; auto.\n  generalize (rel_prime_rel_prime a (rel_prime a b) (rel_prime a b) (rel_prime b m)); intro.\n  apply rel_prime_mult; auto.\n  generalize (rel_prime_factor a (rel_prime a b) (rel_prime a b) (rel_prime a b) (rel_prime b m)).\n  intro; apply rel_prime_rel_prime; apply rel_prime; apply rel_prime; auto.\n  generalize (rel_prime_factor a (rel_prime a b) (rel_prime a b) (rel_prime a b) (rel_prime a b) (rel_prime a b).\n  intro; apply rel_prime_gcd; apply rel_Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  elim (mult_rel_prime a b (power n) (div b m)); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) (div b m)); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power n) m); auto.\n  elim (mult_rel_prime a b (power nQed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  apply rel_prime_rel_prime; auto.\n  apply rel_prime_prime; auto.\n  apply rel_prime_sym; apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_r; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_r; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_l; auto.\n  apply rel_prime_factor_r; auto.\n  apply rel_prime_factor_r; auto.\n  apply rel_prime_factor_Qed.",
                    "Lemma power_power_rel_prime : forall (a n b m:nat),(n>0)->(m>0)->((rel_prime (power a n) (power b m))<->(rel_prime a b)).\n  intros.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m b m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_for_euclid a n m);auto.\n  split;try (apply (rel_prime_mult_strong_mon_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\n",
                "context_tokens": 275,
                "proof_start_offset": 1044,
                "proof_end_offset": 1166,
                "proof": "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nunfold square.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\napply square_mult_strong.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b (c,d) (c,d) (d,d) (d,d).\n rewrite <- (abs_eq (abs (abs (abs a) (abs b)))).\nrewrite <- (abs_eq (abs (abs b))).\nrewrite abs_eq.\nunfold abs.\nrewrite abs_eq.\nrewrite abs_eq.\nfield;auto with zarith.\nunfold abs at 1.\nfield.\nreplace (abs a + abs b) with (abs a + abs b + abs b).\nreplace (abs a + abs b) with (abs a + abs b + abs b).\nreplace (abs a + abs b) with (abs a + abs b).\nreplace (abs a + abs b + abs b) with (abs a + abs b).\nreplace (abs a + abs b) with (abs a + abs b).\nreplace (abs a + abs b) with (abs a + abs b).\nreplace (abs a + abs b) with (abs a + abs b).\nreplace (abs a + abs b) with (abs a + abs b).\nreplace (abs a + abs b) with (abs a +Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b (H,H').\n replace (a*b) with a by ring.\n rewrite (div_mod b (abs b))).\n replace (a*b) with a by ring.\n rewrite (div_mod b (abs b)).\n rewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).\nrewrite (div_mod b (abs b)).Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b Ha.\ndestruct (ln_beta_div_eucl (a*b) (ln_beta_div_eucl b (ln_beta a (ln_beta a)))).\ndestruct (ln_beta_div_eucl (a*b)) (ln_beta a) as (e,He).\nsimpl.\nrewrite Z.mul_1_l.\nrewrite Z.mul_add_distr_r.\nrewrite Z.mul_add_distr_r.\nrewrite Z.mul_1_l.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_l.\nring_simplify (e*a*b).\nsimpl.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_r.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_l.\nrewrite Z.mul_add_distr_l.\nrewrite Z.Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b Ha.\nunfold square.\nrewrite square_mult_distr_r.\nrewrite (mult_comm a b).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (mult_comm b (abs b)).\nrewrite (multQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros.\nunfold square.\ndestruct (abs_nat_dec b) as [H|H];\n  [ rewrite H; ring | rewrite H; ring ]\n | rewrite H; ring ].\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b Ha Hb.\nassert (H:= square_div_mod_same a b Hb).\nassert (H':= square_div_mod_same a b Hc).\nassert (H':= square_div_mod_same a b Hc).\nassert (H':= square_div_mod_same a b Hc).\nrewrite H'.\nrewrite H'.\nrepeat rewrite mult_comm.\nrewrite H'.\nrepeat rewrite mult_comm.\nrewrite (mult_comm (a*b)).\nrewrite (mult_comm (b*b)).\nrewrite (mult_comm (b*b)).\nrewrite (mult_comm (a*b)).\nrewrite (mult_comm (b*b)).\nrewrite (mult_comm (b*b)).\nrewrite (mult_comm b (a*b)).\nrewrite (mult_comm b (a*b)).\nrewrite (mult_comm (b*b)).\nrewrite (mult_comm (a*b)).\nrewrite (mult_comm b (a*b)).\nrewrite (mult_comm b (a*b)).\nrewrite (mult_comm (b*b)).\nrewrite (mult_comm b (aQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\nintros a b Ha.\nassert (H : even a = even b).\napply (f_equal nat).\napply (f_equal nat).\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*b = 0) in |- *.\nchange (0*b = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0*a = 0) in |- *.\nchange (0Qed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros a b.\n assert (H := square_pos_bound a (square (a*b) ) (square_nonneg b)).\n unfold square_pos; simpl; apply square_pos_bound.\n unfold square_pos; simpl; ring.\nQed.",
                    "Lemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\nProof.\n intros.\n rewrite square_mult_div.\n rewrite square_mult_div.\n rewrite square_mult_div.\n ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 1331,
                "proof_end_offset": 1483,
                "proof": "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\ninduction n;simpl;trivial.\nintros;rewrite (IHn x y);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n intros.\n rewrite (mult_comm x n).\n apply power_mult_strong; trivial.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n unfold power.\n intros.\n rewrite power_mult_strong by auto with zarith.\n rewrite power_mult_strong by auto with zarith.\n rewrite ring.\n rewrite IHn by omega.\n ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  replace (x*(div x n)) with (x*(div y n)).\n  rewrite H.\n  rewrite (mult_comm x n).\n  reflexivity.\n  apply mult_comm.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n intros.\n apply power_mult_strong_strong.\n assumption.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n intros.\n destruct n; [ now left | now right].\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n intros.\n destruct n as [| n'].\n simpl.\n rewrite mult_1_r.\n rewrite mult_1_r.\n rewrite mult_1_l.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_l.\n reflexivity.\n simpl.\n rewrite mult_1_l.\n reflexivity.\n simpl.\n rewrite mult_1_l.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_l.\n reflexivity.\n simpl.\n rewrite mult_1_l.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_r.\n reflexivity.\n simpl.\n rewrite mult_1_l.\n reflexivity.\n simpl.Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  intros.\n  replace (x*y) with (x*y).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_comm.\n  apply mult_assoc.\n  apply mult_assoc.\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*y).\n  apply mult_reg_l with (x*Qed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\nProof.\n intros.\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_assoc (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (x*y)).\n apply (mult_comm (xQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  unfold mult.\n  intros.\n  ring.\nQed.",
                    "Lemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  unfold power.\n  intros.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1485,
                "proof_end_offset": 1642,
                "proof": "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\nProof.\ninduction n;simpl;intros.\nauto with arith.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x (S m));ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  unfold pow.\n  intros.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  rewrite mult_assoc.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_l.\n  reflexivity.\n  reflexivity.\n  simpl.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_r.\n  reflexivity.\n  reflexivity.\n  simpl.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_l.\n  reflexivity.\n  reflexivity.\n  simpl.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_r.\n  reflexivity.\n  reflexivity.\n  simpl.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_l.\n  reflexivity.\n  reflexivity.\n  simpl.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_r.\n  reflexivity.\n  reflexivity.\n  simpl.\n  rewrite (mult_comm x (x + m)).\n  rewrite mult_plus_distr_l.\n  reflexivity.Qed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m; simpl;trivial.\n  intros;rewrite (IHn x (S m));ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y); ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m; simpl; tauto.\n  intros; rewrite (IHn x y); ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m;simpl;trivial.\n  intros; rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction m; simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\n",
                "context_tokens": 483,
                "proof_start_offset": 1644,
                "proof_end_offset": 1799,
                "proof": "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\nProof.\ninduction n;simpl;intros.\ninversion H.\nexists (power x n);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros; rewrite (IHn x (S n));ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  intros; generalize (power_pos_pred_pos x n);intro;omega.\n  replace (x*(power x n)) with (1*(x*0)) by ring.\n  replace (x*x) with (1*(x*0)) by ring.\n  rewrite <- IHn; ring.\n  replace (x*x) with (1*(x*0)) by ring.\n  rewrite <- IHn; ring.\n  apply IHn.\n  omega.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros; rewrite (IHn x y);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;trivial.\n  intros; rewrite (IHn x 0);ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  unfold power.\n  intros.\n  rewrite H; auto with arith.\n  auto with arith.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\n",
                "context_tokens": 536,
                "proof_start_offset": 1801,
                "proof_end_offset": 2053,
                "proof": "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\nProof.\ninduction n;simpl;intros.\ninduction m;simpl;auto with arith.\nrewrite IHm;ring.\nrewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m;simpl;intros.\n  auto with arith.\n  replace x with (x*(m+n)+m) by ring.\n  replace x with (x*(m+n)) by ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m;simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n; simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  unfold power; simpl.\n  intros.\n  ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m; simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn; ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\n  rewrite IHn; ring.\n  rewrite IHn; ring.\n  rewrite IHn; ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m; simpl;intros.\n  inversion H.\n  replace (x0 + n) with (x0 + 1) by ring.\n  apply IHn.\n  replace (x0 + n) with (x0 + 1) by ring.\n  apply IHn.\n  replace (x0 + 1) with (x0 + 1) by ring.\n  apply IHn.\n  ring.\nQed.",
                    "Lemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction m; simpl;intros.\n  auto with arith.\n  rewrite IHn; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\n",
                "context_tokens": 619,
                "proof_start_offset": 2055,
                "proof_end_offset": 2202,
                "proof": "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\nProof.\ninduction n;simpl;intros.\ndiscriminate.\ncase (mult_lemma2 x (power x n) H);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros n x;induction n;simpl;intros.\n  inversion H.\n  exists 0%nat;trivial.\n  replace (S x) with (S (S (S n))).\n  trivial.\n  apply IHn.\n  omega.\n  omega.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  inversion H.\n  exists (div x n);trivial.\n  destruct (div_mod x n);simpl;intros;rewrite (IHn x x0);ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  apply power_power_correct;auto with arith.\n  rewrite power_mult_commute;rewrite IHn;ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  apply power_pos_pos;auto.\n  omega.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros;apply ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  inversion H.\n  exists 0;auto.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;reflexivity.\n  omega.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros; simpl in *.\n  elim H; intros.\n  inversion H.\n  rewrite H0;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros;rewrite mult_0_l;rewrite mult_0_l;rewrite mult_0_r;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;rewrite mult_comm;assumption.\nQed.",
                    "Lemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  intros.\n  rewrite power_mult_same.\n  rewrite IHn;ring.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\n",
                "context_tokens": 692,
                "proof_start_offset": 2237,
                "proof_end_offset": 2543,
                "proof": "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\nProof.\ninduction m;simpl;try omega;intros.\ndestruct m;simpl;try omega.\nsimpl in IHm.\nassert (1 < p*(power p m)).\napply IHm;auto with arith.\nrewrite mult_comm.\napply lt_trans with (1*p);try omega.\napply mult_lt_compat_r;try omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  inversion H.\n  destruct m;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_r;simpl;auto with arith.\n  rewrite mult_0_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_0_l;simpl;auto with arith.\n  rewrite mult_1_l;simpl;auto with arith.\n  rewrite mult_1_r;simpl;auto with arith.\n  rewrite mult_1_l;simpl;Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction n;simpl;intros.\n  auto with arith.\n  replace (p+(m-p)) with (1*(p-m)).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p+(m-p)) with (p-m).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p+(m-p)) with (1*(p-m)).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p+(m-p)) with (p-m).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p+(m-p)) with (p-m).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p+(m-p)) with (p-m).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p-m) with (p-m).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (p-m) with (p-m).\n  rewrite <- (mult_n_O m); auto with arith.\n  replace (Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;intros;auto with arith.\n  rewrite mult_0_r;auto with arith.\n  rewrite mult_0_r;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_r;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_l;auto with arith.\n  rewrite mult_1_Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  auto with arith.\n  case (mult_integral_domain p n m);auto with arith.\n  intros; rewrite (IHn x p); ring.\n  intros; rewrite (IHn x p); ring.\n  intros; rewrite (IHn x p); ring.\n  intros; rewrite (IHn x p); ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction n;simpl;intros.\n  destruct m;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto with arith.\n  rewrite IHn;simpl;auto withQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m.\n  simpl;intros.\n  discriminate.\n  simpl;intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl;intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl; intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H 0);omega.\n  simpl; intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl; intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl; intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl; intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl; intros.\n  destruct (le_gt_dec 0 p).\n  subst p0.\n  apply (H0 0);omega.\n  simpl; intros.Qed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction p;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nrewrite IHn;ring.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;intros.\n  discriminate.\n  case (mult_integral _ _ H0);auto.\n  elim (mult_integral _ _ H0);auto.\n  elim (mult_integral _ _ H0);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H0);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H0);auto.\n  elim (mult_integral _ _ H0);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ H1);auto.\n  elim (mult_integral _ _ HQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m.\n  simpl;intros.\n  inversion H.\n  subst p;inversion H0.\n  auto with arith.\n  replace (S (pred (S m)) with (S (pred (S m))).\n  rewrite H; auto with arith.\n  apply mult_le_compat_l.\n  omega.\n  apply mult_le_compat_l.\n  omega.\n  apply mult_le_compat_l.\n  omega.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m; simpl;intros.\n  inversion H0.\n  inversion H0.\n  destruct m;simpl;intros.\n  inversion H0.\n  inversion H0.\n  destruct m0;simpl;intros.\n  inversion H;clear H0.\n  inversion H0.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H1.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2.\n  inversion H2. inversion H2.\n  inversion H2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": "\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\n",
                "context_tokens": 740,
                "proof_start_offset": 2560,
                "proof_end_offset": 2661,
                "proof": "Lemma power_one : forall (n:nat),(power 1 n)=1.\nProof.\ninduction n;simpl;trivial.\nrewrite IHn;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  simpl.\n  rewrite ring_mult_same_full.\n  simpl.\n  assert (1 <= n) by omega.\n  destruct (mult_integral _ _ H0 H1).\n  subst.\n  simpl.\n  apply mult_0_r.\n  apply mult_1_r.\n  apply mult_1_l.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  apply mult_1_r.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_r.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  simpl; auto with arith.\n  apply mult_1_l.\n  simpl; auto with arith.\n  apply mult_1_l.\n Qed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  auto with arith.\n  destruct m;simpl;try omega.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  destruct p;simpl;try omega.\n  simpl.\n  destruct p;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct p0;simpl;try omega.\n  simpl.\n  destruct pQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  intro.\n  assert (1<n).\n  apply (pow_lt 1 n);apply mult_lt_compat_r;try omega.\n  apply mult_lt_compat_r;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_Qed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  intros;rewrite power_pos_nat;try omega.\n  rewrite power_pos_nat;try omega.\n  rewrite power_pos_nat;try omega.\n  rewrite power_pos_nat;try omega.\n  rewrite mult_comm.\n  apply mult_lt_compat_l;try omega.\n  rewrite mult_comm.\n  apply mult_gt_compat;try omega.\n  rewrite mult_comm.\n  apply mult_gt_compat;try omega.\n  omega.\n  omega.\n  omega.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  intro n;simpl;rewrite power_mult_spec;rewrite IHn;rewrite power_mult_strong;try omega.\n  simpl;rewrite IHn;rewrite mult_1_l;rewrite mult_1_l;try omega.\n  simpl;rewrite IHn;rewrite mult_1_l;rewrite mult_1_l;try omega.\n  simpl;rewrite IHn;rewrite mult_1_l;rewrite mult_1_l;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;rewrite mult_1_l;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;rewrite mult_1_l;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;try omega.\n  simpl;rewrite IHn;rewrite mult_1_l;rewrite mult_1_l;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;try omega.\n  simpl;rewrite IHn;rewrite mult_1_r;try omega.\n  simpl;rewrite IHn;rewrite mult_1_rQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  inversion H;subst.\n  apply power_pos_r;auto.\n  replace (1*n) with (1*n);auto with arith.\n  replace (1 * n) with (1*n);auto with arith.\n  replace (1 * n) with (1*n);auto with arith.\n  replace (1 * n) with (1*n);auto with arith.\n  replace (1 * n) with (1*n);auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*n);auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*n); auto with arith.\n  replace (1 * n) with (1*Qed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros;try omega.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;intros.\n  rewrite IHn;ring.\n  destruct m;simpl;try omega.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn; ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\n  simpl.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_one : forall (n:nat),(power 1 n)=1.\n  intros.\n  rewrite power_mult_strong;simpl;auto with arith.\n  rewrite power_mult_strong;simpl;auto with arith.\n  rewrite H;ring.\n  rewrite IHn;ring.\n  rewrite mult_comm;ring.\n  rewrite H;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/power.v",
                "context": ".  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of square *)\nDefinition square (x:nat) := x*x.\n\n(** (x*y)^2 = x^2*y^2 *)\nLemma square_mult_lemma : forall (a b:nat),(square (a*b))=((square a)*(square b)).\n  unfold square.\n  intros.\n  ring.\nQed.\n\n(** we now generalize the theorem to the nth-root *)\nFixpoint power (x n:nat) {struct n} : nat :=\n  match n with\n    O => 1\n    | (S n) => (x*(power x n))\n  end.\n\nLemma power_mult_lemma1 : forall (n x y:nat),(power (x*y) n)=(power x n)*(power y n).\n  induction n;simpl;trivial.\n  intros;rewrite (IHn x y);ring.\nQed.\n\nLemma power_plus_lemma1 : forall (n m x:nat),(power x (n+m))=(power x n)*(power x m).\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\nQed.\n\nLemma power_divides_lemma1 : forall (n x:nat),(0<n)->(divides (power x n) x).\n  induction n;simpl;intros.\n  inversion H.\n  exists (power x n);trivial.\nQed.\n\nLemma power_power_lemma1 : forall (n m x:nat),(power (power x n) m)=(power x (n*m)).\n  induction n;simpl;intros.\n  induction m;simpl;auto with arith.\n  rewrite IHm;ring.\n  rewrite power_mult_lemma1;rewrite IHn;rewrite <- power_plus_lemma1;trivial.\nQed.\n\nLemma power_zero : forall (n x:nat),(power x n)=O->x=O.\n  induction n;simpl;intros.\n  discriminate.\n  case (mult_lemma2 x (power x n) H);auto.\nQed.\n\n(** if 1<p and 0<m then p^m>1 *)\nLemma power_lt : forall (p m:nat),(1<p)->(0<m)->1<(power p m).\n  induction m;simpl;try omega;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < p*(power p m)).\n  apply IHm;auto with arith.\n  rewrite mult_comm.\n  apply lt_trans with (1*p);try omega.\n  apply mult_lt_compat_r;try omega.\nQed.\n\n(** 1^n = 1 *)\nLemma power_one : forall (n:nat),(power 1 n)=1.\n  induction n;simpl;trivial.\n  rewrite IHn;ring.\nQed.\n\n(** if x>1 and x^m | x^n then m<=n *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2701,
                "proof_end_offset": 3361,
                "proof": "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\nintros.\ncase (le_lt_dec m n);trivial.\nintro.\ngeneralize (le_plus_minus n m);intro.\nrewrite H1 in H0;try omega.\nelim H0;intro q;rewrite power_plus_lemma1;intro.\nassert (1=(power x (m-n))*q).\napply mult_lemma6 with (power x n).\nintro;generalize (power_zero n x H3);omega.\nrewrite mult_assoc;rewrite <- H2;ring.\nsymmetry in H3;elim (mult_lemma5 (power x (m-n)) q H3);intros.\ncase (eq_nat_dec (m-n) 0);intro;try omega.\nassert (x=1);try omega.\napply divides_antisym;[apply one_min_div | rewrite <- H4;apply power_divides_lemma1;omega].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\ninduction n;simpl;intros.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\n  rewriteQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\ninduction n;simpl;intros.\n  inversion H;clear H;inversion H0.\n  simpl;rewrite H;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\ninduction n;simpl;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1<=n).\n  apply IHn;auto with arith.\n  rewrite mult_comm.\n  apply IHn;auto with arith.\n  apply mult_lt_compat_l;try omega.\n  apply IHn;auto with arith.\n  rewrite mult_comm.\n  apply IHn;auto with arith.\n  apply mult_lt_compat_l;try omega.\n  apply IHn;auto with arith.\n  rewrite mult_comm.\n  apply IHn;auto with arith.\n  apply mult_lt_compat_l;try omega.\n  apply IHn;auto with arith.\n  apply mult_le_compat_l;try omega.\n  apply IHn;auto with arith.\n  apply mult_le_compat_l;try omega.\n  apply IHn;auto with arith.\n  apply mult_le_compat_l;try omega.\n  apply IHn;auto with arith.\n  apply mult_le_compat_l;try omega.\n  apply IHn;auto with arith.\n  apply mult_le_compat_l;try omega.\n  apply IHn;auto with arith.\n  apply mult_le_compat_lQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\ninduction n;simpl;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (0 <= n); [omega | ].\n  apply mult_lt_compat_r;try omega.\n  apply IHn; omega.\n  simpl; omega.\n  simpl; omega.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\n  intros.\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_r;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_le_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;try omega.\n  apply mult_lt_compat_l;Qed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\n  induction n;simpl;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (1 < n).\n  apply IHn;auto with arith.\n  rewrite mult_comm;rewrite mult_1_l;rewrite mult_1_l;auto with arith.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\n  induction n;simpl;intros.\n  auto with arith.\n  rewrite IHn;ring.\n  rewrite IHn;ring.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\n induction n;simpl;intros.\ndestruct m;simpl;try omega.\nsimpl in IHm.\nassert (1 < n) by omega.\nassert (1 < m) by omega.\nassert (1 < n) by omega.\nassert (1 < n) by omega.\nassert (1 < n) by omega.\nassert (1 <= n) by omega.\nassert (1 < n) by omega.\ndestruct H as (H1,H2).\nrewrite (IHn m n) by omega.\nomega.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\nProof.\n  induction n;simpl;intros.\n  destruct m;simpl;try omega.\n  simpl in IHm.\n  assert (0<=n).\n  apply IHn;auto with arith.\n  simpl in IHm.\n  assert (1 < n)%nat by omega.\n  apply IHn;auto with arith.\n  simpl in IHm.\n  assert (0 <= n)%nat by omega.\n  apply IHn;auto with arith.\n  simpl in IHm.\n  assert (1 < n)%nat by omega.\n  apply IHn;auto with arith.\n  simpl in IHm.\n  assert (1 = S (pred (pred (S n))).\n  apply IHn;auto with arith.\n  omega.\nQed.",
                    "Lemma power_divides_power : forall (x n m:nat),(x>1)->(divides (power x n) (power x m))->(m<=n).\n  induction n;simpl;intros.\n  case (mult_integral_eq x (x+m));auto.\n  rewrite IHn;ring.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  case (mult_integral_eq x (x+m));auto.\n  rewrite IHn;ring.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  rewrite IHn; ring.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  simpl;auto with arith.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nexists (n,n).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, a = (b*q)).\napply (fun p => forall q:nat, aQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nexists (S (S (S (S (S (S (S n)))))) (S n)).\nunfold pred at 1.\nrewrite mult_comm.\nrewrite mult_comm.\napply le_n_S.\napply le_trans with (S (pred (S (S (S (S n))))) (S n)).\napply plus_le_compat_l.\napply le_n_S.\napply plus_le_compat_l.\napply S_pred with 0%nat.\napply le_trans with (S (pred (S (pred n)))).\napply plus_le_compat_l.\napply le_trans with (S (pred n)).\napply plus_le_compat_l.\napply S_pred with 0%nat.\napply le_trans with (S (pred n)).\napply plus_le_compat_l.\napply le_trans with (S n).\napply plus_le_compat_l.\napply le_trans with (S n).\napply plus_le_compat_l.\napply S_pred with 0%nat.\napply le_trans with (S (pred n)).\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists 1.\n  reflexivity.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (S (S (S (S (S (S (S (S (S (S (S n))))))))).\n  apply lt_n_S.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S n).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S n).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S n).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n  exists (S n)).\n  exists (S (S n)).\n  exists (S (S n)).\n Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (S n); auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nexists (S n).\nsplit.\napply (fun x => S (S x)).\nunfold pred, pred, pred, pred; simpl; auto with *.\nsplit.\napply (fun x => S (S x)).\nunfold pred, pred, pred, pred; simpl; auto with *.\nintros x H; apply H.\napply (H x).\napply H.\nintros m H; apply H.\nsimpl; auto with *.\nintros m H; elim (le_or_lt m m).\nintros p H; exists m.\nexists (S m).\nexists (S m).\nsplit.\napply (fun x => S (S x)).\nunfold pred, pred, pred; simpl; auto with *.\nunfold pred, pred, pred; simpl; auto with *.\nunfold pred, pred, pred; simpl; auto with *.\nunfold pred, pred, pred; simplQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintro n; case n.\nintros q H; exists q; exists q; auto.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists 1; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n   unfold prime at 2; exists (S (pred (S n))) 1.\n   intros.\n   split.\n   assumption.\n   intros.\n   split.\n   assumption.\n   intros.\n   elim H1; intros.\n   elim H2; intros.\n   elim H5; intros.\n   elim H6; intros.\n   elim (le_or_lt a b); intros.\n   elim H6; intros.\n   elim (le_or_lt (S (S n)) b); intros.\n   elim H6; intros.\n   elim (lt_or_eq b (S (S (S n)))).\n   intro.\n   elim H6; intros.\n   elim (le_or_lt b (S (S (S n)))).\n   intro.\n   elim (le_or_lt b (S (S (S n)))).\n   intro.\n   elim H6; intros.\n   elim (le_or_lt b b).\n   intros.\n   elim (le_or_lt b b).\n   intros.\n   elim (le_or_eq b (S (S n))).\n   intro.\n   elim (le_or_lt b b).\n   intros.\n   elim (le_or_ltQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intro.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  cut (exists q:nat, a = q).\n  intro.\n  elim H.\n  intro.\n  elim H1.\n  intros.\n  exists (p * q).\n  elim H2.\n  intros.\n  exists (p * q).\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H5.\n  intros.\n  exists (p * q).\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H6.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H5.\n  intros.\n  exists (p * q).\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.\n  elim H5.\n  intros.\n  exists (p * q).\n  split.\n  assumption.Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim H.\n  left.\n  left.\n  apply H.\n  right.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H0.\n  right.\n  apply H.\n  left.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H0.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H.\n  right.\n  apply H.\n  right.\n  apply H.\n  left.\n  apply H.\n  left.\n  apply H0.\n  right.\n  apply H.\n  right.\n  apply H.\n  rightQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  induction  n as [| n Hrecn].\n  simpl.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  simpl in |- *.\n  apply (fun p:nat => exists q:nat, a = q + p).\n  intros.\n  apply (fun p:nat => exists q:nat, a = q + p).\n  simpl in |- *.\n  apply plus_comm.\n  apply (fun p:nat => forall q:nat, a = q + q).\n  simpl in |- *.\n  apply plus_comm.\n  apply le_n_Sm.\n  apply le_S_n.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_S.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_trans with (S q).\n  apply le_n_S.\n  apply le_n_S.\n  apply le_S.\n  apply le_trans with (S q).\n  apply le_n_S.\n  apply le_trans with (S q).\n  apply le_S_n.\n  apply le_n_S.\n  apply le_trans with (S q).\n  apply le_n_S.\n  apply le_n_S.\n  applyQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (minus_O_or_lt n n H).\n  intros.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))).\n  split.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H0.\n  rewrite <- H.\n  rewrite <- H.\n  apply plus_n_Sm.\n  assumption.\n  exact (proj1 (lt_n_O n)).\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intro.\n  red.\n  exists (b*q).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S (S (S (S (S (S (S (S (S(S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim (le_Sn_O n).\n  elim (le_Sn_O n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists (S n).\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a, a).\n  exists (a, a).\n  exists (a', a').\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  apply H.\n  apply cong_left_commutativity.\n  apply cong_left_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n  apply cong_left_commutativity.\n  apply cong_right_commutativity.\n  apply cong_right_commutativity.\n Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a*q).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists a.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists a.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists a.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (fun n => (a = a \\/ n)).\n  intros.\n  exists (fun n => (a = a \\/ n)).\n  intros.\n  exists (fun n => a).\n  exists (fun n => a).\n  exists (fun n => a).\n  intro.\n  exists (fun n => a).\n  intros.\n  exists (fun n => a).\n  apply H.\n  exists (fun n => a).\n  intros.\n  exists (fun n => a).\n  apply H0.\n  exists (fun n => a).\n  intros.\n  exists (fun n => a).\n  split.\n  apply H.\n  auto with arith.\n  exists (fun n => a).\n  auto with arith.\n  exists (fun n => a).\n  auto with arith.\n  exists (fun n => a).\n  exists (fun n => a).\n  split.\n  apply H.\n  auto with arith.\n  exists (fun n => a).\n  auto with arith.\n  exists (fun n => a).\n  auto with arith.\n  exists (fun n => a).\n  auto with arith.\n  exists (fun n => a).\n  auto with arith.\n  exists (fun n => a).\n  splitQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  ring.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists a.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  destruct (gcd_bezout a b c) as [d [d [H1 H2]]].\n  exists d.\n  exists (d*d).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  generalize (gcd_divide_r a b c H H0).\n  intros.\n  generalize (gcd_divide_r a b c H0 H1).\n  intros.\n  destruct H0 as [H0|H0].\n  destruct H0 as [H1|H1].\n  left.\n  exists (a*c).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  exists (b*c).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  exists (b*p).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  elim (rel_prime_not _ _ H0).\n  intros.\n  exists x.\n  elim H0.\n  intros.\n  exists x.\n  apply H2.\n  exists x0.\n  apply H1.\n  exists x0.\n  apply H2.\n  exists x1.\n  apply H2.\n  exists x1.\n  apply H0.\n  exists x1.\n  apply H1.\n  exists x1.\n  apply H2.\n  exists x1.\n  apply H2.\n  exists x1.\n  apply H.\n  exists x2.\n  apply H1.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H1.\n  exists x1.\n  apply H0.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.\n  apply H.\n  exists x1.Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  exists (b*c).\n  apply le_antisym; auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  exists (a*c).\n  apply (H a).\n  apply (H a).\n  apply (H a).\n  apply (H a).\n  apply (H a).\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros a b c.\n  intros.\n  assert (a = b) by (apply (rel_prime_intro a b c); auto with arith).\n  subst c.\n  apply (rel_prime_intro a b c); auto with arith.\n  apply (rel_prime_intro a b c); auto with arith.\n  apply (rel_prime_intro a b c); auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n   intros.\n   elim (le_gt_dec a 0).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 1 a).\n   intros.\n   elim (le_gt_dec 0 a).\n   intros.\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 1 a).\n   intros.\n   elim (le_gt_dec 1 a).\n   intros.\n   elim (le_gt_dec 1 a).\n   intros.\n   elim (le_gt_dec 0 a).\n   intros.\n   rewrite <- H1 in H0.\n   rewrite <- H2 in H0.\n   apply H.\n   split with 0.\n   split.\n   simpl.\n   split.\n   simpl.\n   assumption.\n   reflexivity.\n   apply (le_lt_trans 0 a).\n   simpl.\n   rewrite <- H0 in H0.\n   rewrite <- H0 in H0.\n   apply H.\n   split with 1.\n   split.\n   simpl.\n   reflexivity.\n   reflexivity.\n   apply (le_lt_trans 0 a).\n   simpl.\n   reflexivity.\n   apply (le_lt_Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply (rel_prime_dec a b).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_dec a c).\n  apply (rel_prime_decQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  case (gcd_intro a b H0).\n  intros.\n  rewrite H2 in H1.\n  generalize (gcd_intro a b H0).\n  rewrite H2.\n  rewrite H1.\n  rewrite H2.\n  trivial.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  intros.\n  apply H.\n  assumption.\n  intros.\n  apply H.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim (gcd_total a b H).\n  left; auto with arith.\n  left; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros a b c H.\n  case (gcd_bezout a b c H).\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  cut (a <= a \\/ b <= a).\n  intro; elim H; intro.\n  elim H; intro.\n  elim H0; intro.\n  rewrite H1 in H2.\n  exists (b * q).\n  rewrite <- H1.\n  auto with arith.\n  rewrite <- H1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros a b.\n  case (gcd_unique_divisors a b); intros.\n  left.\n  apply (gcd_intro a a).\n  rewrite <- H1.\n  rewrite <- H2.\n  apply gcd_gcd_l.\n  apply (gcd_divide_r a b).\n  apply gcd_gcd_greatest.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_greatest.\n  assumption.\n  apply gcd_Qed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  elim H; intro q.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim (gcd_unique a b H).\n  intros.\n  apply H.\n  apply (gcd_divide a b H).\n  apply (gcd_divide a b H).\n  apply (gcd_divide a b H).\n  rewrite <- H.\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H2 in H.\n  rewrite H2 in H.\n  rewrite H2 in H.\n  apply H0.\n  rewrite H2 in H.\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros a b c H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  rewrite <- H in H.\n  apply H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 2349,
                "proof_end_offset": 2501,
                "proof": "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\nintros.\nred.\nintro.\napply H.\napply divides_antisym;trivial.\napply one_min_div.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro q;intro.\n  rewrite H1 in H1.\n  exists (a*q).\n  rewrite H1.\n  auto with arith.\n  elim (lt_irrefl a); intros.\n  rewrite H2 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  rewrite H3 in H1Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q; intro.\n  rewrite H0 in H0.\n  rewrite H0 in H0.\n  apply (non_zero _ _ H0).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n  apply (not_equal (fun a0:nat => a0 <> 0)).\n Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q; intro.\n  rewrite H2 in H1.\n  rewrite H0 in H1.\n  elim (not_and_not _ _ H1); intros.\n  rewrite H3 in H2; simpl in H2; rewrite <- H3 in H2; rewrite mult_comm in H2.\n  elim (not_and_not _ _ H2); intros.\n  rewrite H4 in H2; rewrite mult_comm in H2; simpl in H2; rewrite <- H3 in H2.\n  rewrite <- H0 in H2; simpl in H2; rewrite mult_comm in H2; rewrite <- H4 in H2.\n  rewrite (mult_comm a q).\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q; intro.\n  elim H0; intro q; intros.\n  rewrite H2 in H0.\n  exists (a*q).\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q; intro.\n  rewrite H0 in H.\n  assert ((a - a) = a * q).\n  apply (div_unique a); assumption.\n  rewrite H0 in H; rewrite H0 in H; rewrite mult_comm in H; simpl in H; congruence.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim H; intro q; intro.\n  elim H; intro q; intro.\n  elim H0; intro q; intro.\n  elim H0; intro q; intro.\n  elim H0; intro q; intro.\n  elim (le_Sn_O q); intros.\n  rewrite H4 in H; rewrite H2 in H; rewrite mult_comm in H; simpl in H2.\n  elim (mult_lemma5 q q H5); intros.\n  rewrite H5 in H; rewrite mult_comm in H; simpl in H2.\n  elim (mult_lemma5 q q H5); intros.\n  rewrite H5 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H2.\n  elim (mult_lemma5 q q H5); intros.\n  rewrite H5 in H2; rewrite mult_comm in H2; simpl in H2.\n  elim (mult_lemma5 q q H5); intros.\n  rewrite H5 in H2; rewrite mult_comm in H2; simpl in H2.\n  elim (mult_lemma5 q q H5); intros.\n  rewrite H5 inQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros a b.\n  elim (non_div_1 a H); intros.\n  elim (non_div_1 a H); intros.\n  rewrite H1 in H1; rewrite H2 in H1; simpl in H1; elim (mult_diff_0 a H1); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H2; elim (mult_diff_0 a H1); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H2; elim (mult_diff_0 a H1); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H2; elim (mult_diff_0 a H1); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H2; elim (mult_diff_0 a H1); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H2; elim (mult_diff_0 a H1); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H2; elimQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q;intro.\n  rewrite H2 in H; rewrite H2 in H; rewrite H2 in H; contradiction.\n  rewrite H2 in H; rewrite H2 in H; contradiction.\n  rewrite H2 in H; rewrite mult_comm in H; contradiction.\n  rewrite H2 in H; rewrite H2 in H; contradiction.\n  rewrite H2 in H; contradiction.\n  rewrite H2 in H; contradiction.\n  rewrite H2 in H; contradiction.\n  rewrite H1 in H; contradiction.\n  rewrite H2 in H; contradiction.\n  rewrite H2 in H; contradiction.\n  rewrite H2 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\n  rewrite H3 in H; contradiction.\nQed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\nProof.\n  intros.\n  elim (not_le_dec 0 a); intro.\n  elim (not_le_dec 0 a); intro.\n  elim (not_le_lt 0 a); intro.\n  elim (not_le_lt 0 a); intro.\n  elim (not_lt_eq (S a) (S a)); intro.\n  rewrite H5 in H2; simpl in H2; rewrite plus_comm in H2; simpl in H2; tauto.\n  elim (not_le_lt 0 a); intro.\n  rewrite H5 in H2; simpl in H2; rewrite <- (mult_comm a); simpl in H2; tauto.\n  elim (not_le_lt 0 a); intro.\n  rewrite H5 in H2; simpl in H2; rewrite <- (mult_comm a); simpl in H2; tauto.\n  elim (not_le_lt 0 a); intro.\n  rewrite H5 in H2; simpl in H2; rewrite <- (mult_comm a); simpl in H2; tauto.\n  elim (not_le_lt 0 a); intro.\n  rewrite H5 in H2; simpl in H2; rewrite <- (Qed.",
                    "Lemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  elim H; intro q; intro.\n  rewrite H0 in H1.\n  elim (mult_integral_l a a); intros.\n  rewrite H0 in H1; rewrite H2 in H1.\n  elim (mult_integral_l a a); intros.\n  rewrite H1 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H1; contradiction.\n  elim (mult_integral_r a a); intros.\n  rewrite H0 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H1; elim H1;\n   intros.\n  rewrite H1 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H1; elim H1;\n   intros.\n  rewrite H0 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H1; elim H1;\n   intros.\n  rewrite H1 in H1; rewrite mult_comm in H1; rewrite mult_comm in H1; simpl in H1; elim H1;\n   intros.\n  rewrite H0 in H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "s *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2544,
                "proof_end_offset": 2770,
                "proof": "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nexists (q+q').\nrewrite H1;rewrite H2.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro q;intro.\n  elim H1; intro q;intro.\n  rewrite H2 in H2.\n  exists (p * q).\n  rewrite H1.\n  rewrite H2.\n  auto with arith.\n  rewrite <- H2; rewrite <- H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite <- H1; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.\n  rewrite H2; rewrite mult_comm; apply le_plus_minus.Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H0 in H0.\n  elim H0; intro q; intro.\n  rewrite H2 in H1.\n  rewrite <- H0 in H1.\n  rewrite <- H1 in H1.\n  rewrite H0 in H1.\n  rewrite <- H1 in H1.\n  exists (a * q).\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  unfold divide.\n  intros.\n  elim H.\n  elim H0.\n  elim H1.\n  elim H1.\n  intros q' H H1.\n  exists (q' * q').\n  rewrite H1.\n  rewrite H2.\n  rewrite H1.\n  rewrite H2.\n  rewrite H1.\n  rewrite H2.\n  rewrite H2.\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro q;intros.\n  rewrite H2 in H1; rewrite H2 in H1; rewrite H2 in H1; simpl in H1.\n  elim (mult_diff_div a b q); intros.\n  rewrite H2 in H1; rewrite H2 in H1; simpl in H1.\n  elim (mult_diff_div a b q); intros.\n  rewrite H2 in H1; rewrite H2 in H1; simpl in H1.\n  elim (mult_diff_div a b q); intros.\n  rewrite H3 in H1; rewrite mult_comm in H1; simpl in H1.\n  elim (mult_diff_div a b q); intros.\n  rewrite H3 in H1; rewrite H3 in H1; simpl in H1.\n  elim (mult_diff_div a b q); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H1.\n  elim (mult_diff_div a b q); intros.\n  rewrite H4 in H1; rewrite mult_comm in H1; simpl in H1.\n  elim (mult_diff_div a bQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro q;intro.\n  rewrite H0 in H; simpl in H; rewrite (mult_comm a b) in H; simpl in H.\n  rewrite (mult_comm b d).\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro q;intro.\n  rewrite H2 in H1.\n  elim (mult_diff_1_le a b c d); intros.\n  rewrite H3 in H1; rewrite mult_comm in H1; rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite <- (mult_assoc a b).\n  rewrite (mult_comm b b).\n  rewrite (mult_assoc a b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a c).\n  rewrite (mult_assoc a b).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_assoc a b).\n  rewrite (mult_comm b c).\n  rewrite (mult_assoc a b).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm a c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro q; intros.\n  rewrite H2 in H.\n  rewrite H2 in H.\n  assert ((a - a) + (a - b) = a).\n  apply mult_complete.\n  replace (a * q) with (a * q).\n  rewrite <- H0.\n  auto with arith.\n  replace (a * q) with (a * q).\n  rewrite <- H0.\n  auto with arith.\n  rewrite <- H0.\n  auto with arith.\n  rewrite <- H0.\n  auto with arith.\n  apply le_plus_l.\n  apply le_trans with (m := S q).\n  apply le_plus_r.\n  apply le_plus_r.\n  rewrite <- H0.\n  auto with arith.\n  rewrite <- H0.\n  auto with arith.\n  apply le_plus_l.\n  apply le_trans with (m := S q).\n  apply le_plus_l.\n  apply le_plus_r.\n  rewrite <- H0.\n  auto with arith.\n  apply le_plus_l.\n  apply le_trans with (m := S q).\n  apply le_plus_r.\n  rewrite <- H.Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\nProof.\n  intros.\n  apply (prime_not_le (a+b) (b+b)).\n  apply (gcd_sym (a+b) (a+b)).\n  apply (gcd_sym (a+b)).\n  apply (gcd_trans (a+b) (b+c)).\n  apply (gcd_for_euclid (a+b) (b + b)).\n  apply (gcd_sym (a+b)).\n  apply (gcd_for_euclid (a+b) (b+c)).\n  apply (gcd_for_euclid (a+b) (b+c)).\n  apply (gcd_for_euclid (a+b) (c+d)).\n  apply (gcd_for_euclid (a+b) (b+c)).\n  apply (gcd_for_euclid (a+b) (c+d)).\n  apply (gcd_for_euclid (a+c) (b+c) (c+d)).\n  apply (gcd_for_euclid (a+b) (b+d)).\n  apply (gcd_for_euclid (a+b) (b+c) (c+d)).\n  apply (gcd_forQed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  apply H.\n  apply (lt_wf a b H).\n  apply (lt_wf a b H).\n  apply (lt_wf a b H).\n  apply (lt_wf a b H).\n  apply (lt_wf a b H).\n  apply le_trans with (m := le_plus_minus a b H).\n  apply le_trans with (m := le_plus_minus a b H).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (m := S n).\n  apply le_plus_trans with (Qed.",
                    "Lemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  intros.\n  elim H; intro q;intro.\n  rewrite H2 in H; elim H; intro.\n  rewrite H2 in H0; elim H0; intro.\n  rewrite H1 in H0; rewrite mult_comm in H0; simpl in H0; tauto.\n  elim (mult_lemma2 q H0); intros.\n  rewrite H2 in H; elim H0; intro.\n  rewrite H2 in H; rewrite mult_comm in H; simpl in H0; tauto.\n  elim (mult_lemma2 q H0); intros.\n  rewrite H3 in H; rewrite mult_comm in H; simpl in H0; tauto.\n  elim (mult_lemma2 q H0); intros.\n  rewrite H3 in H; rewrite mult_comm in H; simpl in H0; tauto.\n  elim (mult_lemma2 q H0); intros.\n  rewrite H3 in H; rewrite mult_comm in H; simpl in H0; tauto.\n  elim (mult_lemma2 q H0); intros.\n  rewrite H3 in H0; rewrite mult_comm in H0; simpl in H0; tauto.\n  elim (mult_lemma2 q H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\n",
                "context_tokens": 732,
                "proof_start_offset": 2801,
                "proof_end_offset": 2971,
                "proof": "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nexists (b * q).\nrewrite H0.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H; intro q';intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H0.\n  replace (q + q') with (q * a + (q' * a)).\n  replace (q * a + (q' * b + q' * b + q' * b)) with (q * a).\n  rewrite H0.\n  ring.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divide.\n  intros.\n  elim H;intro q;intro.\n  exists (q+q).\n  rewrite H0; rewrite H0; rewrite H1; assumption.\n  elim (mult_lemma_3 q (a*b)).\n  intros.\n  rewrite H0.\n  rewrite H1.\n  rewrite H1.\n  rewrite <- H2; rewrite H2; assumption.\n  elim (mult_lemma_3 q (a*b)).\n  intros.\n  rewrite H0.\n  rewrite H0; rewrite H0; rewrite H0; rewrite H0; assumption.\n  elim (mult_lemma_3 q (a*b)).\n  intros.\n  rewrite H0; rewrite H0; rewrite H0; rewrite H0; ring.\n  elim (mult_lemma_3 q (a*b)).\n  intros.\n  rewrite H0.\n  rewrite H0; rewrite H0; rewrite H0; rewrite H1; ring.\n  elim (mult_lemma_3 q (a*b)).\n  intros.\n  rewrite H0; rewrite H0; rewrite H0; rewrite H0; ring.\n  elim (mult_lemma_3 q (a*b)).\n  intros.\n  rewrite HQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n  intros.\n  elim (le_or_lt a b); intro.\n  elim H0; intro q';intro.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H2; rewrite H2; trivial.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H2; rewrite H2; trivial.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H2; rewrite H2; trivial.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H2; rewrite H2; trivial.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H1; rewrite H2; trivial.\n  elim (le_or_eq b a); intro.\n  rewrite H2; rewrite H2; rewrite H2; trivial.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H1; rewrite H2; trivial.\n  elim (le_or_lt b a); intro.\n  rewrite H1; rewrite H2; rewrite H1; trivial.\n  elim (Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n  intros.\n  elim H; intro q;intro.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q a b); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H0; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b a); intros.\n  rewrite H2 in H; simpl in H; discriminate H.\n  elim (mult_lemma3 q b aQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0; intro q';intro.\n  elim (le_gt_dec 0 (q * a) q); intros.\n  rewrite H1 in H1; rewrite H2 in H1; rewrite H2 in H1; elim (mult_gt_0_compat q' q' a b c); intros.\n  rewrite H1 in H1; rewrite H1 in H1; elim (mult_gt_0_compat q' a b c); intros.\n  rewrite H2 in H1; rewrite (mult_comm (a * b) (b * b)); trivial.\n  rewrite H1 in H1; rewrite (mult_comm (a * b) (b * b)); trivial.\n  ring.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n   intros.\n   elim H; intro q;intro.\n   rewrite H2 in H1.\n   elim (mult_ex_intro q (a*b) (a * b)); intros.\n   rewrite H3 in H2; simpl in H2; rewrite <- H2; rewrite <- H3; auto.\n   elim (mult_ex_intro q (a*b) (a * b)); intros.\n   rewrite H3 in H2; simpl in H2; rewrite <- H2; rewrite <- H3; auto.\n   elim (mult_ex_intro q (a*b) (a * b)); intros.\n   rewrite H3 in H2; simpl in H2; rewrite <- H2; rewrite <- H3; auto.\n   elim (mult_ex_intro q (a*b) (b * b)); intros.\n   rewrite H3 in H2; simpl in H2; rewrite <- H2; rewrite <- H3; auto.\n   elim (mult_ex_intro q (a*b) (b * c)); intros.\n   rewrite H3 in H2; simpl in H2; rewrite <- H2; rewrite <- H3; auto.\n   elim (Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n   intros.\n   elim (le_or_lt a b).\n   elim (le_or_lt b a).\n   elim (le_or_lt b a).\n   elim (le_or_lt b a).\n   elim (le_or_lt b a).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b a).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b b).\n   elim (le_or_lt b a).\n   elim (le_or_eq b b).\n   elim (le_or_lt b a).\n   elim (le_or_eq b b).\n   elim (le_or_eq b c).\n   elim (le_or_lt b b).\n   elim (le_or_ltQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H; intro q; intro.\n  elim H0; intro q'; intros.\n  elim H0; intro q'; intros.\n  elim (le_Sn_O q' q').\n  rewrite H1; rewrite H2; rewrite H2; apply prime_mult_l.\n  elim (mult_diff_mult_l q' q'); intros.\n  rewrite H4 in H2; simpl in H2; rewrite plus_comm in H2; simpl in H2.\n  elim (mult_diff_mult_l q' q); intros.\n  rewrite H4 in H2; rewrite mult_comm in H2; simpl in H2; rewrite plus_comm in H2.\n  elim (mult_diff_mult_l q' q'); intros.\n  rewrite H4 in H2; rewrite mult_comm in H2; simpl in H2; rewrite mult_comm in H2.\n  elim (mult_diff_mult_l q' q'); intros.\n  rewrite H4 in H2; rewrite mult_comm in H2; simpl in H2.\n  elim (mult_diff_mult_l q' q'); intros.\n  rewrite H4 in H2Qed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\nProof.\n  intros.\n  elim H; intro q; intro.\n  exists (a+b).\n  rewrite H; rewrite H0; reflexivity.\n  rewrite H; reflexivity.\nQed.",
                    "Lemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  intros.\n  elim H; intro q;intro.\n  rewrite H2 in H0.\n  rewrite H2 in H0.\n  rewrite H0 in H1.\n  apply pred_nat_of_P.\n  elim H; intro q;intro.\n  rewrite H2 in H1; rewrite mult_comm in H1.\n  rewrite <- H1 in H1.\n  rewrite (mult_comm a (b * q)) at 2.\n  rewrite <- H1.\n  rewrite mult_comm.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm b a).\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b) at 1.\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3014,
                "proof_end_offset": 3325,
                "proof": "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H1;rewrite H2.\nexists (q'-q).\nrewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q; intro.\n  elim H0; intro q; intros.\n  exists (b * q).\n  rewrite H0.\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro q;intro.\n  rewrite H2 in H1.\n  rewrite H1.\n  rewrite H2; assumption.\n  rewrite H2; assumption.\n  elim H; intro q; intro.\n  exists (b * q).\n  rewrite H1.\n  rewrite H2.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  rewrite H2 in H0.\n  exists (b * q).\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro q;intro.\n  elim H0; intro q; intros.\n  exists (b * q).\n  rewrite H1.\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\nProof.\n  unfold divides.\n  intros.\n  elim H; intro q; intro.\n  exists (b * q).\n  rewrite H0.\n  rewrite H0.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q; intro.\n  elim H0; intro q; intro.\n  exists (b * q).\n  rewrite H0.\n  rewrite <- H0.\n  rewrite H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro q; intro.\n  exists (b * q).\n  rewrite H0.\n  rewrite <- H2.\n  rewrite H2.\n  rewrite <- H2.\n  rewrite H0.\n  rewrite H0.\n  rewrite <- H1.\n  rewrite H2.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro q;intro.\n  rewrite H1 in H0.\n  assert ((a + b) + (b + b) = (a * b) + (a * b) + (a * b)).\n  apply mul_least_l_r.\n  replace (a * b + (b + b) + (b * b + b) + (b * b) + (b * b)).\n  apply mul_least_l_r.\n  replace (a * b + (b + b) + (b * b + b * b) + (b * b + b * b)).\n  apply mul_least_r_r.\n  replace (a * b + (b + b) + (b * b + b * b + (b * b)).\n  apply mul_least_r.\n  replace (a * b + (b + b) + (b * b + b * b + (b * b + b * b)).\n  apply mul_least_r_l.\n  replace (a * b + (b * b + b * b + (b * b + b * b)) with (a * b)Qed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro.\n  rewrite H2.\n  apply le_trans with (m * q).\n  rewrite <- H.\n  rewrite <- H2.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H0.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H0.\n  rewrite <- H2.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H0.\n  rewrite <- H1.\n  ring.\nQed.",
                    "Lemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H; intro q; intros.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\nLemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  assert ((a = 0) \\/ (q' * q)=1).\n  apply mult_lemma4.\n  replace (a*(q'*q)) with (a*q'*q);try (auto with arith).\n  case H3;intro.\n  rewrite H4 in H2;simpl in H2;rewrite H2;trivial.\n  elim (mult_lemma5 q' q H4);intros.\n  rewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\n",
                "context_tokens": 730,
                "proof_start_offset": 3412,
                "proof_end_offset": 4144,
                "proof": "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\nProof.\nintros.\napply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\nintro.\ncase n;intros.\nexists 0;auto with arith.\nelim (H0 ((S n0)-b)).\nintro q;intro.\nexists (S q).\nreplace (S n0) with (b+(S n0-b)).\nrewrite p;rewrite plus_comm;auto with arith.\nsymmetry.\napply le_plus_minus.\nelim H1;intros.\nrewrite H2.\nreplace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\napply mult_le_compat_r.\ndestruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\nsimpl;auto with arith.\ndestruct b.\nelim H1;simpl;intros;discriminate.\nomega.\napply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  decide (a=b).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* b <> q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* b <> q *)\n  case (Z_le_gt_dec (b-a) (b-a)).\n  (* a = q *)\n  case (Z_leQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q;intro.\n  exists (b * q).\n  rewrite H1.\n  rewrite (mult_comm a q);rewrite (mult_comm b q).\n  rewrite (mult_comm a q); rewrite (mult_comm a q).\n  rewrite (mult_comm b q);rewrite (mult_comm b q).\n  rewrite (mult_comm b q);rewrite (mult_comm b q).\n  rewrite (mult_comm a q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q); rewrite (mult_comm a q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q); rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm a q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (multQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q;intro.\n  exists (a+b).\n  rewrite H; ring.\n  elim H; intro q; intros.\n  exists (b*q).\n  rewrite H1; rewrite H2.\n  ring.\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  case (le_gt_dec 0 a).\n  left; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; autoQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q;intros.\n  rewrite H0.\n  exists (p-q).\n  rewrite (mult_comm a b);rewrite (mult_comm b q); rewrite (mult_comm b q);auto with arith.\n  rewrite H0.\n  exists (p-q).\n  rewrite (mult_comm a b);rewrite (mult_comm b q);rewrite (mult_comm b q);auto with arith.\n  rewrite H0.\n  rewrite (mult_comm b q);rewrite (mult_comm b q);auto with arith.\n  rewrite (mult_comm b q);rewrite (mult_comm b q);rewrite (mult_comm b q);rewrite (mult_comm b q);auto with arith.\n  rewrite <- H0.\n  exists (p-q).\n  rewrite (mult_comm b q);rewrite (mult_comm b q);rewrite (mult_comm b q);rewrite (mult_comm b q);auto with arith.\n  rewrite (mult_comm b q);rewrite (mult_comm b q);rewrite (mult_comm b q);auto with arith.\n  rewrite H0.\n  exists (p-q).\n  rewrite (mult_comm b qQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  case H; intro.\n  elim H0; intro q; intro.\n  case H0; intro.\n  rewrite H1; rewrite H2.\n  rewrite H2; rewrite <- H2; assumption.\n  intros.\n  case H0; intro.\n  rewrite H1; rewrite H2.\n  rewrite H2; rewrite H2.\n  ring.\n  intros.\n  case H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.\n  elim H0; intro.\n  rewrite H1; rewrite H2.\n  ring.\n  intros.Qed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  case (Z_dec_eq_dec a 0); intro.\n  left; exists 0.\n  split; [ right; reflexivity | left; reflexivity ].\n  right; intro.\n  rewrite H0.\n  rewrite (mult_comm a (b * q)) at 1.\n  rewrite (mult_comm a b (a * b)).\n  rewrite (mult_comm a b (a * b)).\n  rewrite (mult_comm a b (a * b)).\n  rewrite (mult_comm a b (a * b)).\n  rewrite (mult_comm b q); rewrite (mult_comm a b).\n  rewrite (mult_comm a b (a * b)).\n  rewrite (mult_comm b q); rewrite (mult_comm b q).\n  rewrite (mult_comm b q); rewrite (mult_comm a b).\n  rewrite (mult_comm b q); rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q).\n  rewrite (mult_comm b q); rewrite (mult_comm b q).\n  rewrite (mult_comm b q); rewrite (mult_comm b q).\n  rewrite (mult_comm b q); rewriteQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  case H.\n  left; apply le_antisym; auto with arith.\n  right; apply (H (b-a)).\n  right; apply (H (b-a)).\n  right; apply (H (b-a)).\n  right; apply (H (b-a)).\n  left; auto.\n  right; apply (H (b-a)).\n  right; apply (H (b-a)).\n  right; auto.\n  right; apply (H (b-a)).\n  right; auto.\n  right; apply (H (b-a)).\nQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  elim H; intro q; intro.\n  exists (b * q).\n  rewrite (Zmult_comm a b); rewrite (Zmult_comm a b).\n  rewrite (Zmult_comm b q); rewrite (Zmult_comm b q); rewrite (Zmult_comm b q).\n  rewrite (Zmult_comm b q); rewrite (Zmult_comm b q); rewrite (Zmult_comm a q); ring.\n  apply Zmult_gt_0_compat; assumption.\n  rewrite <- (Zmult_comm b q); rewrite (Zmult_comm b q); rewrite (Zmult_comm b q).\n  rewrite (Zmult_comm b q); rewrite (Zmult_comm b q); rewrite (Zmult_comm b q); ring.\n  apply Zmult_gt_0_compat; assumption.\n  apply Zmult_gt_0_compat; assumption.\n  replace (b * q + b * q) with (b * q + b * q).\n  rewrite (Zmult_comm b q); rewrite (Zmult_comm b q); rewrite (Zmult_comm b q); ring.\n  apply Zmult_gt_0_compat; assumption.\n  rewrite <- (Zmult_comm b q); rewrite (Zmult_comm b q); rewriteQed.",
                    "Lemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  assert (H: {q:nat | a = q} + {q:nat | a = q}).\n  apply (proj1 (H (a-b) H)).\n  apply H.\n  symmetry  in |- *.\n  rewrite <- (mult_comm a b) at 1.\n  apply (proj2 (H (a-b) H)).\n  apply (proj1 (H (a-b) H)).\n  apply (proj2 (H (a-b) H)).\n  apply (proj2 (H (a-b) H)).\n  apply (proj2 (H (a-b) H)).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": ".\nQed.\n\n(** corollary: forall a<>1, not(a | 1) *)\nLemma non_div_1 : forall (a:nat),(a<>1)->~(divides 1 a).\n  intros.\n  red.\n  intro.\n  apply H.\n  apply divides_antisym;trivial.\n  apply one_min_div.\nQed.\n\n(** if d | a and d | b then d | (a+b) *)\nLemma divides_plus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\n",
                "context_tokens": 727,
                "proof_start_offset": 4328,
                "proof_end_offset": 4482,
                "proof": "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\nintros.\nunfold quo.\ngeneralize (quo_dec a b H);intro;elim s;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  case (Z_le_lt_dec 0 (new a b H)).\n  intro.\n  case (Z_le_lt_dec 0 (new a b H)).\n  intro.\n  exists (S q).\n  rewrite mult_comm.\n  rewrite <- (mult_comm a b).\n  rewrite (mult_comm (S q)).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b a).\n  rewrite (mult_comm b (S q)).\n  rewrite (mult_comm b a).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_comm b c).\n  rewrite (mult_Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  replace (a + b) with (a + b).\n  apply (proj1 (H (refl_equal (S (a + b))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj1 (H (refl_equal (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2 (H (refl_equal (S (a + b)))).\n  apply (proj2Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)). \nProof.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (a * a) * b)).\n  apply (lt_wf_rec a (fun x:nat => (a * a) * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:nat => a * b)).\n  apply (lt_wf_rec a (fun x:Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold erased, not; intros.\n  elim H; intro.\n  elim H; intro.\n  exists (b * q).\n  rewrite <- H; rewrite <- H0.\n  replace (b * q) with (b * (q - p)).\n  rewrite <- H; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H0; ring.\n  rewrite <- H; ring.\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  case (Z_le_lt_dec 0 a); intro.\n  rewrite H; auto with arith.\n  elim (H0 (Build_finiteT H))); intro.\n  exists (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (min (max (max (max (min (max (max (max (max (max (max_max (max (max_max (max_max (max_r_max (max_r_max (max_r_max (max_r_max_r q))));\n    auto with arith.\n  rewrite <- H0; auto with arith.\n  rewrite <- H; auto with arith.\n  generalize (max_dec (min (max (max (max (max (max (max (max_max (max_dec (max (max_dec (max_r_max_r_max (max_r_max_l q))));\n    auto with arith.\n  rewrite <- H0; auto with arith.\n  rewrite <- H; auto with arith.\n  rewrite <- HQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (a <= x)%nat)).\n  intros.\n  elim H; intro.\n  apply H.\n  apply (lt_wf_rec a (fun x:nat => a <= x)%nat).\n  intros.\n  elim H; intro.\n  elim H1; intro.\n  exists (b * x)%nat.\n  split; [ assumption | apply (lt_wf_rec a (fun x:nat => a <= x)%nat).\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  exists (b * x)%nat.\n  split; [ assumption | apply (lt_wf_rec a (fun x:nat => a <= x)%nat).\n  intros; elim H0; intro.\n  exists (b * x)%nat; split; [ assumption | apply (lt_wf_rec a (fun x:nat => a <= x)%nat).\n  intros; elim H0; intro.\n  exists (b * x)%nat; split; [ assumption | apply (lt_wf_rec a (fun x:nat => a <= x)%nat).\n  intros; elim H0Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  apply (proj1 H).\n  apply (proj2 H).\n  apply (proj2 H).\nQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => a < x) H).\n  elim (lt_wf_rec a (fun x:nat => a < x) H); intro.\n  elim H; intro.\n  elim (H0 (H0 (S n0))); intros.\n  exists (a + b); auto with arith.\n  elim (H (S n0)); intros.\n  exists (a + b); auto with arith.\n  elim (H0 (S n0)); intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (a + b); auto with arith.\n  elim H; intros.\n  exists (aQed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\nProof.\n  unfold Zminus.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (a + x) H)).\n  apply (lt_wf_rec a (fun x:nat => (a + x) / (Qed.",
                    "Lemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  case (Z_le_dec b (quo a b H)).\n  intro.\n  rewrite H0.\n  apply divides_trans with (b * b); auto with arith.\n  rewrite <- H0; auto with arith.\n  apply lt_n_Sm_le.\n  elim H1; intros.\n  rewrite H0.\n  rewrite H1.\n  exists (b * x).\n  replace (x + (b * x)) with (x + (b * x)).\n  rewrite <- H0; rewrite <- H1; rewrite <- H2; ring.\n  symmetry.\n  apply lt_n_Sm_le.\n  elim H1; intros.\n  rewrite H1; rewrite H1; rewrite H2; auto with arith.\n  symmetry.\n  apply lt_n_Sm_le.\n  elim H1; intros.\n  rewrite H0; rewrite H1; auto with arith.\n  apply lt_n_Sm_le.\n  elim H1; intros.\n  rewrite H0; rewrite H1; auto with arith.\n  rewrite <- H1; auto with arith.\n  elim H1; intros.\n  rewrite H1; rewrite H0; auto with arith.\n  elim H1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": " forall (d a b:nat),(divides a d)->(divides b d)->(divides (plus a b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  exists (q+q').\n  rewrite H1;rewrite H2.\n  ring.\nQed.\n\n(** if d | a then d | a*b *)\nLemma divides_mult : forall (d a b:nat),(divides a d)->(divides (a*b) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  exists (b * q).\n  rewrite H0.\n  ring.\nQed.\n\n(** if d | a and d | b then d | (b-a) *)\nLemma divides_minus : forall (d a b:nat),(divides a d)->(divides b d)->(divides (b-a) d).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H1;rewrite H2.\n  exists (q'-q).\n  rewrite (mult_comm d q');rewrite (mult_comm d q);rewrite (mult_comm d (q'-q));auto with arith.\nQed.\n\n(** here we show that if b | a then it is possible to compute q such that a = b*q *)\nLemma quo_dec : forall (a b:nat),(divides a b)->{q:nat | a=b*q}.\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (divides x b)->{q:nat | x = b*q}));trivial.\n  intro.\n  case n;intros.\n  exists 0;auto with arith.\n  elim (H0 ((S n0)-b)).\n  intro q;intro.\n  exists (S q).\n  replace (S n0) with (b+(S n0-b)).\n  rewrite p;rewrite plus_comm;auto with arith.\n  symmetry.\n  apply le_plus_minus.\n  elim H1;intros.\n  rewrite H2.\n  replace (b <= b*x) with (1*b <= b*x);rewrite (mult_comm b x).\n  apply mult_le_compat_r.\n  destruct x;[rewrite mult_comm in H2;discriminate | auto with arith].\n  simpl;auto with arith.\n  destruct b.\n  elim H1;simpl;intros;discriminate.\n  omega.\n  apply (divides_minus b b (S n0));[apply divides_refl | trivial].\nQed.\n\n(** we can now define the quotient of a by b in case of b | a *)\nDefinition quo (a b:nat) (H:(divides a b)) := let (q,_):=(quo_dec a b H) in q.\n\n(** the quotient is the quotient! *)\nLemma quo_is_quo : forall (a b:nat)(H:divides a b),a=(mult b (quo a b H)).\n  intros.\n  unfold quo.\n  generalize (quo_dec a b H);intro;elim s;trivial.\nQed.\n\n(** if b | a then (n*a/b) = n*(a/b) *) \n",
                "context_tokens": 706,
                "proof_start_offset": 4524,
                "proof_end_offset": 5018,
                "proof": "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\nintros.\ngeneralize (quo_is_quo (a*n) b (divides_mult b a n H));intro.\ngeneralize (quo_is_quo a b H);intro.\nreplace (a*n = b * quo (a * n) b (divides_mult b a n H)) with (b*(quo a b H)*n = b * quo (a * n) b (divides_mult b a n H)) in H1.\nsymmetry;rewrite mult_comm.\napply mult_lemma6 with b;trivial.\nrewrite mult_assoc;trivial.\nrewrite <- H2;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\n  intros.\n  unfold Same_dir.\n  generalize (Qhomographic_mod a b H);intro; elim s; tauto.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\n  intros.\n  unfold na.\n  generalize (Qhomographic_sign_neg a b H);intro.\n  elim H; intro r; elim s; trivial.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold Hrest, Zminus.\n  rewrite (Z.mul_comm a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_comm a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n))).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n))).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n)).\n  rewrite <- (Z.mul_assoc a b (Z.mul (a*n))).\n  rewrite <- (Z.mul_Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a <= x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a <= x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (fun x:nat => (a < x)%nat)).\n  apply (lt_wf_rec a (funQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  apply (lt_wf_rec a (fun x:nat => (n,x)) H H0).\n  intros.\n  unfold Zminus.\n  generalize (quo_repr a b H); intro; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n  intros; simpl in H; elim H; trivial.\n Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold erased.\n  generalize (Qhomographic_mod_is_transitive a b H);intro.\n  rewrite H0.\n  rewrite <- H.\n  rewrite <- H0.\n  ring.\n  apply (lt_wf_rec a (fun x:nat => (a < x)%Z) (H0:=H)).\n  intros.\n  elim H0; intros.\n  rewrite H1.\n  replace (a + a) with (1*a + (1/b)).\n  rewrite <- H1; rewrite <- H2; ring.\n  apply lt_n_S.\n  replace (a + (1/b)) with (1*a).\n  rewrite <- H2; rewrite <- H0.\n  ring.\n  apply lt_n_S.\n  apply (lt_wf_rec a (fun x:nat => (a < x)%Z) (H0:=H)).\n  intros.\n  elim H0; intros.\n  rewrite H2.\n  rewrite H2.\n  apply (lt_wf_rec a (fun x:nat => (a >= x)%Z) (H0:=H)).\n  intros.\n  elim H0; intros.\n  rewrite H2.\n  replace (Qed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\n  intros.\n  unfold na.\n  generalize (Qhomographic_sign_mod a b H);intro; elim s; tauto.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\n  intros.\n  unfold na.\n  generalize (quo_interval a b H);intro; elim s; simpl; trivial.\n  elim H; simpl; intros.\n  elim H0; intros.\n  rewrite H1; rewrite H2; rewrite H3; rewrite H4; rewrite H4; reflexivity.\n  apply le_trans with (m + (n + (n + (n + (n + (n + (n + n0)))) + b * b).\n  apply le_plus_minus.\n  elim H; intros.\n  rewrite H1; rewrite H2; rewrite H3; rewrite H4; rewrite H4; reflexivity.\n  apply le_trans with (m + (n + (n + (n + (n + (n + n))) + b * b).\n  apply le_plus_minus.\n  elim H; intros.\n  rewrite H1; rewrite H2; rewrite H4; rewrite H4; rewrite H4; reflexivity.\n  apply le_plus_minus.\n  elim H; intros.\n  rewrite H1; rewrite H2; rewrite H3; rewrite H4; reflexivity.\n  apply le_plus_minus.\n  elim H; intros.\n  rewriteQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\n  intros.\n  unfold Rminus.\n  generalize (Qhomographic_mod a b H);intro; elim s; tauto.\nQed.",
                    "Lemma quo_mult : forall (a b:nat)(H:divides a b),forall (n:nat),(b<>O)->(quo (a*n) b (divides_mult b a n H))=n*(quo a b H).\nProof.\n  intros.\n  unfold num at 1.\n  generalize (Qhomographic_mod a b H);intro; elim s; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\n",
                "context_tokens": 314,
                "proof_start_offset": 1197,
                "proof_end_offset": 1343,
                "proof": "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold is_prime.\nintro.\nelim H;intros.\ncase (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold not in |- *; intros H; elim H.\n intros H1; elim H1; intros H2 H3;\n   elim H2; intros H5 H6;\n   elim H6; intros H7 H8; elim H7; intros H8 H9;\n   elim H9; intros H11 H12;\n   elim H13; intros H12 H13;\n   elim H13; intros H14 H15;\n   elim H15; intros H15 H16;\n   elim H16; intros H16 H17;\n   elim H18; intros H18 H19;\n   elim H18; intros H17 H18;\n   elim H18; intros H17 H18;\n   elim H18; intros H18 H20;\n   elim H18; intros H18 H19;\n   elim H18; intros H20 H18;\n   elim H18; intros H20 H21;\n   elim H18; intros H19 H20;\n   elim H18; intros H18 H20;\n   elim H18; intros H20 H21;\n   elim H18; intros H18 H19;\n   elim H18; intros H18 H19 H20;\n   elim H18;Qed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold not in |- *; auto with *.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold is_prime, is_prime, prime, pred_prime.\n split; intros.\n rewrite H0.\n rewrite <- H0.\n rewrite H1.\n reflexivity.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n  unfold is_prime; intros; split.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply prime_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lc_abs.\n  apply lcQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n split; intros (p,Hp).\n apply False_ind; apply H; apply eq_prime_refl.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n split.\n simpl in |- *.\n apply prime_abs.\n rewrite H0.\n apply prime_abs.\n simpl in |- *.\n apply gt_le_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0, H1)).\n apply gt_trans with (m := (p0,Qed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold not in |- *; auto with *.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\nunfold not; intros.\nunfold is_prime.\napply prime_sym_not_equal.\napply (is_prime_not_zero (p:=p)).\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n unfold not, prime,  split; simpl; tauto.\nQed.",
                    "Lemma not_prime_zero : ~(is_prime O).\nProof.\n split.\n apply is_prime_sym.\n split.\n apply Z.le_antisym.\n apply Z.le_lt_trans with (m:=m).\n apply Z.le_lt_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_lt_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.le_trans with (m:=m).\n apply Z.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\n",
                "context_tokens": 376,
                "proof_start_offset": 1372,
                "proof_end_offset": 1780,
                "proof": "Lemma is_prime_2 : (is_prime 2).\nProof.\nunfold is_prime.\nsplit.\nintro;discriminate.\nintros.\nelim H;destruct x;rewrite mult_comm.\nintro;discriminate.\nsimpl.\ncase d.\nsimpl.\nrewrite mult_comm;simpl;intro;discriminate.\nintros.\ninversion H0.\nsymmetry in H2.\ncase (plus_is_one n (x*(S n)) H2);intro.\nelim a;intros.\nleft;rewrite H1;trivial.\nelim a;intros.\nright;rewrite H1;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_2 p); intros.\n  case (not_prime_2 p); intros.\n  exists (1*p); split; trivial.\n  apply prime_cyclic_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (p:=p); trivial.\n  apply prime_factor_prime with (Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_3 p).\n  intro.\n  elim H0; intros.\n  elim H1; intros.\n  rewrite H2.\n  simpl in |- *.\n  rewrite H0.\n  rewrite H2.\n  simpl in |- *.\n  replace (p * (p * q)) with (p * q).\n  replace (p * q) with (p * q).\n  replace (p * q) with (p * q).\n  replace (p * q) with (p * q).\n  replace (p * q) with (p * q).\n  rewrite <- H5; rewrite H6; reflexivity.\n  ring.\n  ring.\n  ring.\nQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H4; intros.\n  split.\n  apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 2%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; apply (H1 1%Z).\n  simpl in |- *; applyQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_2 p); intros.\n  apply is_prime_2 with (p:=p).\n  elim H; intros.\n  case (not_prime_2 p); intros.\n  elim H2; intros.\n  apply is_prime_2 with (p:=p).\n  elim H3; intros.\n  case (not_prime_2 p); intros.\n  apply is_prime_3 with (p:=p).\n  elim H4; intros.\n  apply is_prime_2 with (p:=p).\n  elim H4; intros.\n  apply is_prime_3 with (p:=p).\n  elim H4; intros.\n  apply is_prime_2 with (p:=p).\n  elim H4; intros.\n  apply is_prime_3 with (p:=p).\n  elim H4; intros.\n  elim H5; intros.\n  apply is_prime_3 with (p:=p).\n  elim H5; intros.\n  apply is_prime_3 with (p:=p).\n  elim H4; intros.\n  apply is_prime_3 with (p:=pQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_2 p).\n  intro.\n  elim H0; intros.\n  apply H1.\n  assumption.\n  apply not_prime_2.\n  apply (not_prime_odd_2 p).\n  apply (not_prime_2 p).\n  apply (not_prime_odd_3 p).\n  apply (not_prime_2 p).\n  apply (not_prime_odd_3 p).\n  apply (not_prime_2 p).\n  apply (not_prime_3 p).\n  apply (not_prime_2 p).\n  assumption.\n  apply (not_prime_2 p).\n  apply (not_prime_3 p).\n  assumption.\n  apply (not_prime_2 q).\n  apply (not_prime_2 q).\n  apply (not_prime_2 q).\n  assumption.\n  apply (not_prime_2 q).\n  apply (not_prime_2 q).\n  apply (not_prime_3 q).\n  apply (not_prime_2 q).\n  apply (not_prime_3 q).\n  assumption.\n  apply (not_prime_Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_3 p H0); intro.\n  apply False_ind; apply H; apply not_prime_2.\n  apply (not_prime_2 (not_prime_3 q)).\n  apply (not_prime_3 (not_prime_3 q)).\n  apply (not_prime_3 (not_prime_3 q)).\n  apply (not_prime_3 (not_prime_3 q)).\n  apply (not_prime_4 (not_prime_4 q)).\n  apply (not_prime_4 q).\n  apply (not_prime_4 (not_prime_4 q)).\n  apply (not_prime_4 (not_prime_4 q)).\n  apply (not_prime_4 (not_prime_4 q)).\n  apply (not_prime_3 (not_prime_3 q)).\n  apply (not_prime_4 (not_prime_3 q)).\n  apply (not_prime_4 (not_prime_4 q)).\n  apply (not_prime_3 (not_prime_4 q)).\n  apply (not_prime_4 (Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_2 p); intros.\n  case (not_prime_2 p); intros.\n  rewrite H0 in H.\n  case (not_prime_2 p); intros.\n  rewrite H1 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H1 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H1 in H.\n  elim (not_prime_2 p); intros.\n  rewrite H2 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H2 in H.\n  elim (not_prime_4 p); intros.\n  rewrite H3 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H3 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H4 in H.\n  elim (not_prime_4 p); intros.\n  rewrite H5 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H5 in H.\n  elim (not_prime_3 p); intros.\n  rewrite H5 in H.\n Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\n unfold is_prime.\n  intro.\n  elim H; intros.\n  elim H0; intros.\n  case (not_prime_2 p); intros.\n  generalize H2; clear H2; intros.\n  apply H0.\n  apply prime_2.\n  apply prime_2.\n  apply prime_3.\n  apply prime_3.\n  apply prime_3.\n  apply prime_3.\n  apply prime_3.\n  apply prime_3.\n  apply prime_3.\n  apply prime_3.\n  apply: contra_prime; assumption.\n  apply prime_3.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_prime; assumption.\n  apply: contra_Qed.",
                    "Lemma is_prime_2 : (is_prime 2).\nProof.\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (not_prime_3 p); intros.\n  case (not_prime_3 p); intros.\n  apply H1.\n  apply H1.\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 p).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (inv_prime_3 q).\n  apply (invQed.",
                    "Lemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  intro.\n  elim H; intros.\n  case (Z_le_lt_dec (2 * q) (2 * q)); intros.\n  apply H1.\n  apply prime_2.\n  apply prime_3.\n  apply prime_3.\n  apply prime_2.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply prime_4.\n  apply: contraNneq q.\n  apply: contra q; apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra q.\n  apply: contra qQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\n",
                "context_tokens": 535,
                "proof_start_offset": 1852,
                "proof_end_offset": 2186,
                "proof": "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\nunfold is_prime.\nunfold rel_prime.\nintros.\nunfold is_gcd;unfold is_cd.\nsplit.\nsplit;apply one_min_div.\nintros.\nelim H;intros.\nelim H1;intros.\ncase (H3 d' H4);intro.\nrewrite H6;apply divides_refl.\nrewrite H6 in H5;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a Ha.\n  elim Ha; intros.\n  elim Ha; intros.\n  case (prime_dec p p).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simpl; intros; discriminate.\n  simpl; intros.\n  case (prime_dec p q).\n  simplQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros; unfold is_prime.\n  intros; elim H; intros.\n  case (le_gt_dec p p).\n  elim H2; intros.\n  case (le_gt_dec p p).\n  elim H2; intros.\n  case (le_gt_dec p p).\n  elim H2; intros.\n  case (le_gt_dec p p).\n  elim H4; intros.\n  case (le_gt_dec p p).\n  elim H4; intros.\n  rewrite H2; rewrite H3; trivial.\n  simpl.\n  case (le_gt_dec p p); intros.\n  elim H4; intros.\n  rewrite H5; rewrite H5; rewrite H5; rewrite H6; auto.\n  simpl; rewrite mult_comm; simpl; intro; discriminate.\n  simpl.\n  case (le_gt_dec p p); intros.\n  elim H5; intros.\n  rewrite H5; rewrite H6; rewrite H6; rewrite H7; auto.\n  simpl; rewrite mult_comm; simpl; intro; discriminate.\n  simpl.\n  case (le_gt_dec p p).\n  elim H5; intros.\n  rewrite HQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros; destruct (prime_prime_2 p) as [H|H].\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n  (* a < b *)\n  apply rel_prime_not_prime; assumption.\n  (* p < a *)\n  apply rel_prime_not_prime; assumption.\n  (* a <= b *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= b *)\n  apply rel_prime_not_prime; assumption.\n  (* p < a *)\n  apply rel_prime_not_prime; assumption.\n  (* p <= a *)\n  apply rel_prime_not_prime; assumption.\n Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  elim H; intros.\n  case (rel_prime_dec a a); intros.\n  case (rel_prime_dec a a); intros.\n  case (rel_prime_dec a a); intros.\n  case (rel_prime_dec a a); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a1); intros.\n  case (rel_prime_dec a a1); intros.\n  case (rel_prime_dec a a1); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a0); intros.\n  case (rel_prime_dec a a1); intros.\n  case (rel_prime_dec a a1); intros.\n  case (rel_prime_dec a a1); intros.\n  case (rel_prime_dec a aQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a.\n  elim (prime_dec a a).\n  intro.\n  case (prime_dec a a).\n  intro.\n  case (prime_dec a a).\n  intro.\n  case (not_prime_dec a a); intro.\n  case (prime_dec a a); intro.\n  case (not_prime_dec b a); intro.\n  case (not_prime_dec a a); intro.\n  case (not_prime_dec a a); intro.\n  case (prime_dec a a0); intro.\n  case (not_prime_dec b a0); intro.\n  case (not_prime_dec b a0); intro.\n  case (not_prime_dec a a0); intro.\n  case (not_prime_dec b a0); intro.\n  case (not_prime_dec a a0); intro.\n  case (not_prime_dec b a0); intro.\n  case (not_prime_dec a b0); intro.\n  case (not_prime_dec a b0); intro.\n  case (not_prime_dec a b); intro.\n  case (not_prime_dec b a0);Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a Ha.\n  case (gcd_prime_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (gcd_divisors p a); intros.\n  case (Qed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a Ha.\n  elim (prime_dec (prime_gt_1 p) a); intro.\n  elim (prime_dec (prime_gt_1 p) a); intro.\n  elim a; intros.\n  left; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_3; assumption.\n  right; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_3; assumption.\n  right; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_2; assumption.\n  right; apply prime_div_prime_2; assumption.\nQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros p a H.\n  destruct a.\n  left; apply prime_div_mod; auto.\n  intros.\n  elim H; elim H; intros.\n  right; auto.\n  right; auto.\n  intros.\n  case H0; elim H; intros.\n  right; auto.\n  right; auto.\n  intros.\n  case H0; elim H; intros.\n  right; auto.\n  right; auto.\n  right; auto.\n  intros.\n  case H; elim H; intros.\n  right; auto.\n  right; auto.\n  intros.\n  case H; elim H; intros.\n  right; auto.\n  left; auto.\n  right; auto.\n  intros.\n  case H; elim H; intros.\n  right; auto.\n  right; auto.\n  right; auto.\n  intros.\n  case H; elim H; intros.\n  left; auto.\n  right; auto.\n  right; auto.\n  intros.\n  case H; elim H; intros.\n  right; auto.\n  right; auto.\n  right; auto.\n  intros.\n  case H; elim H; intros.\n  right; auto.\n  right; auto.\n  intros.\n  case HQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n intros.\ndestruct (rel_prime_divisors p a) as [p0|p].\n(* Case 1 *)\n apply (rel_prime_2 _ H0).\n(* Case 1 *)\n apply (rel_prime_3 _ H1).\n(* Case 1 *)\n apply (rel_prime_3 _ H1).\n(* Case 1 *)\n apply (rel_prime_3 _ H2).\n(* Case 2 *)\n apply (rel_prime_3 _ H2).\n(* Case 2 *)\n apply (rel_prime_3 _ H3).\n(* Case 2 *)\napply (rel_prime_3 _ H3).\n(* Case 2 *)\n apply (rel_prime_3 _ H3).\n (* Case 3 *)\n apply (rel_prime_3 _ H4).\n(* Case 3 *)\n apply (rel_prime_3 _ H4).\n (* Case 2 *)\n apply (rel_prime_3 _ H4).\n (* Case 3 *)\n apply (rel_prime_3 _ H4).\n (* Case 3 *)\n apply (rel_prime_3 _ H4).\n (* Case 3 *)\n apply (rel_primeQed.",
                    "Lemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\nProof.\n  intros.\n  elim H; intros.\n  case (rel_prime_dec a p); intros.\n  elim H; intros.\n  case (rel_prime_dec a p0); intros.\n  elim H; intros.\n  case (rel_prime_dec a p0); intros.\n  elim H1; intros.\n  elim H2; intros.\n  case (rel_prime_dec a p0); intros.\n  elim H2; intros.\n  case (rel_prime_dec a p0); intros.\n  elim H4; intros.\n  elim H4; intros.\n  rewrite H2; auto with zarith.\n  elim (rel_prime_dec a p0); intros.\n  elim H5; intros.\n  rewrite H4; auto with zarith.\n  elim H5; intros.\n  rewrite H3; auto with zarith.\n  elim H5; intros.\n  case (rel_prime_dec a p1); intros.\n  elim H5; intros.\n  rewrite H5; auto with zarith.\n  elim H5; intros.\n  elim H5; intros.\n  rewrite H4; auto with zarith.\n  elim H5; intros.\n  rewrite H6; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\n",
                "context_tokens": 691,
                "proof_start_offset": 2286,
                "proof_end_offset": 2466,
                "proof": "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nunfold is_prime.\nintros.\nelim H;intros.\napply H2.\nelim H0;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros d p a Ha.\n  unfold is_gcd.\n  case (gcd_dec d a).\n  (* a = 1 *)\n  intros.\n  case (gcd_dec d a).\n  (* a = 1 *)\n  intros.\n  case (gcd_dec d a); intros.\n  (* a = 0 *)\n  intros.\n  case (gcd_dec d a).\n  (* a = 0 *)\n  intros.\n  case (gcd_dec d a); intros.\n  (* b = 0 *)\n  intros.\n  case (gcd_dec d a); intros.\n  case (gcd_dec d a); intros.\n  case (gcd_dec d a); intros.\n  (* a = 0 *)\n  intros.\n  case (gcd_dec d a); intros.\n  (* a = 0 *)\n  intros.\n  case (gcd_dec d a); intros.\n  (* a = 0 *)\n  intros.\n  case (gcd_dec d a); intros.\n  case (gcd_dec d a); intros.\n  (* a = 0 *)\n  intros.\n  case (gcd_dec d a); intros.\n  case (gcd_dec d a); intros.\n  (* a = 0 *)\n  intros.\n  caseQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H1; intros.\n  rewrite H2; rewrite H3; simpl; intro; discriminate.\n  elim H; intros.\n  rewrite H2; rewrite H3; simpl; intro; discriminate.\n  inversion H1; inversion H2; inversion H3; inversion H3; trivial.\n  inversion H1; inversion H3; inversion H3; trivial.\n  inversion H1; inversion H3; trivial.\n  inversion H1; inversion H3; trivial.\n  inversion H1; inversion H3; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion H1; trivial.\n  inversion HQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  elim H; intros.\n  rewrite H0 in H; discriminate H.\n  rewrite H0 in H; discriminate H.\n  rewrite H0 in H; discriminate H.\n  rewrite H0; discriminate H.\n  rewrite H1; discriminate H.\n  intros.\n  elim H; intros.\n  case (gcd_bezout_divisors a p); intros.\n  rewrite H0 in H; discriminate H.\n  rewrite H1 in H; discriminate H.\n  simpl; intros; discriminate H.\n  simpl; intros; discriminate H.\n  simpl; intros.\n  case (gcd_bezout_divisors a p); intros.\n  rewrite H1 in H; discriminate H.\n  rewrite H0 in H; discriminate H.\n  simpl; intros; discriminate H.\n  simpl; intros; discriminate H.\n  simpl; intros.\n  case H; intros.\n  case (gcd_bezout_divisors a p); intros.\n  rewrite H1 in H; discriminate H.\n  simpl; intros; discriminate H.\n  simpl; intros.\n  case (gcd_bezout_divisors a p); intros.\n  rewrite H1 in H; discriminate H.\n  simpl; intros.\n  case (gcd_bezout_divisors a p);Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H2; intros.\n  case (gcd_bezout_gcd_bezout_gcd a a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_greatest_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_bezout_gcd a b); intros.\n  case (gcd_Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\nunfold is_gcd.\nintros.\nunfold is_gcd;unfold is_gcd.\ngeneralize (gcd_nonneg_nonneg q a).\nintro.\nelim H; intros.\n  case (gcd_nonneg q a); intros; rewrite H2; auto with zarith.\n  rewrite H2; auto with zarith.\n  simpl; intros.\n  case (gcd_nonneg q a); intros; rewrite H2; auto with zarith.\n  rewrite H3; auto with zarith.\n  rewrite H3; auto with zarith.\n  simpl; intros.\n  case (gcd_nonneg q a); intros; rewrite H2; auto with zarith.\n  rewrite H3; auto with zarith.\n  rewrite H3; auto with zarith.\n  simpl; intros.\n  case (gcd_nonneg q a); intros; rewrite H2; auto with zarith.\n  rewrite H3; auto with zarith.\n  rewrite H3; auto with zarith.\n  rewrite H3; auto with zarith.\n  simpl; intros.\n  case (gcd_nonneg q a); intros; rewrite H2; auto with zarith.\n  rewrite H3; auto with zarith.\n  rewrite H3; auto with zarith.\n  simpl; intros.\n  case (Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  intros.\n  case (gcd_greatest p q a); intros.\n  rewrite H;apply prime_mult_l.\n  apply prime_div_1.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div_2.\n  apply prime_div2.\n  apply prime_div_2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n  apply prime_div2.\n Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  simple destruct d; simpl; intros.\n  case (gcd_greatest p q); intros; elim H; intros.\n  rewrite H2; apply prime_divide_r; trivial.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in H; discriminate.\n  simpl in HQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  rewrite H2; apply prime_div_exact.\n  rewrite H3; apply prime_div_exact; apply prime_div_2; assumption.\n  rewrite H3; apply prime_div_exact; apply prime_div_exact; assumption.\n  rewrite H3; apply prime_div_exact; apply prime_div_exact; assumption.\n  rewrite H3; apply prime_div_exact; apply prime_div_exact; assumption.\nQed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  intros.\n  rewrite <- H; apply prime_gcd_l.\n  apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H; apply prime_gcd_for_euclid with (p:=b).\n  rewrite <- H0; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H0; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H0; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H1; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H1; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H0; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H1; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H0; apply prime_gcd_for_euclid with (p:=a).\n  rewrite <- H0;Qed.",
                    "Lemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\nProof.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H; intros.\n  elim H; intros.\n  elim H2; intros.\n  split; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_1; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2; assumption.\n  simpl; apply prime_div_2;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "NU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\n",
                "context_tokens": 723,
                "proof_start_offset": 2516,
                "proof_end_offset": 2785,
                "proof": "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\nProof.\nunfold rel_prime.\nintros.\ngeneralize (gcd_is_gcd a p);intros.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\nelim H1;intros.\nelim H3;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  intros.\n  apply (non_prime_prime _ H).\n  apply prime_rel_prime.\n  unfold rel_prime.\n  intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  apply H4; apply H5.\n  elim H1; intros.\n  rewrite H5; apply prime_eq_prime; apply prime_ge_0.\n  apply prime_prime_gt.\n  intros.\n  elim H3; intros.\n  elim H5; intros.\n  elim H1; intros.\n  elim H5; intros.\n  rewrite H6; apply prime_eq_prime; apply prime_ge_0.\n  apply prime_prime_gt.\n  intros.\n  elim H1; intros.\n  rewrite H6; apply prime_eq_prime; apply prime_gt_0.\n  apply prime_prime_gt.\n  apply prime_prime_gt.\n  apply prime_prime_gt.\n  apply prime_gt_0.\n  intros.\n  elim H; intros.\n  rewrite H5; apply prime_eq_prime; apply prime_gt_0.\n  apply prime_prime_gt.\n  apply prime_gt_Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  case (H3 d'); intros.\n  rewrite H6; apply prime_prime_0.\n  rewrite H6; apply prime_prime_0.\n  rewrite H7; apply prime_gt_0.\n  rewrite H6; apply prime_prime_0.\n  rewrite H8; apply prime_prime_mod.\n  rewrite H8; apply prime_prime_gt_1.\n  rewrite H8; apply prime_prime_mod.\n  rewrite H8; apply prime_prime_mod.\n  rewrite H8; apply prime_prime_mod.\n  rewrite H8; apply prime_prime_mod.\n  rewrite H8; apply prime_prime_gt_0.\n  rewrite H8; apply prime_gt_0.\n  rewrite H8; apply prime_prime_gt_0.\n  rewrite H8; apply prime_prime_gt_0.\n  rewrite H8; apply prime_prime_mod.\n  rewrite H8; apply prime_gt_0.\n  rewrite H9; apply prime_prime_gt_Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  apply H0.\n  elim H1; intros.\n  elim H2; intros.\n  apply H1.\n  elim H4; intros.\n  case (H1 2); intros.\n  elim H4; intros.\n  left; rewrite H2; apply prime_gt_prime.\n  apply rel_prime_2.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply (fun p:nat => (a * p) * (a * a) * (a * a)).\n  apply prime_factor_prime; try assumption.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.\n  apply prime_factor_prime.Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  unfold rel_prime in |- *.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  case (H3 p); intros; elim H4; intros.\n  elim H5; intros.\n  rewrite H6; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H6; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H6; apply prime_prime_2; assumption.\n  rewrite H6; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H6; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H7; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H8; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H6; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H7; apply prime_prime_2; assumption.\n  elim H5; intros.\n  rewrite H7; apply prime_prime_2; assumption.\n  elim H5; intros.\n Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H1; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_rel_prime; trivial.\n  apply prime_Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  case (prime_dec a p); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  elim H; intros.\n  elim H1; intros.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_dec b p0); intro.\n  case (prime_dec a p0); intro.\n  case (prime_decQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  unfold rel_prime.\n  intros.\n  split.\n  intro; discriminate.\n  intros.\n  elim H0; intros.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  case (prime_dec p p); intro.\n  elim H2; intros.\n  case (prime_dec p p); intro.\n  elim H0; intros.\n  case (prime_dec p p); intro.\n  rewrite H5; apply prime_gt_1; auto.\n  elim H1; intros.\n  case (prime_dec p p); intro.\n  rewrite H5; apply prime_gt_1; auto.\n  elim H1; intros.\n  elim H1; intros.\n  apply H2.\n  elim H2; intros.\n  elim H3; intros.\n  case (not_prime_dec p p); intro.\n  rewrite H5; apply prime_gt_1; auto.\n  elim H3; intros.\n  apply H4.\n  elim H1; intros.\n  case (prime_dec p p); intro.\n  rewrite H5; apply prime_gt_1; auto.\n  elim H2; intros.Qed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim HQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  apply H5; rewrite H5; apply prime_minus_div; assumption.\n  elim H5; intros.\n  elim H5; intros.\n  apply H5; rewrite H5; apply prime_minus_div; assumption.\n  elim H5; intros.\n  apply H5; rewrite H6; apply prime_minus_div; assumption.\n  elim H5; intros.\n  elim H5; intros.\n  apply H6; rewrite H5; apply prime_minus_div; assumption.\n  elim H5; intros.\n  apply H6; rewrite H5; apply prime_minus_div; assumption.\n  elim H5; intros.\n  apply H5; rewrite H5; apply prime_minus_div; assumption.\n  elim H5; intros.\n  apply H5; rewrite H5; apply prime_minus_div; assumption.\n  elim H5; intros.\n  elim HQed.",
                    "Lemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  apply H1.\n  elim H1; intros.\n  case (H2 p); intros.\n  elim H2; intros.\n  rewrite H3; rewrite H2; rewrite H3; ring.\n  elim H0; intros.\n  rewrite H3; rewrite H3; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H3; rewrite H2; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H3; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H3; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H3; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H4; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H4; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H3; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H4; ring.\n  elim H0; intros.\n  rewrite H4; rewrite H4; ring.\n  elim H0; intros.\n  rewrite H3; rewrite HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import euclide.\nRequire Import gcd.\nRequire Import power.\nRequire Import permutation.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** definition of a \"prime number\" *)\nDefinition is_prime (p:nat) := (p<>1)/\\(forall (d:nat),(divides p d)->(d=1)\\/(d=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\n",
                "context_tokens": 720,
                "proof_start_offset": 2840,
                "proof_end_offset": 3139,
                "proof": "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a p);intro.\ncase (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\nright;apply gauss with a;trivial.\nred in H1;elim H1;intros.\nred in H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_gcd.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  split; apply prime_mult_l.\n  intros.\n  elim H0; intros.\n  elim H2; intros.\n  elim H4; intros.\n  apply H5; apply prime_mult_l; auto.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  apply H5; apply prime_mult_l; auto.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  apply H6; apply prime_mult_l; auto.\n  elim H4; intros.\n  elim H4; intros.\n  apply H5; apply prime_mult_l; auto.\n  elim H4; intros.\n  apply H5; apply prime_mult_l; auto.\n  elim H4; intros.\n  apply H5; apply prime_mult_l; auto.\n  elim H4; intros.\n  apply H5; apply prime_mult_l; auto.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5;Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  rewrite H6; rewrite H7; apply until_even; auto.\n  rewrite H7; apply prime_prime.\n  generalize (gcd_not_gcd a p); intros.\n  case (gcd_not_gcd (gcd a p) p a H H0 H1); intro; rewrite H6 in H3; try assumption.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  rewrite H6; rewrite H7; apply until_even; auto.\n  rewrite H7; apply prime_prime.\n  generalize (gcd_not_gcd a p); intros.\n  case (gcd_not_gcd a p a H); intro; rewrite H6 in H3; try assumption.\n  elim H6; intros.Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) a H H0);intro;rewrite H2 in H1; try tauto.\n  elim H1; intros.\n  rewrite H2; rewrite H3; apply prime_gt_2; auto.\n  elim H3; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim H3; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim H3; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim H4; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim H4; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim H4; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim H4; intros.\n  rewrite H4; rewrite H4; apply prime_gt_2; auto.\n  elim HQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\nProof.\n  intros p a b; case (prime_div_mod_bound p a b); intros; rewrite H2 in H; try tauto.\n  elim H0; intros.\n  case (prime_div_mod_aux p a b); intros; rewrite H3;apply prime_factor_bound; assumption.\n  elim H3; intros.\n  case (prime_div_mod_aux p a b); intros; rewrite H3; apply prime_factor_bound; assumption.\n  elim H1; intros.\n  case (prime_mod_aux p a b); intros; rewrite H3; apply prime_factor_bound; assumption.\n  elim H2; intros.\n  case (prime_mod_aux p a b); intros; rewrite H3; apply prime_factor_bound; assumption.\n  elim H3; intros.\n  case (prime_mod_aux p a b); intros; rewrite H3; apply prime_factor_bound; assumption.\n  elim H3; intros.\n  case (prime_mod_aux p a b); intros; rewrite H4; apply prime_factor_bound; assumption.\n  elim H3; intros.\n  case (prime_mod_auxQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_gcd.\n  intros.\n  generalize (gcd_nonneg_nonneg a p);intros.\n  case (gcd_prime a p) as (q,H); simpl in H; rewrite H2 in H; try tauto.\n  elim H; intros.\n  elim H0; trivial.\n  rewrite H2 in H5; discriminate.\n  elim H0; trivial.\n  elim H0; trivial.\n  rewrite H1 in H5; discriminate.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0; trivial.\n  elim H0;Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold not in |- *; intros.\n  generalize (gcd_correct_divisors a p);intro.\n  case (prime_divisors (gcd a p) a H);intros;rewrite H2 in H1; try tauto.\n  elim H1; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; introsQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H1; intros.\n  case (H1 1); intro.\n  rewrite H2; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  rewrite H5; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H5; apply prime_factor_bound.\n  assumption.\n  elim H2; intros.\n  elim H4; intros.\n  rewrite H6; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H6; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H6; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H6; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H6; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H6; apply prime_factor_bound.\n  assumption.\n  elim H1; intros.\n  rewrite H6; applyQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold not; intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (gcd_bezout (gcd a p) a b H H0);intro.\n  elim H1; intros.\n  apply H2.\n  elim H3; intros.\n  rewrite H4; apply prime_prime_2; auto.\n  rewrite H4; apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2; auto.\n  apply prime_cyclic_prime_2; auto.\n  apply prime_cyclic_prime_3; auto.\n  apply prime_prime_2; auto.\n  apply prime_prime_2Qed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold is_gcd.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H0);intro;rewrite H2 in H1; try tauto.\n  elim H1; intros.\n  elim H3; intros.\n  rewrite H3; apply prime_prime_refl.\n  rewrite H3; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H4; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H3; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H4; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H4; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H4; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H4; apply prime_prime_gt_2; assumption.\n  elim H1; intros.\n  rewrite H4; apply prime_prime_gt_2; assumption.\n  elimQed.",
                    "Lemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  unfold not; intros.\n  elim H; intros.\n  elim H1; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "=p)).\n\nLemma not_prime_zero : ~(is_prime O).\n  unfold is_prime.\n  intro.\n  elim H;intros.\n  case (H1 2);try (apply zero_max_div);intro;discriminate.\nQed.\n\n(** 2 is a prime number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\n",
                "context_tokens": 729,
                "proof_start_offset": 3196,
                "proof_end_offset": 3355,
                "proof": "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\nunfold square.\nintros;case (prime_mult p a a H H0);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  right; rewrite H2; apply prime_mult_l; assumption.\n  red in H2; elim H2; intros.\n  elim H2; intros.\n  right; rewrite H3; apply prime_mult_l; assumption.\n  red in H2; elim H2; intros.\n  right; rewrite H3; apply prime_mult_l; assumption.\n  red in H2; elim H2; intros.\n  left; rewrite H3; apply prime_mult_l; assumption.\n  red in H2; elim H2; intros.\n  right; rewrite H3; apply prime_mult_l; assumption.\n  red in H2; elim H2; intros.\n  elim H2; intros.\n  right; rewrite H3; apply prime_mult_l; assumption.\n  red in H1; elim H2; intros.\n  right; rewrite H4; apply prime_mult_l; assumption.\n  red in H1; elim H2; intros.\n  right; rewrite H4; apply prime_mult_l; assumption.\n Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  left; rewrite H4; rewrite H4; rewrite H5; apply prime_factor_bound.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elimQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\nProof.\n  unfold is_prime.\n  intros.\n  generalize (gcd_div_mod p p);intro.\n  case (prime_even a p) as [p|p]; intros; rewrite H2 in H1; try tauto.\n  generalize (gcd_nonneg a p);intro.\n  rewrite H2 in H1; tauto.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  simpl; rewrite H2; rewrite H4; rewrite H5; ring.\n  simpl; rewrite H5; rewrite H5; ring.\n  simpl; rewrite H5; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewrite H5; ring.\n  simpl; rewriteQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  generalize (gcd_gcd a p);intro.\n  case (gcd_gcd a p a H H0);intros;rewrite H2 in H1;try tauto.\n  elim H1;intros; rewrite H2 in H1;try tauto.\n  elim H1;intros; rewrite H2 in H1; try tauto.\n  simpl; tauto.\n  elim H1; intros.\n  red in H4; elim H4; intros.\n  rewrite H4 in H1; try tauto.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H0; intros.\n  apply H2.\n  elim H0; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H0; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  apply HQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_gcd.\n  intros.\n  generalize (gcd_nonneg_nonneg p);intro.\n  case (prime_gcd (gcd a p) a H H0);intro;rewrite H2 in H0; try tauto.\n  elim H1; intros.\n  generalize (gcd_nonneg_nonneg p);intro.\n  case (gcd_nonneg (gcd a p) a H H0);intro; rewrite H2 in H0; try tauto.\n  elim H0; intros.\n  generalize (gcd_nonneg_nonneg p);intro.\n  case (gcd_nonneg (gcd a p) b H H0);intro; rewrite H2 in H0; try tauto.\n  elim H0; intros.\n  generalize (gcd_nonneg_nonneg p); intro.\n  case (gcd_nonneg (gcd a p) b H H0);intro; rewrite H2 in H0; try tauto.\n  elim H0; intros.\n  generalize (gcd_nonneg_nonneg p); intro.\n  case (gcd_nonneg (gcd a p) b H H0); intro; rewrite H2 in H0; try tauto.\n  elim H0; intros.\n  generalize (gcd_nonneg_nonneg p); intro.Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  generalize (gcd_nonneg_nonneg p);intro.\n  case (gcd_nonneg a p) as [H|H].\n  left; apply prime_pos.\n  split; apply prime_prime_2; auto.\n  left; apply prime_prime_2; auto.\n  right; apply prime_prime_2; auto.\nQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  generalize (gcd_divisors a p);intro.\n  case (prime_dec (gcd a p) a); intro.\n  rewrite H0 in H1.\n  generalize (gcd_nonneg_nonneg a p);intro.\n  case (prime_gcd (gcd a p) a H1); intro; rewrite H2 in H2.\n  apply Zis_gcd_for_euclid with p; auto.\n  red in H1; elim H1; intros.\n  apply H2.\n  elim H1; intros.\n  case (gcd_greatest p a p); intro; rewrite H2 in H2; try tauto.\n  rewrite H3 in H2; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in H1; discriminate.\n  rewrite H3 in HQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  apply H1.\n  elim H1; intros.\n  rewrite H2; rewrite H3; apply prime_cyclic.\n  apply prime_cyclic.\n  elim H1; intros.\n  apply H1.\n  elim H2; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  apply prime_cyclic.\n  elim H1; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  elim H1; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  elim H0; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  elim H0; intros.\n  rewrite H5; rewrite H4; apply prime_cyclic.\n  elim H; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  elim H1; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  elim H0; intros.\n  rewrite H4; rewrite H4; apply prime_cyclic.\n  elim H0; intros.\n  rewrite H4; rewrite H4; applyQed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  apply H1.\n  elim H2; intros.\n  apply H3; auto.\n  elim H3; intros.\n  elim H4; intros.\n  apply H4; auto.\n  apply H4; auto.\n  elim H4; intros.\n  elim H4; intros.\n  apply H4; auto.\n  elim H4; intros.\n  apply H4; auto.\n  elim H4; intros.\n  apply H4; auto.\n  elim H4; intros.\n  apply H4; auto.\n  elim H4; intros.\n  apply H4; auto.\n  elim H4; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H4; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5; intros.\n  apply H5; auto.\n  elim H5;Qed.",
                    "Lemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold is_prime.\n  unfold is_prime.\n  unfold is_gcd.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  rewrite H2; apply prime_cyclic_mult; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply prime_cyclic_Aut_cyclic; auto.\n  apply (cyclic_cyclic_Aut_cyclic_cyclic _ (Aut_cyclic_cyclic _ (Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Aut_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " number *)\nLemma is_prime_2 : (is_prime 2).\n  unfold is_prime.\n  split.\n  intro;discriminate.\n  intros.\n  elim H;destruct x;rewrite mult_comm.\n  intro;discriminate.\n  simpl.\n  case d.\n  simpl.\n  rewrite mult_comm;simpl;intro;discriminate.\n  intros.\n  inversion H0.\n  symmetry in H2.\n  case (plus_is_one n (x*(S n)) H2);intro.\n  elim a;intros.\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\n",
                "context_tokens": 727,
                "proof_start_offset": 3388,
                "proof_end_offset": 3666,
                "proof": "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\ninduction n;simpl;intros.\nelim H;intros.\nelim H1;apply divides_antisym;trivial;apply one_min_div.\ncase (prime_mult p x (power x n) H H0);trivial.\nintro;apply IHn;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\nintros p n x; case n.\nsimpl; intros.\nrewrite prime_power; auto with *.\nrewrite prime_power; auto with *.\nrewrite prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewrite <- prime_power; auto with *.\nrewriteQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\n  unfold prime.\n  intros; case (prime_div_mod p n x); trivial.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\n unfold is_prime.\n intros (a,p); exists a.\n split; apply prime_factor_pos; auto.\n intros.\n generalize (gcd_nonneg a p); intro.\n rewrite H0 in H; try discriminate.\n generalize (gcd_nonneg a p); intro.\n rewrite H0 in H; try discriminate.\n simpl in H; discriminate.\nQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\n  unfold is_prime.\n  intros.\n  apply prime_power.\n  apply prime_power.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.\n  apply prime_power_nat.Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\n  unfold prime.\n  intros.\n  destruct (ppower_nat_dec n 0) as [p0|p0].\n  simpl; auto.\n  intros.\n  apply prime_div_pos; auto.\n  replace (S (p + 1)) with (S (p0 + 1)).\n  replace (S (p + 1)) with (S (p0 + 1)).\n  replace (S (p + 1)) with (S (p0 + 1)).\n  replace (S (p + 1)) with (S (p0 + 1)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  simpl; ring.\n  apply prime_div_pos; auto.\n  replace (S (p + 1)) with (S (p0 + 1)).\n  replace (S (p + 1)) with (S (p0 + 1)).\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm (p + 1)).\n  rewrite mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite mult_comm.\n  simpl; ring.\n  apply prime_div_pos; auto.\n  replace (SQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H7; intros.\n  elim H7; intros.\n  apply H8; assumption.\n  elim H7; intros.\n  elim H7; intros.\n  apply H8; assumption.\n  elim H8; intros.\n  elim H6; intros.\n  apply H9; assumption.\n  elim H7; intros.\n  apply H9; assumption.\n  elim H8; intros.\n  apply H9; assumption.\n  elim H8; intros.\n  apply H9; assumption.\n  elim H8; intros.\n  apply H9; assumption.\n  elim H9; intros.\n  apply H9; assumption.\n  elim H8; intros.\n  apply H9; assumption.\n  elim H8; intros.\n  apply H10; assumption.\n  elim H8; intros.\n  apply H10; assumption.\n  elim H8; intros.\n  apply H9; assumption.\n  elim HQed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  unfold is_prime.\n  intros.\n  generalize (not_prime_mod (prime_gt_0 p) (prime_mod x p) H0);intro.\n  case (prime_odd (prime_div_mod x p) n x H0); intros.\n  elim H0; intros.\n  apply H2.\n  apply prime_div_2; assumption.\n  generalize (not_prime_mod (prime_gt_0 p) (prime_mod x p) H0);intro.\n  elim H1; intros.\n  rewrite H2 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3 in H5; discriminate.\n  rewrite H3Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_prime.\n  intros.\n  generalize (prime_div_mod p n x);intro.\n  case (prime_dec (gcd x p) n); intros.\n  rewrite H1 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H1; rewrite H2;ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  rewrite H1; ring.\n  ring.\n  rewrite H1; ring.\n  ring.\n  ring.\n  rewrite H1; ring.\n  ring.\n  rewrite H1; ring.\n  ring.\n  ring.\n  rewrite H1; ring.\n  ring.\n  ring.\n  ring.\n  rewrite H1; ring.\n Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  unfold is_gcd.\n  intros.\n  apply (prime_dec (prime_mod x p) (prime_mod x p) H0).\n  apply (prime_mod (prime_mod x p) (prime_mod x p) H H0).\n  apply (prime_mod (prime_mod x p) (prime_mod x p) H H1).\n  apply (prime_mod_eq (prime_mod x p) (prime_mod x p) H H1).\n  apply (prime_mod_eq (prime_mod x p) (prime_mod x p) H H1).\n  apply prime_mod_eq.\n  generalize (gcd_mod x p);intro.\n  case (prime_mod (prime_mod x p) p) as (r,r); simpl in *.\n  case (prime_mod r r); simpl; intros; rewrite H1 in H1; try discriminate; simpl;\n  generalize (Zpos_1_r (Zpos_1_r (Zpos p) r (Zpos_1_r (Zpos p) r)); \n  intro H2; rewrite H2 in H2; try discriminate; simpl;\n  rewrite H2; rewrite H3Qed.",
                    "Lemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\nProof.\n  unfold is_prime.\n  intros p n x0 p0 H1 H2.\n  generalize (prime_mod_bound p n);intro.\n  case (prime_mod_bound p n (x0 * x0) p0); intro; rewrite H2 in H1; try tauto.\n  generalize (prime_mod_bound p n x0 p0);intro.\n  rewrite H2 in H1; try tauto.\n  generalize (prime_mod_eq_full p n x0 p0);intro.\n  generalize (prime_mod_eq_full p n x0 p0 H1);intro.\n  rewrite H1 in H1; try tauto.\n  generalize (prime_mod_eq_full p n x0 p0);intro.\n  rewrite H2 in H1; try tauto.\n  generalize (prime_mod_eq_full p n x0 p0 H1);intro.\n  rewrite H2 in H1; try tauto.\n  generalize (prime_mod_eq_full p n x0 p0 H1);intro.\n  rewrite H2 in H1; try tauto.\n  generalize (prime_mod_eq_full p n x0 p0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  left;rewrite H1;trivial.\n  elim a;intros.\n  right;rewrite H1;trivial.\nQed.\n\n(** if p is prime and not(p | a) then a and p are relatively prime *)\nLemma prime_div_gcd : forall (p a:nat),(is_prime p)->~(divides a p)->(rel_prime p a).\n  unfold is_prime.\n  unfold rel_prime.\n  intros.\n  unfold is_gcd;unfold is_cd.\n  split.\n  split;apply one_min_div.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  case (H3 d' H4);intro.\n  rewrite H6;apply divides_refl.\n  rewrite H6 in H5;tauto.\nQed.\n\n(** We show some lemmae about prime numbers *)\n(** if p is prime then gcd(a,p)=1 or gcd(a,p)=p *)\nLemma prime_gcd : forall (d p a:nat),(is_prime p)->(is_gcd d a p)->(d=1)\\/(d=p).\n  unfold is_prime.\n  intros.\n  elim H;intros.\n  apply H2.\n  elim H0;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and gcd(a,p)<>1 then p | a *)\nLemma prime_rel_prime : forall (p a:nat),(is_prime p)->~(rel_prime a p)->(divides a p).\n  unfold rel_prime.\n  intros.\n  generalize (gcd_is_gcd a p);intros.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1;try tauto.\n  elim H1;intros.\n  elim H3;trivial.\nQed.\n\n(** if p is prime and p | a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 3668,
                "proof_end_offset": 4798,
                "proof": "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\ninduction q;simpl;intros.\napply one_min_div.\nrewrite power_plus_lemma1 in H0.\nassert (divides x (power p q)).\napply IHq;trivial.\nelim H0;intros;exists ((power p n)*x0).\nrewrite H2;ring.\nelim H2;intros.\nrewrite H3 in H0.\nrewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\nelim H0;intros.\nassert ((power p (q*n))<>0).\nintro.\ngeneralize (power_zero (q*n) p H5).\nintro.\napply not_prime_zero.\nrewrite H6 in H;trivial.\nrewrite <- mult_assoc in H4.\ngeneralize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\nintro.\nassert (exists n':nat,n=(S n')).\ninversion H1;[exists 0 | exists m];trivial.\nelim H7;intro n';intro.\nrewrite H8 in H6;simpl in H6.\nassert (divides x0 p).\ncase (prime_mult p x0 (power x0 n'));trivial.\nrewrite H6.\nexists ((power p n')*x1);ring.\nintro.\napply prime_power with n';trivial.\nelim H9;intros.\nrewrite H10 in H3.\nrewrite H3.\nexists x2;ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\n  unfold is_prime; intros.\n  generalize (gcd_nonneg_nonneg q (gcd x n) (gcd x n) H);intro.\n  rewrite H0 in H; discriminate H.\n  apply prime_power_qn; tauto.\n  apply prime_power_q_n; tauto.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H6; intros.Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_div_mod p p n q);intro.\n  case (prime_mod p q n x);intros;rewrite H2 in H0;try tauto.\n  elim H0;intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6;Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_factor_prime p n q x);intro.\n  case (prime_mod p x (power x n) H H0);intro.\n  rewrite H1;rewrite H2;apply prime_power_p;auto.\n  rewrite H2;apply prime_power_p;auto.\n  rewrite H2;apply prime_power_p;auto.\n  generalize (prime_factor_prime p n q x);intro.\n  case (prime_factor_prime p n q x); intros.\n  rewrite H2 in H2; rewrite H2 in H2; try tauto.\n  generalize (gcd_correct2 p n);intro.\n  rewrite H2 in H2; rewrite H2 in H2; try tauto.\n  elim H2; intros.\n  red in H4; rewrite H2 in H4; try tauto.\n  elim H4; intros.\n  rewrite H4 in H4; rewrite H4 in H4; try tauto.\n  elim (prime_div_mod p x (power x n) H H0 H1); intros.\n  rewrite H4 in H4; rewrite H4 in H4; try tauto.\n  elim (prime_divQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_div_gcd p q);intro.\n  case (prime_mod_p q n x H0);trivial.\n  intro; apply H2.\n  elim H;intros.\n  elim H2;intros.\n  case H3; intros; assumption.\n  elim H3; intros; assumption.\n  elim H3; intros; assumption.\n  elim H3; intros; assumption.\n  elim H4; intros; assumption.\n  elim H3; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; intros; assumption.\n  elim H4; introsQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros; case (prime_dec p q); trivial.\n  intro; apply H; apply prime_div_qn; trivial.\n  intro; apply H0; apply prime_div_r; trivial.\n  case (prime_dec (p * n) (q * n)); trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  case (prime_dec (p * n) q); trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r; trivial.\n  intro; apply H; apply prime_div_r;Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\nProof.\n  intros; split.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\n  apply prime_div_p; auto.\nQed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (prime_div_mod p q x);intro.\n  case (prime_mod p q x); simpl;intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H6; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H7; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H9; intros.\n  elim H9; intros.\n  elim H8; intros.\n  elim H9; intros.\n Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n \nProof.\n  intros p n x q x q x q.\n  pattern p at 1; replace p with (q*n); auto with zarith.\n  rewrite <- H; apply prime_power_r.\n  intros; apply H; apply prime_power_r.\n  apply prime_power_r.\n  apply prime_power_r.\n  apply prime_power_r.\n  apply prime_power_p.\n  apply prime_power_r.\n  apply prime_power_p.\n  apply prime_power_p.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_pos.\n  apply prime_power_Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros p n q x; elim n; simpl; intros.\n  elim H; intros.\n  elim H2; intros.\n  elim H3; intros.\n  elim H3; intros.\n  elim H4; intros.\n  elim H4; intros.\n  apply H5; assumption.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  apply H5; assumption.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  apply H6; assumption.\n  elim H5; intros.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H6; intros.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H6; intros.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H6; intros.\n  apply H6; assumption.\n  elim H6; intros.\n  apply H7; assumption.\n  elim H6; intros.\n  apply H6;Qed.",
                    "Lemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  intros.\n  generalize (gcd_div_mod p q);intro.\n  case (prime_mod p q n x); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg p q);intro.\n  case (prime_dec (gcd x p) q); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg q q);intro.\n  case (gcd_nonneg x p); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg q p);intro.\n  case (gcd_nonneg x p); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg q p);intro.\n  case (gcd_nonneg x p); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg q q);intro.\n  case (gcd_nonneg x p); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg q p);intro.\n  case (gcd_nonneg x p); trivial.\n  intro; apply H; trivial.\n  generalize (gcd_nonneg_nonneg q p);intro.\n  case (gcd_nonneg x p); trivialQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " a*b then p | a or p | b *)\nLemma prime_mult : forall (p a b:nat),(is_prime p)->(divides (a*b) p)->((divides a p)\\/(divides b p)).\n  intros.\n  generalize (gcd_is_gcd a p);intro.\n  case (prime_gcd (gcd a p) p a H H1);intro;rewrite H2 in H1.\n  right;apply gauss with a;trivial.\n  red in H1;elim H1;intros.\n  red in H3;tauto.\nQed.\n\n(** corollary: if p is prime and p | a^2 then p | a *)\nLemma prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\n",
                "context_tokens": 719,
                "proof_start_offset": 4831,
                "proof_end_offset": 5126,
                "proof": "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\nintros;intro.\nelim H;intro p;intro.\nelim H1;intros.\nelim H3;intros.\nunfold is_prime in H0.\nelim H0;intros.\nunfold is_prime in H4.\nelim H4;intros.\ncase (H7 p H5);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha.\n  elim (prime_prime_not_prime _ (prime_not_prime _ _)) (prime_not_prime _ _ Ha).\n  intros; exists (p,p).\n  rewrite <- H.\n  rewrite <- H.\n  rewrite <- prime_prime_mult.\n  rewrite <- prime_mult.\n  rewrite (factor_correct2 a p).\n  rewrite (factor_correct2 a p).\n  rewrite <- (mult_comm (p-p)).\n  rewrite <- mult_assoc.\n  rewrite <- (mult_assoc (p+p)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite (mult_comm (p+p)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <- (mult_comm (p*a)).\n  rewrite (mult_comm (p*a)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <- (mult_assoc (p*a)).\n  rewrite <-Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elim Ha; intros.\n  elimQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha.\n  apply (gcd_unique a Ha).\n  apply prime_mult_l.\n  apply prime_div_mod; auto.\n  apply prime_div_mod; auto.\n  apply prime_div_mod; auto.\n  apply prime_mod_mult; auto.\n  apply prime_div_mod; auto.\n  apply prime_mod_mult; auto.\n  apply prime_mod_mult; auto.\n  apply prime_mod; auto.\n  apply prime_mod_mult; auto.\n  apply prime_mod_mult; auto.\n  apply prime_mod_mult; auto.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n intros a Ha Hb.\n generalize (gcd_nonneg a Ha);intro.\n assert (H := prime_power_pos a Ha).\n apply prime_div_intro with (p:=a); trivial.\n apply prime_power_pos; trivial.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros a Ha H.\n  elim (prime_dec (prime_not_prime a) (prime_not_prime a)); intro.\n  elim (prime_not_prime (prime_not_prime a) H H0); intros.\n  elim (prime_not_prime (prime_not_prime a) H0); intros.\n  elim (prime_not_prime (not_prime a) H H1); intros.\n  rewrite H5 in H6; discriminate H6.\n  rewrite H6 in H6; discriminate H6.\n  rewrite H6 in H6; discriminate H6.\n  rewrite H7; rewrite H8; ring.\n  rewrite H8; ring.\n  rewrite H8; ring.\n  rewrite H8; ring.\n  rewrite <- H9; ring.\n  rewrite <- H8; ring.\n  rewrite <- H9; ring.\n  rewrite <- H9; ring.\n  rewrite <- H9; ring.\n  rewrite H9; ring.\n  rewrite <- H9; ring.\n  rewrite <- H9; ring.\n  ring.\n  rewrite <- H9; ring.\n  rewrite <- H9; ring.\n  ring.\n  rewrite <- H9; ring.\n  rewriteQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha.\n  unfold Bezout in Ha.\n  elim Ha; intros.\n  apply prime_prime; assumption.\n  elim H; intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  rewrite H3 in H4; rewrite H4 in H4; elim H4; intros.\n  rewrite H4 in H5; rewrite H5 in H5; elim H5; intros.\n  rewrite H5 in H6; rewrite H5 in H5; rewrite H5 in H5.\n  exists x0; ring.\n  elim H5; intros.\n  rewrite H3 in H3; rewrite H4 in H5; rewrite H5 in H5; elim H5; intros.\n  rewrite H5 in H5; rewrite H5 in H5; rewrite H5 in H5.\n  exists x0; ring.\n  elim H5; intros.\n  rewrite H3 in H4; rewrite H5 in H4; rewrite H5 in H5; elim H5; intros.\n  rewrite H5 in H4; rewrite H5 in H4; rewrite H5 in H5; elim H5; intros.\n  rewrite HQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros.\n  elim H; intros.\n  elim H0; intros.\n  elim H1; intros.\n  elim H2; intros.\n  right; apply H2.\n  left; assumption.\n  right; apply H2.\n  right; apply H3.\n  right; apply H3.\n  right; apply H3.\n  right; apply H2.\n  right; apply H3.\n  right; apply H4.\n  right; apply H3.\n  right; apply H3.\n  right; apply H3.\n  right; apply H3.\n  right; apply H3.\n  left; apply H4.\n  left; apply H3.\n  left; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H3.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n  right; apply H4.\n Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha H.\n  apply prime_div_1; tauto.\nQed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\nProof.\n  intros a Ha H.\n  assert (H := prime_div a p H).\n  assert (H' := prime_div a p H).\n  elim H; intros.\n  elim H1; intros.\n  rewrite H3 in H0.\n  elim (prime_mod_pos p H1); intros.\n  rewrite H1 in H1; discriminate.\n  elim H1; intros.\n  rewrite H3 in H0; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.\n  elim H0; intros.\n  rewrite H3 in H; discriminate.Qed.",
                    "Lemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros a Ha.\n  case (prime_dec (gcd a p) (gcd a b)).\n  intro.\n  case (prime_dec (gcd a p) (gcd a b)); intro.\n  elim H; intros.\n  elim H1; intros.\n  rewrite H2 in H1; simpl in H1.\n  destruct a0 as [p0|p0].\n  left; apply prime_pos.\n  apply prime_dec.\n  apply prime_dec.\n  replace (p0 - a) with (p0 - a); [ idtac | ring ].\n  elim H1; intros.\n  rewrite H2 in H2; simpl in H2.\n  assert (a = p0).\n  rewrite H3; ring.\n  elim H1; intros.\n  rewrite H3 in H1; simpl in H1.\n  elim H1; intros.\n  rewrite H4 in H1; rewrite H4 in H1; simpl in H1.\n  elim H1; intros.\n  rewrite H4 in H1; simpl in H1.\n  rewrite H4 in H1; simpl in H1.\n  rewrite H4 in H1; rewrite H4 in H1; simpl in H1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " prime_square : forall (p a:nat),(is_prime p)->(divides (square a) p)->(divides a p).\n  unfold square.\n  intros;case (prime_mult p a a H H0);trivial.\nQed.\n\n(** generalisation to power *)\nLemma prime_power : forall (p n x:nat),(is_prime p)->(divides (power x n) p)->(divides x p).\n  induction n;simpl;intros.\n  elim H;intros.\n  elim H1;apply divides_antisym;trivial;apply one_min_div.\n  case (prime_mult p x (power x n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\n",
                "context_tokens": 713,
                "proof_start_offset": 5187,
                "proof_end_offset": 5475,
                "proof": "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\nProof.\nintros.\nsplit;try tauto.\nintro d';intro.\nassert (is_gcd d' d' p).\nunfold is_gcd;unfold is_cd.\nsplit;[split;[apply divides_refl | tauto] | tauto].\neapply H0;apply H2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;unfold is_gcd.\n  apply (gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=p)).\n  intros (H0,H1).\n  apply prime_factor_l with (p:=gcd_for_euclid (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=p) (gcd:=p).\n  intros (H1,H2).\n  apply gcd_gcd; trivial.\n  rewrite H3 in H1.\n  rewrite H3 in H1;simpl in H1.\n  assert (H3 := gcd_unique_divisors (p:=p) (gcd:=gcd_for_euclid (p:=p) (gcd:=p) (gcd:=p) (gcd:=pQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  elim H; intro p.\n  unfold is_gcd in H0.\n  elim H0; intros.\n  apply H1; auto with zarith.\n  elim H1; intros.\n  rewrite H3 in H.\n  rewrite H in H0.\n  rewrite <- H in H0.\n  rewrite <- (mult_comm (p * a) (p * a)); ring.\n  rewrite <- (mult_comm (p * a) (p * a)); ring.\n  rewrite <- (mult_comm (p * a) (p * a)); ring.\n  rewrite <- (mult_comm (p * a) (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ring.\n  rewrite <- (mult_comm (p * a) (p * a)); ring.\n  rewrite <- (mult_comm (p * a)); ringQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;apply (gcd_intro (gcd p)).\n  apply gcd_divide_l.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  induction p;simpl;intros.\n  split; auto.\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H2.\n  rewrite <- mult_1_l_reverse.\n  replace (p * 1) with (p * 1).\n  rewrite <- (mult_comm (p * 1)).\n  apply plus_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_l.\n  apply mult_le_compat_lQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;intro; case (gcd_gcd_bezout a p a H0);intros.\n  elim H; intros.\n  rewrite H1.\n  rewrite H2.\n  rewrite H2;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite H3;auto.\n  rewrite HQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros; generalize (gcd_nonneg a p H H0).\n  generalize (gcd_nonneg a p H H0).\n  rewrite <- H1; intros.\n  generalize (gcd_nonneg a p H0 H1).\n  rewrite <- H2; intros.\n  rewrite H3 in H0; simpl in H0.\n  assert (H2:=gcd_nonneg a p H3).\n  rewrite H3 in H0; rewrite H0 in H0; tauto.\n  elim H1; intros.\n  rewrite H3 in H0; simpl in H0.\n  assert (H3:=gcd_nonneg a p H3 H1).\n  rewrite <- H3 in H0; rewrite H1 in H0; tauto.\n  elim H1; intros.\n  rewrite H3 in H1; simpl in H1.\n  assert (H4:=gcd_nonneg a p H3).\n  rewrite <- H3 in H0; rewrite H1 in H0; tauto.\n  elim H1; intros.\n  rewrite H3 in H1; simpl in H1.\n  assert (H5:=gcd_nonneg a p H3 H1).\n  rewrite <- H4 in H0; rewrite H1 in H0Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;unfold is_gcd in H.\n  elim H; intro p; elim H; intros.\n  rewrite H0 in H; rewrite H in H; discriminate.\n  rewrite H1 in H; rewrite H in H; discriminate.\n  rewrite H1 in H; rewrite H in H; discriminate.\n  rewrite H1 in H; rewrite H in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H1 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H0 in H; discriminate.\n  rewrite H1 in H;Qed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;elim H;intro p;intro.\n  rewrite <- H3;rewrite <- H4; auto.\n  rewrite <- H4; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\n  rewrite <- H5; auto.\nQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;apply gcd_gcd;auto.\n  unfold is_gcd in H0.\n  elim H0; intros.\n  rewrite H3 in H1; discriminate H1.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H2; discriminate H2.\n  unfold is_gcd in H1; elim H2; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfold is_gcd in H1; elim H1; intros.\n  rewrite H3 in H4; discriminate H4.\n  unfoldQed.",
                    "Lemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros;split.\n  apply gcd_bezout;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcd_greatest;auto.\n  apply gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n) H H0);trivial.\n  intro;apply IHn;trivial.\nQed.\n\nLemma prime_power_qn : forall (p n q x:nat),(is_prime p)->(divides (power x n) (power p (q*n)))->(1<=n)->(divides x (power p q)).\n  induction q;simpl;intros.\n  apply one_min_div.\n  rewrite power_plus_lemma1 in H0.\n  assert (divides x (power p q)).\n  apply IHq;trivial.\n  elim H0;intros;exists ((power p n)*x0).\n  rewrite H2;ring.\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\n",
                "context_tokens": 714,
                "proof_start_offset": 5536,
                "proof_end_offset": 5890,
                "proof": "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\nsplit;intros.\nelim H;intros.\nsplit;try tauto.\nintros.\ncase (eq_nat_dec d 1);intro;try tauto.\ncase (eq_nat_dec d p);intro;try tauto.\nelim (H1 d n n0 H2).\nelim H;intros.\nsplit;try tauto.\nintros;intro.\nelim (H1 a H4);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime; auto with zarith.\n  apply prime_denom_prime; auto with zarith.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply: prime_denom_prime.\n  apply: prime_denom_prime.\n  apply: prime_denom_prime.\n  apply: contra (not_prime p); auto with zarith.\n  apply: prime_denom_prime.\n  apply: prime_denom_prime; auto with zarith.\n  apply: prime_denom_prime; auto with zarith.\n  apply: prime_denom_prime.\n  apply: prime_denom_prime.\n  apply: prime_denom_prime.\n  apply: prime_denom_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros p; elim p;intros;\n unfold is_gcd in |- *.\n  split;[apply prime_intro;assumption\n | unfold is_gcd in |- *;intro;apply prime_intro;assumption\n | unfold is_gcd in |- *;intro;apply prime_intro;assumption\n ].\n  apply (gcd_divide_l (gcd p));auto.\n  elim H1;intros.\n  unfold is_gcd in H2.\n  elim H2;intros.\n  rewrite H4 in H2;simpl in H2;tauto.\n  elim H2;intros.\n  rewrite H4 in H2;simpl in H2;tauto.\n  elim H2; intros.\n  rewrite H4 in H2; simpl in H2;tauto.\n  elim H2; intros.\n  rewrite H4 in H2; simpl in H2;tauto.\n  elim H2; intros.\n  rewrite H4 in H2; simpl in H2;tauto.\n  elim H2; intros.\n  rewrite H4 in H2; simpl in H2;tauto.\n  elim H2; intros.\n  rewrite H4 in H2; simpl in H2; tauto.\n  elim H2; intros.\n  rewrite HQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros p.\n  elim H;intros p H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  unfold is_prime in H4.\n  elim H4; intros.\n  rewrite H5; rewrite H5; apply prime_minus_r; assumption.\n  unfold is_prime in H4.\n  elim H4; intros.\n  rewrite H5; rewrite H5; apply prime_minus_r; assumption.\n  unfold is_prime in H4.\n  elim H4; intros.\n  rewrite H5; rewrite H5; apply prime_minus_r; assumption.\n  unfold is_upper_bound;split; [ assumption | assumption ].\n  rewrite H5; rewrite H6; apply prime_minus_r; assumption.\n  unfold is_upper_bound;split; [ assumption | assumption ].\n  apply prime_power_pos; try assumption.\n  apply prime_power_pos; try assumption.\n  apply prime_power_pos; try assumption.\n  apply prime_power_pos; try assumption.\n  apply prime_power_pos; try assumption.\n  apply prime_power_pos; try assumption.\n  apply prime_power_pos; try assumption.Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros; apply prime_prime; auto.\n  generalize (Z_mod_bound_pos p (a/p) H0).\n  intro.\n  apply prime_prime.\n  rewrite <- H1; rewrite <- H2; auto.\n  apply prime_prime.\n  rewrite <- H1; rewrite <- H2; auto.\n  apply prime_prime.\n  rewrite <- H1; rewrite <- H2; auto.\n  apply prime_prime.\n  rewrite <- H2; rewrite <- H3; auto.\n  apply prime_prime.\n  rewrite <- H2; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H4; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H4; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H5; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H4; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H4; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H4; rewrite <- H4; auto.\n  apply prime_prime.\n  rewrite <- H4;Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros.\n  split;try tauto.\n  intro.\n  assert (is_gcd d a p).\n  unfold is_gcd;unfold is_nonneg.\n  split;[apply (is_gcd_for_euclid (a:=a) (b:=a) (b:=b) H0);trivial | tauto].\n  apply (gcd_for_euclid (a:=a) (b:=a) (b:=b) H0);trivial.\n  apply (gcd_for_euclid (a:=b) (b:=b) (b:=a) H0);trivial.\n  apply (gcd_for_euclid (a:=a) (b:=a) (b:=b) H0);trivial.\n  apply (gcd_for_euclid (a:=a) (b:=b) H0);trivial.\n  apply (gcd_for_euclid (a:=a) (b:=b) H0);trivial.\n  apply (gcd_for_euclid (a:=a) (b:=a) H0);trivial.\n  apply (gcd_for_euclid (a:=a) (b:=a) H1);trivial.\n  apply (gcd_for_euclid (aQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply prime_denom_prime.\n  apply: contra.\n  apply: contraTneq (prime_gt_1 p) => ->.\n  apply: contra.\n  apply: contra.\n  rewrite -prime_coprime; apply: contra.\n  by rewrite -prime_coprime; apply: contra.\nQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;apply prime_denom_prime;assumption.\n  apply prime_denom_prime;assumption.\n  apply prime_denom_prime;assumption.\n  apply prime_denom_prime;assumption.\n  apply prime_denom_prime;assumption.\n  apply prime_denom_prime;assumption.\n  apply prime_denom_prime;assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom; assumption.\n  apply prime_denom; assumption.\n  apply prime_denom_prime; assumption.\n  apply prime_denom; assumption.\n  applyQed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros;split;try tauto.\n  intro d;intro.\n  assert (is_gcd d a).\n  unfold is_gcd.\n  split;[apply prime_dec | apply prime_dec ].\n  apply (gcd_nonneg a);assumption.\n  elim H;intros.\n  assert (is_gcd d a).\n  unfold is_gcd;unfold is_gcd;simpl; tauto.\n  elim H; intros.\n  apply H1; split; try tauto.\n  unfold is_gcd in H0.\n  elim H0; intros.\n  replace (gcd (gcd a a) (gcd a b)) with (gcd a b).\n  rewrite H2; ring.\n  split; try tauto.\n  rewrite H2; auto.\n  split; try tauto.\n  unfold is_gcd in H0.\n  elim H0; intros.\n  replace (gcd a b) with (gcd a b).\n  replace (gcd a b) with (gcd a b).\n  rewrite H2; ring.\n  split; try tauto.\n  unfold is_gcd in H0.\n  elim H0; intros.\n  rewrite H1 in H0; simpl in H0.\n  assert (gcd a b = a).\n  replace (Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  intros.\n  split;try tauto.\n  intro.\n  assert (forall (a:nat)(a:nat)(b:nat)(b:nat)(p:p=0)(p:p=0)(p:p=1) by auto.\n  rewrite H2 in H0; discriminate H0.\n  apply prime_prime.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_class_quotient_eq; auto.\n  apply prime_Qed.",
                    "Lemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\nProof.\n  intros p Hp; elim Hp; intro p; intro p; intro p; intro p; intros; exists p; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\n  apply prime_prime; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "\n  elim H2;intros.\n  rewrite H3 in H0.\n  rewrite power_mult_lemma1 in H0;rewrite power_power_lemma1 in H0;rewrite (mult_comm (power p n)) in H0.\n  elim H0;intros.\n  assert ((power p (q*n))<>0).\n  intro.\n  generalize (power_zero (q*n) p H5).\n  intro.\n  apply not_prime_zero.\n  rewrite H6 in H;trivial.\n  rewrite <- mult_assoc in H4.\n  generalize (mult_lemma6 (power x0 n) ((power p n)*x1) (power p (q*n)) H5 H4).\n  intro.\n  assert (exists n':nat,n=(S n')).\n  inversion H1;[exists 0 | exists m];trivial.\n  elim H7;intro n';intro.\n  rewrite H8 in H6;simpl in H6.\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\n",
                "context_tokens": 734,
                "proof_start_offset": 5951,
                "proof_end_offset": 6368,
                "proof": "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\nintro.\ncase (divides_nat n);intro.\nelim s;intros.\nright;intro.\nunfold is_prime in H.\nelim H;intros.\nelim (H1 x);try tauto.\ncase (eq_nat_dec n 1);intro.\nright;unfold is_prime;tauto.\nleft;unfold is_prime.\nsplit;trivial.\nintros.\ncase (eq_nat_dec d 1);try tauto.\ncase (eq_nat_dec d n);try tauto;intros.\nelim (n0 d n3 n2 H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H; intro p.\n  elim H0;intros.\n  elim (prime_dec n 1);intro; try tauto.\n  elim (prime_dec n 1);intro; try tauto.\n  elim (prime_dec n 1);intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n  elim (prime_dec n 1); intro; try tauto.\n Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H;intro p;intro.\n  elim H1; intros.\n  elim H2; intros.\n  elim (H1 0%nat); intro.\n  elim (H3 (1/1)); intro.\n  elim H3; intros.\n  elim (H4 0%nat); intro.\n  elim (H1 (1/1)).\n  elim (H4 (1/1)); intro.\n  elim (H5 0%nat); intro.\n  elim (H5 (1/1)); intro.\n  elim (H6 0%nat); intro.\n  elim (H6 (1/1)); intro.\n  elim H6; intros.\n  elim (H6 (1/1)); intro.\n  elim (H6 (1/1)); intro.\n  elim (H7 (1/1)); intro.\n  elim (H6 (1/1)); intro.\n  elim H6; intros.\n  rewrite H8 in H12; rewrite H12 in H12; discriminate.\n  elim H12; intros.\n  rewrite H9 in H12; rewrite H12 in H12; discriminate.\n  elim H12; intros.\n  rewrite H12 in H12; rewrite H12Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H; intro p;intros.\n  case (prime_dec n 1);intro; try tauto.\n  elim (H1 p);intros; try tauto.\n  elim H1; intros; try tauto.\n  elim (H2 p);intros; try tauto.\n  elim H3; intros; try tauto.\n  elim (H1 p); intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H3; intros; try tauto.\n  elim H4; intros; try tauto.\n  elim H4; intros; try tauto.\n  elim H4; intros; try tauto.\n  elim H4; intros; try tauto.\n  elim H4; intros; try tauto.\n  elim H4; intros; try tauto.\n  elim H4Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros.\n  elim H;intros.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H1; intros.\n  elim H2; intros.\n  apply H3; auto with algebra.\n  intros.\n  elim H1; intros.\n  unfold is_prime in H0.\n  elim H1; intros.\n  apply H5; auto with algebra.\n  elim H1; intros.\n  apply H5; auto with algebra.\n  apply H5; auto with algebra.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H; intro p;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H2; intros.\n  elim H2; intros.\n  split; try tauto.\n  unfold is_upper_bound in H0.\n  elim H0; intros.\n  elim H1; intros.\n  unfold is_upper_bound in H1.\n  elim H1; intros.\n  elim H3; intros.\n  unfold is_upper_bound in H4.\n  elim H4; intros.\n  elim H4; intros.\n  split; try tauto.\n  apply H1; simpl; auto.\n  elim H4; intros.\n  split; try tauto.\n  unfold is_upper_bound in H0.\n  elim H0; intros.\n  elim H4; intros.\n  elim H4; intros.\n  unfold is_upper_bound in H4.\n  elim H4; intros.\n  elim H4; intros.\n  unfold is_upper_bound in H4.\n  elim H4; intros.\n  split; try tauto.\n  apply H3; simpl; auto.\n Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H; intro p;intros.\n  elim H1; intros.\n  elim H1; intros.\n  elim H2; intros.\n  elim H3; intros.\n  split; try tauto.\n  apply H4; auto.\n  elim H; intros.\n  elim H3; intros.\n  elim H1; intros.\n  elim H4; intros.\n  elim H1; intros.\n  split; try tauto.\n  elim H4; intros.\n  elim H4; intros.\n  split; try tauto.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H4; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  split; try tauto.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H5; intros.\n  elim H6; intros.\n  elim H6Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H;intros.\n  left;exists 1%nat;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\nProof.\n  intros.\n  elim H;intro p;intro.\n  split; auto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1);intro; try tauto.\n  elim (divide_dec n 1);intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; try tauto.\n  elim (divide_dec n 1); intro; tryQed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H; intro p;intro.\n  right;apply prime_dec.\n  destruct (Z_dec n (p-n));[right|right].\n  left;apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  left; apply prime_dec.\n  right;Qed.",
                    "Lemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intros.\n  elim H; intro p;intro.\n  elim H1;intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim H1; intros.\n  split; try tauto.\n  elim (H1 a); auto.\n  elim (H1 H4); intros.\n  split; try tauto.\n  elim (H1 a); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (H1 H6); auto.\n  elim (H1 H6); auto.\n  elim (H1 H5); auto.\n  elim (H1 H6); auto.\n  elim (H1 H6); auto.\n  elim (H1 H5); auto.\n  elim (H1 H6); auto.\n  elim (H1 H5); auto.\n  elim (H1 H5); auto.\n  elim (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ".\n  assert (divides x0 p).\n  case (prime_mult p x0 (power x0 n'));trivial.\n  rewrite H6.\n  exists ((power p n')*x1);ring.\n  intro.\n  apply prime_power with n';trivial.\n  elim H9;intros.\n  rewrite H10 in H3.\n  rewrite H3.\n  exists x2;ring.\nQed.\n\n\n(** study of prime numbers *)\nLemma divides_prime : forall (a:nat),(exists p:nat,(p<>a)/\\(is_prime p)/\\(divides a p)) -> ~(is_prime a).\n  intros;intro.\n  elim H;intro p;intro.\n  elim H1;intros.\n  elim H3;intros.\n  unfold is_prime in H0.\n  elim H0;intros.\n  unfold is_prime in H4.\n  elim H4;intros.\n  case (H7 p H5);auto.\nQed.\n\n(** p<>1 is prime if forall n, gcd(n,p)=1 or gcd(n,p)=p *)\nLemma gcd_prime : forall (p:nat),(p<>1)->(forall (d a:nat),(is_gcd d a p)->(d=1)\\/(d=p))->(is_prime p).\n  intros.\n  split;try tauto.\n  intro d';intro.\n  assert (is_gcd d' d' p).\n  unfold is_gcd;unfold is_cd.\n  split;[split;[apply divides_refl | tauto] | tauto].\n  eapply H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\n",
                "context_tokens": 711,
                "proof_start_offset": 6458,
                "proof_end_offset": 7237,
                "proof": "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\nintro.\napply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\ncase (eq_nat_dec n0 1);try tauto;intro.\ncase (eq_nat_dec n0 0);intro.\nleft;exists 2.\nsplit;[apply is_prime_2 | rewrite e;apply zero_max_div].\ncase (divides_nat n0);intro.\nelim s;intro d;intro.\nelim p;intros.\nelim H2;intros.\nassert (d<n0).\ngeneralize (divides_le n0 d n2 H4);omega.\ncase (prime_dec d);intro.\nleft;exists d;tauto.\nelim (H d H5 n3);try tauto.\nintro.\nelim a;intro q;intro.\nleft;exists q.\nsplit;try tauto.\napply divides_trans with d;try tauto.\nelim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intros.\n  case (not_prime_prime n); intro.\n  elim H; intro.\n  left; apply prime_prime_not_prime; assumption.\n  right; apply prime_prime_not_prime; assumption.\n  right; apply prime_prime_not_prime; assumption.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n; case (not_prime_not_prime n); intros.\n  left; apply prime_prime_pos.\n  right;intro.\n  apply prime_prime_not_prime with (p:=p).\n  apply prime_prime_irr; auto.\n  right; intro.\n  apply prime_prime_not_prime with (p:=p).\n  apply prime_prime_not_prime with (p:=p).\n  apply prime_prime_decomp_prime with (p:=p).\n  apply prime_prime_prime; auto.\n  left; apply prime_prime_not_prime with (p:=p).\n  apply prime_prime_prime with (p:=p).\n  apply prime_cyclic; auto.\n  right; intro.\n  apply prime_prime_factor with (p:=p).\n  apply prime_factor_prime with (p:=p).\n  apply prime_factor_prime with (p:=p).\n  apply prime_factor_prime with (p:=p).\n  apply: prime_factor_prime; auto.\n  left; apply prime_factor_prime with (p:=p).\n  apply prime_factor_prime with (p:=p).\n  apply prime_factorQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro.\n  case (not_prime_not_prime n); intro.\n  left; apply prime_prime_not_prime; auto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  left; apply prime_prime_not_prime; auto.\n  left; apply prime_prime_not_prime; auto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  left; apply prime_not_prime; auto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  right; intro;\n  case (not_prime_not_prime n); intro; try tauto.\n  right; intro;\n  case (notQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro.\n  case (prime_dec n 1); intro.\n  left; unfold is_prime in H;\n  elim H; intros.\n  right; unfold is_prime in H;\n  elim H; intros.\n  elim (H1 x); try tauto.\n  left; apply prime_cyclic; assumption.\n  right; apply prime_cyclic; assumption.\n  right; apply prime_cyclic; assumption.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n; case (prime_not_prime n); intro.\n  left; apply prime_prime_sym.\n  left; apply prime_prime_sym.\n  right; apply prime_prime_not_prime.\n  apply prime_prime_not_prime; auto.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros.\n  case (not_prime_not_prime n); intro.\n  left; red; intro.\n  apply H1; apply prime_cyclic_prime with n; trivial.\n  apply (not_prime_not_prime n); trivial.\n  right; red; intro.\n  apply H1; apply prime_cyclic_prime with n; trivial.\n  apply (not_prime_not_prime n); trivial.\n  left; red; intro.\n  apply H1; apply prime_cyclic_prime with n; trivial.\n  apply (not_prime_not_prime n); trivial.\n  right; red; intro.\n  apply H1; apply prime_cyclic_prime with n; trivial.\n  apply (not_prime_not_prime n); trivial.\n  right; red; intro.\n  apply H1; apply prime_cyclic_prime with n; trivial.\n  apply (not_prime_not_prime n); trivial.\n  right; red; intro.\n  apply H1; apply prime_cyclic_prime with n; trivial.\n  apply (not_prime_not_prime n); trivial.\n  right; red; intro.\n  apply H1; apply prime_cyclic_Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro n.\n  case (prime_dec n (not_prime n)); intro.\n  left; apply prime_prime_sym.\n  right; intro.\n  assert (H2 := prime_not_prime n H1).\n  apply prime_prime_not_prime with (p:=p).\n  generalize (prime_not_prime n H2).\n  elim (prime_not_prime n H2); intros.\n  apply prime_prime_not_prime with (p:=p).\n  elim (prime_not_prime n H2); intros.\n  split;try tauto.\n  elim H2; intros.\n  elim (prime_not_prime n H2); intros.\n  elim (prime_not_prime n H2); intros.\n  elim (prime_not_prime n H2); intros.\n  elim (not_prime_not_prime n H3); intros.\n  elim (prime_not_prime n H3); intros.\n  elim H4; intros.\n  elim (not_prime_not_prime n H4); intros.\n  elim (prime_not_prime n H1); intros.\n  elim H4; intros.\n  elim (not_prime_notQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\nProof.\n  intros.\n  case (prime_dec n 0); intro.\n  left; apply prime_prime_diff; assumption.\n  right; apply prime_prime_diff; assumption.\n  right; apply prime_not_prime.\n  apply prime_not_prime; assumption.\n  left; apply prime_not_prime.\n  apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime.\n  apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime.\n  apply prime_not_prime; assumption.\nQed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n.\n  case (not_prime_not_prime n); intro.\n  left; apply prime_dec; auto.\n  right; intro.\n  unfold is_prime in H.\n  elim H; intros.\n  elim H; intros.\n  split; try tauto.\n  intros.\n  elim H3; intros.\n  unfold is_prime in H0.\n  elim H0; intros.\n  elim (H1 x); elim H1; intros.\n  auto.\n  elim H2; intros.\n  elim H3; intros.\n  auto.\n  elim H4; intros.\n  elim H5; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n  elim H4; intros.\n  auto.\n Qed.",
                    "Lemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intros n Hn;case (prime_not_prime n); intro.\n  left;apply prime_prime_prime; assumption.\n  right;apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.\n  right; apply prime_not_prime; assumption.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " H0;apply H2.\nQed.\n\n(** p is prime iff forall n, n<>1 /\\ n<>p -> not(a | p) *)\nLemma prime_cond : forall (p:nat),((p<>1)/\\(forall (a:nat),(a<>1)->(a<>p)->~(divides p a))<->(is_prime p)).\n  split;intros.\n  elim H;intros.\n  split;try tauto.\n  intros.\n  case (eq_nat_dec d 1);intro;try tauto.\n  case (eq_nat_dec d p);intro;try tauto.\n  elim (H1 d n n0 H2).\n  elim H;intros.\n  split;try tauto.\n  intros;intro.\n  elim (H1 a H4);auto.\nQed.\n\n(** a number n is either prime or not (it is decidable) *)\nLemma prime_dec : forall (n:nat),{is_prime n}+{~(is_prime n)}.\n  intro.\n  case (divides_nat n);intro.\n  elim s;intros.\n  right;intro.\n  unfold is_prime in H.\n  elim H;intros.\n  elim (H1 x);try tauto.\n  case (eq_nat_dec n 1);intro.\n  right;unfold is_prime;tauto.\n  left;unfold is_prime.\n  split;trivial.\n  intros.\n  case (eq_nat_dec d 1);try tauto.\n  case (eq_nat_dec d n);try tauto;intros.\n  elim (n0 d n3 n2 H).\nQed.\n\n(** if n is not prime then either n = 1 or there is a prime number p such that p | n *)\nLemma not_prime_impl_prime_divides : forall (n:nat),(~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})).\n  intro.\n  apply (lt_wf_rec n (fun n:nat => ~(is_prime n)->({p:nat | (is_prime p)/\\(divides n p)}+{n=1})));intros.\n  case (eq_nat_dec n0 1);try tauto;intro.\n  case (eq_nat_dec n0 0);intro.\n  left;exists 2.\n  split;[apply is_prime_2 | rewrite e;apply zero_max_div].\n  case (divides_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\n",
                "context_tokens": 710,
                "proof_start_offset": 7333,
                "proof_end_offset": 8614,
                "proof": "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\nintros n p H.\napply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\ncase (divides_dec n0 p);intro.\ngeneralize (quo_is_quo n0 p d);intro.\nelim (H0 (quo n0 p d)).\nintro m;intros.\nexists (m+1).\nelim p0;intros.\nelim H3;intros.\nrewrite H5 in H2;rewrite mult_assoc in H2.\nrewrite plus_comm.\nsplit;simpl.\nexists x;trivial.\nrewrite plus_comm;simpl.\nrewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\nelim H6;intros.\nrewrite H2 in H7.\nassert (p<>0).\nintro.\nrewrite H8 in H.\napply not_prime_zero;trivial.\nassert ((power p m)*x=(power p m)*p*x0).\napply mult_lemma6 with p;trivial.\nrewrite mult_assoc;rewrite H7;ring.\nrewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\napply H4.\nrewrite plus_comm;simpl.\nexists x0;trivial.\nrewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\nintro.\napply H1;rewrite H2;rewrite H3;trivial.\nelim H.\nintros.\ndestruct p;omega.\nintro;apply H1.\nrewrite H2;rewrite H3;ring.\nexists 0;simpl.\nsplit.\napply one_min_div.\nrewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (le_or_prime_bezout n m H);intro.\n  left;apply (not_prime_not_prime (m+n));trivial.\n  left;apply (not_prime_not_prime (m+n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_not_prime (m-n));trivial.\n  left; apply (not_prime_not_prime (m-n));trivial.\n  left; apply (not_prime_not_prime (m-n));trivial.\n  right; apply (not_prime_Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  apply (lt_wf_rec n (fun n:nat => (is_prime n)) (fun n:nat => (is_prime n)).\n  intros.\n  apply (lt_wf_rec n (fun m:nat => (is_prime n)) (fun m:nat => (is_prime m) /\\ (is_prime m)) H H0 H1).\n  apply nat_rel_prime; auto.\n  intros.\n  apply (lt_wf_rec n (fun m:nat => (is_prime m)) H H0 H1).\n  apply (lt_wf_rec m (fun n:nat => (is_prime m) /\\ (is_prime m)) H H0 H1).\n  apply (lt_wf_rec m (fun n:nat => (is_prime m)) H H0 H1).\n  apply (lt_wf_rec m (fun n:nat => (is_prime n)) H H0 H1).\n  apply (fun n:nat => (is_prime n) /\\ (is_prime n)).\n  intros.\n  apply (not_prime_not_prime (fun m:nat => (is_Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p Hp.\n  rewrite <- (eq_decidable n m) in Hp.\n  apply (lt_wf_rec n (fun m:nat => (is_prime n)) (fun m:nat => (is_prime n m) /\\ m=n)).\n  intros.\n  case (not_prime_not_prime n m); intro; try tauto; intro.\n  elim H; intros.\n  elim H2; intros.\n  elim H3; intros.\n  exists x0.\n  split;try tauto.\n  elim (prime_dec m n); intro; try tauto.\n  elim (not_prime_not_prime n m); intro; try tauto.\n  elim (not_prime_not_prime n m); intro; try tauto.\n  elim (prime_not_prime n m); intro; try tauto.\n  elim (not_prime_not_prime n m); intro; try tauto.\n  elim (not_prime_not_prime n m); intro; try tauto.\n  elim (not_prime_not_prime n m); intro; try tauto.\n  elim (not_prime_not_prime n m); intro; try tauto.\n  elim (not_primeQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (prime_dec n 0); intro.\n  left; elim H0;intros; left; trivial.\n  left; elim H0;intros; left; trivial.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  left; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_neg_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_cyclic_pos_iff; auto.\n  right; apply prime_Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\nProof.\n  intros.\n  case (is_prime_dec n); intro.\n  left;apply prime_prime_intro; try tauto; try tauto.\n  left; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; try tauto.\n  right; apply prime_prime_intro; try tauto; tryQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  destruct (Even_dec n p) as [(H1,H2)|(H2,H3)]); rewrite H3 in H3.\n  left; exists (S p).\n  split; [assumption | apply prime_prime_2 ].\n  apply prime_prime_monotone_prime_divisors.\n  apply prime_cyclic_prime_divisors.\n  apply prime_divisors_prime_divisors.\n  apply prime_decomp_prime_divisors.\n  apply prime_decomp_prime_decomp_prime.\n  apply prime_decomp_prime_decomp; auto with zarith.\n  intros; elim H; intros.\n  elim H2; intros.\n  elim H3; intros.\n  rewrite H3; rewrite H4; rewrite H5; apply prime_mult_strong; auto with zarith.\n  intros; elim H3; intros.\n  elim H2; intros.\n  elim H4; intros.\n  rewrite H3; rewrite H4; rewrite H5; rewrite H5; apply prime_mult_strong; auto with zarith.\n  elim H5; intros.\n  elim H5; intros.\n  rewrite H4; rewrite H5; rewrite H5; rewrite H5; apply prime_mult_Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  case (prime_dec n m); intro.\n  left; exists (S m).\n  split;[apply is_prime_2 | rewrite e; apply is_prime_2].\n  right;auto.\n  elim (prime_dec n m); intro.\n  left; exists (S m).\n  split;[apply is_prime_2 | rewrite e; apply is_prime_2].\n  right;auto.\n  elim (not_prime_not_prime _ _ H).\n  right;auto.\n  right;auto.\n  elim (not_prime_not_prime _ _ H).\n  left; exists (S m).\n  split;[apply is_prime_2 | rewrite e;apply is_prime_2].\n  right;auto.\n  elim (not_prime_not_prime _ _ H).\n  left; exists (S m).\n  split;[apply is_prime_2 | rewrite e; apply is_prime_2].\n  right;auto.\n  elim (not_prime_not_prime _ _ H).\n  right;auto.\n  elim (not_prime_not_prime _ _ H).\n  left; exists (S m).\n  split;[apply is_Qed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros.\n  elim H; intros.\n  left;exists (S m).\n  elim H; intros.\n  right; exists (S m).\n  elim H; intros.\n  right;split;try tauto.\n  right;split;try tauto.\n  right;split;try tauto.\n  left;apply is_prime_2.\n  right;split;try tauto.\n  right;split;try tauto.\n  left;apply is_prime_2.\n  right;split;try tauto.\n  right;split;try tauto.\n  left;apply is_prime_2.\n  left;apply is_prime_2.\n  left;apply is_prime_2.\n  left; apply is_prime_2.\n  right;split;try tauto.\n  right;split;try tauto.\n  right;split;try tauto.\n  right;split;try tauto.\n  right;split;try tauto.\n  right;right;split;try tauto.\n  right;split;try tauto.\n  right;split;try tauto.\n  left;apply is_prime_2.\n  left;apply is_prime_2.\n  left; apply is_prime_2.\n  right;split;try tautoQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p q H.\n  case (le_gt_dec n p); intro.\n  left;apply prime_prime_not_iff; auto with *.\n  left; apply prime_prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  left; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  left; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  left; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; auto with *.\n  left; apply prime_not_iff; auto with *.\n  right; apply prime_not_iff; autoQed.",
                    "Lemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intro.\n  apply (lt_wf_rec n (fun m:nat => (is_prime m) /\\ (exists n, (is_prime n) /\\ (is_prime n) /\\ (n<m)%nat)).\n  intros.\n  apply (lt_wf_rec n (fun m:nat => (is_prime m) /\\ (is_prime n))).\n  intros.\n  apply (lt_wf_rec m (fun m:nat => (is_prime m) /\\ (is_prime m)).\n  intros.\n  apply (lt_wf_rec m (fun m:nat => (is_prime m) /\\ (is_prime m)).\n  intros.\n  apply (lt_wf_rec m (fun m:nat => (is_prime m) /\\ (is_prime m)).\n  intros.\n  apply (not_prime_not_prime (fun m:nat => (is_prime m) /\\ (is_prime m))).\n  intros.\n  elim H0; intro.\n  left; exists 1%nat; split; try tauto.\n  apply prime_cyclic_prime_factor.\n  apply Z.le_refl.\n  elim H1; intro.\n  rightQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_nat n0);intro.\n  elim s;intro d;intro.\n  elim p;intros.\n  elim H2;intros.\n  assert (d<n0).\n  generalize (divides_le n0 d n2 H4);omega.\n  case (prime_dec d);intro.\n  left;exists d;tauto.\n  elim (H d H5 n3);try tauto.\n  intro.\n  elim a;intro q;intro.\n  left;exists q.\n  split;try tauto.\n  apply divides_trans with d;try tauto.\n  elim (prime_cond n0);intros;elim H0;apply H1;auto.\nQed.\n\n(** if n<>0 and p is a prime number then there is m such that p^m | n and not(p^(m+1) | n) *)\nLemma nat_factor : forall (n p:nat),(is_prime p)->(n<>0)->{m:nat | (divides n (power p m))/\\~(divides n (power p (m+1)))}.\n  intros n p H.\n  apply (lt_wf_rec n (fun n:nat => n <> 0 -> {m : nat | divides n (power p m) /\\ ~ divides n (power p (m + 1))}));intros.\n  case (divides_dec n0 p);intro.\n  generalize (quo_is_quo n0 p d);intro.\n  elim (H0 (quo n0 p d)).\n  intro m;intros.\n  exists (m+1).\n  elim p0;intros.\n  elim H3;intros.\n  rewrite H5 in H2;rewrite mult_assoc in H2.\n  rewrite plus_comm.\n  split;simpl.\n  exists x;trivial.\n  rewrite plus_comm;simpl.\n  rewrite (mult_comm p (power p m));rewrite mult_assoc;intro.\n  elim H6;intros.\n  rewrite H2 in H7.\n  assert (p<>0).\n  intro.\n  rewrite H8 in H.\n  apply not_prime_zero;trivial.\n  assert ((power p m)*x=(power p m)*p*x0).\n  apply mult_lemma6 with p;trivial.\n  rewrite mult_assoc;rewrite H7;ring.\n  rewrite <- H5 in H9;rewrite (mult_comm (power p m) p) in H9.\n  apply H4.\n  rewrite plus_comm;simpl.\n  exists x0;trivial.\n  rewrite mult_comm in H2;rewrite H2;apply mult_lemma3.\n  intro.\n  apply H1;rewrite H2;rewrite H3;trivial.\n  elim H.\n  intros.\n  destruct p;omega.\n  intro;apply H1.\n  rewrite H2;rewrite H3;ring.\n  exists 0;simpl.\n  split.\n  apply one_min_div.\n  rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nQed.\n\n(** if n>1 then there is a prime number p and two integers m and q with m>0 and q<n such that n=p^m*q and gcd(p,q)=1 *)\n",
                "context_tokens": 686,
                "proof_start_offset": 8736,
                "proof_end_offset": 10293,
                "proof": "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros.\ncase (prime_dec n);intro.\nexists n;exists 1;exists 1;simpl.\nsplit;try tauto.\nsplit;try omega.\nsplit;try ring.\nsplit;try omega.\napply gcd_sym;apply gcd_one.\nelim (not_prime_impl_prime_divides n n0);intro;try tauto.\nelim a;intro p;intro.\nelim p0;intros.\nelim (nat_factor n p H1).\nintro m;intro.\nelim p1;intros.\nexists p;exists m;exists (quo n (power p m) H3).\nsplit;trivial.\nsplit.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\nsplit.\napply (quo_is_quo n (power p m) H3).\ngeneralize (gcd_is_gcd p (quo n (power p m) H3));intro.\nassert ((gcd p (quo n (power p m) H3))=1).\ncase (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\napply gcd_sym;trivial.\nintro.\nrewrite H6 in H5;elim H5;intros.\nelim H7;intros.\nelim H4;rewrite plus_comm;simpl.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nelim H10;intros.\nrewrite H12 in H11.\nexists x;rewrite H11;ring.\nrewrite H6 in H5;trivial.\ngeneralize (quo_is_quo n (power p m) H3);intro.\nsplit;trivial.\nrewrite H7;rewrite mult_comm;apply mult_lemma3.\nintro.\napply H;rewrite H7.\nrewrite H8;ring.\nred;apply power_lt.\ndestruct p.\nelim (not_prime_zero H1).\ndestruct p;try omega.\nelim H1;tauto.\ndestruct m;try omega.\nelim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nintros n p H0.\napply (lt_wf_rec n (fun n:nat => n <> 0) (fun m:nat => forall m:nat, n <> 0 -> m <> 0 -> m <> 0 -> m <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> m <> 0 -> m <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> m <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> m <> 0 -> n <> 0 -> m <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> m <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> m <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0 -> n <> 0Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p.\n  case (le_or_lt 0 n).\n  intro m;intros.\n  case (le_or_lt n m).\n  intro m;intros.\n  elim H2; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H in H; discriminate.\n  elim H; intros.\n  rewrite H3 in H; rewrite H inQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p H; case (prime_dec n (prime_dec n m)); intro.\n  elim H; intro.\n  rewrite H2 in H; rewrite mult_comm in H.\n  rewrite <- (mult_comm n (div2 n m)).\n  rewrite <- (mult_comm m (div2 m)).\n  rewrite <- (mult_comm m (div2 m)).\n  rewrite mult_assoc;rewrite H6;auto with arith.\n  rewrite <- (mult_comm m (div2 m)).\n  rewrite mult_assoc;rewrite H7;auto with arith.\n  rewrite (mult_comm m (div2 m)).\n  rewrite mult_comm;auto with arith.\n  rewrite (mult_comm m (div2 m)).\n  rewrite mult_comm.\n  rewrite (mult_comm m (div2 m)).\n  rewrite mult_comm;auto with arith.\n  rewrite (mult_comm m (div2 m)).\n  rewrite (mult_comm m (div2 m)).\n  rewrite mult_assoc;rewrite H6;auto with arith.\n  rewrite <- (mult_comm m (div2 m)).\n  rewrite mult_comm;auto with arith.\n  rewrite (mult_comm m (div2 mQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n p H.\n  case (prime_dec n p); intro.\n  elim H0; intros.\n  right; exists (m+1).\n  apply prime_factor_prime with m; auto.\n  rewrite <- H; ring.\n  right; exists (m+1).\n  rewrite mult_comm; rewrite mult_comm; rewrite (mult_comm m);rewrite mult_assoc;\n  rewrite (mult_comm m); rewrite <- (mult_comm m); rewrite <- (mult_comm m);\n  rewrite (mult_comm m); rewrite <- (mult_comm m); rewrite <- (mult_comm m);\n  rewrite (mult_comm m); rewrite (mult_comm m); rewrite (mult_comm m);\n  rewrite (mult_comm m); rewrite (mult_comm m); rewrite (mult_comm m); \n  rewrite (mult_comm m); rewrite (mult_comm m); rewrite (mult_comm m); \n  rewrite (mult_comm m); rewrite (mult_comm m); rewrite (mult_comm m);\n  rewrite (mult_comm m); rewrite (mult_comm m); rewrite (mult_comm m); \n  rewrite (mult_comm m); rewrite (mult_comm mQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H.\n  apply (lt_wf_rec m (fun n:nat => n <> 0 -> {m:nat & {q:nat & {q:nat & {q:nat & {q:nat | (q+n)}).\n  intros m n p H H1.\n  apply (lt_wf_rec m (fun n:nat => n <> 0 -> {m:nat & {q:nat & {q:nat & {q:nat & {q:nat & {q:nat | (q+n)}).\n  intros m n p H H0.\n  apply (lt_wf_rec m (fun m n:nat => n <> 0 -> {q:nat & {q:nat & {q:nat & {q:nat & {q:nat & {q:nat & {q:nat & {q:nat & {r:nat & {r:nat | (q+n)}).\n  intros m n p H0 H1.\n  apply (lt_wf_rec m (fun m n:nat => n <> 0 -> {q:nat & {q:nat & {r:nat & {r:Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\n  intros n m p H.\n  apply (lt_wf_rec n (fun n m:nat => n <> 0 -> {m:nat & {q:nat & {m:nat & {q:nat & {q:nat & {m:nat & {q:nat & {m:nat & {q:nat & {q:nat | (m*m)})}).\n  intros.\n  case (prime_dec n (fun m:nat => n <> 0 -> {q:nat & {q:nat & {m:nat & {m:nat & {q:nat & {q:nat & {m:nat & {q:nat & {q:nat & {q:nat & {m:nat & {r:nat | (m*m)*q}):Z}.\n  intro m; case (prime_dec n (fun m:nat => n <> 0 -> {q:nat & {m:nat & {q:nat & {q:nat & {q:nat & {m:nat & {r:nat & {r:nat & {r:nat | (m*m}):Z}).\n  intro m; case (Z_le_dec mQed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p H; elim H.\n  intro m; intros.\n  exists (S m).\n  elim H; intros.\n  rewrite H4 in H2; rewrite mult_comm in H2; rewrite mult_comm in H2.\n  rewrite (mult_comm m p) in H2; rewrite mult_comm in H2; rewrite mult_comm in H2;\n   rewrite mult_assoc in H2;\n   rewrite (mult_comm (S m) (S m)) in H2;\n   rewrite mult_assoc in H2;\n   rewrite (mult_comm m (S m)) in H2;\n   rewrite mult_comm in H2; rewrite (mult_comm m (S m)));\n   rewrite mult_assoc in H2;\n   rewrite (mult_comm (S m) (S m)) in H2;\n   rewrite mult_assoc in H2;\n   rewrite (mult_comm (S m) (S m)) in H2;\n   rewrite (mult_comm m (S m)) in H2;\n   rewrite (mult_comm (S m) (S m)) in H2;\n   rewrite mult_assoc in H2;\n   rewrite (mult_comm (Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n  intros n p.\n  case (Z_le_dec n (fun m n => proj1_sig (Z_of_P m n)) n m); intros.\n  case (Z_le_dec n (fun m n => proj1_sig (Z_of_P m n))) n m); intros.\n  elim H; intros.\n  rewrite H2 in H.\n  elim (H m (fun m n => proj1_sig (Z_of_P m n) (fun n => proj1_sig (Z_of_P m n))) n m); intros.\n  elim H1; intros.\n  rewrite H2 in H.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  split; simpl; ring.\n  rewrite mult_comm; simpl; ring.\n  rewrite mult_comm; simpl; ring.\n  rewrite mult_comm; simpl; ring.\n  apply lt_n_S.\n  rewrite mult_comm; simpl; ring.\n  apply lt_n_S.\n  rewrite mult_comm; simpl; ring.\n  apply lt_n_S.\n  rewrite mult_comm; simpl; ring.\n  apply lt_n_S.\n Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\n intros n p.\n case (Z_le_gt_dec n (fun m n => n <> 0 -> {m:nat & {q:nat & {q:nat & {q:nat & {q:nat | m = q })}).\n  intros m n q H H0.\n  replace (m + 1) with m; trivial.\n  rewrite <- (plus_n_Sm m m); trivial.\n  apply mult_complete_conv_l with m; trivial.\n  rewrite mult_comm; simpl.\n  rewrite mult_comm; simpl.\n  rewrite (mult_comm p (power p m)); trivial.\n  apply mult_complete_conv_r with m; trivial.\n  rewrite mult_comm; simpl.\n  rewrite (mult_comm m); trivial.\n  apply mult_complete_conv_r with m; trivial.\n  rewrite mult_comm; simpl.\n  rewrite (mult_comm m); trivial.\n  apply mult_complete_conv_r with m; trivial.\n  rewrite mult_comm; simpl.\n  rewrite (mult_comm m); trivial.\n  apply mult_complete_conv_r with m; trivial.\n  rewrite mult_comm; simpl.\n Qed.",
                    "Lemma nat_factor_prime : forall (n:nat),(n<>0)->(n<>1)->{p:nat & {m:nat & {q:nat | (is_prime p)/\\(m>0)/\\(n=(power p m)*q)/\\(is_gcd 1 p q)/\\(q<n)}}}.\nProof.\nintros n p H.\nelim (le_or_lt n (fun m:nat => n <> 0 -> {m:nat & {m:nat & {q:nat & {q:nat | (m<m)}).\nintros m; case (le_or_lt m (fun m:nat => m <= m) with (n:=m);intros.\nrewrite H1 in H; elim H; intros.\nrewrite H1 in H; elim H; intros.\nrewrite H2 in H; rewrite H2 in H; discriminate.\nrewrite H2 in H; discriminate.\nrewrite H1 in H; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " omega.\n  apply gcd_sym;apply gcd_one.\n  elim (not_prime_impl_prime_divides n n0);intro;try tauto.\n  elim a;intro p;intro.\n  elim p0;intros.\n  elim (nat_factor n p H1).\n  intro m;intro.\n  elim p1;intros.\n  exists p;exists m;exists (quo n (power p m) H3).\n  split;trivial.\n  split.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  split.\n  apply (quo_is_quo n (power p m) H3).\n  generalize (gcd_is_gcd p (quo n (power p m) H3));intro.\n  assert ((gcd p (quo n (power p m) H3))=1).\n  case (prime_gcd (gcd p (quo n (power p m) H3)) p (quo n (power p m) H3));trivial.\n  apply gcd_sym;trivial.\n  intro.\n  rewrite H6 in H5;elim H5;intros.\n  elim H7;intros.\n  elim H4;rewrite plus_comm;simpl.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  elim H10;intros.\n  rewrite H12 in H11.\n  exists x;rewrite H11;ring.\n  rewrite H6 in H5;trivial.\n  generalize (quo_is_quo n (power p m) H3);intro.\n  split;trivial.\n  rewrite H7;rewrite mult_comm;apply mult_lemma3.\n  intro.\n  apply H;rewrite H7.\n  rewrite H8;ring.\n  red;apply power_lt.\n  destruct p.\n  elim (not_prime_zero H1).\n  destruct p;try omega.\n  elim H1;tauto.\n  destruct m;try omega.\n  elim H4;simpl;rewrite mult_comm;simpl;rewrite plus_comm;simpl;trivial.\n  trivial.\nQed.\n\n(** this compute p1^n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\n",
                "context_tokens": 720,
                "proof_start_offset": 10997,
                "proof_end_offset": 12081,
                "proof": "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintro.\ncase (eq_nat_dec n 0);intro.\nright;trivial.\ncase (eq_nat_dec n 1).\nintro;left;exists (nil (A:=nat*nat)).\nsplit;[apply nil_is_wf | simpl;trivial].\ngeneralize n0.\napply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\nelim (nat_factor_prime n1 H0 H1).\nintro p;intro.\nelim p0;intro m;intro.\nelim p1;intro q;intro.\nelim p2;intros.\nelim H3;intros.\nelim H5;intros.\nelim H7;intros.\ncase (eq_nat_dec q 1);intro.\nleft;exists (cons (p,m) nil);simpl;rewrite e in H6.\nsplit;trivial.\napply cons_is_wf;auto;try (apply nil_is_wf).\nunfold rel_prime;simpl;rewrite e in H8;trivial.\nassert (q<>0).\nintro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\nelim (H q H9 H10 n2).\nintro.\nelim a;intro l;intro.\nelim p3;intros.\nleft;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\napply cons_is_wf;auto.\nrewrite <- H12;unfold rel_prime;trivial.\nintro;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros; unfold is_wf.\n destruct (is_wf_type p) as (x,p).\n exists x; auto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintros n.\ninduction n as [| n IH]; simpl; auto.\nintros p; generalize p; clear p.\ninduction n as [| n IH]; simpl; auto.\nintros p.\ndestruct n as [| n]; simpl; auto.\nintros p; case p; simpl; auto.\nintros p; case p; simpl; auto.\nintros p; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; auto.\nintros p1; case p; simpl; autoQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n.\ntrivial.\nsimpl.\ndestruct (dec_eq n n0).\nsubst n0.\nrewrite IHn0;trivial.\nsimpl.\nrewrite IHn0.\nsimpl;omega.\nrewrite IHn0;trivial.\nsimpl;omega.\nsimpl;omega.\nsimpl;omega.\nsimpl;omega.\nsimpl;omega.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n as [| n IH]; simpl; intros.\ntrivial.\ndestruct l.\nrewrite hd_error_nil.\nsimpl.\nrewrite IH; simpl; ring.\ndestruct l.\nrewrite hd_error_nil; simpl; ring.\nrewrite IH; simpl; ring.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n.\nintros.\nsimpl.\ninduction n;intros.\ntrivial.\nsimpl.\ninduction n;intros;trivial.\nintros.\nsimpl.\ninduction n;intros.\nsimpl.\ninduction n;intros.\ntrivial.\nsimpl.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\ninduction (hd nil (tl::nil)).\ntrivial.\nsimpl.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\nauto.\nintros.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\nauto.\nsimpl.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\nauto.\nsimpl.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\nauto.\nintros.\ninduction n.\nsimpl.\ninduction n.\nsimpl.\nauto.\nsimpl.\ninduction n.\nsimpl.\nauto.\nsimpl.\ninduction n.\nsimpl.\nauto.\nsimpl.\ninduction n.\nsimpl.\nauto.\nsimpl.\nauto.\nsimpl.\ninduction n.\nsimpl.Qed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\n intros n.\n induction n; simpl; intros; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\n case n; trivial.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n.\n simpl; trivial.\nintros p n.\ninduction p.\nsimpl; intros; omega.\nintros p n.\ninduction p.\nsimpl; intros.\nrewrite IHn; simpl; auto.\nrewrite IHn; simpl; auto.\ndestruct n.\nsimpl; intros; omega.\nsimpl; intros; rewrite IHn; simpl; auto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\ninduction n as [| n IH]; simpl; trivial.\nintros p t.\ninduction t as [| n IH].\nsimpl; trivial.\nrewrite IH.\nsimpl.\nauto.\nrewrite IH.\nsimpl.\nauto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintros n; case n.\n simpl; intros.\nexists (S n).\nrewrite mult_comm; simpl; auto.\nintros.\ncase (H n); intros.\nexists (S n).\nrewrite mult_comm; simpl; auto.\nrewrite mult_comm; simpl; auto.\nrewrite mult_comm; simpl; auto.\nrewrite (mult_comm n); simpl; auto.\nrewrite mult_comm; simpl; auto.\nrewrite mult_comm; simpl; auto.\nrewrite mult_comm; simpl; auto.\nQed.",
                    "Lemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\nProof.\nintros n; induction l.\nsimpl;intros; case (le_lt_dec n 0); intros.\nrewrite H; simpl; auto.\nrewrite H; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simpl; auto.\nrewrite IHn0; simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "n1*p2^n2*...*pm^nm if l = (p1,n1)::(p2,n2)::...::(pm,nm) *)\nFixpoint refactor (l:(list (nat*nat))) {struct l} : nat :=\n  match l with\n    nil => 1\n    | (cons (p,n) tail) => (power p n)*(refactor tail)\n  end.\n\n(** a list l is well-formed (is a factorisation) if whenever (p,n) is in l then p is prime and n>0 and p is relatively prime to (refactor (l\\(p,n))) and l\\(p,n) is well-formed *)\nInductive is_wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\n",
                "context_tokens": 713,
                "proof_start_offset": 12199,
                "proof_end_offset": 12539,
                "proof": "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l;simpl;try tauto.\nintro.\ncase H;intro.\ndestruct a.\nrewrite <- H0;simpl.\nexists (refactor l);trivial.\ndestruct a.\nelim (IHl H0);intros.\nrewrite H1.\nexists ((power n n0)*x0);ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l.\n  simpl;auto.\n  intros; simpl in H;inversion H.\n  destruct n;auto.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;omega.\n  simpl;Qed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intro.\n  case (le_gt_dec n 0).\n  intro; right;trivial.\n  case (le_gt_dec n (length l)).\n  intro; right;trivial.\n  case (le_gt_dec n (length l)).\n  intro; left;exists (length l);simpl;rewrite e;trivial.\n  case (le_lt_dec (length l) (length l)).\n  intro; right;trivial.\n  case (le_gt_dec n (length l)).\n  intro; right;trivial.\n  case (le_gt_dec n (length l)).\n  intro; right;trivial.\n  case (le_lt_dec n (length l)).\n  intro; right;trivial.\n  case (le_lt_dec n (length l)).\n  intro; right;trivial.\n  case (le_gt_dec n (length l)).\n  intro; left;exists (length l); simpl; rewrite e;trivial.\n  case (le_lt_dec n (length l)).\n  intro; right;trivial.\n  case (le_lt_dec n (length l)).\n  intro; right;trivial.\n  case (le_lt_dec nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l.\nsimpl;auto.\nintros; case H;auto.\nintros n1; case H;auto.\nintros n2; case H;auto.\nintros n2; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case H;auto.\nintros n3 H; case HQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\nintro.\ncase (le_lt_dec n (length l)) n); intro.\nright;trivial.\ncase (le_gt_dec n (length l)); intro.\nright;trivial.\ncase (le_gt_dec n (length l)); intro.\nright;omega.\nright;omega.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  intro.\n  case l; simpl;intros.\n  case (eq_nat_dec n 0).\n  intro; left;omega.\n  case (eq_nat_dec n (length l)).\n  intro; right;omega.\n  case (eq_nat_dec n (length l)).\n  intro; left;omega.\n  case (le_gt_dec n (length l)); intro; right;omega.\n  case (le_lt_dec n (length l)).\n  intro; right;omega.\n  case (le_gt_dec n (length l)).\n  intro; right;omega.\n  case (le_lt_dec n (length l)).\n  intro; right;omega.\n  case (le_lt_dec n (length l)).\n  intro; right;omega.\n  case (le_lt_dec n (length l)).\n  intro; left;omega.\n  case (le_lt_dec n (length l)).\n  intro; right;omega.\n  case (le_lt_dec n (length l)).\n  intro; left; omega.\n  case (le_gt_dec n (length l)).\n  intro; left; omega.\n  case (le_lt_decQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\ninduction l.\nsimpl;intros.\nomega.\nsimpl.\nintros.\nomega.\nsimpl.\nintros.\nomega.\nsimpl.\nintros.\nomega.\nsimpl.\nintros.\nomega.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\nintro.\nassert (H:=is_wf_rec_is_wf (fun x => length (fst x) + length l)}).\ncase (le_lt_dec n 1); intro.\nleft;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;auto.\nright;autoQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\nintro.\nassert (H := length_to_correct_inf _ _ _ H).\nunfold factorizable in H.\nsimpl in H.\nrewrite <- minus_n_O in H.\nsimpl.\nomega.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nProof.\n  intro; simpl; rewrite e;reflexivity.\nQed.",
                    "Lemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\nintro.\ncase (le_gt_dec n 0).\nintros.\ncase (le_gt_dec n 0).\nintros.\nright;exists 0;split;trivial.\nrewrite H2;trivial.\nintros p H.\ncase (le_lt_dec n (length (fst x)) (length (snd x))); intros.\nleft;exists (S p, S p).\nsplit;trivial.\nrewrite H2;trivial.\nrewrite H2;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "wf : (list (nat*nat))->Prop :=\n  nil_is_wf : (is_wf nil)\n|cons_is_wf : forall (p n:nat)(tail:(list (nat*nat))),(is_prime p)->(n>0)->(is_wf tail)->(rel_prime p (refactor tail))->(is_wf (cons (p,n) tail)).\n\n(** this gives an inefficient algorithm to compute a factorisation of n *)\nLemma factorisation : forall (n:nat),{l:(list (nat*nat)) | (is_wf l)/\\n=(refactor l)}+{n=0}.\n  intro.\n  case (eq_nat_dec n 0);intro.\n  right;trivial.\n  case (eq_nat_dec n 1).\n  intro;left;exists (nil (A:=nat*nat)).\n  split;[apply nil_is_wf | simpl;trivial].\n  generalize n0.\n  apply (lt_wf_rec n (fun n:nat => n<>0 -> n <> 1 -> {l : list (nat * nat) | is_wf l /\\ n = refactor l}+{n=0}));intros.\n  elim (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\n",
                "context_tokens": 704,
                "proof_start_offset": 12623,
                "proof_end_offset": 13304,
                "proof": "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nProof.\ninduction l;simpl;intros.\nassert (p=1).\napply divides_antisym;trivial.\napply one_min_div.\nrewrite H2 in H;elim H;tauto.\ndestruct a.\ncase (divides_dec (power n n0) p);intro.\ngeneralize (prime_power p n0 n H d);intro.\nassert (n=p).\ninversion H0.\nelim H6.\nintros.\nelim H;intros.\ncase (H11 p H2);try tauto;try omega.\nexists n0;rewrite <- H3;left;trivial.\ninversion H0.\nelim (IHl H H7).\nintros;exists x;tauto.\napply gauss with (power n n0);trivial.\napply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\ninduction l;simpl;try tauto.\n  intros.\n  case (le_gt_dec n (length l)); intros.\n  left;exists (S m).\n  split;[apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H;simpl;apply H.\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros.\n  case (le_lt_dec (fst (proj1_sig p) l) 0);intro.\n  elim H1; intros.\n  left; auto.\n  right; auto.\n  right; auto.\n  intro.\n  case (le_lt_dec (snd (proj1_sig p) l) 0); intro.\n  left; exists (fst (proj1_sig p) l); split;[apply H;simpl;trivial | idtac].\n  rewrite H1.\n  exists (snd (proj1_sig p) l);trivial.\n  right; auto.\n  right; auto.\n  right; auto.\n  intro.\n  case (le_lt_dec (fst (proj1_sig p) l) 0); intro.\n  left; exists (snd (proj1_sig p) l); split;[apply H;simpl;trivial | idtac].\n  rewrite H1.\n  exists (snd (proj1_sig p) l);trivial.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; auto.\n  right; autoQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros p l.\n  case (le_lt_dec (fst p) (fst p) l);intro.\n  left; exists (snd p).\n  split;[apply pred_hereditary with (fst p);simpl;trivial|].\n  case (le_lt_dec (fst p) (fst p)); intro.\n  left; exists (snd p).\n  split;[apply pred_hereditary with (fst p);simpl;trivial|].\n  case (le_lt_dec (fst p) (fst p)).\n  intro.\n  left; exists (snd p0).\n  split;[apply pred_hereditary with (snd p0);simpl;trivial|].\n  case (le_lt_dec (fst p) (snd p0)); intro.\n  left; exists (snd p).\n  split;[apply pred_hereditary with (fst p0);simpl;trivial|].\n  case (le_lt_dec (fst p) (fst p)).\n  intro.\n  left; exists (snd p0).\n  split;[apply pred_hereditary with (snd p0);simpl;trivial|].\n  case (le_lt_dec (fst p) (fst p0)); intro.\n  left; exists (snd p).\n  split;[applyQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intros;\n  case H;intro.\n  left;exists (pos,(is_prime p));simpl;trivial.\n  destruct H1.\n  left;exists (pos,(is_prime p)); simpl;trivial.\n  left;exists (pos,(is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos,(is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos,(is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  right; exists (pos (is_prime p)); simpl;trivial.\n  left; exists (pos (is_prime p)); simpl;trivial.\n  rightQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\nintros.\ncase (le_gt_dec n (length l) + 1)); intro.\n  case (le_gt_dec n (length l) + 1); intro.\n  left;trivial.\n  apply le_S_n; auto.\n  elim H0; intros.\n  case H; intro.\n  left;exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  unfold is_wf; simpl; firstorder.\n  intro.\n  case H; intro.\n  destruct H0 as (m,H2).\n  exists (S m).\n  split;[apply (H m) | apply (H m)].\n  apply (H m).\n  apply (H m).\n  apply (H m).\n  apply (H m).\n  apply (H m).\n  apply (H m).\n  apply (H m).\n  apply (H m).\n  apply (H m).\nQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;try tauto.\n  intros.\n  case H;intro.\n  destruct a.\n  simpl in H0.\n  rewrite H1;simpl.\n  trivial.\n  case H0; intros.\n  case (eq_nat_dec p p0); intro.\n  left; exists (S m0); simpl;rewrite e; simpl;trivial.\n  case H; intros.\n  right; exists (S m0); simpl;rewrite e; simpl;trivial.\n  case H; intros.\n  case (eq_nat_dec p p0); intro.\n  left; exists (S m0); simpl; rewrite e; simpl;trivial.\n  case (eq_nat_dec p p0); intro.\n  left; exists (S m0); simpl; rewrite e; simpl; trivial.\n  case H; intros.\n  left; exists (S m0); simpl; rewrite e; simpl; trivial.\n  case H; intros.\n  left; exists (S m0); simpl; rewrite e; simpl;trivial.\n  case H; intros.\n  left; exists (S m0); simpl; rewrite e; simpl;trivial.\n  case H; intros.\n  left; exists (S mQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case (le_gt_dec n (length l)).\n  intro; left;exists (S (length l))).\n  split;[apply le_S_n; apply le_S_n | apply le_S_n].\n  apply (le_S_n (fun n0:nat => n0<=n0) (S m)); auto.\n  rewrite H; simpl.\n  apply le_S_n.\n  apply le_S_n; apply le_S_n; apply le_S_n.\n  apply le_S_n.\n  apply le_trans with (S m); auto.\n  apply le_S_n; apply le_S_n; apply le_S_n.\n  apply le_trans with (S m); auto.\n  apply le_S_n; apply le_S_n; apply le_S_n.\n  apply le_trans with (S m); auto.\n  apply le_S_n; apply le_S_n; apply le_S_n; apply le_S_n.\n  apply le_trans with (S m); auto.\n  apply le_S_n; apply le_SQed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\ninduction l;simpl;try tauto.\n  intro;apply False_ind;clear H.\n  case (le_lt_dec p 0);intro.\n  left; exists (S m).\n  split;[apply False_ind;assumption | left;assumption].\n  left;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  left;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  right;exists (S m).\n  split;[apply False_ind;assumption | left;assumption].\n  left;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  right;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  left;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  right;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  right;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  left;exists (S m).\n  split;[apply False_ind;assumption | right;assumption].\n  left;Qed.",
                    "Lemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  intro.\n  case H; intro.\n  elim H2; intro.\n  elim H4; intros.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H1.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H3.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);trivial.\n  rewrite H2.\n  exists (posGI m n1);split;trivial.\n  rewrite H2.\n  exists (posGI m nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " (nat_factor_prime n1 H0 H1).\n  intro p;intro.\n  elim p0;intro m;intro.\n  elim p1;intro q;intro.\n  elim p2;intros.\n  elim H3;intros.\n  elim H5;intros.\n  elim H7;intros.\n  case (eq_nat_dec q 1);intro.\n  left;exists (cons (p,m) nil);simpl;rewrite e in H6.\n  split;trivial.\n  apply cons_is_wf;auto;try (apply nil_is_wf).\n  unfold rel_prime;simpl;rewrite e in H8;trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\n",
                "context_tokens": 714,
                "proof_start_offset": 13376,
                "proof_end_offset": 13646,
                "proof": "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;try tauto.\nintros;destruct a.\ninversion H0.\ncase (in_inv H);intros.\ninversion H8;rewrite <- H10;rewrite <- H11;try tauto.\napply IHl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros l.\n  destruct (p,n) as (m,H).\n  exists m;intros.\n  generalize (H m (S m) H0);intro.\n  generalize (H m (S m) H0);intro.\n  rewrite H0 in H0; discriminate.\n  elim H0; intros.\n  elim H1; intros.\n  elim H3; intros.\n  left; exists x0;auto.\n  elim H3; intros.\n  right; exists x1;auto.\n  elim H3; intros.\n  left; exists x1;auto.\n  elim H3; intros.\n  right; exists x1;auto.\n  elim H3; intros.\n  right; exists x1;auto.\n  elim H3; intros.\n  right; exists x1;auto.\n  elim H3; intros.\n  left; exists x1;auto.\n  elim H3; intros.\n  right; exists x1;auto.\n  elim H3; intros.\n  left; exists x1;auto.\n  elim H3; intros.\n  right; exists x1;auto.\n  elim H3; intros.\n  left; exists x1;auto.\n  elimQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;intros.\nleft;trivial.\nright;intros;apply in_inv_pred with (n:=n0);trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  unfold is_finite; intros.\n  destruct H as (m,H).\n  elim H; intros.\n  apply H; tauto.\n  apply (H0 H1).\n  simpl; tauto.\n  apply (H0 (fst m)); simpl; tauto.\n  apply (H1 (fst m)); simpl; tauto.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;try tauto.\nintro.\ncase H;intros.\nrewrite H1;simpl;trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l.\nsimpl;trivial.\nsimpl;trivial.\nintro.\nassert (p=1).\n  apply in_split with (pred (length l));simpl;trivial.\nrewrite pred_of_P_of_P_of_succ_nat.\nsimpl;omega.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  intros.\n  apply all_coplanar_prime with (p,n).\n  apply all_coplanar_prime with (p,n).\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivial.\n  apply all_coplanar_prime with (P:=n);trivialQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;intros.\nsimpl in H.\ndestruct l.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nintros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H0;intros.\napply H0;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napply H;intros.\napplyQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\ninduction l;simpl;intros;trivial.\nQed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  apply in_rev in H; destruct H.\n  apply in_rev in H0.\n  destruct H as [m [H H]].\n  destruct (p0,m).\n  destruct (p0,m).\n  exists m.\n  rewrite <- H0;simpl.\n  exists (S m).\n  rewrite H0; simpl.\n  exists (S m).\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  exists (S m).\n  rewrite H0; simpl.\n  exists (S m).\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  rewrite H0.\n  exists (S m).\n  rewrite H0.\n  simpl; ring.\n  inversion H0.\n  elim (H n m); intros.\n  case (H n m); intros.\n  elim H; intros.\n  elim H; intros.\n  elim H; intros.\n  elim H; intros.Qed.",
                    "Lemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\nProof.\n  induction l;simpl;intros.\n  destruct n;simpl in H;simpl in H;destruct H;simpl in H.\n  destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;simpl in H;destruct H;subst;simpl in H;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;simpl in H;simpl in H;inversion H;simpl in H;destruct H;subst;simpl in H;destruct H;subst;simpl in H;simpl in H;destruct H;subst;simpl in H;simpl in H;destruct H;subst;simpl in H;simpl in H;destruct H;subst;simpl in H;simpl in H;simpl in H;destruct H;subst;simpl inQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": ";trivial.\n  assert (q<>0).\n  intro;rewrite H10 in H6;rewrite mult_comm in H6;simpl in H6;auto.\n  elim (H q H9 H10 n2).\n  intro.\n  elim a;intro l;intro.\n  elim p3;intros.\n  left;exists (cons (p,m) l);simpl;rewrite H12 in H6;split;trivial.\n  apply cons_is_wf;auto.\n  rewrite <- H12;unfold rel_prime;trivial.\n  intro;tauto.\nQed.\n\n(** we now show that a factorisation is unique upto permutations *)\n(** if (p,n) is in l then p^n | (refactor l) *)\nLemma factor_divides_refactor : forall (x:nat*nat)(l:list (nat*nat)),(In x l)->(divides (refactor l) (power (fst x) (snd x))).\n  induction l;simpl;try tauto.\n  intro.\n  case H;intro.\n  destruct a.\n  rewrite <- H0;simpl.\n  exists (refactor l);trivial.\n  destruct a.\n  elim (IHl H0);intros.\n  rewrite H1.\n  exists ((power n n0)*x0);ring.\nQed.\n\n(** if p is prime and p | (refactor l) then there is n such that (p,n) is in l *)\nLemma prime_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\n",
                "context_tokens": 709,
                "proof_start_offset": 13716,
                "proof_end_offset": 14282,
                "proof": "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\ninduction l;simpl;intros;try tauto.\ndestruct a.\ninversion H0;case (in_inv H);intro.\nrewrite H8 in H7;simpl in H7.\nelim (in_wf ((n0,n1)::l) p n H);trivial;intros.\nelim (mult_rel_prime q (power p n) (refactor l) H7);intros.\napply rel_prime_sym;apply power_rel_prime with n;trivial.\napply (IHl p n q m);trivial.\napply cons_is_wf;trivial.\ninversion H6;trivial.\nsimpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\n  intros l; induction l.\n  simpl; intros.\n  assert (p=m).\n  apply in_or_app with (p,m); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\n  apply (H (S m)); auto.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\ninduction l;simpl;intros.\nassert (p=1).\n  apply pred_hereditary with (p,m).\n  apply pred_hereditary with (p,(m,m)).\n  apply pred_hereditary with (p,(m,m)).\n  apply pred_hereditary with (p,(m,m)).\n  apply pred_hereditary with (p,(m,m)).\n  apply pred_hereditary with (p,(m,m)).\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  apply pred_hereditary with m.\n  applyQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;intros.\nassert (p=m).\n  inversion H;clear H0;inversion H0;subst;trivial.\n  inversion H0.\n  case (le_gt_dec (p,m) m);intro.\n  generalize (H0 p);intro.\n  replace (p,(q,m)) with (p,(q,m)).\n  replace (p,(m,m)) with (p,(q,m)).\n  replace (p,(m,m)) with (p,(q,m)).\n  replace (p,(m,m)) with (p,(q,m)).\n  replace (p,(m,m)) with (p,(q,m)).\n  replace (p,(q,m)) with (p,(q,m)).\n  rewrite <- H.\n  rewrite H1.\n  rewrite H2.\n  replace (p,(q,m)) with (p,(q,m)).\n  rewrite H0.\n  ring.\n  replace (p,(q,m)) with (p,(q,m)).\n  apply H0.\n  rewrite H2.\n  reflexivity.\n  inversion H1.\n  case (le_gt_dec (p,m) m); intro.Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\n  intros; destruct a.\n  inversion H0.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl; exists (p,m);trivial.\n  simpl; exists (p,m);trivial.\n  simpl; exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl; exists (p,m);trivial.\n  simpl; exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl; exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (p,m);trivial.\n  simpl;exists (Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (H p);intros.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\nProof.\ninduction l;simpl;intros.\ndestruct p;simpl.\nassert (p=0).\napply pred_dec; tauto.\ndestruct a;simpl;trivial.\nrewrite <- H;simpl.\nexists (S (S n0)).\nreplace (S (m+n0)) with (m+n0).\nreplace (m+n0) with (m+n0).\nreplace (m+n0) with (m-n0).\nrewrite H1;simpl;ring.\nassert (m-n0=0).\napply pred_dec; tauto.\nrewrite <- H1;simpl.\nexists (S (m+n0)).\nrewrite H1;simpl;ring.\nring.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;try tauto.\n  intros; destruct a.\n  inversion H0;rewrite H in H3;simpl in H3;simpl in H3;inversion H3.\n  elim (H p0);intros.\n  rewrite H0;simpl.\n  exists (S (q,m)).\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\n  apply H;simpl;trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros.\n  assert (p=m).\n  apply in_or_app.\n  generalize (eq_nat_dec (p,m) H0).\n  case (p=m);intro.\n  subst;trivial.\n  inversion H1;rewrite <- H2;simpl;rewrite H6;trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));trivial.\n  apply (IHn (m+p));Qed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\ninduction l;simpl;intros.\n  case H0;intro.\n  case H;intro.\n  case H0;intro.\n  case H1;intro.\n  case H1;intro.\n  case H2;intro.\n  apply H2;rewrite H4;simpl.\n  rewrite H4;simpl;trivial.\n  apply H1;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\n  apply H2;simpl;trivial.\nQed.",
                    "Lemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;try tauto.\n  intros; destruct a.\n  simpl in H;inversion H;clear H;inversion H0;inversion H1.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\n  apply H0;trivial.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\n  apply H;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_divides_refactor : forall (p:nat)(l:list (nat*nat)),(is_prime p)->(is_wf l)->(divides (refactor l) p)->(exists m:nat,(In (p,m) l)).\n  induction l;simpl;intros.\n  assert (p=1).\n  apply divides_antisym;trivial.\n  apply one_min_div.\n  rewrite H2 in H;elim H;tauto.\n  destruct a.\n  case (divides_dec (power n n0) p);intro.\n  generalize (prime_power p n0 n H d);intro.\n  assert (n=p).\n  inversion H0.\n  elim H6.\n  intros.\n  elim H;intros.\n  case (H11 p H2);try tauto;try omega.\n  exists n0;rewrite <- H3;left;trivial.\n  inversion H0.\n  elim (IHl H H7).\n  intros;exists x;tauto.\n  apply gauss with (power n n0);trivial.\n  apply rel_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\n",
                "context_tokens": 728,
                "proof_start_offset": 14570,
                "proof_end_offset": 14965,
                "proof": "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\nProof.\ninduction l;intro.\napply nil_is_pwd.\ndestruct a.\ninversion H.\napply cons_is_pwd;auto.\nintros;intro.\nassert (rel_prime n n).\neapply rel_prime_wf;[apply H7 | apply H].\ngeneralize (gcd_refl n);intro.\nunfold rel_prime in H8.\nassert (1=n).\neapply gcd_unique;eauto.\nrewrite <- H10 in H3;elim H3;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;auto.\n  destruct l0.\n  inversion H0.\n  simpl in H2;inversion H2;subst;auto.\n  destruct l0.\n  inversion H2;subst;auto.\n  apply IHl;trivial.\n  simpl in H2;inversion H2;subst;auto.\n  inversion H2;subst;auto.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros.\napply (H (length l))).\napply (H (length l)).\napply (H (length l)).\napply (H (length l)).\napply (H (length l)).\napply (H (length l)).\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l; simpl;intros;trivial.\ninversion H0;clear H0;inversion H0;clear H0;intros;simpl in *.\n(* case l is in l' and (r,m) *)\n(* case l' is a (p,m) *)\n(* case l' is a (p,m') *)\nintros n m p' p' H H0 H1 H2.\ninversion H2;inversion H3;clear H1;intros;inversion H3;clear H3;\n inversion H3;clear H3;intros;inversion H3;clear H3;\n inversion H3;clear H3;intros;inversion H3;clear H3;\n inversion H3; clear H3;\n inversion H3;clear H3;\n inversion H3; clear H3;\n inversion H3; clear H3;\n inversion H3; clear H3;\n inversion H3;clear H3;\n inversion H3; clear H3;\n inversion H3; clear H3;\n inversion H3; clear H3;\n inversion H3; clear H3;\ninversion H3; clear H3;\n inversion H3; clear HQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros.\nelim H;clear H;intros;simpl;trivial.\nassert (p=0).\nclear H0;intros;simpl in H;inversion H.\ninversion H0.\nsubst;simpl;trivial.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros.\napply is_pequiv.\napply is_pequiv.\napply in_equiv.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_founded_induction.\napply well_Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  simpl.\n  destruct l;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.\n  destruct l0;simpl;trivial.\n  simpl.Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros.\ninversion H.\napply (IHp n (fun n => is_pwd (is_paux n)) (fun n => is_pwd (is_paux n))).\napply (IHp n (fun n => is_pwd (is_paux n))).\napply (IHp n (fun n => is_pwd (is_paux n))).\nintros;apply (IHp n (fun n => is_pwd (is_paux n)))).\nintros;apply (IHp n (fun n => is_pwd (is_paux n))).\nintros;apply (IHp n (fun n => is_pwd (is_paux n))).\nintros;apply (IHp n (fun n => is_pId (is_paux n)))).\nintros;apply (IHp n (fun n => is_pwd (is_paux n))).\nintros;apply (IHp n (fun n => is_pwd (is_paux n))).\nintros;apply (IHp n (fun n => is_pId (is_paux n))).\nintros;apply (Qed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l; simpl;intros;trivial.\ncase (is_pequiv l);intros.\nrewrite H;auto.\ncase (in_inv H);intros;rewrite H;auto.\nQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros;trivial.\n  destruct a.\n  inversion H0.\n  simpl in H; inversion H.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHn;trivial.\n  simpl;apply IHnQed.",
                    "Lemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\ninduction l;simpl;intros.\nassert (p0=0).\n  apply in_map_iff in H0; destruct H0;subst;assumption.\n  subst;rewrite H;rewrite H;rewrite H0;simpl;ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_prime_sym;apply prime_div_gcd;trivial.\nQed.\n\n\n(** if (p,n) is in l and l is well-formed then p is prime and n>0 *)\nLemma in_wf : forall (l:list (nat*nat))(p n:nat),(In (p,n) l)->(is_wf l)->(is_prime p)/\\(n>0).\n  induction l;simpl;try tauto.\n  intros;destruct a.\n  inversion H0.\n  case (in_inv H);intros.\n  inversion H8;rewrite <- H10;rewrite <- H11;try tauto.\n  apply IHl;trivial.\nQed.\n\n(** if (p,n) is in l and (q,m)::l is well-formed then gcd(p,q)=1 *)\nLemma rel_prime_wf : forall (l:list (nat*nat))(p n q m:nat),(In (p,n) l)->(is_wf ((q,m)::l))->(rel_prime p q).\n  induction l;simpl;intros;try tauto.\n  destruct a.\n  inversion H0;case (in_inv H);intro.\n  rewrite H8 in H7;simpl in H7.\n  elim (in_wf ((n0,n1)::l) p n H);trivial;intros.\n  elim (mult_rel_prime q (power p n) (refactor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\n",
                "context_tokens": 694,
                "proof_start_offset": 15062,
                "proof_end_offset": 15834,
                "proof": "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\ninduction l;simpl;intros;try tauto.\ncase H3;intro.\nrewrite H4 in H2.\nrewrite H4 in H1;inversion H1.\ngeneralize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\nrewrite mult_comm in H2.\ngeneralize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\napply power_divides_power with p;trivial.\ndestruct p.\nelim (not_prime_zero H8).\nelim H8;omega.\ndestruct a.\ninversion H1.\napply IHl;trivial.\napply gauss with (power n0 n1);trivial.\napply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\napply (rel_prime_wf l p m n0 n1);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\ninduction n;simpl;intros.\napply False_ind;intros.\nassert (H:=is_pwd n).\nassert (H:=is_pwd n).\nassert (H:=is_pwd n).\nassert (H:=is_pwd n).\nassert (H:=is_pwd n).\nassert (H:=is_pwd n).\nassert (H:=is_pwd n).\napply (lt_is_pos_equiv (fun n => (n-m)<n) H H0).\nassert (H:=is_pwd n).\napply (lt_is_pos_equiv (fun n => (n-m)<n) H H0).\napply (lt_is_pos_equiv (fun n => (n-m)<n) H H0).\napply (lt_is_pos_equiv (fun n => (n-m)<n) H H0).\napply (lt_is_pos_equiv (fun n => (n-m)<n) H H0).\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  intros; simpl; intros.\n  assert (H : forall n, (n<=m)%nat -> (n<=m)%nat -> (n<=m)%nat).\n  intros n Hn H; apply H; auto with arith.\n  destruct a.\n  inversion H;clear H;try tauto.\n  inversion H0;clear H0;try tauto.\n  simpl; apply IHn;auto.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  unfold prime, is_paux, prime; intros.\n  assert (H := (fun n => (n<=m/\\is_pwd (pos_div p n))).\n  assert (H := H (fun n => (n<=m/\\is_pwd (pos_div p n))).\n  assert (H1 := H (fun n => (n<=m/\\is_pwd (pos_div p n) (pos_div p n))).\n  assert (H2 := H (fun n => (n<=m/\\is_pwd (pos_div p n) (pos_div p n))));\n  assert (H3 := H (fun n => (n<=m/\\is_pwd (pos_div p n) (pos_div p n))).\n  assert (H3 := H (fun n => (n<=m/\\is_pwd (pos_div p n) (pos_div p n)));\n  assert (H4 := H4 (fun n => (n<=m/\\is_pwd (pos_div p n) (pos_div p n)));\n  assert (H4 := H2 (fun n => (n<=m/\\isQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n induction n;intros.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\nsimpl;auto.\nconstructor.\nconstructor;auto.\nconstructor.\nconstructor;auto.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\ninduction l;intros.\nsimpl.\nsplit;try tauto.\nsimpl.\nassert (p0=n).\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (snd p) n (fst p0));intro.\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (snd p) n (snd p0));intro.\n  apply (lt_wf_ind (fst p) n (fst p0));intro.\n  apply (lt_wf_ind (snd p) n (fst p0));intro.\n  apply (lt_wf_ind (snd p) n (fst p0));intro.\n  apply (lt_wf_ind (sndQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\ninduction n;intros.\nsimpl;induction H.\nsimpl;intros.\ndestruct H as [a?].\napply (IHn p (a::l) a); trivial.\napply (IHn p (a::l) a); trivial.\nsimpl;intros.\nassert (a=a).\n  apply (IHn p (a::l) a); trivial.\napply (IHn p (a::l) a); trivial.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  induction n;intros.\n  simpl.\n  rewrite (mult_comm (1 + n)).\n  apply (fun n m => mult_le_compat_l n m n).\n  apply (fun n m => mult_le_compat_l n m n).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m n).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m m).\n  apply (fun n m => mult_le_compat_l n m m).\n Qed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\ninduction l;intros.\nsimpl;intros.\nsimpl.\napply le_refl.\nintros;apply (le_refl (fst p) (snd p)); auto.\nintros;apply (le_refl (fst p) (snd p)); auto.\nQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;intros.\n  apply False_ind;apply H;auto.\n  elim (prime_dec n m);intro.\n  apply pred_prime_minus.\n  apply (IHn m n p);auto.\n  elim (prime_dec m n);intro.\n  apply pred_prime_minus.\n  apply (IHn m n p);auto.\n  elim (prime_dec n m);intro.\n  apply prime_factor_prime with n;auto.\n  apply (IHn m n p);auto.\n  elim (prime_dec n m);intro.\n  apply prime_factor_prime with n;auto.\n  apply (IHn m n p);auto.\n  elim (prime_dec n m);intro.\n  apply prime_factor_prime with n; auto.\n  apply (IHn m n p);auto.\n  elim (prime_dec n m);intro.\n  apply prime_factor_prime with n; auto.\n  apply (IHn m n p);auto.\n  elim (prime_dec n m);intro.\n  apply prime_factor_prime with n; auto.\n  apply (IHn m n p);auto.\n  elim (prime_dec n m);intro.\n  apply prime_factorQed.",
                    "Lemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\nProof.\n  intros p n m l.\n  assert (H:= prime_power_theory_correct n m).\n  assert (H:= prime_power_theory_correct n m).\n  assert (H':= prime_power_correct n m).\n  assert (H':= fun n => (prime_gt_0 n) H').\n  assert (H:= prime_power_correct n m).\n  assert (H':=fun n => (prime_gt_0 n) H').\n  assert (H':=fun n => (prime_0 n) H').\n  assert (H':= fun n => (prime_0 n) H').\n  destruct H' as (q,q).\n  apply prime_power_correct with q;auto.\n  assert (H':=fun n => (prime_0 n) H').\n  assert (H':=fun n => (prime_0 n) H').\n  assert (H':=fun n => (prime_1 n) H').\n  assert (H':=fun n => (prime_1 n) H').\n  rewrite H' in H'; inversion H'; clear H'.\n  apply prime_div_monotonic; auto.\n  clear n H n.\n  intros.\n  assert (HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "actor l) H7);intros.\n  apply rel_prime_sym;apply power_rel_prime with n;trivial.\n  apply (IHl p n q m);trivial.\n  apply cons_is_wf;trivial.\n  inversion H6;trivial.\n  simpl in H7;elim (mult_rel_prime q (power n0 n1) (refactor l) H7);auto.\nQed.\n\nInductive is_pwd : list (nat*nat) -> Prop :=\n  nil_is_pwd : (is_pwd nil)\n|cons_is_pwd : forall (p n:nat)(tail:list (nat*nat)),(is_pwd tail)->(forall (n:nat),~(In (p,n) tail))->(is_pwd ((p,n)::tail)).\n\n(** if l is well-formed then the first projection of l is pairwise distinct (pwd) *)\nLemma wf_impl_pwd : forall (l:list (nat*nat)),(is_wf l)->(is_pwd l).\n  induction l;intro.\n  apply nil_is_pwd.\n  destruct a.\n  inversion H.\n  apply cons_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\n",
                "context_tokens": 691,
                "proof_start_offset": 15927,
                "proof_end_offset": 16738,
                "proof": "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\nProof.\nintros l l';intro;intro;intro;intros p n;intro.\nelim (in_wf l p n H2 H);intros.\ngeneralize (factor_divides_refactor (p,n) l H2);simpl;intro.\nrewrite H1 in H5.\nassert (divides (refactor l') p).\napply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\nelim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\ncut (n=m).\nintro;rewrite H8;trivial.\napply le_antisym.\neapply prime_power_divides_refactor;eauto.\ngeneralize (factor_divides_refactor (p,m) l' H7);simpl;intro.\nrewrite <- H1 in H8.\napply prime_power_divides_refactor with p l;auto.\nelim (in_wf l' p m);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intros.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;trivial.\n  simpl;rewrite mult_comm;apply mult_is_palg;Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  apply (IHp n0 l' m);trivial.\n  elim H3;intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3;intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3;intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3; intros.\n  apply (IHp n0 l' m);trivial.\n  elim H3;Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2; inversion H2.\n  rewrite H4 in H2;inversion H2.\n  rewrite H4 in H2;inversion H2.\n  apply (IHl' p n m);trivial.\n  apply (IHp n m);trivial.\n  apply (IHp n m);trivial.\n  apply (IHp n m);trivial.\n  apply (IHp n m);trivial.\n  apply (IHp n m);trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\ninduction l;intros.\nsimpl;unfold mk_pequiv; simpl.\nrewrite IHn;apply (conj_pequiv_pequiv_l l l');intros.\nassert (factor_inverse n (snd (fst x)) l').\n  apply (conj_pequiv_l l l');intros.\n  unfold mk_pequiv in H2.\n  rewrite H2 in H2;inversion H2.\n  apply (IHpequiv_l l l');intros.\n  apply H0;simpl;auto.\nsimpl;unfold mk_pequiv;simpl;unfold R_dist; simpl.\nrewrite IHn;apply (conj_pequiv_pequiv l l');intros.\napply H0;simpl;auto.\nsimpl;unfold R_dist; simpl.\nrewrite IHn;apply (conj_pequiv_pequiv l l');intros.\napply H0;simpl;auto.\nsimpl;unfold R_dist; simpl.\nrewrite IHn;apply (conj_pequiv_pequiv l l');intros.\napply H0;simpl;auto.\nsimpl;unfold R_dist; simpl.\nrewrite IHn;apply (conj_pequiv_pequiv l l');introsQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intros.\n  apply all_ex_intro;apply (is_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pin_pQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros;try tauto.\n  case H2;intro.\n  rewrite H2 in H2;inversion H2.\n  apply (IHl' l n n0);trivial.\n  apply (IHl' l' n0);trivial.\n  apply (IHl' l n0);trivial.\n  apply (IHl' l n0);trivial.\n  apply (IHl' l n0);trivial.\n  apply (IHl' l n0);trivial.\n  apply (IHl' l n0);trivial.\n  apply (IHl' l n0);trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\ninduction l;intros.\nsimpl in H.\nrewrite H1 in H;clear H.\ndestruct l'.\nsimpl.\nauto.\nsimpl in H.\nrewrite H1 in H;inversion H.\nsimpl in H.\nrewrite H2 in H;inversion H.\nsimpl in H.\nrewrite H2 in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H.\nrewrite H2 in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;inversion H.\nsimpl in H;Qed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\ninduction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H1;inversion H1.\n  apply all_prime_correct;trivial.\n  elim H3;intro.\n  rewrite H4 in H1;inversion H1.\n  rewrite H5 in H1;inversion H1.\n  apply all_prime_correct;trivial.\n  apply (IHl l' l');trivial.\n  apply (IHl' l');trivial.\n  apply all_prime_correct;trivial.\n  apply (IHl' l');trivial.\n  apply all_prime_correct;trivial.\n  apply (IHl' l');trivial.\n  apply all_prime_correct;trivial.\n  apply (IHl' l');trivial.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;simpl;intros.\n  case H;intro.\n  rewrite H2 in H2;rewrite H2 in H2;inversion H2.\n  rewrite H3 in H2;inversion H2.\n  rewrite H3 in H2;inversion H2.\n  rewrite H2 in H2;rewrite H2 in H2;inversion H2.\n  simpl;rewrite H3;rewrite H3;rewrite H4;rewrite H4;ring.\n  simpl;rewrite H3;rewrite H4;ring.\n  simpl;rewrite H3;rewrite H4;ring.\nsimpl;rewrite H4;rewrite H4;ring.\nQed.",
                    "Lemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  induction l;intros.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H0);apply all_ex_intro with n0 n1;trivial.\n  apply all_ex_intro with (1:=H1);apply all_ex_intro with n0 n1;trivial.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "_is_pwd;auto.\n  intros;intro.\n  assert (rel_prime n n).\n  eapply rel_prime_wf;[apply H7 | apply H].\n  generalize (gcd_refl n);intro.\n  unfold rel_prime in H8.\n  assert (1=n).\n  eapply gcd_unique;eauto.\n  rewrite <- H10 in H3;elim H3;tauto.\nQed.\n\n(** if p is prime, n>0, l is well-formed and p^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\n",
                "context_tokens": 723,
                "proof_start_offset": 16740,
                "proof_end_offset": 16884,
                "proof": "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\ninduction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction l;simpl;intros;try tauto.\n  case H0;intro.\n  rewrite H1 in H2.\n  generalize (power_correct_divisors_correct l 0);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m));intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) l H2);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) l H2);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) l H2);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) l H2);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) l H2);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) l H2);intro.\n  rewrite mult_comm in H2.\n  generalize (factor_correct_divisors l (pos m) lQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\nintros l l';intro;intros.\nelim (in_wf l p n H); intros.\ngeneralize (pwd_iff_on_factor_bound l p (fst p) (snd p) H0);intro.\nrewrite H1 in H1;inversion H1.\napply prime_power_monotone_minus with p;auto with *.\nelim H1;intros.\nrewrite H2 in H2; inversion H2.\napply prime_power_monotone_minus with p;auto with *.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\nunfold is_paux, is_finite; intros.\napply is_finite_prime_aux with (gcd 0 (fst (fst (snd (snd (snd (snd (snd (snd (snd p)))))).\napply is_finite_prime_aux;auto with *.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\nProof.\nintros l l';intro;intros p n;intro.\ncase (le_gt_dec n m); intros.\napply is_divide_r_iff in H0; destruct H0.\nrewrite H1 in H0;inversion H0.\nrewrite H1 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H;inversion H0.\nrewrite H2 in H; inversion H0.\nrewrite H2 in H; inversion H0.\nrewrite H2 in H; inversion H0.\nrewrite H2 in H; inversion H0.\nrewrite H2 in H; inversion H0.\nrewrite H2 in H; inversion H0.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intros p n;rewrite is_p_correct;auto.\n  case H;auto.\n  case H;auto.\n  intros;apply H.\n  apply is_finite_prime_correct with (1:=is_nonneg l);auto.\n  elim (not_prime_correct _ H8).\n  elim H8;auto.\n  intros; apply H.\n  apply is_finite_prime_correct with (1:=is_nonneg l);auto.\n  elim (not_prime_correct _ H8).\n  elim H8;auto.\n  intros; apply H.\n  apply is_finite_prime_correct with (1:=is_nonneg l);auto.\n  elim H8;auto.\n  intros; apply H.\n  apply is_finite_prime_correct with (1:=is_nonneg l);auto.\n  elim H8;auto.\n  intros; apply H.\n  apply is_finite_prime_correct with (1:=is_nonneg l);auto.\n  elim H8;auto.\n  intros; apply H.\n  apply is_finite_prime_correct with (1:=is_nonneg l);auto.\n  elim H8;auto.Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intro;intros p n;intro.\n  elim (in_inv_on_prime l p n H);intros.\n  generalize (factorisation_correct_divisors (p,m) l' H2);simpl;intro.\n  rewrite H0 in H0;inversion H0.\n  generalize (factorValue_correct_divisors (p,m) l' H0);simpl;intro.\n  generalize (factorValue_correct_divisors (p,m) l' H2);simpl;intro.\n  generalize (factorValue_correct_divisors (p,m) l' H2);simpl;intro.\n  rewrite H1 in H8.\n  assert (H9 := prime_power_monotone_pos p (snd p) H10 H11 H9).\n  generalize (factorValue_correct_divisors (p,m) l' H9);simpl;intro.\n  rewrite H9 in H10; inversion H10.\n  apply H10.\n  apply prime_power_monotone_pos with p; auto.\n  apply (rel_prime_equiv l p n m);trivial.\n  apply rel_prime_positive.\n  apply (rel_prime_equiv l pQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\ninduction l.\n  simpl;intros;apply pwd_iff_set;trivial.\n  case H;intros.\n  elim (not_prime_0 H);intros.\n  generalize (prime_divisors_correct_divisors p l H1);simpl;intro.\n  rewrite H2 in H5.\n  generalize (prime_divisors_correct_divisors p l H1);simpl;intro.\n  rewrite H6 in H5.\n  generalize (not_prime_correct_divisors p l H1 H3);simpl;intro.\n  rewrite H7 in H5.\n  apply prime_power_monotone_pos with p;auto.\n  elim (not_prime_dec (prime_divisors p) l); intros.\n  generalize (prime_divisors_correct_divisors p l H2);simpl;intro.\n  rewrite H7 in H5.\n  generalize (prime_divisors_correct_divisors p l H1);simpl;intro.\n  rewrite H7 in H5.\n  generalize (prime_divisors_correct_divisors p l H1);simpl;intro.\n  rewrite H7 in H5.\n  generalize (not_prime_correct_divisors p l H1);simpl;intro.\n  rewrite H7Qed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intros l l';intro;intros p n;intro.\n  elim (in_inf_prime l p n H); intros.\n  generalize (pwd_iff_aux p n H1);simpl;intro.\n  rewrite H1 in H2.\n  generalize (Zis_gcd_correct_divisors p n H1);simpl;intro.\n  rewrite H2 in H3.\n  apply prime_power_monotone_pos with p;auto.\n  elim (not_prime_dec p n H2);trivial.\n  elim (not_prime_dec p n H2); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n H3); tauto.\n  elim (not_prime_dec p n HQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  intro l;apply (is_prime_correct (nat*nat) l);apply is_pwd_domain_bound; auto.\n  apply is_pwd_domain_bound; auto.\n  apply is_pwd_domain_bound; auto.\n  apply is_pwd_domain_bound; auto.\n  apply is_pwd_domain_bound; auto.\n  apply is_pwd_domain_bound; auto.\nQed.",
                    "Lemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\ninduction l.\nsimpl;intros;auto with arith.\ncase H;intro.\nrewrite H1 in H2.\nrewrite H2 in H3;inversion H3.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": "^n | (refactor l) and (p,m) is in l then n<=m *)\nLemma prime_power_divides_refactor : forall (p n m:nat)(l:list (nat*nat)),(is_prime p)->(n>0)->(is_wf l)->(divides (refactor l) (power p n))->(In (p,m) l)->(n<=m).\n  induction l;simpl;intros;try tauto.\n  case H3;intro.\n  rewrite H4 in H2.\n  rewrite H4 in H1;inversion H1.\n  generalize (rel_prime_power p (refactor l) n (rel_prime_sym p (refactor l) H11));intro.\n  rewrite mult_comm in H2.\n  generalize (gauss (power p n) (refactor l) (power p m) H12 H2);intro.\n  apply power_divides_power with p;trivial.\n  destruct p.\n  elim (not_prime_zero H8).\n  elim H8;omega.\n  destruct a.\n  inversion H1.\n  apply IHl;trivial.\n  apply gauss with (power n0 n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\n",
                "context_tokens": 705,
                "proof_start_offset": 16982,
                "proof_end_offset": 17483,
                "proof": "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\nintros.\nassert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\napply factorisation_unique_upto_equiv_aux;trivial.\nassert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\napply factorisation_unique_upto_equiv_aux;auto.\napply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H;simpl in *.\n  generalize (factorFunction_correct_prod l l' (inf l') (inf l'));simpl;intro.\n  rewrite H1 in H1;inversion H1.\n  apply H1.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H2.\n  apply H3.\n  apply H2.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H;elim H;intros;clear H;intros;\n elim (interplist_dec l (pred (nat*nat))).\n\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nsimpl;auto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H;simpl in H.\n  elim (in_wf l' p0); intros.\n  generalize (factorisation_correct_prod l l' H2);simpl;intro.\n  rewrite H2 in H0;rewrite H1 in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  generalize (factorisation_correct_prod l l' H1);simpl;intro.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  generalize (factorisation_correct_prod l l' H1);simpl;intro.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in H0.\n  rewrite mult_comm in HQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\n intros l l' H;induction H;simpl;intros;inversion H.\ninversion H.\ninversion H0.\ninversion H1.\ninversion H.\ninversion H.\ninversion H.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros;apply (pwd_iff l l');auto.\n  apply (pwd_iff l' H2 H3 H4).\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  apply (pwd_iff (p,m));auto.\n  applyQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H H0 H1.\n  elim (in_split_prime l' H1);intro m;intro;intros.\n  elim (in_split_prime l' H1);intro m;intros.\n  generalize (factorpath_correct_prod_aux l l' H2); simpl;intro.\n  rewrite H1 in H0; inversion H0;clear H0.\n  simpl.\n  rewrite H1.\n  rewrite H2.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  trivial.\n  rewrite mult_comm.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  trivial.\n  rewrite mult_Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H;simpl in H.\n  destruct (is_pos_correct_divisors l) as (m,H).\n  generalize (is_pos_correct_divisors l') (is_pos_correct_divisors l') H);intro.\n  generalize (is_pos_correct_divisors l') (is_pos_correct_divisors l') H);intro.\n  rewrite H0 in H;inversion H.\n  assert (H1 := H2 H0).\n  apply  IHe with (power p n);trivial.\n  apply H;auto.\n  apply H;auto.\n  apply H0;auto.\n  apply H1;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H0;auto.\n  apply H;auto.\n  apply H;auto.\n  apply H0;auto.\n  apply H;auto.\n  apply H;auto.\nQed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\nProof.\ninduction l;simpl;intros.\ninversion H.\ninversion H1.\ninversion H0.\ndestruct l';trivial.\ninversion H1.\nsimpl.\ninversion H0.\nsimpl.\ninversion H0.\nsimpl.\ninversion H0.\ninversion H1.\nsimpl.\ninversion H0.\ninversion H1.\nsimpl.\ninversion H1.\nsimpl.\ninversion H0.\ninversion H1.\ninversion H0.\nsimpl.\ninversion H0.\ninversion H1.\nsimpl.\ninversion H1.\ninversion H1.\ninversion H1.\nsimpl.\ninversion H0.\ninversion H0.\nsimpl.\ninversion H0.\ninversion H1.\ninversion H0.\nsimpl.\ninversion H1.\ninversion H1.\nsimpl.\ninversion H1.\ninversion H1.\ninversion H1.\nsimpl.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\nsimpl.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H1.\nsimpl.\ninversion H1.Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H.\n  apply (factorpathisation_correct_prod_equiv l l' l');trivial.\n  case (is_prime_linear_gcd l l');intros.\n  generalize (factor3_correct_prod l l' H0);simpl;intro.\n  rewrite H1 in H;inversion H.\n  apply (factorpathity_correct_prod_equiv l l' l');trivial.\n  case (is_prime_linear_gcd l l');intros.\n  generalize (factor3_correct_prod l l' H0);simpl;intro.\n  rewrite H1 in H;clear H.\n  generalize (factor3_correct_prod l l' H0);simpl;intro.\n  rewrite H1 in H;clear H.\n  generalize (factor3_correct_prod l l' H0);simpl;intro.\n  rewrite H1 in H;clear H1.\n  generalize (factor3_correct_prod_equiv l l' H0);simpl;intro.\n  rewrite H2 in H;clear H.\n  rewrite H2 in H;clear H.\n  generalize (factor3_correct_prod l l' H0);simpl;intro.\n  rewrite H1Qed.",
                    "Lemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros l l' H H0;apply H;simpl;apply H;simpl;apply H;simpl;apply H0;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H2;simpl;apply H2;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H2;simpl;apply H1;simpl;apply H1;simpl;apply H2;simpl;apply H1;simpl;apply H2;simpl;apply H2;simpl;apply H2;simpl;apply H2;simpl;apply H1;simpl;apply H2;simpl;apply H1;simpl;apply H1;simpl;apply H1;simpl;apply H2;simpl;apply H2;simpl;apply H2;simpl;apply H2;simpl;apply H1;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " n1);trivial.\n  apply rel_prime_power;apply rel_prime_sym;apply rel_prime_power.\n  apply (rel_prime_wf l p m n0 n1);trivial.\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l is included in l' *)\nLemma factorisation_unique_upto_equiv_aux : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\n",
                "context_tokens": 723,
                "proof_start_offset": 17745,
                "proof_end_offset": 17899,
                "proof": "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros.\ncase (factorisation n);intros;try tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros n.\ninduction n.\nsimpl;intros.\nintros.\nintros.\nsimpl in H.\napply H.\nassert (H:=H0).\nunfold is_factorizable in H.\nsimpl in H.\napply (H (S n) (S n)).\nsimpl;intros.\napply H.\napply H.\nclear H.\nassert (H':=H0).\nunfold is_factorizable in H.\nsimpl in H.\napply (H (S n) (S n)).\nsimpl;intros.\napply H.\nclear H.\nassert (H:=H0).\nunfold is_factorizable in H.\nsimpl in H.\napply (H (S n) (S n)).\nsimpl;intros.\napply H.\nclear H.\nassert (H:=H0).\nunfold is_factorizable in H.\nsimpl in H.\napply (H (S n) (S n)).\nsimpl;intros.\napply H.\nclear H.\nassert (H:=H0).\nunfold is_factorizable in H.\nsimpl in H.\napply (H (S n) (S nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  assert (H:=H0 n).\n  apply (H (fun n:nat => forall (x:nat),n=0 -> is_factorisation n l).\n  apply H; auto.\n  apply (H0 (fun n:nat => is_factorisation n l));intros.\n  apply (H (fun n:nat => is_factorion (S n) l));intros.\n  generalize (factorpath_correct_prod (S n) l H2);simpl;intro.\n  rewrite H2 in H3.\n  apply H3; auto.\n  apply (H (fun n:nat => is_factorion (S n) l));intros.\n  generalize (factorpath_correct_prod (S n) l H2); simpl;intro.\n  rewrite H3 in H3.\n  apply H3; auto.\n  apply (H (fun n:nat => is_factorion (S n) l));intros.\n  generalize (factorpath_correct_prod (S n) l H2); simpl; intro.\n  rewrite H3 in H3.\n  apply H3; auto.\n  apply (H0 (fun n:nat => is_factorion (SQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  destruct (exists_witness_dec n l).\n  exists (fun x => is_factorisation (fun x => x) l).\n  intros.\n  generalize (extendallity_unique_upto_equiv n l H0);intro;intros;clear H0.\n  exists (S x).\n  intros.\n  apply (H (S x)) with (S (S x)).\n  apply (H (S x)) with (S x).\n  apply (H (S x) (S x)).\n  apply H1;auto.\n  apply (H (S x)) with (S x).\n  apply (H0 (S x) (S x)).\n  apply (H0 (S x) (S x)).\n  apply (H0 (S x) (S x) (S x)).\n  apply H1;auto.\n  apply (H0 (S x) (S x) (S x) (S x)).\n  apply H1;auto.\n  apply (H0 (S x) (S x) (S x) (S x)).\n  apply (H0 (S x) (S x) (S x) (S x)).\n  apply (H0 (SQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n l.\n  set (R:=fun n => is_factorisation n l).\n  set (R:=fun n => is_factorisation n l).\n  assert (R':= fun n => is_factorisation n l).\n  assert (R':= fun n => is_factorisation n l).\n  assert (R':= fun n => is_factorisation n l).\n  unfold R';simpl.\n  intros (x,(H1,H2)).\n  rewrite H2.\n  apply (H (is_factorisation n l H2));auto.\n  apply is_factorisation_unique_prod.\n  apply is_factorisation_unique with 0%R;auto.\n  apply is_factorBound_correct;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  apply is_factorizable;auto.\n  applyQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n l H';case (is_factorizable n l);intros.\n  left;apply is_factorizable;auto.\n  right;apply is_factorizable;auto.\n  right;apply is_factorizable;auto.\n  right;apply is_factorizable;auto.\nright;apply is_factorizable;auto.\nright;apply is_factorizable;auto.\nright;apply is_factorizable;auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros n l.\n  exists (fun n => is_factorizable n l).\n  exists (fun n => is_factorizable n l).\n  exists (fun n => is_factorizable n l).\n  exists (fun n => is_factorizable n l).\n  exists (fun n => is_factorizable n l).\n  split;trivial.\n  intros.\n  elim (is_factorizable n l (fun n => is_factorizable n l)).\n  intros n' l'.\n  exists (fun n => is_factorizable n' l).\n  split;trivial.\n  intros n' l'.\n  elim (is_factorizable n l' (fun n => is_factorizable n' l)).\n  intros n' l''.\n  exists (fun n => is_factorizable n' l').\n  split.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorizable.\n  apply is_factorQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\nintros n l.\ninduction n as [| n Hrecn].\nsimpl;intros n H;inversion H;clear H.\nexists (S n).\nsimpl;auto.\nintros n H;inversion H.\nexists (S n).\nsimpl;auto.\nintros n H.\ninversion H;clear H.\nexists (S n).\nsimpl;auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  exists (fun _ => True).\n  split; auto.\n  destruct (infton n l) as (x,p).\n  exists (fun _ => x).\n  split; auto.\n  destruct (infton n l) as (x,p).\n  exists (fun _ => x).\n  split; auto.\n  destruct (infton n l) as (x,p).\n  exists x.\n  split; auto.\n  destruct (infton n l) as (x,p).\n  exists (fun _ => x).\n  split; auto.\n  destruct (infton n l) as (x,p).\n  exists x.\n  split; auto.\n  apply (is_factorizable_correct_prod (x,p)); auto.\n  apply is_factorizable_correct with p l; auto.\n  apply is_factorizable_correct with p l; auto.\n  apply is_factorizable_correct with p l; auto.\n  apply is_factorizable_correct with p l; auto.\n  apply is_factorizable_correct with p l; auto.\n  apply is_factorizable_correct with p l; auto.\n  apply is_factorizable_correct with p lQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros;apply is_factorion_correct;intros;intros.\n  exists 0%nat;split;auto.\n  apply is_factorion_correct;intros.\n  exists 0%nat;auto.\n  apply is_factorion_correct;intros.\n  exists 0%nat;auto.\n  apply is_factorion_correct;intros.\n  exists 0%nat;auto.\n  apply is_factorion_correct;intros.\n  exists 0%nat;auto.\n  apply is_factorion_correct;intros.\n  exists 0%nat;auto.\n  apply is_factorion_correct;intros.\n  exists 0%nat;auto.\nQed.",
                    "Theorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\nProof.\n  intros n H;induction  n as [| n Hrec].\n  + left; auto.\n  + right; auto.\n  + right; auto.\n  + right; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  intros l l';intro;intro;intro;intros p n;intro.\n  elim (in_wf l p n H2 H);intros.\n  generalize (factor_divides_refactor (p,n) l H2);simpl;intro.\n  rewrite H1 in H5.\n  assert (divides (refactor l') p).\n  apply divides_trans with (power p n);[trivial | apply power_divides_lemma1;auto with arith].\n  elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\n",
                "context_tokens": 706,
                "proof_start_offset": 17978,
                "proof_end_offset": 18273,
                "proof": "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\nProof.\nunfold is_factorisation;intros.\nelim H;intros.\nelim H0;intros.\napply factorisation_unique_upto_perm;auto;congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n); intros; try tauto.\n  destruct (le_gt_dec n (length l')); try tauto.\n  generalize (factorisation_correct_prod n l l' H2);simpl;intro.\n  rewrite H2 in H2.\n  rewrite H2 in H2.\n  apply le_antisym.\n  apply (H (S n)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  trivial.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n  simpl.\n  rewrite mult_comm.\n Qed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros;apply factorisation_unique_upto_perm;trivial.\n  rewrite <- H;apply is_factorisation_correct;trivial.\n  rewrite <- H;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factority;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;apply is_factorisation_correct;trivial.\n  rewrite <- H0;applyQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros; try tauto.\n  generalize (factorisation_correct_prod (S n) l l' H0);intro.\n  apply (H0 H1);apply is_factorisation; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizable; auto.\n  apply is_factorizableQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros; try tauto.\n  apply is_factorisation_unique_upto_perm;trivial.\n  rewrite <- (mult_comm (S (length l))));simpl;trivial.\n  rewrite <- (mult_comm (S (length l)));simpl;trivial.\n  apply is_factorizable_correct.\n  apply is_factorizable_correct.\n  apply is_factorizable_correct.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply is_factorizable;trivial.\n  apply isQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n l); intros; try tauto.\n  apply (is_factorisation n l l');trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply is_factorally_bound with (n:=nat);trivial.\n  apply isQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n); intros; try tauto.\n  case (factorisation n); intros; try tauto.\n  generalize (factorisation n);intro p; generalize (factorisation n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factority n);intro p;intros.\n  generalize (factorisation n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorizable n);intro p;intros.\n  generalize (factorQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  simpl;intros.\n  rewrite H;simpl;auto.\n  simpl;intros.\n  rewrite H;simpl;auto.\n  simpl;intros.\n  rewrite H;simpl;auto.\nQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  generalize (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorizable (factorQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros;try tauto.\n  elim (factority n);intros;intro n0;intro.\n  generalize (factority n l l' H H0);intro.\n  rewrite H1 in H0.\n  assert (H2:n=0).\n   rewrite H2 in H2.\n   rewrite mult_comm in H2.\n   rewrite <- H2 in H2.\n   apply mult_comm.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l with (S n0); trivial.\n   rewrite mult_comm.\n   apply mult_reg_l withQed.",
                    "Theorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  intros.\n  case (factorisation n);intros; try tauto.\n  generalize (factorFunction_correct_prod n l' l' H); simpl;intro.\n  rewrite H1 in H;clear H;inversion H.\n  rewrite (inv_is_factorisation n l' l H2 l' H3);simpl;intro.\n  rewrite H2 in H;simpl in H;inversion H.\n  rewrite (inv_is_factority n l' l' l' H4 l' H3);simpl;intro.\n  rewrite H2 in H;simpl in H;inversion H.\n  rewrite (inv_is_factority n l' l' l' H4 l' H2);simpl;intro.\n  rewrite H2 in H;simpl in H;inversion H.\n  rewrite (inv_is_factority n l' l' l' H4 l' H4);simpl in H;inversion H.\n  rewrite (inv_is_factority n l' l' l' H4 l' H4 l' H4);simpl;intro.\n  rewrite H2 in H;simpl in H;inversion H.\n  rewrite (inv_is_factority n l' lQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " elim (prime_divides_refactor p l' H3 H0 H6);intro m;intro.\n  cut (n=m).\n  intro;rewrite H8;trivial.\n  apply le_antisym.\n  eapply prime_power_divides_refactor;eauto.\n  generalize (factor_divides_refactor (p,m) l' H7);simpl;intro.\n  rewrite <- H1 in H8.\n  apply prime_power_divides_refactor with p l;auto.\n  elim (in_wf l' p m);trivial.\nQed.\n\nLemma pwd_impl_set : forall (l:list (nat*nat)),(is_pwd l)->(is_set (nat*nat) l).\n  induction 1;[apply nil_is_set | apply cons_is_set;auto].\nQed.\n\n(** if l and l' are well-formed and (refactor l)=(refactor l') then l' is a permutation of l *)\nLemma factorisation_unique_upto_perm : forall (l l':list (nat*nat)),(is_wf l)->(is_wf l')->(refactor l)=(refactor l')->(is_permutation (nat*nat) l l').\n  intros.\n  assert (forall (x n:nat),(In (x,n) l)->(In (x,n) l')).\n  apply factorisation_unique_upto_equiv_aux;trivial.\n  assert (forall (x n:nat),(In (x,n) l')->(In (x,n) l)).\n  apply factorisation_unique_upto_equiv_aux;auto.\n  apply is_set_eq_impl_permutation;intros;(try (apply pwd_impl_set;apply wf_impl_pwd;trivial));destruct x;split;auto.\nQed.\n\n(** a list is a factorisation of n if l is well-formed and (refactor l)=n *)\nDefinition is_factorisation (n:nat)(l:list (nat*nat)) := (is_wf l)/\\(n=(refactor l)).\n\n(** The fondamental theorem of arithmetic *)\n(** forall n<>0, there exists a factorisation l *)\nTheorem factorisation_exists : forall (n:nat),n<>0->{l:list (nat*nat) | (is_factorisation n l)}.\n  intros.\n  case (factorisation n);intros;try tauto.\nQed.\n\n(** if l and l' are two factorisation of n, then l' is a permutation of l *)\nTheorem factorisation_unique_upto_permutation : forall (n:nat)(l l':list (nat*nat)),(is_factorisation n l)->(is_factorisation n l')->(is_permutation (nat*nat) l l').\n  unfold is_factorisation;intros.\n  elim H;intros.\n  elim H0;intros.\n  apply factorisation_unique_upto_perm;auto;congruence.\nQed.\n\n(** *)\n",
                "context_tokens": 652,
                "proof_start_offset": 18282,
                "proof_end_offset": 20069,
                "proof": "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintro.\ninduction l;simpl;intros.\nleft;exists 1;rewrite power_one;trivial.\ndestruct a.\nassert (n<>0);try omega.\ngeneralize (quo_rem_euclide n1 n H1);intro.\ncase (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\nrewrite e in H2;rewrite plus_comm in H2;simpl in H2.\ncase IHl;intros;trivial.\ninversion H;trivial.\nelim s;intro y;intro.\nrewrite H2.\nleft;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nelim p3;intros.\nelim H4;intros.\nelim H6;intros.\nelim H8;intros.\nright.\nexists p;exists q;exists r.\nrewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\nexists (k*(power n0 n1)).\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\napply rel_prime_mult;trivial.\ninversion H.\nrewrite H9 in H17.\nelim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\napply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\nrewrite plus_comm;auto with arith.\nright.\nexists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\nrewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\nexists (refactor l).\nelim (in_wf ((n0,n1)::l) n0 n1);intros.\nsplit;trivial.\nsplit;trivial.\ndestruct (remainder_euclide n1 n H1);try tauto;auto with arith.\nsplit;trivial.\napply rem_euclide.\nsplit;trivial.\ninversion H;trivial.\nsimpl;tauto.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros n l.\n  case (is_factority n); intros.\n  case (is_factority n); intros.\n  simpl;auto with arith.\n  case (is_factority n); intros; simpl;intros.\n  case (is_factority n); intros.\n  elim H1; intros.\n  apply H1; simpl; auto with arith.\n  apply H2; simpl; auto with arith.\n  case (is_factority n); intros.\n  elim H0; intros.\n  case (is_factority n); intros; simpl;intros.\n  case (is_factority n); intros.\n  elim H1; intros.\n  elim H1; intros.\n  rewrite H1 in H3.\n  apply H3; simpl; auto with arith.\n  elim H3; intros.\n  rewrite H1 in H3.\n  apply H3; simpl; auto with arith.\n  elim H3; intros.\n  rewrite H1 in H3.\n  apply H3; simpl; auto with arith.\n  elim H3; intros.\n  rewrite H1 in H3.\n  apply H3; simpl; auto with arith.\n  elim H3; intros.\n  rewriteQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (is_prime_dec n); intros; try tauto.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.\n  exists (S n).\n  apply is_upperValue_bound_nat.Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n l l Hl.\ncase (le_or_lt 0 (length l)).\nintros; elim Hl; intros.\nelim H0; intros.\nelim H1; intros.\nleft; auto with arith.\nelim H1; intros.\nright; auto with arith.\nleft; auto with arith.\nelim H1; intros.\nelim H1; intros.\nleft; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nleft; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nright; auto with arith.\nelim H1; intros.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros n l l' H H0.\n  case (is_factorisation n); intros; try tauto.\n  destruct H0.\n  simpl in H.\n  rewrite H0 in H.\n  simpl in H.\n  rewrite H0 in H.\n  apply (lt_irrefl (lt_O_nat _)).\n  apply lt_le_trans with (S (q+n)).\n  apply lt_le_trans with (S (q+n)).\n  apply lt_le_trans with (S (q+n)).\n  apply lt_le_trans with (S (q+n)).\n  apply le_trans with (S (q+n)).\n  apply le_trans with (S (q+n)).\n  apply le_trans with (S q).\n  apply le_trans with (S (q+n)).\n  apply le_trans with (S q).\n  apply le_trans with (S q).\n  apply le_trans with (S q).\n  apply le_trans with (S (q+n)).\n  apply le_trans with (S q).\n  apply le_trans with (S q).\n  apply le_trans with (S q).\n  apply le_trans with (SQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nintros n l.\ninduction n; intros.\ndestruct l.\nleft; auto.\nright; auto.\nleft; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nright; auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n l l' H H0 H1.\ncase (is_dezeric_induction_type n l'); intros.\nexists (S (S n)).\ntrivial.\nexists (S (S n)).\ntrivial.\napply (lt_wf (S n) l');auto.\nelim H1;intros.\napply is_upperible with n l';auto.\nQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intros n l l' H.\n  case (is_factorisation n); intros.\n  destruct l; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct n; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct l; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.\n  destruct l'; auto.\n  simpl.Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (is_delexore n);intros.\n  case (is_delexore n); intros.\n  case (is_delexore n); intros.\n  case (is_delexore n); intros.\n  elim (lt_irreflexive n); intros.\n  apply H0; auto.\n  apply H2; auto.\n  apply H3; auto.\n  apply H3; auto.\n  apply H2; auto.\n  apply H3; auto.\n  apply H3; auto.\n  apply H3; auto.\n  apply H3; auto.\n  Qed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intros.\n  case (is_factorisation n); intros.\n  apply (is_factorizable (is_factorizable (nat*nat) (S n) (q*n)) H H0 H1).\n  simpl.\n  apply (is_factorizable (is_factorizable (nat*nat) (S n) (S n) (q*n))).\n  simpl.\n  apply (is_factorizable (is_factorizable (nat*nat) (S n) (S n) (q*n))); \n  simpl;auto.\n  apply (is_factorizable (is_factorizable (nat*nat) (S n) (q*n))); \n  simpl;auto.\n  apply is_factorizable (is_factorizable (nat*nat*nat) (S n) (q*n))); \n  simpl;auto.\n  apply is_factorizable (is_factorizable (nat*nat*nat*nat*nat*nat*nat*nat) (q*n+r)).\n  simpl.\n  apply (is_factorizable (nat*nat) (S n) (q*S n) (q*n+r)).\n  simpl.\n  apply (is_factorQed.",
                    "Lemma wf_power_dec : forall (n:nat)(l:list (nat*nat)),(is_wf l)->(n>0)->{x:nat | (refactor l)=(power x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n l l.\ncase (le_or_lt n (q*n));intros.\nleft;omega.\nright;intros n H0 H1.\napply is_upperisation_bound with n;auto.\nright;intros n H1.\napply is_upperisation_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunction_bound with n;auto.\nright;intros n H1.\napply is_upperFunctionQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/primes.v",
                "context": " x n)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<n)/\\(refactor l)=(power p (q*n+r))*k/\\(rel_prime p k)}}}}.\n  intro.\n  induction l;simpl;intros.\n  left;exists 1;rewrite power_one;trivial.\n  destruct a.\n  assert (n<>0);try omega.\n  generalize (quo_rem_euclide n1 n H1);intro.\n  case (eq_nat_dec (remainder_euclide n1 n H1) 0);intro.\n  rewrite e in H2;rewrite plus_comm in H2;simpl in H2.\n  case IHl;intros;trivial.\n  inversion H;trivial.\n  elim s;intro y;intro.\n  rewrite H2.\n  left;rewrite p;rewrite (mult_comm n);rewrite <- power_power_lemma1;rewrite <- power_mult_lemma1;exists (power n0 (quotient_euclide n1 n H1)*y);trivial.\n  elim s;intro p;intro.\n  elim p0;intro q;intro.\n  elim p1;intro r;intro.\n  elim p2;intro k;intro.\n  elim p3;intros.\n  elim H4;intros.\n  elim H6;intros.\n  elim H8;intros.\n  right.\n  exists p;exists q;exists r.\n  rewrite H9;rewrite mult_comm;rewrite <- mult_assoc.\n  exists (k*(power n0 n1)).\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  split;trivial.\n  apply rel_prime_mult;trivial.\n  inversion H.\n  rewrite H9 in H17.\n  elim (mult_rel_prime n0 (power p (q*n+r)) k H17);intros.\n  apply rel_prime_power;apply rel_prime_sym;apply power_rel_prime with (q*n+r);trivial.\n  rewrite plus_comm;auto with arith.\n  right.\n  exists n0;exists (quotient_euclide n1 n H1);exists (remainder_euclide n1 n H1).\n  rewrite (mult_comm (quotient_euclide n1 n H1));rewrite <- H2.\n  exists (refactor l).\n  elim (in_wf ((n0,n1)::l) n0 n1);intros.\n  split;trivial.\n  split;trivial.\n  destruct (remainder_euclide n1 n H1);try tauto;auto with arith.\n  split;trivial.\n  apply rem_euclide.\n  split;trivial.\n  inversion H;trivial.\n  simpl;tauto.\n  trivial.\nQed.\n\n(** let n be a natural number and m>1 then either n=x^m or there is a prime number p and three numbers q,r and k such that n = p^(q*m+r)*k with 0<r<m and gcd(p,k)=1 *)\n",
                "context_tokens": 668,
                "proof_start_offset": 20239,
                "proof_end_offset": 20661,
                "proof": "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m;intro H.\ncase (eq_nat_dec n 0);intro.\nleft;exists 0.\ndestruct m;simpl;try omega;trivial.\ngeneralize (factorisation_exists n n0);intro.\nelim H0;intro l;intro.\nelim p;intros.\nrewrite H2;apply wf_power_dec;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintro.\ninduction n; simpl;intros.\ndestruct a;\ndestruct b;\ndestruct b;\ntry solve [inversion H;clear H;simpl;intros;inversion H].\nexists (S m);split;trivial.\ninversion H.\nclear H;subst.\ndestruct a;\ndestruct b;\ntry solve [inversion H;clear H;simpl;intros;inversion H].\nexists (S m);split;trivial.\ndestruct (IHn m'0 m'1) as (x,(y,(H0,H1)).\nexists (S m');split;trivial.\nsplit;trivial.\nsplit;trivial.\nexists x;split;trivial.\nsplit;trivial.\nsplit;trivial.\nsplit;trivial.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros.\nassert (H:=non_prime_dec _ _ H).\ndestruct (gcd_dec p m) as (q,r);destruct r;\ntry solve [right;exists 1%positive;rewrite div_small;trivial];\ndestruct (gcd_dec p m) as (q,r);\ntry solve [right;exists 1%positive;rewrite div_small;trivial];\ndestruct (gcd_dec p m) as (q,r);\ntry solve [right;exists 2%positive;rewrite div_small;trivial];\ndestruct (gcd_dec p m) as (q,r);\ntry solve [right;exists 1%positive;rewrite div_small;trivial];\ndestruct (gcd_dec p m) as (q,r);\ntry solve [right;exists 2%positive;rewrite div_small;trivial];\ndestruct (gcd_dec p m) as (q,r);\ntry solve [right;exists 2%positive;rewrite div_small;trivial];\ndestruct (gcd_dec p m) as (q,r);\ntry solve [right;exists 2%positive;rewrite div_small;trivial];\ndestructQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nintro n.\ninduction n.\nsimpl;intros.\nleft;exists 0%nat;rewrite power_0_l;trivial.\ndestruct a.\nleft;exists (S m).\nrewrite div_add_S;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nleft;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversion H.\nrewrite div_small_iff;trivial.\nright;intro;inversionQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\ninduction n; intros.\ndestruct p;\ndestruct p;\ndestruct p0;\ndestruct (le_gt_dec (fibonacci (p+m)) p0) as [H|H];\n [left; exists (Zpos p0); rewrite H;ring|right;apply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\n apply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\n apply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\n apply Zis_gcd_for_euclid2;\napply Zis_gcd_for_euclid2;\n apply Zis_gcd_for_euclid2;\n apply Zis_gcd_for_euclid2;\n apply Zis_gcd_for_euclid2;\n apply Zis_gcd_forQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m p.\ninduction n;simpl;intros.\nleft;exists 0%nat;rewrite Nat.pow_0_r;trivial.\ndestruct a.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nleft;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright; exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%nat;rewrite Nat.pow_0_r;trivial.\nright;exists 1%natQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m p.\ninduction n; simpl; intros.\ndestruct m;\ndestruct p.\ndestruct a;\ndestruct 1.\ndestruct p;\ndestruct n.\ndestruct m;\ndestruct p.\ndestruct (IHn p m0) as (r,r).\nexists r.\nrewrite <- (mult_comm (S r)).\nrewrite <- (mult_comm (S r)).\nrewrite <- (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite <- (mult_comm (S r)).\nrewrite <- (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite (mult_comm (S r)).\nrewrite (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite (mult_comm (S r)).\nrewrite (mult_comm (S r)).\nrewrite (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite (mult_comm (S r)).\nrewrite mult_assoc.\nrewrite (mult_comm (S r)).\nrewriteQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros n m.\ninduction n; intros.\ndestruct m; simpl.\nassert (m = 0%positive); try discriminate.\ngeneralize (factor_mod_even n m H1); intro.\ncase (le_or_lt (decompose_lt n m) 0); intro.\nrewrite e in H2; rewrite (mult_comm (n0 + m)) in H2; simpl in H2.\ncase (le_gt_dec (decompose_lt n m) 0); intro.\nrewrite e in H2;rewrite (mult_comm m) in H2;simpl in H2.\ncase (le_gt_dec (decompose_lt n m) 0); intro.\nrewrite e in H2;rewrite (mult_comm n0) in H2; simpl in H2.\ncase (le_gt_dec n m); intro.\nrewrite e in H2;rewrite (mult_comm m) in H2; simpl in H2.\ncase (le_gt_dec n m); intro.\nrewrite e in H2; rewrite (mult_comm (n0 + m)) in H2; simpl in H2.\ncaseQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\nintros.\nassert (forall m n p, n<=m -> {r:nat & {r:nat & {r:nat | (is_prime p)} + {r:nat & {r:nat & {r:nat | (is_prime p)} + {r:nat & {r:nat & {r:nat | is_prime p}}}).\nintros.\ngeneralize (is_power_correct n m H);intro.\ncase (le_gt_dec (Zquotient n m) (p*m) n); intros.\nexists (S m); split; trivial.\nrewrite H in H0; discriminate H0.\nexists (S m); split; trivial.\nrewrite H0 in H; discriminate H.\nQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\ninduction n;intros.\ndestruct m as [p|p].\ndestruct m as [p|p].\ndestruct m as [p|p].\ndestruct p; simpl in *; intros.\nabsurd (0<=p); try omega.\ngeneralize (is_power_correct p);intro.\ncase (le_gt_dec (prime p) (prime q)); intros.\nrewrite e in H; rewrite (mult_comm n); simpl in H.\ncase (le_gt_dec (prime q) (prime q)); intros.\nrewrite e in H; rewrite (mult_comm m); simpl in H.\ncase H; intros; auto.\nrewrite (mult_comm (p*n)); simpl in H.\ncase H; intros; auto.\napply (IH p); auto with arith.\nrewrite mult_comm; auto with arith.\nrewrite (mult_comm (p*n)); simpl in H.\ncase H; intros; auto.\nrewrite (mult_comm (p*n)); simpl in H.\ncase H; intros; auto.\nrewrite (mult_comm (p*n)); simpl in H.\ncase H; intros; autoQed.",
                    "Lemma is_power_m_dec : forall (n m:nat),(m>0)->{x:nat | n=(power x m)}+{p:nat & {q:nat & {r:nat & {k:nat | (is_prime p)/\\(0<r)/\\(r<m)/\\n=(power p (q*m+r))*k/\\(rel_prime p k)}}}}.\nProof.\n  intro n m; case (prime_dec n m); intros.\n  case (prime_dec n m); intros.\n  rewrite e in H.\n  case (gcd_dec n m); intros.\n  rewrite e in H0;rewrite H in H0;inversion H0; clear H0.\n  rewrite e in H;rewrite (mult_comm (n-m)) in H;inversion H; clear H; simpl in H;inversion H;\n  auto.\n  rewrite H; rewrite (mult_comm n); rewrite (mult_comm m); rewrite (mult_comm m); \n  apply gcd_factor_for_euclid with (p*m);trivial.\n  rewrite (mult_comm m); rewrite (mult_comm m);rewrite (mult_comm m); \n  apply gcd_factor_for_euclid with (p*m);trivial.\n  rewrite (mult_comm m); rewrite (mult_comm m); rewrite (mult_comm m); \n  apply gcd_factor_for_euclid with (p*m);trivial.\n  split;trivial.\n  apply divide_factor_for_euclid with (p*m);trivial.\n  split;trivial.\n  split;trivial.\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\n",
                "context_tokens": 252,
                "proof_start_offset": 1012,
                "proof_end_offset": 1219,
                "proof": "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nelim H0;intro q;intro.\nreplace b with (b*1);try ring.\nrewrite H1.\napply mult_le_compat;try omega.\ndestruct q;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nintro.\nintro.\ncut (a=O) by tauto.\nintro.\nabsurd (a=O) by tauto.\nintro.\nabsurd (a=O) by tauto.\nintro.\nabsurd (a=O) by tauto.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b (Ha,H).\nassert (H:=H).\nelim (gcd_bezout a b (a/b)).\nintro.\ncut (gcd a b = a/b).\nintros.\nassert (H:=H).\nelim (gcd_bezout a b (a/b) H0).\nintro.\nabsurd (gcd a b = a/b).\napply gcd_unique_gcd; trivial.\nelim (gcd_bezout a b (a/b)).\nintro.\nabsurd (gcd a b = a/b); trivial.\nrewrite H in H0.\nrewrite H0 in H0.\nrewrite H0.\nreflexivity.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\n  intros.\n  assert (H:=a).\n  elim (H0 a); intros.\n  assert (H1:=a).\n  elim (H1 (b + a) H H1); intros.\n  assert (H2:=a).\n  elim (H1 (b + a) H H2); intros.\n  assert (H3:=a).\n  elim (H2 (b + a) H H0); intros.\n  apply H2; assumption.\n  apply H1; assumption.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n  elim H1; intros.\n  apply H1; assumption.\n Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b H.\napply le_trans with (b*(a/b)); auto with *.\napply le_trans with (b*(a/b)); auto with *.\napply le_trans with (b*(a/b)); auto with *.\napply le_trans with (b*(a/b)); auto with *.\napply le_trans with (b*(a/b)); auto with *.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintro a; split; intro H.\napply (gcd_intro a b H).\napply (gcd_intro a b H).\napply gcd_intro; auto with *.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros.\nassert (H:=H0).\nassert (H:=H0).\ndestruct (le_gt_dec a b) as [Ha|Ha].\napply (gcd_divide_r a b Hb).\nelim (gcd_divide_r a b Hb).\napply (gcd_divide_r a b Hb).\nrewrite <- H.\nrewrite <- H0.\napply gcd_divide_l.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_l.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napply gcd_divide_r.\napplyQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintro a; unfold Bezout in |- *; split; intros.\napply H.\n rewrite <- H.\n apply divide_antisym.\n apply divide_antisym.\n apply H.\n rewrite <- H; apply divide_antisym; assumption.\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b.\nsplit.\napply (euclid_mod a b).\nexact (euclid_mod a b).\nexact (euclid_mod a b).\nQed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\nintros a b H.\ndestruct (gcd_greatest a b H) as (g,(H1,H2)).\ndestruct (gcd_greatest a b H) as (g,(H1,H2)).\ndestruct (gcd_greatest a b H1) as (g,(H2,H3)).\ndestruct (gcd_greatest a b H2) as (g,(H5,H6)).\ndestruct (gcd_greatest a b H5) as (g,(H7,H7)).\ndestruct (gcd_greatest a b H5) as (g,(H8,H9)).\ndestruct (gcd_greatest a b H8) as (g,(H9,H10)).\ndestruct (gcd_greatest a b H6) as (g,(H9,H10)).\ndestruct (gcd_greatest a b H5) as (g,(H10,H10)).\ndestruct (gcd_greatest a b H6) as (g,(H10,H11)).\ndestruct (gcd_greatest a b H5) as (g,(H10,H10)).\ndestruct (gcd_greatest a b H5) as (g,(H10,Qed.",
                    "Lemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\nProof.\ninduction a.\nleft.\nexists a.\nexists (S b).\nauto with arith.\nelim H0; intros; auto with arith.\nelim H0; intros.\nexists (S b).\nauto with arith.\nelim H0; intros.\nexists (S b).\nauto with arith.\nelim H0; intros.\nexists (S b).\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\n",
                "context_tokens": 338,
                "proof_start_offset": 1256,
                "proof_end_offset": 1718,
                "proof": "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\nProof.\nintros.\napply (lt_wf_rec a (fun a:nat =>{q : nat & {r : nat | a = b * q + r /\\ r < b}})).\nintros.\ncase (le_lt_dec b n);intro.\nelim (H0 (n-b)).\nintro q;intro.\nelim p;intro r;intro.\nexists (q+1);exists r.\nsplit;try tauto.\nrewrite (le_plus_minus b n);trivial.\nelim p0;intros.\nrewrite H1;ring.\nomega.\nexists 0;exists n.\nsplit;try tauto.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H; intro q;intros.\n  replace b with (a*q); try ring.\n  rewrite <- (inv_Sn _ H0).\n  apply (mult_reg_l (a/b) (a/b)).\n  rewrite H0.\n  ring.\n  replace (a/b) with (b*p); try ring.\n  rewrite <- (inv_Sn _ H0).\n  rewrite (inv_Sn _ H0).\n  apply mult_le_compat; try omega.\n  destruct (a/b) as (q,r).\n  apply (mult_reg_l (a/b) (a/b)).\n  rewrite <- (inv_Sn _ H0).\n  apply (mult_reg_l (a/b) (a/b)).\n  rewrite H0.\n  ring.\n  rewrite (inv_Sn _ H0).\n  apply mult_le_compat; try omega.\n  destruct (a/b) as (q,r).\n  apply (mult_reg_l (a/b) (a/b)).\n  rewrite H0.\n  ring.\n  rewrite (inv_Sn _ H0).\n  apply (mult_reg_l (Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0; intro q;intros.\n  replace b with (b*q); try ring.\n  apply (mult_reg_r (a/b) (a/b) q).\n  apply (mult_reg_l (a/b) (a/b) q).\n  rewrite <- H1.\n  apply mult_le_compat; try omega.\n  apply mult_le_compat; try omega.\n  apply (mult_reg_l (a/b) (a/b) q).\n  rewrite <- H2.\n  apply mult_le_compat; try omega.\n  apply (mult_reg_l (a/b) q).\n  apply mult_le_compat; try omega.\n  apply (mult_reg_l (a/b) q).\n  rewrite <- H2.\n  apply mult_le_compat; try omega.\n  apply (mult_reg_l (a/b) q).\n  apply (mult_reg_l (a/b) q).\n  apply (mult_reg_l (a/b) q).\n  rewrite <- H1.\n  apply mult_le_compat; try omega.\n  apply (mult_regQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0; intro q;intro.\n  replace b with (b*q); try ring.\n  rewrite H1.\n  apply mult_le_compat; try omega.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumption.\n  elim H2; intros; assumptionQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0; intro q; intro.\n  replace b with (b*0); try ring.\n  apply (mult_reg_l b (a+q0) (b+p)).\n  apply (mult_reg_l b (a+q)).\n  apply mult_reg_l with (b + q0); try ring.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b a).\n  rewrite (mult_comm b a).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b a).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b a).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewrite (mult_comm b b).\n  rewriteQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0; intro q;intro.\n  replace b with (b*q+r); try ring.\n  rewrite H0.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  left.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  right.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  right.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  right.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  left.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  right.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (H p q); auto.\n  right.\n  apply mult_le_compat; try omega.\n  destruct (H p q); destruct (HQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros a b c.\n  elim H0; intro r; elim (H0 a); intro.\n  replace b with (b*a); try ring.\n  rewrite H1.\n  apply (mult_comm a b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm b b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm b b); try ring.\n  rewrite (mult_comm b b); try ring.\n  rewrite (mult_comm a b); try ring.\n  rewrite (mult_comm b c); try ring.\n  rewrite (mult_comm b c); try ring.\n  rewrite (mult_comm b c); try ring.\n  rewrite (mult_comm b c); try ring.\n  rewrite (mult_comm b c); try ring.\n  rewrite (mult_comm b c); try ring.\n Qed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0; intro.\n  replace b with (b*1); try ring.\n  rewrite H1.\n  apply mult_le_compat; try omega.\n  rewrite (mult_comm a (b*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm a b).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewrite (mult_comm b (a*q)).\n  rewriteQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H; intro q.\n  replace b with (a*q); try ring.\n  rewrite <- H1.\n  apply mult_le_compat; try omega.\n  destruct q;omega.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H0; intro r; elim (le_gt_dec q a); intro.\n  replace b with (b*p+b); try ring.\n  rewrite H2.\n  apply mult_le_compat; try omega.\n  destruct (le_gt_dec q a); auto.\n  apply (mult_gt_compat_l (a*q+a) q).\n  apply (mult_gt_compat_l (a*q+b) q).\n  omega.\n  apply (mult_gt_compat_l (a*q+a) q).\n  omega.\nQed.",
                    "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  elim H; intro q;intro.\n  replace (a*q+r) with a; try ring.\n  replace (a*q+b) with a; try ring.\n  replace (a*q+q) with a; try ring.\n  ring.\n  replace (a*q+r) with a; try ring.\n  ring.\n  replace (a*q+r) with a; try ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  ring.\n  replace (a*q+a) with a; try ring.\n  ring.\n  ring.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\n",
                "context_tokens": 619,
                "proof_start_offset": 1941,
                "proof_end_offset": 2205,
                "proof": "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\nunfold quotient_euclide;unfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros a b H.\n  case (Req_dec a b); intros.\n  left; auto.\n  left; auto.\n  right; auto.\n  right; auto.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  elim H; intro r; intros.\n  exists (n-a).\n  split; try tauto.\n  rewrite <- H; ring.\n  rewrite H; ring.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros a b.\n  unfold quotient_digit, mult_fct.\n  rewrite (Z_div_mod a b H).\n  rewrite (Z_div_mod a b H).\n  rewrite (Z_div_mod a b H).\n  ring.\n  destruct p;discriminate || now apply Zpower_gt_0.\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm b a H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm b a H).\n  rewrite (Zmult_comm a b H).\n  rewrite (Zmult_comm b a H).\n  rewrite (Zmult_Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  rewrite (Z_mod_eq a b H) at 1.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply Z_mod_pos.\n  apply ZQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  case (Rle_dec a b); intros.\n  case (Rle_dec b a); intros.\n  apply (Rlt_le_trans _ _ _ H H0).\n  apply (Rlt_trans _ _ _ H H0).\n  apply (Rlt_trans _ _ _ H H0).\n  apply (Rlt_trans _ _ _ H H0 H).\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nintros.\nassert (H:=a);unfold quotient_eucl in *; simpl in *.\nassert (H:=H0 0); unfold quotient_algorithm in H.\ngeneralize (H0 0%Z (n-a) H0); intros.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.\nrewrite (Zmod_eq n a H0) in H; discriminate H.Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  set (g := (a/b) in *.\n  set (g := (g a) in *.\n  set (g := (a/b) in *.\n  set (g := (g a) in *.\n  set (g := (a/b) in *.\n  set (g := (g a) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (g a) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  set (g := (a/b) in *.\n  setQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  intros.\n  rewrite <- (Ropp_involutive a).\n  apply (f_equal (fun a b => {q : nat &  {r : nat | a = b * q + a * b}).\n  intros.\n  case (le_gt_dec b 0); intro.\n  elim (H (n-b)).\n  intro q; intro.\n  exists (S q).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite Ropp_mult_distr_l_reverse.\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n  rewrite <- (Ropp_involutive b).\n Qed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nProof.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {r : nat | (a=b*q) /\\ (r < b * q)).\n  intros.\n  case (le_gt_dec b n); intro.\n  left; now rewrite H, H0; apply H.\n  right; now rewrite H, H0; apply H.\n  right; now rewrite H, H, H, H0; apply H.\n  right; now rewrite H, H0, H, H0; apply H.\n  right; now rewrite H, H, H0; apply H.\nQed.",
                    "Lemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\nintros.\napply (lt_wf_rec a (fun a:nat => {q : nat &  {r : nat | (a=b*q) /\\ (r < b)}).\n intros.\n case (le_gt_dec b n); intros.\n  elim (H0 (n-b)); intros.\n  elim (H1 (n-b)); intros.\n  left; assumption.\n  right; assumption.\n  right; assumption.\n  left; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\n  right; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\n",
                "context_tokens": 722,
                "proof_start_offset": 2233,
                "proof_end_offset": 2442,
                "proof": "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\nunfold remainder_euclide;intros.\ngeneralize (euclide a b H);intros.\nelim s;intro q;intro.\nelim p;intro r;intro.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat &  {r : nat | (a=b*q) /\\ (a=b*q))}).\n  intros.\n  apply (lt_wf_rec a (fun a:nat => {q : nat | a = a * q)}).\n  intros.\n  elim H; intro r; elim r; intro.\n  elim (H0 (a+b)); intros.\n  elim H1; intro r; elim r; intro.\n  elim (H1 (a+b)); intros.\n  elim H2; intro.\n  exists (r+b); exists r.\n  split; try tauto.\n  elim H2; intro.\n  exists r; split; auto.\n  elim H2; intro.\n  exists (r+a); exists r; split; try tauto.\n  elim H2; intro.\n  exists (r+a); exists r; split; try reflexivity.\n  elim H2; intro.\n  exists (r+a); exists r; split; try reflexivity.\n  elim H2; intro.\n  exists (r+a); exists r; split; try reflexivity.\n  elim HQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\n  unfold quotient_sgn, quotient_sgn, mult_nan.\n  intros.\n  generalize (H (a/b) H).\n  unfold quotient_sgn, quotient_sgn, mult_nan.\n  generalize (binary_euclide a b H); intros.\n  elim s; intro r; elim r; intro.\n  elim p; intro r; elim r; intro.\n  rewrite H0; rewrite H1; rewrite H2; rewrite H2; reflexivity.\n  rewrite H0; rewrite H2; rewrite H2; reflexivity.\n  rewrite H0; rewrite H2; reflexivity.\n  rewrite H0; rewrite H2; reflexivity.\n  rewrite H; rewrite H2; reflexivity.\n  rewrite H; rewrite H2; reflexivity.\n  rewrite H; rewrite H2; reflexivity.\n  rewrite H; rewrite H; rewrite H2; reflexivity.\n  rewrite H; rewrite H0; reflexivity.\n  rewrite H; rewrite H; reflexivity.\n  rewrite H; rewrite H; reflexivity.\n  rewrite H; rewrite H1; reflexivity.\n  rewrite H; rewrite H; reflexivity.\n  rewrite H; rewrite H; reflexivity.\nQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (le_gt_dec b 0); intro.\n  elim (H 0); intro.\n  elim (H0 0); intro.\n  elim (H1 0%nat); intro.\n  elim (H1 0%nat); intro.\n  elim (H1 0%nat); intro.\n  elim (H1 0%nat); intro.\n  elim (H2 0%nat); intros.\n  elim (H2 0%nat); intro.\n  elim (H3 0%nat); intros.\n  elim (H1 (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S O)))))))))); auto with arith.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (le_gt_dec a b); intro.\n  elim (H0 (n-a)); auto.\n  rewrite H0.\n  apply H; auto.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  rewrite H0; ring.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  rewrite H0; ring.\n  elim n; intros; auto.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  rewrite H0; ring.\n  elim n; intros; auto.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  rewrite H0; ring.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  elim n; intros; auto.\n  elim n; intros; auto.\n  elim (H0 (n-a)); auto.\n  elim (H0 (n-a)); auto.\n  elim n; intros; auto.\n  elim (H0Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (le_gt_dec b 0); intros.\n  case (le_gt_dec b 0); intros.\n  case (le_gt_dec b 0); intros.\n  case (le_gt_dec b (a+b)); intros.\n  rewrite H; rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  rewrite H; auto with zarith.\n  Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (Rle_dec b 0); intro.\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_trans 0 (Rle_lt_trans 0 (a + b) 0 H0)).\n  elim (Rlt_irrefl 0).\n  elim (Rlt_trans 0 (a + b) 0).\n  elim (Rlt_trans 0 (a + b) 0).\n  elim (Rlt_trans 0 (a + b) 0).\n  elim (Rlt_trans 0 (a + b) 0).\n  elim (Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (div_eucl a b H); intros.\n  case (div_eucl a b H); intros.\n  generalize (H0 (n-b)); intros.\n  generalize (H0 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H0 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H0 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H0 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H0 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H1 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H1 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H2 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H0 (n-b)).\n  case (div_eucl a b H); intros.\n  generalize (H1 (n-b)).\n  case (div_eucl a b HQed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\nProof.\n  unfold quotient_sgn.\n  destruct (a =? b) eqn:H; [left|right]; reflexivity.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n  discriminate.\n Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (le_lt_dec a b); intro.\n  elim (H (n-b)).\n  intro q;intro.\n  case (le_lt_dec b n); intro.\n  elim (H (n-b)).\n  intro q;intro.\n  case (le_lt_dec a n); intro.\n  elim (H (n-b)).\n  intro q; intro.\n  case (le_lt_dec b n); intro.\n  elim (H (n-b)).\n  intro q; intro.\n  elim q; intro.\n  elim p; intro.\n  rewrite <- H; rewrite H; rewrite <- H0; rewrite H1; reflexivity.\n  rewrite H; rewrite H1; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H; reflexivity.\n  rewrite H;Qed.",
                    "Lemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  intros.\n  case (le_gt_dec b 0); intro.\n  elim H; intro r; intro.\n  rewrite H; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\n  rewrite H0; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import Wf_nat.\n\nUnset Standard Proposition Elimination Names.\n\n(** lemmae about divisibility *)\nLemma divides_le : forall (a b:nat),(a<>O)->(divides a b)->(b<=a).\n  intros.\n  elim H0;intro q;intro.\n  replace b with (b*1);try ring.\n  rewrite H1.\n  apply mult_le_compat;try omega.\n  destruct q;omega.\nQed.\n\n(** Euclide theorem (existence) *)\nTheorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\n",
                "context_tokens": 700,
                "proof_start_offset": 2478,
                "proof_end_offset": 3403,
                "proof": "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros.\nrewrite H1 in H0.\ncase (lt_eq_lt_dec q q');intro.\ncase s;intro.\nrewrite (le_plus_minus q q') in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (b*(q'-q)+r' = r).\napply plus_reg_l with (b*q).\nrewrite plus_assoc;trivial.\nassert (0<(q'-q));try omega.\nassert (b<=b*(q'-q));try omega.\ncase (mult_O_le b (q'-q));intro;try omega.\nrewrite mult_comm;trivial.\nsplit;try tauto.\nrewrite <- e in H0.\nsymmetry;apply plus_reg_l with (b*q);trivial.\nrewrite (le_plus_minus q' q) in H0;try (auto with arith).\nrewrite mult_plus_distr_l in H0.\nassert (r'=(b*(q-q')+r)).\napply plus_reg_l with (b*q').\nrewrite plus_assoc;trivial.\nassert (0<(q-q'));try omega.\nassert (b<=b*(q-q'));try omega.\ncase (mult_O_le b (q-q'));intro;try omega.\nrewrite mult_comm;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  case (le_gt_dec b n); intro.\n  elim (H (n-q)).\n  intro q; intro q; intro.\n  elim p; intro r'; intro.\n  elim q; intro r'; intro.\n  elim (H (n-q)).\n  intro q; intro.\n  elim p; intro r'; intro.\n  elim r'; intro r'; intro.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim p; intro r'; intro.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim p; intro r'.\n  elim q; intro r; intro.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim (H0 (n-q)).\n  intro q; intros.\n  elim (H0 (n-q)).\n  intro q; intro.\n  elim (H0 (n-q)).\n  intro q; intros.\n  elimQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n intros a b q r q' r' H H0 H1.\n replace (a+q') with (a*q+q+r*(r+r+r')).\n replace (a+q') with (a*q+r*(r+r')).\n apply div_unique with (a*q+r').\n replace (a+q') with (a*q+r*(r+r')).\n apply div_unique with (a*q+r').\n rewrite (add_comm a b) at 1.\n apply div_unique with (a*q+r').\n rewrite (add_comm a b) at 1.\n apply div_unique with (a*q+r').\n replace (a*q') with (a*q+r').\n apply div_unique with (a*q+r').\n rewrite (add_comm a b) at 1.\n apply div_unique with (a*q+r').\n rewrite (add_comm a b) at 1.\n apply div_unique with (a*q+r').\n apply div_unique with (a*q+r').\n rewrite (add_comm b (aQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros.\nrewrite <- (Ropp_involutive a b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite <- (Ropp_involutive b) at 2.\nrewrite (Ropp_involutive b) at 2.\nrewrite <- (Ropp_involutive b) at 2.\nrewrite <- (Ropp_involutive b) at 1.\nrewrite (Ropp_involutive b) at 1.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros a b q r q r' q r' H H1 H2; rewrite H2; intros H1 H2;\n generalize (Zmod_eucl a b q r'); intros.\nelim H2; intro r';intro H3; elim H3; intros H4 H5.\nelim H4; intro H5; elim H5; intros H6 H7.\nelim H5; intros H6 H7.\nelim H5; intros H7 H8.\nelim H7; intros H8 H9; elim H9; intros H9 H10.\nelim H9; intros H10 H11.\nrewrite H6; ring.\nQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros a b q r q' r q' H H0.\napply (lt_wf_rec a (fun a:nat => {q : nat &  {r' : nat | a = b * q + r /\\ r' < b}).\n intros.\n case (le_gt_dec b n); intro.\n  elim (H0 (n-b)).\n  intro q; intro q; elim q; intro r; intro.\n  elim r; intro r; intro.\n  exists (q+r); split; try reflexivity.\n  rewrite H0; ring.\n  rewrite H0; ring.\n  rewrite H0; ring.\n  intros; exists 0; exists 0; exists 0; split; try reflexivity.\n  rewrite H1; ring.\n  intros; exists 0; exists 1; exists 0; split; try reflexivity.\n  rewrite H1; ring.\n  intros; exists 0; exists 1; exists 1; split; try reflexivity.\n  rewrite H1; ring.\n  intros; exists 0; exists 1; exists 1; split; try reflexivity.\n  rewrite H1; ring.\n  intros; exists 1; exists 1; exists 1; split; try reflexivity.\n  rewriteQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  case (le_gt_dec b n); intro.\n  case (le_gt_dec q' n); intro.\n  case (le_gt_dec q' n); intro.\n  case (le_gt_dec q' n); intro.\n  rewrite (lt_plus_minus_r b n); trivial.\n  case (le_gt_dec q' n); intro.\n  case (le_gt_dec q' n); intro.\n  case (le_lt_dec q' n); intro.\n  case (le_lt_dec q' n); intro.\n  case (le_lt_dec q' n); intro.\n  case (le_lt_eq_dec q' n); intro.\n  case (le_lt_dec q' n); intro.\n  rewrite (lt_plus_minus_r b n); trivial.\n  elim p; intro.\n  elim (le_lt_dec q' n); intro.\n  case (le_lt_eq_dec q' n); intro.\n  case (le_gt_dec q' n); intro.\n  case (le_lt_eq_dec q' n); intro.\n  caseQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\nintros.\nassert (H:=a_0_1b_1a a b H H0).\nrewrite H;intros.\napply div_unique with (b:=b) (a:=b) (a:=b) (a:=b) (c:=b) (c:=b) (a:=b) (c:=d) (c:=c) (r':=c) H0).\nrewrite H;intros.\napply div_unique with (b:=b) (c:=d) (c:=c) (a:=c) (c':=c) (c':=d).\nrewrite H;intros.\napply div_unique with (c:=d) (c:=d) (c:=d) (c:=d) (c':=d) (d':=d) H0).\nrewrite H; intros.\napply div_unique with (c:=c) (a:=b) (c:=d) (c:=c) (d':=d) (c':=d) H0).\nrewrite H; intros.\napply div_unique with (c:=d) (a:=c) (c':=d) (c':=d) (Qed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n  intros.\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H0)).\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H0)).\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H0)).\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H1)).\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H1)).\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H0)).\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H H0)).\n  case (Rle_lt_dec b a); intro.\n  elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H0 HQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  case (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_lt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_lt_dec b n); intro.\n  elim (le_gt_dec b n); intro.\n  elim (le_lt_dec b n); intro.\n  elim (le_lt_dec b n); intro.\n  elim (le_ltQed.",
                    "Lemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\nProof.\n  unfold third_eucl.\n  intros a b q r q r' H H0 H1 H2.\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite Ropp_mult_distr_l_reverse.\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite Ropp_involutive.\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (Ropp_involutive r).\n  rewrite <- (RoppQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n\nDefinition quotient_euclide (a b:nat)(H:(b<>O)) := let (q,_) := (euclide a b H) in q.\n\nDefinition remainder_euclide (a b:nat)(H:(b<>O)) := let (_,e0) := (euclide a b H) in let (r,_) := e0 in r.\n\n(** a div b where b<>0 *)\nLemma quo_rem_euclide : forall (a b:nat)(H:(b<>O)),a=b*(quotient_euclide a b H)+(remainder_euclide a b H).\n  unfold quotient_euclide;unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \n",
                "context_tokens": 721,
                "proof_start_offset": 3449,
                "proof_end_offset": 4020,
                "proof": "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\nProof.\nintros.\nred.\nsplit;intro.\ngeneralize (quo_rem_euclide a b H);intro.\ngeneralize (rem_euclide a b H);intro.\nelim H0;intro q;intro.\nassert (a=b*q+0).\nrewrite plus_comm;simpl;trivial.\nassert (0<b);try omega.\ngeneralize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\nintros;tauto.\ngeneralize (quo_rem_euclide a b H).\nrewrite H0;rewrite plus_comm;simpl.\nintro;exists (quotient_euclide a b H);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  apply (euclidab_gcd a b H).\n  unfold Zgcd_bound in H.\n  generalize (Zgcd_gcd_gcd a b H); intros.\n  elim H; intro q;intro.\n  elim p; intro r;intro.\n  elim p; intro r;intro.\n  elim p; intro r;intros.\n  elim p; intro r;intros.\n  elim p; intro r; intros.\n  elim p; intro r; intros.\n  elim p; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intro r; intros.\n  elim p0; intros.\n  elim p0; intros.\n  elim p0; intro r; intros.\n  elim p0; intros.\n  elim pQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H;reflexivity.\n  split;try omega.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivity.\n  intros.\n  apply H.\n  unfold Zgcd_bound in H.\n  rewrite H0;reflexivityQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  case (Zdivide_dec a b H);intros.\n  elim H0; intro r;intro.\n  elim r;intro r;intro.\n  elim r; intro r;intros; elim r;intro r;intros; elim r; intro; try tauto.\n  elim (divide_0_r r);intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_l r); intro.\n  elim (divide_1_l r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_1_r r); intro.\n  elim (divide_Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H0 in H.\n  case (leb_eq_lt_dec 0 a);intros; try discriminate.\n  rewrite (lt_irreflexive a) in H; discriminate.\n  rewrite (lt_irreflexive a) in H; discriminate.\n  Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  apply Zis_gcd_for_euclid with (b:=a) (q:=a) (q:=a) (r:=b) (r:=b).\n  apply Zis_gcd_for_euclid with (b:=a) (r:=d) (r:=b) (r:=b); try omega.\n  apply Zis_gcd_for_euclid with (b:=b) (r:=b) (r:=b) (r:=b); try omega.\n  apply Zis_gcd_for_euclid with (b:=b) (r:=b) (r:=b); try omega.\n  apply Zis_gcd_for_euclid with (a:=b) (r:=b) (r:=b) (r:=b); try omega.\n  apply Zis_gcd_for_euclid with (b:=a) (r:=b) (r:=b) (r:=b); try omega.\n  apply Zis_gcd_for_euclid with (b:=b) (r:=b) (r:=b) (r:=b); try omega.\n  apply Zis_gcd_for_euclid with (b:=b) (r:=b) (r:=b)Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  case (Zcompare_spec a b H); intros.\n  elim H.\n  simpl; auto.\n  case (Zcompare_spec a b H); intros.\n  elim H.\n  simpl; auto.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simpl; auto.\n  case (Zcompare_spec b b H); intros.\n  elim H.\n  simplQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  case (gcd_uniqueness a b H);intro.\n  elim (gcd_uniqueness a b H0);intro.\n  elim H1; intro r;intro.\n  elim (gcd_uniqueness a b H1);intro.\n  elim (gcd_uniqueness a b H2);intro.\n  elim H2; intro.\n  elim (gcd_uniqueness a b H1);intro.\n  elim H2; intro.\n  elim H2; intro.\n  elim (gcd_uniqueness a b H3);intro.\n  elim H4; intro.\n  elim H4; intro.\n  elim (gcd_uniqueness a b H3);intro.\n  elim (gcd_uniqueness a b H3); intro.\n  elim H5; intro.\n  elim (gcd_uniqueness b b H4); intro.\n  elim H5; intro.\n  elim (gcd_uniqueness a b H3); intro.\n  elim (gcd_uniqueness a b H3); intro.\n  elim (gcd_uniqueness a b H2); intro.\n  elim H4; intro.\n  elim (gcd_uniqueness a b H4); intro.\n  elim (gcd_uniqueness a b H4); intro.\n  elim (gcd_uniquenessQed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H;auto with arith.\n  Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H in H.\n  case (le_gt_dec a 0); intros; auto with arith.\n  rewrite (inv_prime a (Zpos p)).\n  destruct (gcd_nonneg a b) as (q,r); destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r); destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r); destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r); destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,r);\n  destruct (gcd_nonneg a b) as (q,Qed.",
                    "Lemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  rewrite H.\n  rewrite (gcd_comm a b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b H).\n  rewrite (gcd_comm b b HQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": "\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** a mod b where b<>0 *)\nLemma rem_euclide : forall (a b:nat)(H:(b<>O)),(remainder_euclide a b H)<b.\n  unfold remainder_euclide;intros.\n  generalize (euclide a b H);intros.\n  elim s;intro q;intro.\n  elim p;intro r;intro.\n  tauto.\nQed.\n\n(** Euclide division is unique *)\nLemma euclide_unique : forall (a b q r q' r':nat),(b<>O)->a=b*q+r->a=b*q'+r'->r<b->r'<b->(q=q')/\\(r=r').\n  intros.\n  rewrite H1 in H0.\n  case (lt_eq_lt_dec q q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\n",
                "context_tokens": 735,
                "proof_start_offset": 4055,
                "proof_end_offset": 4426,
                "proof": "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\nintros.\ncase (eq_nat_dec b 0).\ncase (eq_nat_dec a 0);intros.\nrewrite e;left;apply zero_max_div.\nright;rewrite e;intro.\nelim H;intro q;intro.\nsimpl in H0;apply n;trivial.\nintro.\ncase (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n intros.\n case (Even_dec a b H); intros.\nexists a;split;auto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n intros a b.\n destruct (gcd_dec a b) as [H|H].\n left; exists a; auto.\n right; exists a; auto.\n right; exists a; auto.\n right; exists a; auto.\n right; exists a; auto.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros.\n  case (gcd_dec a b); intro.\n  left; auto with zarith.\n  left; auto with zarith.\n  left; auto with zarith.\n  right; auto with zarith.\n  right; auto with zarith.\n  right; auto with zarith.\n  right; auto with zarith.\n  right; auto with zarith.\n  right; auto with zarith.\nQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros a b.\n  case (gcd_unique a b H); intros.\n  elim (gcd_unique a b H); intros.\n  elim (gcd_unique a b H); intros.\n  elim (gcd_unique a b H0); intros.\n  elim (gcd_unique a b H0); intros.\n  elim (gcd_unique a b H0); intros.\n  elim (gcd_unique a b H0); intros.\n  elim (gcd_unique b b H0); intros.\n  elim (gcd_unique a b H0); intros.\n  elim (gcd_unique b b H0); intros.\n  elim (gcd_unique a b H1); intros.\n  elim (gcd_unique a b H0); intros.\n  elim (gcd_unique a b H1); intros.\n  elim (gcd_unique b b H1); intros.\n  elim (gcd_unique a b H1); intros.\n  elim (gcd_unique a b H1); intros.\n  elim (gcd_unique b b H1); intros.\n  elim (gcd_unique a b H1); intros.\n  elim (gcd_unique b b H0); intros.\n  elim (gcdQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (gcd_dec a b); intro.\n  elim H;intro q;intro.\n  rewrite (gcd_comm a b) in H.\n  elim H; intro q;intro.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q;intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewrite (gcd_comm b c) in H.\n  elim H; intro q; intros.\n  rewriteQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (Even_dec a b);intros.\n  elim H;intro.\n  elim H;intro.\n  elim H;intro.\n  elim H;intro.\n  elim H0;intro.\n  left; assumption.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  right; apply prime_dec.\n  left; apply prime_dec.\n  left; apply prime_Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros.\n  assert (H:=H).\n  destruct (le_gt_dec 0 a) as [H0|H0].\n  rewrite (gcd_comm a b H0).\n  apply gcd_gcd_r with a b;auto.\n  rewrite (gcd_comm a b H0).\n  rewrite (gcd_comm a b H0).\n  rewrite (gcd_comm b b H0).\n  generalize (gcd_div_mod a b H).\n  rewrite (gcd_comm a b H0).\n  rewrite (gcd_comm b b H0).\n  generalize (gcd_div_mod a b H).\n  rewrite (gcd_comm a b H0).\n  rewrite (gcd_comm b b H0).\n  rewrite (gcd_comm a b H0).\n  generalize (gcd_div_mod a b H).\n  rewrite (gcd_comm b b H0).\n  generalize (gcd_div_mod a b H).\n  rewrite (gcd_comm b b H0).\n  generalize (gcd_div_mod b b H).\n  rewrite (gcd_div_mod a b H0).\n  rewrite (gcd_comm b b H0).\n  generalize (gcd_divQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\nProof.\n  intros.\n  generalize (Zis_gcd_for_euclid a b H);intro.\n  elim H;intro q;intro.\n  elim q; intro q;intro.\n  elim p; intro q;intros.\n  elim (q~1 q); intro.\n  rewrite (IHn q r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn q r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn q r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~0 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~0 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~0 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn r r); trivial.\n  elim (q~1 q); intro.\n  rewrite (IHn r r);Qed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  destruct a;destruct b;simpl in *;\n  try (right;auto with arith).\n  destruct b;simpl in *;\n  try (right;auto with arith).\n  destruct b0;simpl in *;\n  try (right;auto with arith).\n  destruct b0;simpl in *;\n  try (right;auto with arith).\n  destruct b0;simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;auto with arith).\n  destruct b0; simpl in *;\n  try (right;autoQed.",
                    "Lemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (gcd_dec a b); intro.\n  left; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  left; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " q');intro.\n  case s;intro.\n  rewrite (le_plus_minus q q') in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (b*(q'-q)+r' = r).\n  apply plus_reg_l with (b*q).\n  rewrite plus_assoc;trivial.\n  assert (0<(q'-q));try omega.\n  assert (b<=b*(q'-q));try omega.\n  case (mult_O_le b (q'-q));intro;try omega.\n  rewrite mult_comm;trivial.\n  split;try tauto.\n  rewrite <- e in H0.\n  symmetry;apply plus_reg_l with (b*q);trivial.\n  rewrite (le_plus_minus q' q) in H0;try (auto with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\n",
                "context_tokens": 685,
                "proof_start_offset": 4561,
                "proof_end_offset": 4980,
                "proof": "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\nProof.\nintros.\ninduction m.\nright;intros;inversion H0.\ncase (H m);intro.\nleft;exists m;split;try (auto with arith).\ncase IHm;intro.\nelim s;intro n0;intro.\nleft;exists n0;split;[omega | tauto].\nright;intros.\ninversion H0;trivial.\napply n0;omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (beq_nat_dec n ( Iirr_nat n) 0);intros.\n  case (dec n ( Iirr_nat n) 0).\n  intros.\n  case (dec n ( Iirr_nat n0)); intros.\n  case (dec n0 ( Iirr_nat n0) 0).\n  intros.\n  apply H; auto with arith.\n  intros.\n  rewrite H0; simpl;rewrite mult_1_l; auto with arith.\n  rewrite mult_1_l; auto with arith.\n  intros.\n  rewrite H0; simpl;rewrite mult_1_l; auto with arith.\n  simpl; rewrite mult_1_l; auto with arith.\n  intros; rewrite H0; simpl; rewrite mult_1_l; auto with arith.\n  intros; rewrite H0; simpl;rewrite mult_1_l; auto with arith.\n  intros; rewrite H0; simpl; rewrite mult_1_l; auto with arith.\n  intros; rewrite H0; simpl; rewrite mult_1_l; auto with arith.\n  intros; rewrite H0; simpl; rewrite mult_1_l; auto with arith.\n  intros; rewrite H0; simpl; rewriteQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (P n);intros.\n  destruct (IHm1_dec n) as [H0|H0].\n  left.\n  rewrite H0; simpl;auto.\n  right; rewrite e;intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  left;rewrite e;intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  left; rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right;rewrite e;intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right; rewrite e; intro; discriminate.\n  right; rewrite e;intro; discriminate.\n  right; rewrite e;Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (dec_nat_dec n n);intros.\n  rewrite e;rewrite e;rewrite e;simpl.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.\n  simpl;intros;apply H;simpl;auto.\n  case (P n);intros.\n  generalize (H n);intro;omega.Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (dec n m);intros.\n  rewrite e;destruct n; simpl;intros; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; destruct n; simpl;intros; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  case (le_gt_dec n m); intros.\n  rewrite e; auto.\n  rewrite e;Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (dec_nat_dec n 0); intros.\n  rewrite e in H0; discriminate H0.\n  rewrite e in H0; discriminate H0.\n  rewrite e;right;apply succ_lt_dec.\n  right;rewrite e;intro;subst;apply pred_lt_dec.\n  right;apply pred_lt_dec.\n  right;apply pred_lt_dec.\n  rewrite e;intro;subst;apply pred_lt_dec.\n  right;apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  right; apply pred_lt_dec.\n  left; apply pred_lt_dec.\n  right;Qed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (even_odd_dec n 0);intros.\n  rewrite e;auto.\n  generalize (pos_odd_dec n (P n) H0);intro.\n  destruct (even_odd_dec m n0) as [[H|H]|H].\n  rewrite H;auto.\n  destruct H as [(H1,H2)|(H1,H2)].\n  rewrite H1;auto.\n  generalize (pos_odd_dec n (P n) H1);intro.\n  destruct (even_odd_dec m n0) as [[H|H]|H].\n  rewrite H;auto.\n  generalize (pos_odd_dec n (P n) H1);intro.\n  destruct (even_odd_dec m n0) as [[H|H]|H].\n  rewrite H;auto.\n  generalize (pos_odd_dec n (P n) H1);intro.\n  destruct (even_odd_dec m n0) as [[H|H]|H].\n  rewrite H;auto.\n  rewrite H;auto.\n  generalize (pos_odd_dec n (P n) H0);intro.\n  destruct (even_odd_dec m nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (P_nat_dec n 0).\n  case (P_nat_dec n 0).\n  case (even_odd_dec n 0).\n  intros.\n  rewrite e;intro.\n  rewrite mult_comm; simpl;trivial.\n  generalize (pos_div_mod_eq n 1); intro.\n  generalize (pos_div_mod_eq n 1); intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1); intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_div_mod_eq n 1);intro.\n  generalize (pos_divQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (even_odd_dec n).\n  left.\n  left.\n  intro.\n  apply H0.\n  apply H1.\n  right.\n  intro.\n  apply H1.\n  simpl;trivial.\n  intro.\n  apply H0.\n  simpl;trivial.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (dec_nat_dec m n).\n  intros.\n  rewrite e in H.\n  destruct (lt_eq_dec n m).\n  apply (H n m);auto.\n  destruct (lt_eq_dec n m);intros.\n  rewrite e in H.\n  symmetry in H;apply (IHn m m);auto.\n  elim H; intro q;intros.\n  simpl in H0;apply H;auto.\n  apply n;trivial.\n  intro.\n  case (le_lt_dec n m).\n  intro; right; left; auto.\n  left; auto.\n  right; auto.\n  right; auto.\nQed.",
                    "Lemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  case (not_Zeq_bool (Nbit0 a) (NatSet.div2 a) H0).\n  case (not_Zeq_bool (Nbit0 a) (Nbit0 a) H0); intros.\n  rewrite H1; simpl.\n  case (Nbit1 a); case (Nbit1 a); case (Nbit1 a); case (Nbit1 a); \n   intros.\n  simpl in H0;apply n;trivial.\n  apply H; compute; auto.\n  apply False_ind; apply H; compute; auto.\n  apply H; compute; auto.\n  apply H; compute; auto.\n  right; rewrite e; simpl; auto.\n  case (Nbit0 a); case (Nbit0 a); case (Nbit0 a); \n  intros.\n  simpl in H0; apply n; auto.\n  apply H; compute; auto.\n  apply H; compute; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/euclide.v",
                "context": " with arith).\n  rewrite mult_plus_distr_l in H0.\n  assert (r'=(b*(q-q')+r)).\n  apply plus_reg_l with (b*q').\n  rewrite plus_assoc;trivial.\n  assert (0<(q-q'));try omega.\n  assert (b<=b*(q-q'));try omega.\n  case (mult_O_le b (q-q'));intro;try omega.\n  rewrite mult_comm;trivial.\nQed.\n\n(** if b<>0, then b | a iff a mod b = 0 *) \nLemma divides_euclide : forall (a b:nat)(H:(b<>O)),((divides a b)<->((remainder_euclide a b H)=O)).\n  intros.\n  red.\n  split;intro.\n  generalize (quo_rem_euclide a b H);intro.\n  generalize (rem_euclide a b H);intro.\n  elim H0;intro q;intro.\n  assert (a=b*q+0).\n  rewrite plus_comm;simpl;trivial.\n  assert (0<b);try omega.\n  generalize (euclide_unique a b (quotient_euclide a b H) (remainder_euclide a b H) q 0 H H1 H4 H2 H5).\n  intros;tauto.\n  generalize (quo_rem_euclide a b H).\n  rewrite H0;rewrite plus_comm;simpl.\n  intro;exists (quotient_euclide a b H);trivial.\nQed.\n\n(** divisibility is decidable *)\nLemma divides_dec : forall (a b:nat),{divides a b}+{~(divides a b)}.\n  intros.\n  case (eq_nat_dec b 0).\n  case (eq_nat_dec a 0);intros.\n  rewrite e;left;apply zero_max_div.\n  right;rewrite e;intro.\n  elim H;intro q;intro.\n  simpl in H0;apply n;trivial.\n  intro.\n  case (eq_nat_dec (remainder_euclide a b n) 0);[left | right];intros;elim (divides_euclide a b n);auto.\nQed.\n\n(** if a property about integer is decidable then it is decidable if there is an integer less than n that satisfies this property *)\nLemma dec_impl_lt_dec : forall (P:nat->Prop),(forall (n:nat),{(P n)}+{~(P n)})->(forall (m:nat),{n:nat | (n<m)/\\(P(n))}+{(forall (n:nat),(n<m)->~(P n))}).\n  intros.\n  induction m.\n  right;intros;inversion H0.\n  case (H m);intro.\n  left;exists m;split;try (auto with arith).\n  case IHm;intro.\n  elim s;intro n0;intro.\n  left;exists n0;split;[omega | tauto].\n  right;intros.\n  inversion H0;trivial.\n  apply n0;omega.\nQed.\n\n(** forall n, either forall p, p<>1 /\\ p<>n -> not(p | n) or there is p such that p<>1 and p<>n and p | n *) \n",
                "context_tokens": 706,
                "proof_start_offset": 5092,
                "proof_end_offset": 5809,
                "proof": "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\nintros.\ncase (dec_impl_lt_dec (fun p => (p<>1)/\\(divides n p))) with n;intros.\ncase (divides_dec n n0);intro.\ncase (eq_nat_dec n0 1);intros.\nright;intro;tauto.\nleft;tauto.\nright;tauto.\nelim s;intros.\nleft;exists x.\nsplit;try tauto.\nsplit;try tauto.\nomega.\ncase (eq_nat_dec n 0);intro.\nrewrite e;left;exists 2.\nsplit;try (intro;discriminate).\nsplit;try (intro;discriminate).\napply zero_max_div.\nright;intros.\ncase (lt_eq_lt_dec p n);intro.\ncase s;intro;[red in n0;intro;apply n0 with p;tauto | auto].\nintro;generalize (divides_le n p n1 H1);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros; induction n.\n  right;intros;inversion H0.\n  case (le_or_lt n p).\n  left;intros;inversion H0.\n  left;intros;inversion H0.\n  simpl in H0;apply H;auto.\n  left;intros;inversion H0.\n  simpl in H0;apply H;auto.\n  right;intros;inversion H0.\n  simpl in H0;apply H;auto.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\n  intros n p.\n  case (le_gt_dec n p);intros.\n  case (le_lt_dec n p).\n  intro.\n  elim H0; intro.\n  case (le_lt_dec n p).\n  intro.\n  left;intros; rewrite H0 in H; discriminate H.\n  right;intros; rewrite H0 in H; discriminate H.\n  right;intros; rewrite H0 in H; discriminate H.\n  left;intros; rewrite H0 in H; discriminate H.\n  right;intros; rewrite H0 in H; discriminate H.\n  right;intros; rewrite H0 in H; discriminate H.\n  right;intros; rewrite H0 in H; discriminate H.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (le_gt_dec n p); intros.\n  left;intro; auto with arith.\n  elim H; intro n0; intro.\n  case (le_gt_dec n p); intros.\n  left; intro; auto with arith.\n  elim H; intro n0; intros; auto with arith.\n  elim H0; intro n0; intros; auto with arith.\n  elim H0; intro n1; intros; auto with arith.\n  elim H; intro n1; intros; auto with arith.\n  elim H; intro n1; intros; auto with arith.\n  elim H; intros n2; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim H; intros; auto with arith.\n  elim HQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct n.\n  left;intros.\n  destruct (lt_dec n m).\n  left;intros;inversion H1.\n  right;intros.\n  apply H;auto with arith.\n  right;intros.\n  apply H;auto with arith.\n  right;intros.\n  apply H;auto with arith.\n  right;intros.\n  apply H;auto with arith.\n  left;intros.\n  apply H;auto with arith.\n  right;intros.\n  apply H;auto with arith.\n  right;intros.\n  apply H;auto with arith.\n  left;intros.\n  apply H;auto with arith.\n  right;intros.\n  apply H;auto with arith.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  case (le_gt_dec n p);intros.\n  left;intros; inversion H0.\n  left;intros;inversion H0.\n  right;intros;inversion H0.\n  right;intros;inversion H0;inversion H1;inversion H1;inversion H1;inversion H1;inversion H1;inversion H1;inversion H1;inversion H2;inversion H2;inversion H3;inversion H3;inversion H3;inversion H3;inversion H3;inversion H3;inversion H4;inversion H4; inversion H4; inversion H4;inversion H4;inversion H4; inversion H4; inversion H4;inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4;inversion H4; inversion H4;inversion H4;inversion H4; inversion H4;inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4; inversion H4;Qed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\n intros.\n case (le_gt_dec n p).\n case (le_gt_dec n p).\n intros.\n  left;intros;inversion H0.\n  right;intros;inversion H;trivial.\n  apply n;apply prime_max_lub;trivial.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\n  intros.\n  destruct n.\n  left;intros;inversion H0;auto with arith.\n  right;intros;inversion H0;auto with arith.\n  right;intros;inversion H0;auto with arith.\n  right;intros;inversion H0;auto with arith.\n  right;intros;inversion H0;auto with arith.\n  right;intros;inversion H0;auto with arith.\n  right;intros;inversion H0;auto with arith.\n  left;intros;inversion H1;auto with arith.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros.\n  destruct n.\n  left;intros; inversion H0.\n  right;intros;inversion H0.\n  apply n;omega.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\n  intros; generalize (Even_dec n p);intro p;elim p;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp; intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp;intros p Hp; intros p Hp; intros p Hp; intros p Hp; intros p Hp; intros p Hp; intros p Hp; intros p Hp; subst p; simpl; ring.\nQed.",
                    "Lemma divides_nat : forall (n:nat),{p:nat | (p<>1)/\\(p<>n)/\\(divides n p)}+{forall (p:nat),(p<>1)->(p<>n)->~(divides n p)}.\nProof.\nintros n H;\ninduction n.\nsimpl;intros;inversion H0.\ndestruct p;destruct p0;destruct p0;\nexists (S p0);split;try (auto with arith).\nintros p H p0 H1.\nrewrite H1.\ndestruct p; destruct p0;\nexists (S p0);split;try (auto with arith).\nrewrite H;\nrewrite H0;\nrewrite <- H1;\nrewrite H1;\nrewrite H0;\nrewrite H2;\nrewrite H2;\nrewrite H2;\nrewrite H0;\n rewrite H2;\nrewrite H1;\nrewrite H2;\nrewrite H2;\nrewrite H2;\nrewrite H1;\nrewrite H2;\nrewrite H0;\nrewrite H2;\nrewrite H2;\nrewrite H2;\n rewrite H2;\n rewrite H2;\nrewrite H0;\n rewrite H0;\n rewrite H2;\n rewrite H2;\nrewrite H1;\n rewrite H0;\nrewrite H0;\nrewrite H2;\nrewrite H0;\nrewrite H1;\nrewrite H0;\n rewrite H2;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\n",
                "context_tokens": 382,
                "proof_start_offset": 1408,
                "proof_end_offset": 2212,
                "proof": "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_square;trivial.\nexists (k*(square b)).\nrewrite <- H2;ring.\nelim H3;intro n_a;intro.\nrewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\nassert (k*(b*b)=p*(n_a*n_a)).\napply mult_lemma6 with p.\nintro H5;rewrite H5 in H;apply not_prime_zero;trivial.\nrewrite mult_assoc;rewrite H2;ring.\nassert (divides b p).\napply prime_square;trivial;unfold square.\napply gauss with k.\napply rel_prime_sym;trivial.\nexists (n_a*n_a);trivial.\nassert (p=1).\nunfold rel_prime in H1.\nelim H1;intros.\napply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nelim H;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros.\n apply Bezout_intro with (1:=a) (2:=b) (3:=b) (3:=b).\n rewrite H.\n reflexivity.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nassert (H: forall p, {p:positive | prime p} + {p:positive | prime p}).\n apply (rel_prime_pos p (abs_pos p)) (abs_pos p)).\n intros q.\n destruct q as [| q| q]; simpl; try discriminate.\n left; unfold rel_prime; simpl.\n rewrite <- (abs_eq_0 q).\n unfold rel_prime; simpl; ring.\n left; unfold rel_prime; simpl.\n rewrite <- (abs_eq_0 q).\n unfold rel_prime; simpl; ring.\n right; unfold rel_prime; simpl.\n rewrite <- (abs_eq_0 q).\n unfold rel_prime; simpl.\n rewrite <- (abs_eq_0 q).\n unfold rel_prime; simpl; ring.\n right; unfold rel_prime; simpl.\n rewrite <- (abs_eq_0 q).\n unfold rel_prime; simpl; ring.\n right; unfold rel_prime; simpl.\n rewrite <- (abs_eq_0 q).\n unfold rel_prime; simpl; ring.\n right; unfold rel_prime; simpl.\n rewrite <- (absQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b.\n generalize p.\n induction p.\n (* 1 < p *)\n unfold rel_prime in |- *.\n intros.\n replace (S p) with (S (p+p)) by ring.\n rewrite div_mod_eq; auto with zarith.\n rewrite <- (div_mod a b) at 1.\n rewrite div_mod_eq; auto with zarith.\n (* (0 < p) *)\n unfold rel_prime in |- *.\n intros.\n replace (S p) with (S (p+p)) by ring.\n rewrite div_mod_eq; auto with zarith.\n (* (0 < p) *)\n unfold rel_prime in |- *.\n intros.\n replace (S p) with (S (p+p)) by ring.\n rewrite div_mod_eq; auto with zarith.\n (* (0 < p) *)\n unfold rel_prime in |- *.\n intros.\n replace (S p) with (S (p+p)) by ring.\n rewrite div_mod_eq; auto with zarith.\n (* (0 < p) *)\n unfold rel_prime in |- *.\n intros.\n replace (SQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nunfold rel_prime.\nintros p k a b c p.\nunfold rel_prime.\ndestruct (dec_prime p) as [q|q].\n (* a=q *)\nexists (Zabs_nat (Zabs_nat q)).\nrepeat split; auto.\napply Zis_gcd_for_euclid with (1:=p) (2:=p) (3:=p) (3:=p) (3:=p) (3:=p) (3:=p) (3:=p) (4:=p) (4:=p) (5:=p) (5:=p) (5:=p) (5:=p) (5:=p) (5:=p) (6:=p) (5:=p) (5:=p) (5:=p) (5:=p) (5:=p) (6:=p) (5:=p) (5:=p) (6:=p) (5:=p) (5:=p) (6:=p) (5:=p) (6:=p) (5:=p) (5:=p) (7:=p) (5:=p) (5:=p) (5:=pQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nunfold rel_prime.\nintros p k a b Hb.\nassert (Ha : 0 < p) by (apply (lt_cancel_pos_bound _ _ Hb)).\nassert (Hb : 0 < b) by (apply (lt_cancel_pos_bound _ _ _ Hb)).\ndestruct (lt_ge_dec 0 p) as [H|H].\napply (lt_cancel_pos_bound _ _ _ Hb).\ndestruct (lt_ge_dec (b - a) (b - b)) as [H'|H'].\ndestruct (lt_ge_dec a b) as [H'|H'].\ndestruct (lt_ge_dec a b) as [H'|H']; auto.\nexfalso.\napply (lt_cancel_pos_bound _ _ _ Hb).\nrewrite <- (lt_cancel_pos_bound _ _ H').\nrewrite <- (lt_cancel_pos_bound _ _ _ H).\nrewrite <- (lt_cancel_pos_pos_bound _ _ H').\nrewrite <- (lt_cancel_pos_pos_bound _ _ H').\nrewrite <- (lt_cancel_pos_bound _ _ H').Qed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros.\nassert (H:=ex_prime p).\nassert (H':=ex_prime p).\nassert (H:=ex_prime p).\ndestruct (not_prime_prime_factor_prime p) as [H0|H0].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H0|H0].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H1|H1].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H2|H2].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H3|H3].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H3|H3].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H4|H3].\n(* a=b *)\ndestruct (non_prime_factor_prime p) as [H4|H4].\n(* a=b *)\ndestruct (non_prime_factor_primeQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b Ha Hb.\nassert (H := sqrt_pos_aux p k a b Hb).\nunfold rel_prime in H.\nelim H; intros; trivial.\nrewrite <- H; trivial.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b.\nunfold rel_prime.\nunfold rel_prime in |- *.\nelim (dec_prime p); intros.\nrewrite H0.\nrewrite H1; ring.\nrewrite H1; ring.\nrewrite H1; ring.\nrewrite H1; ring.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nunfold rel_prime.\nintros (H1,H2) (H3,H4).\nassert (H5 := div_mod_pos a b H5 H6).\nassert (H6 := div_mod_pos b a H5 H6).\nrewrite <- H6, div_mod_eq.\nrewrite <- H6.\nrewrite <- H5.\nfield.\nrewrite H3.\nfield.\nrewrite H3.\nring.\nQed.",
                    "Lemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b Ha Hb.\nunfold rel_prime.\ndestruct (le_gt_dec 0 k) as [H|H].\n (* 0 < r *)\ngeneralize (le_refl _ H); clear H; intro H'.\nassert (H' : forall p:nat, (p <= p)%nat ->  (p <= p)%nat).\napply (fun m n => (p <= m)%nat).\nintros n H' p.\ncase (le_gt_dec n m); intros H'1.\n(* 0 < r *)\ngeneralize (le_refl _ H'); intro H'.\ngeneralize (lt_irrefl _ H'); intro H'.\nreplace (p * (m + p)) with (p * m + p)%nat.\nrewrite H'1.\nring_simplify.\napply (fun m n => (m + p)%nat).\napply (fun m n => (m + p)%nat).\nring_simplify.\napply (fun m n => (m + p)%nat).\nring_simplify.\napply (fun m n => (m + p)%nat).\nring_simplify.\napply (fun mQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "t (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\n(** First, we show the following theorem: *)\n(** if p is a prime number and gcd(p,k)=1 then sqrt(p*k) is not rational *)\n\n(** Then, we strengthen the result to the n-th root of p^r*k *)\n(** where 0 < r < n obtaining the theorem: *)\n(**  if p is a prime number, gcd(p,k)=1 and 0 < r < n then the n-th root of p^r*k is not rational *)\n\nRequire Import missing.\nRequire Import division.\nRequire Import gcd.\nRequire Import primes.\nRequire Import power.\n\nUnset Standard Proposition Elimination Names.\n\n(** now, we show the result claimed in the header *)\nLemma sqrt_prime_irrat_aux : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(rel_prime a b)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\n",
                "context_tokens": 696,
                "proof_start_offset": 2307,
                "proof_end_offset": 3364,
                "proof": "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\nintros.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\nintro.\nrewrite H3 in H5.\nreplace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\nrewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\nassert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\napply mult_lemma6 with (square (gcd a b)).\nunfold square.\ngeneralize (gcd_non_zero (gcd a b) a b H1 H2);intro.\nintro;apply H6.\ncase (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\nrewrite <- H5;ring.\napply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  apply  prime_nt_prime with (p:=p);trivial.\n  apply prime_nt_prime with (p:=p);trivial.\n  unfold Bezout;simpl; tauto.\n  elim H; intros;\n    apply prime_nt_prime with (p:=p);trivial.\n  elim H1; intros;\n    apply prime_nt_prime with (p:=p);trivial.\n  elim H1; intros;\n    rewrite H4 in H2; rewrite square_mult_strong in H2;unfold square in H2.\n  rewrite H4 in H2; rewrite square_mult_strong in H2;unfold square in H2.\n  rewrite H4 in H2; rewrite square_mult_strong in H2;unfold square in H2.\n  assert (H : 1 < p);\n    [apply lt_le_trans with (p:=p); tauto | apply le_trans with (p:=p); tauto].\n  elim H; intros;\n    rewrite H4 in H2; rewrite square_mult_strong in H2; unfold square in H2.\n  rewrite H4 in H2; rewrite square_mult_strong in H2; unfold square in HQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  rewrite <- (abs_prime a);trivial.\n  elim H;intros n p0.\n  rewrite H2 in H2;rewrite square_mult_strong in H2;unfold square in H2.\n  assert (H4:=abs_pos p0).\n  assert (H5:=abs_pos p0).\n  assert (H5:=abs_pos p0).\n  assert (H5:=abs_neg p0).\n  assert (H6:=abs_pos p0).\n  assert (H7:=abs_pos p).\n  unfold div in H3;rewrite H6 in H3;apply not_prime_not_prime; tauto.\n  apply lt_trans with (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_pos (abs_Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\n intros p k a b.\n unfold rel_prime in |- *.\nunfold is_prime in |- *.\nelim (rel_prime_dec (k*p) (k*p) k); intros p1 p2.\nelim (prime_dec (k*p) (k*p1)); intros p2 p3.\nexists (p1*p1); rewrite <- H2; ring.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b.\nintro H.\nunfold is_prime.\ndecompose [and] H; clear H.\nrewrite <- H0;ring.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  apply (sqrt_prime_aux (p*k) (p*b)).\n  apply prime_div_pos;auto.\n  apply prime_div_pos;auto.\nQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  apply prime_prime_decomp_aux with (p:=p) (p:=p).\n  rewrite <- H2; ring.\n  elim H; intros.\n  rewrite H4 in H; rewrite square_mult_strong in H; unfold square in H;\n  rewrite (mult_comm (a*b)) in H;rewrite (mult_comm (b*c)) in H;\n  rewrite (mult_comm (a*b)) in H; rewrite (mult_comm (a*b)) in H;\n  rewrite (mult_comm (a*b)) in H; rewrite (mult_comm b (a*b)) in H;\n  rewrite (mult_comm b (a*b)) in H; rewrite (mult_comm (a*b)) in H;\n  rewrite (mult_comm (a*b)) in H; rewrite (mult_comm b (a*b)) in H;\n  rewrite (mult_comm (a*b*b)) in H;\n  rewrite (mult_comm (a*b)) in H; rewrite (mult_comm b (a*b)) in H;\n  rewrite (mult_comm (a*b)) in H; rewrite (Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (H1:=H).\n  apply prime_odd;trivial.\n  rewrite H1 in H; rewrite square_mult_strong in H1; unfold square in H1.\n  assert (H2:=H1).\n  assert (H3:=H2).\n  apply lt_le_trans with (S (p*k*p)).\n  rewrite mult_comm.\n  rewrite <- H2.\n  rewrite (mult_comm (p*p)).\n  rewrite <- H3.\n  rewrite mult_assoc;rewrite <- H3; ring.\n  rewrite <- H1; ring.\n  elim H; intros.\n  rewrite H4 in H; rewrite square_mult_strong in H;unfold square in H2.\n  assert (H1:=H1).\n  apply le_trans with (S (p*k*p)).\n  rewrite mult_comm.\n  rewrite <- H1.\n  rewrite mult_comm.\n  rewrite <- H2.\n  rewrite mult_comm.\n  rewrite <- H2.\n  rewrite (mult_comm (p*p)).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite <- H2.\n  rewrite (mult_comm (p*Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\nProof.\nintros p k a b.\nintro H.\nassert (H:=gcd_nonneg p).\nunfold rel_prime in H;decompose [and] H; clear H.\nassert (H:=gcd_nonneg p).\nunfold rel_prime in H;decompose [and] H; clear H.\nassert (H:=gcd_nonneg p).\nunfold rel_prime in H;decompose [and] H; clear H.\nassert (H:=gcd_nonneg p).\nunfold rel_prime in H;decompose [and] H; clear H.\nassert (H:=gcd_nonneg p).\nunfold rel_prime in H;decompose [and] H; clear H.\nassert (H:=(gcd_nonneg p) H).\napply Zis_gcd_for_euclid with p; try assumption.\nrewrite H4 in H2;rewrite square_mult_strong in H2;unfold square in H2.\nassert (H':=gcd_nonneg p).\nunfold rel_prime in H2;decompose [and] H2; clear H2.\nassert (H':=gcd_nonneg p).\nunfold rel_prime in H2; decompose [and] H2;Qed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros p k a b c.\n  intro.\n  apply prime_even;trivial.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_odd; tauto.\n  apply prime_even; tauto.\n  apply prime_odd; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_odd; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_even; tauto.\n  apply prime_evenQed.",
                    "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  intro.\n  apply prime_prime_decomp_construction;auto.\n  clear H; intro p; destruct p as [p0|p0];\n  [auto with field | auto with field ].\n  rewrite H0;rewrite H1;rewrite H2;ring.\n  elim H; intros n0 H0.\n  apply prime_prime_decomp_construction;auto.\n  replace (p0 * (b*p0)) with (p0 * b) by ring.\n  replace (p0 * (b*p0)) with (p0 * (b*p0)) by ring.\n  apply mul_integral_domain;auto.\n  rewrite <- H2; rewrite H2; ring.\n  rewrite H0; rewrite H1;ring.\n  replace (p0 * (b * p0)) with (p0 * (b*p0)).\n  apply mul_integral_domain;auto.\n  replace (p0 * (b*p0)) with (p0 * (b*p0)).\n  rewrite <- H2; ring.\n  replace (p0 * (b*p0)) with (p0 * (b*p0)).\n  apply mul_integral_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*(square b) <> (square a)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_square;trivial.\n  exists (k*(square b)).\n  rewrite <- H2;ring.\n  elim H3;intro n_a;intro.\n  rewrite H4 in H2;rewrite square_mult_lemma in H2;unfold square in H2.\n  assert (k*(b*b)=p*(n_a*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\n",
                "context_tokens": 720,
                "proof_start_offset": 3417,
                "proof_end_offset": 3629,
                "proof": "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros.\nreplace p with (p*1);try (auto with arith).\napply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros a b H.\n  generalize (gcd_unique_divisors a b H);intro.\n  rewrite H;rewrite H;clear H.\n  rewrite (gcd_sym (gcd_comm (gcd a b) (gcd a b) b H0).\n  apply gcd_gcd.\n  generalize (gcd_for_gcd a b (gcd b b) (gcd a b H1));intro.\n  generalize (gcd_for_gcd a b (gcd a b) (gcd a b H0));intro.\n  rewrite H0;rewrite H0;clear H0.\n  rewrite (gcd_comm (gcd a b) (gcd a b) b H0);intro.\n  replace (gcd a b) with (gcd a b * 1).\n  apply gcd_gcd.\n  generalize (gcd_for_gcd a b (gcd a b) (gcd a b H1));intro.\n  rewrite H0;rewrite H0; clear H0.\n  rewrite (gcd_comm (gcd a b) (gcd a b) b H0);intro.\n  replace (gcd a b) with (gcd a b * 1).\n  apply gcd_gcd.\n  generalize (gcd_greatest a b (gcd a bQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  unfold sqrt.\n  destruct (gcd_gcd a b) as [b0 b1].\n  destruct (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1 b2].\n  rewrite H;auto.\n  case (gcd_gcd a b) as [b1Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\nintros p Hp.\nassert (Hp' : forall p q, (p<=q <-> a/b=q)).\n  apply (gcd_divide_l_reverse (gcd p q) (gcd a b)); intros q H;\n  try rewrite H; apply divide_refl.\n  apply (gcd_divide_r_reverse (gcd p q) (gcd a b));\n  try rewrite H; apply divide_refl.\n (* case p is prime *)\n  intros q Hp; apply gcd_divide_l.\n  exists (gcd a b); exists (gcd a b);\n  rewrite <- H; rewrite <- H0; ring.\n  apply (gcd_divide_r_reverse (gcd p q) (gcd a b));\n  try rewrite H; apply divide_refl.\n  apply (gcd_divide_r_reverse (gcd p q) (gcd a b));\n  try rewrite H; apply gcd_divide_r.\n  exists (gcd a b); exists (gcd a b);\n  rewrite <- H0; rewrite <- H0; ring.\n  apply (gcd_divide_r_reverse (gcd p q) (gcd a b));\n  try rewrite H; apply gcd_divide_rQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros a b.\n  assert (H := div_mod_unique a b).\n  replace (gcd a b) with (gcd a b).\n  apply mod_unique with (gcd a b).\n  rewrite <- H; ring.\n  apply mod_same.\n  exists (gcd a b).\n  rewrite <- H; ring.\n  apply div_unique with (gcd a b).\n  rewrite <- H; ring.\n  apply mod_same.\n  exists (gcd a b).\n  rewrite <- H; ring.\n  apply mod_same.\n  exists (gcd a b).\n  rewrite <- H; ring.\n  apply mod_same; auto.\n  exists (gcd a b).\n  rewrite <- H; ring.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n intros.\n assert (H:=gcd_nonneg p).\n apply (gcd_nonneg a b);auto.\n apply gcd_nonneg; auto.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  unfold div.\n  assert (H:=H).\n  unfold div.\n  case (gcd_bezout a b H).\n  assert (H:=H0).\n  destruct (gcd_bezout a b H).\n  rewrite H0.\n  ring.\n  rewrite H0.\n  ring.\n  rewrite H0.\n  ring.\n  unfold sqrt.\n  case (gcd_bezout a b H).\n  replace (gcd a b) with (gcd a b * (gcd a b * (gcd a b) * (gcd a b) * (gcd a b * (gcd a b) * (gcd a b) * (gcd a b * (gcd a b)) * (gcd a b)).\n  apply gcd_unique with (gcd a b).\n  unfold gcd.\n  generalize (gcd_greatest a b H);intro.\n  generalize (gcd_greatest a b H0);intro.\n  rewrite H2 in H5; rewrite square_mult_strong in H5; rewrite square_mult_strong in H5; unfold square in H5.\n  apply div_exact; trivial.\n  apply (gcd_divide_r_abs a b); trivial.\n  apply (gcd_divide_r_Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  apply sqrt_div_mod_pos; auto.\n  apply lt_le_trans with (1:=a) (2:=b) (2:=b) (2:=b); auto.\n  apply div_unique with (2:=a) (3:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (2:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (3:=b) (3:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (3:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (3:=b) (3:=b) (4:=b); auto.\n  apply div_unique with (3:=b) (3:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (3:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (1:=b) (3:=b) (3:=b) (3:=b); auto.\n  apply div_unique with (Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros p a b.\n  set (k:=p) in *.\n  set (k:=p) in *.\n  set (k:=p) in *.\n  set (k' :=p) in *.\n  set (k' :=p - k') in *.\n  set (k' :=p - k' - k') in *.\n  set (k' :=p - k') in *.\n  set (k'' :=p - k') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' := p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (k'' :=p - k'') in *.\n  set (Qed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\nProof.\n  intros.\n  unfold sqrt.\n  generalize (gcd_div_mod a b);intro.\n  generalize (gcd_nonneg b (gcd a b));intro.\n  generalize (gcd_nonneg b (gcd a b));intro.\n  rewrite <- (gcd_gcd a b) at 1;rewrite <-gcd_gcd; tauto.\n  rewrite <- (gcd_gcd a b) at 1; rewrite <-gcd_gcd; tauto.\n  apply (gcd_greatest a b) with (gcd a b).\n  apply gcd_gcd; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\n  apply gcd_greatest; auto.\nQed.",
                    "Fact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  assert (H:=gcd_unique_gcd a b);intro.\n  generalize (gcd_divide_r_gcd a b);intro.\n  generalize (gcd_divide_r_gcd a b);intro.\n  rewrite H0 in H.\n  replace (gcd a b) with (gcd a b).\n  replace (gcd a b) with (gcd a b).\n  rewrite H; ring.\n  generalize (gcd_divide_r_gcd a b);intro.\n  rewrite H0 in H.\n  replace (gcd a b) with (gcd a b).\n  replace (gcd a b) with (gcd a b).\n  rewrite H; ring.\n  rewrite <- H0; ring.\n  apply (gcd_divide_r_r p).\n  apply rel_prime_sym.\n  exists (gcd a b); ring.\n  apply gcd_divide_r_l.\n  exists (gcd a b); ring.\n  apply gcd_divide_l.\n  exists 1; ring.\n  apply gcd_divide_r.\n  exists 1; ring.\n  apply gcd_divide_r.\n  exists 1; ring.\n  apply gcd_divide_r.\n  exists 1; ring.\n  apply gcdQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "*n_a)).\n  apply mult_lemma6 with p.\n  intro H5;rewrite H5 in H;apply not_prime_zero;trivial.\n  rewrite mult_assoc;rewrite H2;ring.\n  assert (divides b p).\n  apply prime_square;trivial;unfold square.\n  apply gauss with k.\n  apply rel_prime_sym;trivial.\n  exists (n_a*n_a);trivial.\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\n",
                "context_tokens": 728,
                "proof_start_offset": 3719,
                "proof_end_offset": 3854,
                "proof": "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\nintros.\napply sqrt_prime;trivial.\napply is_prime_2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  replace p with (q*(p*q));try (auto with arith).\n  apply sqrt_preserves_div_aux;auto with zarith.\n  replace (p*q*(p*q)) with (p*q*(p*q)); try (auto with arith).\n  apply sqrt_preserves_div_aux;auto with zarith.\n  replace (p*q*(p*q)) with (p*q*(p*q)); try (auto with arith).\n  apply sqrt_preserves_div_aux;auto with zarith.\n  replace (p*q*(p*q)) with (p*q*(p*q)); try (auto with arith).\n  apply sqrt_preserves_div_aux;auto with zarith.\n  replace (p*q*(p*q)) with (p*q*(p*q)); try (auto with arith).\n  apply sqrt_preserves_div_aux;auto with zarith.\n  replace (p*q*(p*q)) with (p*q*(p*q)); try (auto with arith).\n  apply sqrt_preserves_div_aux;auto with zarith.\n  replace (p*q*(p*q)) with (p*q*(Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n apply sqrt_is_gcd; auto.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros; apply sqrt_prime_2; auto with zarith.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  unfold sqrt.\n  intros (a,b) (Ha,H).\n  replace b with (2*a);try (auto with zarith).\n  apply sqrt_bound;trivial.\n  rewrite <- H;ring.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n  intros.\n  replace (p*q) with (p*q); auto with zarith.\n  replace (p*q) with (p*q); auto with zarith.\n  rewrite H; auto with zarith.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  replace q with (q*p);auto with arith.\n  rewrite <- H;ring.\n  symmetry; apply div_upper_bound;trivial.\n  symmetry; apply div_upper_bound;trivial.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  replace (p*(q*(q*(S q))*(S q)) with (p*(S q*(S q*(S q))).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  replace (p*(S q*(S q)) + (S q*(S q))).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  replace (p*(S q)) with (S q*(S q*(S q*(S q))).\n  apply mul_factor_l with (S q).\n  unfold sqrt.\n  generalize (sqrt_prime q); intro.\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (sqrt_div_mod (S q) (S q)).\n  rewrite <- (Qed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros;apply sqrt_pos_conod with (1:=1%nat); auto.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\nunfold sqrt.\nintros p q (a,b) (b,c) (c,p) (c,p) (c,p) (c,p) (c,p) (c,p) H.\nrewrite <- (div_mod b (gcd a b) c (gcd a b));\n apply mod_bound_pos;auto with zarith.\nQed.",
                    "Fact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\nProof.\n intros.\n assert (a = 1*(p*q)); auto with zarith.\n rewrite H; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": ".\n  assert (p=1).\n  unfold rel_prime in H1.\n  elim H1;intros.\n  apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\n  elim H;tauto.\nQed.\n\n(** Theorem: if p is prime, p and k are relatively prime, then sqrt(p*k) is not rationnal *)\nTheorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\n",
                "context_tokens": 694,
                "proof_start_offset": 3878,
                "proof_end_offset": 5151,
                "proof": "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nassert (divides a p).\napply prime_power with n;trivial.\ngeneralize (power_divides_lemma1 r p H1);intro.\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite <- H4;exists (q*k*(power b n));ring.\nassert (divides b p).\nelim H5;intro q;intros.\nrewrite H6 in H4.\nrewrite power_mult_lemma1 in H4.\nassert ((power p n)=(power p (r+(n-r)))).\nrewrite <- le_plus_minus;try (auto with arith).\nrewrite H7 in H4;rewrite power_plus_lemma1 in H4.\nassert ((power p r)<>O).\nintro.\napply not_prime_zero.\nassert (p=O).\napply power_zero with r;trivial.\nrewrite H9 in H;trivial.\nrewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\nassert (divides (power p (n-r)) p).\napply power_divides_lemma1;apply minus_lt_lemma1;trivial.\napply prime_power with n;trivial.\napply gauss with k;try (apply rel_prime_sym;trivial).\nrewrite H9;apply divides_mult;trivial.\nelim H3;intros.\nelim H;intros.\napply H9;apply divides_antisym;try (apply one_min_div).\napply H8;red;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n r.\n  rewrite <- (mult_comm p).\n  rewrite <- (mult_comm (p*p)).\n  rewrite <- (mult_assoc (p*p)).\n  rewrite <- (mult_comm (p*p)).\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm (p*p)).\n  apply (mult_comm (p*p)).\n  apply mult_le_compat_l; auto.\n  apply (mult_comm (p*p)).\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros p k a b n l.\n apply (lt_wf_ind (fun n => forall p:nat, p=0/\\p=0) (lt_wf_ind (fun n => n) (fun n => n) a b n (lt_wf_ind n)).\n apply (lt_wf_ind (fun n => forall p:nat, p=0/\\p=0)).\n  intros.\n  destruct (p==0).\n  subst;auto.\n  apply (lt_wf_ind (fun n => forall p:nat, p=0 <-> p=0) (lt_wf_ind (fun n => n) a b n (lt_wf_ind n)).\n  intros p.\n  destruct (p==0).\n  subst;auto.\n  apply (lt_wf_ind (fun n => forall p:nat, p=0 <-> p=0).\n  intros.\n  destruct (p!n).\n  subst;auto.\n  apply (lt_wf_ind (fun n => forall p:nat, p=0 <-> p=0) (lt_wf_ind (fun n => n) (fun n => n) a b nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  assert (H:=H).\n  apply nth_error_pos;trivial.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_prime_2.\n  apply is_gcd_for_prime; apply (gcd_nonneg_nonneg p); auto with zarith.\n  apply (gcd_divide_trans _ _ (gcd_divide_r_iff _ _ H)).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  apply (gcd_divide_r_iff _ _ H).\n  applyQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply pred_dec; auto with zarith.\n  apply (decomp_correct_aux (p*p) (p*p));auto.\n  apply (decomp_correct_aux (p*p) (p*p));auto.\n  apply (decomp_correct_aux (p*p) (p*p));auto.\n  apply (decomp_correct_aux (p*p) (p*p));auto.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n r.\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs b)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (abs a)).\n  rewrite <- (mult_1_l (Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  assert (H:=is_nonneg p).\n  assert (H:=is_nonneg p).\n  rewrite H; apply is_nonneg_nonpos;auto.\n  apply (H (max_r (gcd a b) (gcd p b));auto.\n  apply (gcd_nonneg_nonneg p);auto.\n  apply (gcd_nonneg_nonneg p);auto.\n  apply (gcd_nonneg_nonneg p);auto.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n l.\n  apply (is_prime_2p p).\n  intros.\n  apply (is_prime_2p p).\n  intros.\n  apply (is_prime_2p p).\n  intros.\n  apply (is_prime_2p p).\n  apply prime_factor_l; trivial.\n  apply (is_prime_2p p).\n  intros.\n  apply (not_prime_3 p).\n  apply prime_factor_l; trivial.\n  apply prime_factor_r; trivial.\n  apply prime_factor_l; trivial.\n  apply (is_prime_2p p).\n  apply (is_prime_3 p).\n  intros.\n  apply (not_prime_3 p).\n  apply prime_factor_l; trivial.\n  apply (is_prime_3 p).\n  apply prime_factor_l; trivial.\n  apply (is_prime_3 p).\n  apply (is_prime_3 p).\n  intros.\n  apply (not_prime_3 p).\n  apply prime_factor_l; trivial.\n  apply (not_prime_3 p).\n  intros.\n  apply (not_prime_Qed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n r.\n  replace (p*1) with (p*p*(div2 (S n) * (div2 (S n) * (div2 (S n) * (div2 (S n) * (div2 (S n))))) by ring.\n  rewrite mult_comm.\n  replace (p*p*(div2 (S n) * (div2 (S n) * (div2 (S n) * (div2 (S n) * (div2 (S n) * (div2 (S n)))).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm 1).\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm (S n)).\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm 1).\n  apply mult_le_compat_l.\n  apply le_trans with (S (pred (div2 (S n) * (div2 (S n) * (div2 (S n) * (div2 (S n)))).\n  rewrite mult_comm.\n  rewrite <- (multQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply (factor_non_zero (gcd p a) b);auto with arith.\nQed.",
                    "Lemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n intros p k a b n l.\n replace (p*p+p) with ((p+p)+p); try (auto with arith).\n apply nth_error_conint;trivial.\n apply is_prime_2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** if p is prime then sqrt(p) is not rationnal *)\nFact sqrt_prime : forall (p:nat),(is_prime p)->forall (a b:nat),(b<>O)->(p*(square b)<>(square a)).\n  intros.\n  replace p with (p*1);try (auto with arith).\n  apply sqrt_prime_irrat;trivial;apply rel_prime_1.\nQed.\n\n(** We now deduce from this theorem that sqrt(2) is not rationnal *)\n(** here is it! *)\nFact sqrt_2_irrat : forall (p q:nat),(q<>O)->(2*(square q)<>(square p)).\n  intros.\n  apply sqrt_prime;trivial.\n  apply is_prime_2.\nQed.\n\n(** generalisation *)\nLemma nth_root_irrat_aux : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(rel_prime a b)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  assert (divides a p).\n  apply prime_power with n;trivial.\n  generalize (power_divides_lemma1 r p H1);intro.\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite <- H4;exists (q*k*(power b n));ring.\n  assert (divides b p).\n  elim H5;intro q;intros.\n  rewrite H6 in H4.\n  rewrite power_mult_lemma1 in H4.\n  assert ((power p n)=(power p (r+(n-r)))).\n  rewrite <- le_plus_minus;try (auto with arith).\n  rewrite H7 in H4;rewrite power_plus_lemma1 in H4.\n  assert ((power p r)<>O).\n  intro.\n  apply not_prime_zero.\n  assert (p=O).\n  apply power_zero with r;trivial.\n  rewrite H9 in H;trivial.\n  rewrite <- mult_assoc in H4;rewrite <- mult_assoc in H4;generalize (mult_lemma6 (k*(power b n)) ((power p (n-r))*(power q n)) (power p r) H8 H4);intro.\n  assert (divides (power p (n-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\n",
                "context_tokens": 698,
                "proof_start_offset": 5286,
                "proof_end_offset": 6579,
                "proof": "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\ngeneralize (gcd_is_gcd a b);intro.\ngeneralize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\ngeneralize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\nassert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\nassert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\nrewrite power_mult_lemma1 in H8;rewrite H8 in H4.\nrewrite power_mult_lemma1 in H9;rewrite H9 in H4.\nrewrite mult_lemma7 in H4.\nassert ((power (gcd a b) n)<>O).\nintro.\ngeneralize (power_zero n (gcd a b) H10);intro.\napply (gcd_non_zero (gcd a b) a b);trivial.\ngeneralize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\nfold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\napply nth_root_irrat_aux;trivial.\napply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\nassert (forall p:nat, {p:nat | is_prime p} + {p:nat | is_prime p}}).\n  apply (fun p => forall p:nat, {p:nat | is_prime p} + {p:nat | is_prime p}.\n  elim (dec_prime p); intro p; intros.\n  elim H0; intro q; intros.\n  rewrite H1 in H2.\n  rewrite H2 in H4; rewrite H4 in H4; discriminate H4.\n  rewrite H3; rewrite H4; rewrite H4; apply prime_factor_prime_1.\n  elim H2; intros q r; intros.\n  rewrite H1 in H4; rewrite H4 in H4; rewrite H4 in H4; discriminate H4.\n  rewrite H5 in H4; rewrite H5 in H4; discriminate H4.\n  rewrite H4 in H4; discriminate H4.\n  rewrite H5 in H4; discriminate H4.\n  rewrite H5 in H4; discriminate H4.\n  rewrite H5 in H4; discriminate H4.\n  rewrite H5 in H4; discriminate H4.Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  apply H.\n  apply is_prime_2.\n  apply prime_factor_for_prime.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_for_prime; auto with zarith.\n  apply prime_factor_forQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nintros p k a b n r.\nrewrite <- (mult_comm (div2 (p + k)) (div2 (p + k)) (div2 (p + k)) (div2 (p + k))) at 1.\nrewrite <- (mult_comm (div2 (p + k)) (div2 (p + k)) (div2 (p + k)) at 1.\nrewrite <- div2_den.\nrewrite div2_double.\nrewrite div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nrewrite div2_double.\nrewrite <- div2_double.\nrewrite <- div2_double.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nintros p k a b n r H H0 H1 H2.\nrewrite <- H2.\nrewrite <- H3.\nrewrite <- H3.\nrewrite <- H3;ring.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n l H H1 H2.\nassert (H1:=H1).\nunfold is_prime in H1.\nassert (H3:=H1).\nunfold is_upper_bound in H3.\nunfold is_upper_bound in H3.\ndestruct (H1 H3) as (H4,_).\nassert (H6:=H2).\nunfold is_upper_bound in H3.\ndestruct (H1 H3) as (H5,_).\nassert (H7:=H4).\nunfold is_upper_bound in H3.\ndestruct (H1 H4) as (H5,_).\nassert (H6:=H6).\nunfold is_upper_bound in H3.\nunfold is_upper_bound in H3.\ndestruct (H2 H3) as (H6,_).\nassert (H8:=H2).\nunfold is_upper_bound in H3.\nunfold is_upper_bound in H3.\ndestruct (H1 H3) as (H6,_).\nassert (H7:=H4).\nunfold is_upper_bound in H3.\ndestruct (Qed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  apply pred_prime_factor with (p:=p) (q:=q);clear p q.\n  simpl; tauto.\n  elim H; intro q; intros.\n  rewrite H6 in H4.\n  rewrite H7 in H4; rewrite H4 in H4; discriminate H4.\n  rewrite H7 in H4; rewrite H4 in H4; discriminate H4.\n  rewrite H7 in H4; rewrite H4 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H7 in H4; discriminate H4.\n  rewrite H8 in H4; discriminate H4.\n  rewrite H8 in H4; discriminate H4.\n  rewrite H8 inQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nintros.\nassert (H:=H).\napply is_gcd_for_euclid with (1:=H).\nassert (H:=H).\nrewrite H;rewrite H;ring.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\n  intros p k a b n l.\n  unfold is_prime in *.\n  apply prime_factor with n;trivial.\n  generalize (factor_correct a b n r);intro.\n  elim H; intro q; intros.\n  rewrite H9 in H2; rewrite H2 in H2; rewrite H2 in H2; discriminate H2.\n  rewrite H8 in H2; rewrite H2 in H2; discriminate H2.\n  rewrite H9 in H2; rewrite H8 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminate H2.\n  rewrite H9 in H2; discriminateQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n r.\nrewrite <- (mult_comm (a*n)); simpl; auto.\nrewrite H0; ring.\nQed.",
                    "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\nProof.\nintros.\ndestruct p;\n[unfold is_prime, div;\nsimpl;\nunfold is_prime;\nsimpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nunfold is_prime;simpl;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": "-r)) p).\n  apply power_divides_lemma1;apply minus_lt_lemma1;trivial.\n  apply prime_power with n;trivial.\n  apply gauss with k;try (apply rel_prime_sym;trivial).\n  rewrite H9;apply divides_mult;trivial.\n  elim H3;intros.\n  elim H;intros.\n  apply H9;apply divides_antisym;try (apply one_min_div).\n  apply H8;red;tauto.\nQed.\n\n(** generalization of the theorem: if p is a prime number, 0 < r < n and gcd(p,k)=1 then the n-th root of p^r*k is not rationnal! *)\nTheorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\n  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\n  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\n",
                "context_tokens": 691,
                "proof_start_offset": 6627,
                "proof_end_offset": 7532,
                "proof": "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros.\nintro.\nrewrite power_plus_lemma1 in H4.\nassert (divides a (power p q)).\napply prime_power_qn with n;try (auto with arith);try omega.\nexists ((power p r)*k*(power b n)).\nrewrite <- H4;ring.\nassert (0<n);try omega.\nelim H5;intro a';intro.\nrewrite H7 in H4.\nrewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\nassert ((power p (q*n))<>0).\nintro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\nrewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\ngeneralize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\nfold (power p r * k * power b n <> power a' n).\napply nth_root_irrat;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r (H1,H2).\napply H2.\nintros p H3.\nassert ((p+q) = ((p+q) * (p+p)) by ring.\nrewrite H3.\nrewrite H1;ring.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n generalize (gcd_div_mod a b);intro.\n generalize (gcd_greatest a b);intro.\n generalize (gcd_greatest a b);intro.\n generalize (gcd_greatest a b);intro.\n generalize (gcd_greatest a b);intro.\n rewrite H2; rewrite H3; rewrite H4; ring.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\nintros p k a b n q r Hr.\nintro r; generalize (gcd_not_gcd a b);intro.\nrewrite H;rewrite H0;clear H0.\ndestruct r as [| r]; trivial; try easy.\nsimpl; ring.\nrewrite H; clear H0.\ndestruct r as [| r]; trivial; try easy.\nsimpl; ring.\nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros p k a b n q r H1 H2 H3;\n generalize (gcd_gcd_for_euclid p k a b n q r H1);intro.\n generalize (gcd_gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b n q r H2); intro.\n generalize (gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b n q r H2); intro.\n generalize (gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b n q r H2); intro.\n generalize (gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b n q r H1); intro.\n generalize (gcd_for_euclid p k a b nQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros p k a b n q r H1 H2.\n generalize (gcd_not_gcd a b);intro.\n generalize (gcd_nonneg a b);intro.\n generalize (gcd_nonneg a b);intro.\n generalize (gcd_nonneg b a);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b a);intro.\n generalize (gcd_nonneg a b);intro.\n generalize (gcd_nonneg b a);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg a b);intro.\n generalize (gcd_nonneg b a);intro.\n generalize (gcd_nonneg b a);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b);intro.\n generalize (gcd_nonneg b b); intro.\n generalize (gcd_nonnegQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n  intros.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (gcd_unique_gcd a b);intro.\n  generalize (Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros p k a b n q r H.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n rewrite H.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply H1.\n intros.\n apply H1; auto with arith.\n apply lt_wf_ind with (p+p)%nat.\n intros.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply H1.\n intros.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply (lt_wf_ind (fun p => (p+p)%nat)).\n intros.\n apply H0.\n intros.\n apply (lt_wf_ind (fun pQed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_correct_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_correct_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_correct_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (gcd_unique_divisors p p);intro.\n generalize (Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros p k a b n q r H H1 H2; apply (lt_wf_ind p n m p);\n [ intros (k,p)|[ k| k] ;\n apply (lt_wf_ind p n m p);\n [ intros (k',p)| k'];\n apply (lt_wf_ind p n m p);\n [intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [ intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [ intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [ intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [ intros (k'',p)| k'';\n apply (lt_wf_ind p n m p);\n [ intros (k'',p)| k'';\n apply (lt_Qed.",
                    "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\nProof.\n intros.\n apply (mult_integral_for_euclid (p:=a) (gcd_for_euclid (p:=a) (gcd p b) p));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd_for_euclid (p:=a) (gcd p b) (gcd p c)));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=a) (q:=gcd p c));\n try (rewrite <- (mult_comm (p:=Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/nthroot.v",
                "context": " b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n\n(** Generalization of the previous theorem *)\nTheorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  rewrite power_plus_lemma1 in H4.\n  assert (divides a (power p q)).\n  apply prime_power_qn with n;try (auto with arith);try omega.\n  exists ((power p r)*k*(power b n)).\n  rewrite <- H4;ring.\n  assert (0<n);try omega.\n  elim H5;intro a';intro.\n  rewrite H7 in H4.\n  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\n  assert ((power p (q*n))<>0).\n  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\n  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\n  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\n  fold (power p r * k * power b n <> power a' n).\n  apply nth_root_irrat;trivial.\nQed.\n\n(** let x and n be two numbers such that n > 0, then either the n-th root of x is a natural number of it is not rationnal *)\n",
                "context_tokens": 706,
                "proof_start_offset": 7659,
                "proof_end_offset": 8047,
                "proof": "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\nintros.\ncase (is_power_m_dec x n H);intro;try tauto.\nelim s;intro p;intro.\nelim p0;intro q;intro.\nelim p1;intro r;intro.\nelim p2;intro k;intro.\nright;intros.\nassert (x=(power p (q*n+r))*k);try tauto.\nrewrite H1;apply nth_root_irrational;tauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n  intros.\n  rewrite (mult_comm x (a^n)) at 1.\n  rewrite <- (mult_comm (a^n)) at 1.\n  rewrite <- (mult_assoc (a^n) (a^n)) at 1.\n  rewrite <- (mult_assoc (a^n) (a^n)) at 1.\n  rewrite <- (mult_assoc a (a^n)) at 1.\n  rewrite <- (mult_assoc a (a^n)) at 1.\n  rewrite (mult_comm (a^n)).\n  rewrite (mult_comm x (a^n)) at 1.\n  rewrite <- (mult_assoc a (a^n)) at 1.\n  rewrite <- (mult_assoc a (a^n)) at 1.\n  rewrite <- (mult_assoc a (a^n)) at 1.\n  rewrite <- (mult_assoc a (a^n)).\n  rewrite (mult_comm x (a^n)).\n  rewrite (mult_comm x (a^n)).\n  rewrite <- (mult_assoc a (a^n)).\n  rewrite <- (mult_assoc (a^n)).\n  rewrite <- (mult_assoc a (a^nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n intros.\n set (x:=n) in *; set (x:=n) in *; set (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.\nset (y:=n) in *.Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  apply (H (b:=0)) in H.\n  destruct H as [? [? [? [??]]]].\n  subst x.\n  destruct (H0 (b:=0)) as [? [? [??]]].\n  subst x.\n  rewrite H1 in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_l in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_l in H4.\n  rewrite <- H4 in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_l in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_l in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_0_l in H4.\n  rewrite mult_0_l in H4.\n  rewrite <- mult_0_r in H4.\n  rewrite mult_0_l in H4.\n  rewrite mult_0_l in H4.\n  rewrite mult_0_r in H4.\n  rewrite mult_Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  elim (le_dec x 0).\n  left; auto with arith.\n  right; auto with arith.\n  left; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  left; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  left; auto with arith.\n  left; auto with arith.\n  right; auto with arith.\n  left; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arith.\n  right; auto with arithQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\nProof.\n intros.\n rewrite power_0_r.\n assert (H:=H).\n apply nth_error_without_factor with (n:=n) (c:=a) (d:=a) in H; auto with arith.\n rewrite H; auto with arith.\n symmetry; apply nth_error_Strong_correct with (d:=a) (d:=a) (d:=a) (d:=a) (d:=a) (d:=a) (d':=a) (d:=a) (d:=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=a) (d':=Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  assert (H:=mult_real a (S b) H).\n  rewrite H;rewrite H0;auto.\n  simpl;auto with arith.\n  exists (S x);auto.\n  exists (S x);auto.\n  exists (S x);auto.\n  exists (S x);auto.\nQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  rewrite H.\n  apply nth_root_element_complete; auto with arith.\n  rewrite (mult_comm a (power b n)) at 1.\n  rewrite (mult_comm a (power b n)) at 1.\n  rewrite (mult_comm a (power b n)) at 1.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm a (power b n)) at 1.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (mult_comm a (power b n)) at 1.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (mult_comm a (power b n)) at 1.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite <- mult_assoc.\n  rewrite (mult_comm b (power b n)) at 1.\n  rewrite (multQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  apply (mult_integral x (lt_O_n _)) in H;clear x H.\n  rewrite <- H0.\n  rewrite (mult_comm (power_nat a n)) in H;rewrite <- H0 in H;trivial.\n  rewrite (mult_comm (power_nat a n)) in H;rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H;rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H;rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H;rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H; rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H;rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H; rewrite <- H0 in H;tauto.\n  rewrite (mult_comm (power_nat a n)) in H; rewrite <- H0 in H;tauto.\n Qed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  rewrite (mult_comm (div b n) (div b n)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (div b n) (div b n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm (div b n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite (mult_comm 1 n).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite (mult_comm 1 (div b n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite mult_assoc.\n  rewrite (mult_comm 1 (div b n)).\n  rewrite (mult_comm 1 (div b n)).\n  rewrite (mult_comm 1 (div b n)).\n  rewrite multQed.",
                    "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  destruct (rel_prime_dec (gcd a b) (gcd b n) H0) as [H0|H0].\n  left; apply rel_prime_dec with (gcd a b);auto.\n  left; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  left; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  left; apply rel_prime_dec with (gcd a b);auto.\n  left; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  left; apply rel_prime_dec with (gcd a b);auto.\n  right; apply rel_prime_dec with (gcd a b);auto.\n  left;Qed."
                ]
            }
        ]
    }
}