{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 4,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "f1b018037f5a44df2b2cee78bafc19e6eedd4cf9"
    },

    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 440,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold LT; simpl; intros; subst; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold simple; red; intros.\n      destruct (A x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B x); auto.\n      destruct (B xQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold LT; simpl; intros; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros. apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x); intros.\n      apply (well_founded_induction_type x0); intros.\n      apply (well_founded_induction_type x0); intros.\n      apply (well_founded_induction_type xQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold LT; intuition.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction x; simpl; intros; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold sim. unfold trans.\n      destruct x; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold LT; simpl; intros; intuition.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold LT; intuition.\n  Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold LT.\n      intros.\n      apply (well_founded_induction _ _ H).\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 473,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros.\n      induction H; simpl; auto.\n      destruct H; auto.\n      right; auto.\n      right; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. unfold L; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros. destruct H; simpl; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. induction l; simpl; intros.\n    contradiction.\n    apply IHt; auto. apply IHt; auto.\n    apply IHt; auto. apply IHt; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros. unfold ESolve.step. apply H. apply H. apply H0. apply H0. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      unfold Par; intros. apply H; auto.\n      apply H; auto.\n      apply H; auto.\n      apply H; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros. apply L. intros. apply L. intros. apply L. intros. apply L. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros. destruct H; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros. apply L. apply L. apply L. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 561,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z Hz.\n      apply S_star with y; assumption.\n      destruct YZ as [ w' Z].\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z VAL YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w' YW].\n      exists w'; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z Hz.\n      apply S_inj with z; assumption.\n      destruct XZ as [ w Z]; destruct Z as [ w' Z]; destruct Z as [ w' Z]; destruct Z as [ w' Z]; destruct Z as [ w' Z]; simpl; intros.\n      apply S_inj with z; assumption.\n      apply S_inj with z; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z LV YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w' Y W].\n      exists w'; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l x z; destruct l; simpl; intros y z Hz Z.\n      apply S_inj with y; assumption.\n      destruct YZ as [ w' Z].\n      exists w'; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z [[] z Hz].\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros z HABYZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z HAB; simpl; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z.\n      destruct l; simpl; intros x z LV YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w' Y'].\n      exists w'; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z mB YZ.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 633,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z HAC YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w' YW].\n      exists w'; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y HH; destruct l; simpl; intros x z HAB YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w' Hz' | Hz' | Hz' ]; assumption.\n      destruct XZ as [ w' Hz' | Hz' ]; assumption.\n      destruct XZ as [ w' Hz' | Hz' | Hz' ]; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y z H; destruct l; simpl; intros x z LV YZ.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z Az YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y z; destruct l; simpl; intros x z LV Z.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z LV Z.\n      apply S_star with y; assumption.\n      destruct YZ as [ w Z].\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y z; destruct l; simpl; intros x z LV YZ.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H; destruct l; simpl; intros x z LV; apply RD; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z LV YZ.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H; destruct l; simpl; intros y z HzZ.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 677,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply R_left; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z HAB.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y z H H0.\n      apply Wes_open with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_update with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y z H.\n      apply weak_update with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y H.\n      apply H.\n      apply H.\n      apply H.\n      apply H.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y z H.\n      apply weak_update with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y z; destruct l; simpl; intros x z Hz; apply S_inj with x; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros l x y z H.\n      apply weak_log with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply functional_base; assumption.\n      apply wf_ind with x; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 718,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l x z.\n      apply strong_T with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z Hz YZ.\n      apply S_star with y; assumption.\n      apply inv_wf; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_update with x; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l; destruct l; simpl; intros x z Hz Z.\n      apply R_trans with x; assumption.\n      apply R_trans with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z Hz Z.\n      apply S_star with z; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l x z Hz Hxy Hyz; destruct Hxy; simpl; intros z Hz.\n      apply inv_E; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply open_te with y; assumption.\n      apply weak_valid_rel_l with y; assumption.\n      apply weak_valid_rel_l with x; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z.\n      apply strong_parallel with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_tarski_s with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros x y l x z.\n      apply weak_lt_wf; assumption.\n    Qed."
                ]
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  simple induction xs; simpl in |- *.  intros.  elim H; intros.  elim H; intros.\n  split.  assumption.  intros.  elim H; intros.  elim H0; intros.  elim H2; intros.\n  split.  assumption.  intros.  elim H2; intros.  elim H3; intros.  elim H5; intros.  elim H6; intros.\n  split.  assumption.  intros.  elim H6; intros.  elim H6; intros.  elim H6; intros.\n  split.  assumption.  intros.  elim H6; intros.  elim H7; intros.  elim H7; intros.\n  split.  assumption.  intros.  elim H7; intros.  elim H7; intros.\n  split.  assumption.  intros.  elim H7; intros.  elim H7; intros.  elim H8; intros.\n  split.  assumption.  intros.  elim H7; intros.  elim H8; intros.  elim H9; intros.\n  split.  assumption.  intros.  elim H9; intros.  elim H9Qed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f.  apply H.  simpl.  intros.  rewrite H.  elim H.  intros.  elim H.  intros.  elim H0.  intros.  elim H1.  intros.  elim H2.  intros.\n  split.  assumption.  split.  assumption.  intros.  simpl in |- *.  split.  assumption.  split.  assumption.  assumption.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros.  unfold re_in, re_in.  simpl.  elim (sumbool_of_bool (f a))).  intro y.  rewrite y in H.\n  discriminate H.  intro H.  rewrite H0.  reflexivity.  intro H0.  rewrite H0.  reflexivity.  intro H0.\n  rewrite H0.  reflexivity.  intro H0.  rewrite H0.  reflexivity.  intro H0.\n  rewrite H0.  reflexivity.  intro H0.  rewrite H0.  reflexivity.  intro H0.  rewrite H0.  reflexivity.  intro H0.  rewrite H0.  reflexivity.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  simple induction xs; simpl in |- *; auto with arith. \nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f b xs.\n  induction xs as [| a xs]; simpl; intros; auto.\n  rewrite H.\n  rewrite H0.\n  reflexivity.\n  intros.\n  destruct (f a) as [[a0 b0] | ] eqn:Heq; auto.\n  apply H.\n  apply H.\n  assumption.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros.\n  apply (map_NoDup f).\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f.\n  induction xs as [ | a xs]; simpl; intros; trivial.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H0.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion H.\n  inversion HQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f b xs.\n  rewrite <- map_app.\n  rewrite map_app.\n  rewrite <- map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply mapQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f.\n  induction xs as [| a xs]; intros.\n    apply False_ind; apply H; assumption.\n  apply False_ind; apply H; assumption.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  intros A B f a b.  elim b; simpl.  intros; discriminate. \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 214,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f; elim l1; simpl in |- *; auto.\nintros a l1 l2 H' H'0; elim H'0; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f; elim l1; simpl in |- *; auto.\nintros a l1 l2 H'0; elim H'0;\n [ intros H'1; clear H'0 ]; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros a0 l1 l2 H'0; elim H'0;\n [ intros H'1; clear H'0 ]; auto.\nexists a0; split; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l1 l1 H'0; rewrite H'0; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l; rewrite <- H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' l; rewrite H' l; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H'; elim H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H'; elim H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' l; rewrite H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 414,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; rewrite H'0; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros; apply map_in; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros; elim H; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'0;\n [ intros H'0; clear H'0 | intros H'0; clear H'0 ]; \n auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros; apply (map_app l l); auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros; elim H; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H' H'0; elim H'0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 524,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros; apply in_rev; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H' H'0; elim H'0; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H' H'0; elim H'0; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H' H'0; elim H'0; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'0; simpl in |- *; auto.\nintros a0 l0 H' H'0; elim H'0; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 163,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition zeroP : Term -> Prop.\nDefinition Prop := (A * mon n)%type.\n\nLemma oneP : Equality.axiom zeroP.\nProof.\n  constructor; [ apply zero_ext | apply zero_ext ].\n  constructor; [ apply zero_ext | apply zero_ext ].\n  constructor; [ apply zero_ext | apply zero_ext ]; constructor; auto.\n  constructor; [ apply zero_ext | apply zero_ext ]; constructor; auto.\nDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinition Term (e : Term) :=\n  forall x : Term, e x -> x = 0.\n\nDefinitionDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\n(* The following notation *)\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\nDefinition Term := (A * mon n)%type.\n\n(* The following notations are defined *)\nNotation \"A * B\" := (prod A B) : type_scope.\n\n(* Note that \"A * B\" is an explicit structure of B. *)\nNotation \"A * B\" := (prod A B) : type_scope.\n\n(* Note that \"A * B\" is an explicit structure on B. *)\nNotation \"A * B\" := (prod A B) :Defined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition unit : Set := (A * mon n)%type.\n\nDefinition const (A : Set) := (A * mon n)%type.\n\nDefinition const (A : Set) := A * const A.\n\nDefinition const_map (A B : Set) : A -> B := fun _ => const A.\n\nDefinition const_map (A B : Set) : B -> B := fun _ => const A.\n\nDefinition const_map (A B : Set) : B -> B := fun _ => const A.\n\nNotation \"a - b\" := (const a b) (at level 70) : ring_scope.\n\nDefinition const_map (A B : Set) : B -> B := fun _ => const A.\n\nNotation \"a - b\" := (const a b) (at level 70) : ring_scope.\n\nDefinition const_map (A B : Set) : A -> B := fun _ => const A.\n\nNotation \"a - b\" := (const a b) (at level 70) : ring_scope.\n\nDefinition const_map (A B C : Set) : A -> B := fun _ =>Defined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition I (n : I) := n * { n : I & (n + 1) * (n + 1) * (n + 1))%type.\n\nInductive I (n : I) : Type :=\n  E0 : I n -> I n -> I n -> I n -> I n -> I n -> I n.\n\nDefinition I (n : I) : I n -> I n -> I n :=\n  forall n : I, (n * n)%type -> I n -> I n.\n\nDefinition I (n : I) : I n -> I n -> I n.\nintros I n.\napply (I n); [ | apply I_0 | apply I_0].\nDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition I (e : Term) :=\n  let: Term t := e in True.\nDefinition I (e : Term) :=\n  let: Term t := e in True.\n\nDefinition I (e : Term) :=\n  let: Term t := e in True.\nDefinition I (e : Term) :=\n  let: Term t := e in True.\n\nDefinition I (e : Term) :=\n  let: Term t := e in True.\nDefinition I (e : Term) :=\n  let: Term t := e in True.\nDefinition I (e : Term) :=\n  let: Term t := e in True.\n\nDefinition I (e : Term) :=\n  let: Term t := e in True.\n\nDefinition I (e : Term) :=\n  let: Term t := e in True.\n\nLemma I_refl : I e.\nProof.\n  unfold I.\n  rewrite (op_id e); auto.\nDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition sum : law -> Type :=\n  fun x y => op (op x y) (op y x).\n\nDefinition sum : law -> law -> Type :=\n  fun x y => op (op x y) (op y x).\n\nDefinition sum : law -> law -> Type :=\n  fun x y => op (op x y) (op y x).\n\nStructure law : Type := Pack {sort; _ : class_of sort}.\nLocal Coercion sort : type >-> Sortclass.\nDefinition class := let: Pack _ c as cT' := cT return class_of cT' in c.\nDefinition clone c of phant_id class c := @Pack T c.\nLet xT := let: Pack T _ := cT in T.\nNotation xclass := (class : class_of xT).\n\nDefinition pack b0 (m0 : mixin_of (ring_sort m0)) :=\n  fun (m0 : mixin_of (ring_sort m0)) (m1 : mixin_of (ring_sort m0)) =>\n  fun m & phant_id m0 m => Pack (@Class T b m0 m) T.\n\nDefinition eqType := ltac:(EqualityPack cT (classDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nDefinition I (x : Prop) : Prop := x.\n\nLemma I_refl I I (x : I) : I x.\nProof.\nFail case: x.\nAbort.\n\nDefinition I (x : I) : Prop := x.\n\nLemma I_refl I I I I (x : I) : I x.\nProof.\nby case: x.\nDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition L := (A * mon n)%type.\nDefinition L := (A * mon n)%type.\n\nDefinition L : Prop := (A * mon n)%type.\nDefinition L : Prop := (A * mon n)%type.\n\nDefinition L (A : Type) : Prop := (A * mon n)%type.\n\nDefinition L (A : Type) : Type := (A * mon n)%type.\n\nRecord box (A : Type) : Type := mk box {\n  inv1 : A -> A;\n  inv2 : A -> A -> A;\n  inv3 : A -> A -> A;\n  inv3 : A -> A -> A -> A;\n  inv4 : A -> A -> A -> A;\n  inv5 : A -> A -> A -> A -> A;\n  inv5 : A -> A -> A;\n  inv5 : A -> A -> A -> A -> A;\n  inv5 : A -> A -> A -> A -> A;\n  inv5 : A -> A -> A -> A;\n  inv5 : A -> A -> A;\n  inv5 : A -> A -> A -> A -> A;\n  inv5 : A -> ADefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition is_true (P : Prop) : Prop :=\n  forall x, P x -> P x.\n\nSection Term.\n\nVariable P : Prop.\n\nDefinition is_true (P : Prop) : Prop :=\n  forall x, P x -> P x.\n\nDefinition is_true (P : Prop) : Prop :=\n  forall x, P x.\n\nDefinition is_true (P : Prop) : Prop :=\n  forall x, P x -> P x.\n\nDefinition is_true (P : Prop) : Prop :=\n  forall x, P x -> P x.\n\nLemma is_true_is_true : is_true false false false.\nProof.\n  unfold is_true, is_true, is_true, is_true, is_true, is_true, is_true, is_true; simpl; intros; contradiction.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 197,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (op (op a) (op a)).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'0; exact (op (op a) (op a)).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'0; exact (op a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'0; exact (R a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'0; exact (op a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqel a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (op a A H').\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'0; exact ( eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; elim H'.\nintros a H'1; elim H'1; intros H'2 H'3; try exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (opitititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititititDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 259,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; auto with algebra.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; intros a b H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H'; case H';Qed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; auto with algebra.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; auto with algebra.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; intros; red in |- *; intros H'; case H'.\nred in |- *; intros H' H'0; try exact ( eqA a' a).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; auto with algebra.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; intros; red in |- *; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; auto with algebra.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; intros H'; case H'.\nintros a a' H'0; case H'0; intros H'2; case H'3; intros H'4; case H'5;\n intros H'5; case H'5; intros H'6 H'7; case H'6; intros H'7; clear H'6 H'7;\n intros H'6; case H'6; intros H'7 H'8; clear H'6 H'7;\n intros H'8; case H'7; intros H'8; clear H'6 H'7; clear H'7 H'8;\n intros H'8; case H'8; intros H'8; clear H'7; intros H'8; clear H'8;\n intros H'8; case H'10; intros H'10; clear H'8; intros H'9; elim H'10; intros H'11;\n clear H'10; intros H'10; elim H'10; intros H'11; clear H'10;\n intros H'11; elim H'10; intros H'10; clear H'10; introsQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; intros H'; case H'.\nintros a a' H'0; case H'2; intros H'3 H'4; try exact (op a' a' a' H'4).\nexact (op a' a' a' a' H'5).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 293,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; intros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y z H'; case H'; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y z; try assumption.\napply Trans with (monoid_unit R); auto with algebra.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y z H'; case H'; intros H'2 H'3; try exact H'3; clear H'2.\nred in |- *; intros H' H'3; try exact H'3; clear H'3.\nred in |- *; intros H' H'0; try exact H'0; clear H'0.\nred in |- *; intros H'0; try exact H'0; clear H'0.\nred in |- *; intros H' H'0; try exact H'0; clear H'0.\nred in |- *; intros H'0; try exact H'0; clear H'0.\nred in |- *; intros H' H'0; try exact H'0; clear H'0.\nred in |- *; intros H'0; try exact H'0; clear H'0.\nred in |- *; intros H' H'0; try exact H'0; clear H'0.\nred in |- *; intros H' H'0; try exact H'0; clear H'0.\nred in |- *; intros H' H'0; try exact H'0; clear H'Qed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y z; elim x; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 350,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; elim z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; elim x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; elim x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *; intros x y z; case x; case y; simpl in |- *; intuition.\napply (Eq_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'0).\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; intuition.\napply (H' x y z); auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; intuition.\napply (Eq_sym _ _ _ _ _ _ _ _ _ _ _ _ _ _ H' H'); auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 435,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition T2M : Term -> mon n.\nintros x y z; case x; case y; case z; simpl in |- *; auto.\nintros z z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z' H'0; case z; simpl in |- *; auto.\nintros z' z'Defined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros x y z H'0; case H'0; intros H'1 H'2; case H'3; intros H'3 H'4; clear H'0.\nexists (plus_n_O n); split; auto.\napply sum_comm; auto.\napply sum_comm; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros x y z; case z; simpl in |- *; auto.\nintros x y z; case z; simpl in |- *; auto.\nintros x' y' z' z' H' H'0; rewrite H'0; auto.\nintros x' y' z' H'0; rewrite H'0; auto.\nintros x' y' z' H'0; rewrite H'0; auto.\nintros x' y' z' H'0; rewrite H'0; auto.\nintros x' y' z' H'0; rewrite H'0; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'; intros; auto.\napply (H' (op:=op) (op:=op) (op:=op) (op:=op) (op:=op) (op:=op)).\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.\nred in |- *; intros; apply H'.Defined.",
                    "Definition T2M : Term -> mon n.\nintros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Map (Ap:=fun c => c)).\nred in |- *.\nintros x y z; case y; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply (Build_Map (A:=A) (B:=fun x : A => x) (a:=a) (b:=b)).\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nintros a b H'0; case H'1; auto.\nintros a' b' H'1; case H'2; auto.\nintros H'2 H'3; case H'3; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros x y z; case x; case y; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'; auto.\nintros a a' H'0; case H'0; auto.\nintros H'1; case H'1; auto.\nintros H'2; case H'2; auto.\nintros H'3; case H'3; auto.\nintros H'3; case H'3; auto.\nintros H'4; case H'4; auto.\nintros H'5; case H'4; auto.\nintros H'5; case H'5; auto.\nintros H'6 H'7; case H'8; auto.\nintros H'7; case H'8; auto.\nintros H'9; case H'10; auto.\nintros H'10; case H'10; auto.\nintros H'10; case H'10; auto.\nintros H'10; case H'10; auto.\nintros H'10; case H'11; auto.\nintros H'10; case H'10; auto.\nintros H'10; case H'10; auto.\nintros H'11; case H'10; auto.\nintros H'12; caseDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 522,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y z; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intros x y H'; case H'; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y z; elim x; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; intros a b H; case (rel_dec a b); case (rel_dec a b);\n intros H1 H2; try (rewrite H1 in H2; discriminate);\n intros H1 H2; try discriminate H1;\n try discriminate H1;\n try discriminate H2;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H2;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n try discriminate H1;\n tryQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y z; elim y; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros a b c H'; case H'; auto.\nintros a b H'0; case H'0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 543,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case a; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *;Qed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *.\nauto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 564,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 601,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; apply (rel_of_equivalence a b H'); auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\n  intros a b H'; elim H'; intros H'0; elim H'0; intros H'1 H'2; elim H'2; intros H'3 H'4; clear H'0 H'0.\n  setoid_rewrite H'0; auto.\n  setoid_rewrite H'0; auto.\n  setoid_rewrite H'1; auto.\n  setoid_rewrite H'2; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; case H'; intros H'0; try exact H'0; auto.\napply H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; rewrite H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 618,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintros; case x; simpl in |- *; auto.\nintrosQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "****)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *.\nintros b H' H'0; elim H'0; intros H'1 H'2; clear H'0.\nelim H'0; intros H'3 H'4; clear H'0.\nelim (cmp_dec b3 b); introseqAZ; auto.\nleft; red in |- *; intros H'0 H'1; elim H'3; intros H'4 H'5; clear H'3.\nelim (cmp_dec b3 b); intros cmpZ; auto.\nright; red in |- *; intros H' H'4; elim H'4; intros H'6 H'7; clear H'4.\nelim (cmp_dec b6 b3); intros cmpZ; auto.\nleft; red in |- *; intros H' H'5; elim H'5; intros H'6 H'7; clear H'4.\nelim (cmp_dec b7 b8); intros cmpZ; auto.\nright; red in |- *; intros H' H'5; elim H'5; intros H'6 H'7; clear H'4.Qed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case b; simpl in |- *.\nintros b c2 b3 c4.\ncase (Rle_dec b3 b3); intros RleZ2; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0.\ncase (eqmon_dec n c3); intros RleZ2; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H'0.\ncase (leCorrect_dec n c3); intros RleZ2; auto.\nleft; red in |- *; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'0.\ncase (leCorrect_dec n c3); intros RleZ2; auto.\nright; red in |- *; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'0.\ncase (le_or_lt n c3); intros RleZ2; auto.\nright; red in |- *; intros H'0Qed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'.\ncase H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros; left; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; left; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; left; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; left; red in |- *; intros; discriminate.\nintros; right; red in |-Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b2 c3; case b; simpl in |- *.\nintros b3 c4; case b4; simpl in |- *.\nintros b4 c5; case b4; simpl in |- *.\nintros b4 c5; case b4; simpl in |- *.\nintros b5 b6 c7; case b8; simpl in |- *.\nintros b8 c8; case b9; simpl in |- *.\nintros b8 c9; simpl in |- *.\nintros b8 c9; simpl in |- *.\nintros b9; case b10; simpl in |- *.\nintros b9; simpl in |- *.\nintros b9; case b10; simpl in |- *.\nintros b9; simpl in |- *.\nintros b9; case b9; simpl in |- *.\nintros b9; simpl in |- *.\nintros b11 b12; simpl in |- *.\nintros b12; simpl in |- *.\nintros b11 b12; case b12; simpl in |- *.\nintros b12; simpl in |- *.\nintros b12; simpl in |- *.\nintros b12; case b12; simpl in |- *.Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros b2 c3; case c3; simpl in |- *; auto.\nintros b3 c4; case c4; simpl in |- *; auto.\nintros b4 c5; case c4; simpl in |- *; auto.\nintros b5 c6 c6; case c6; simpl in |- *; auto.\nintros b6 c6; case c6; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c9; simpl in |- *; auto.\nintros b7 c8; case c8; simpl in |- *; auto.\nintros b7 c8; case c9; simpl in |- *; auto.\nintrosQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros b H'; case b; simpl in |- *; auto.\nintros b2 c3 c4.\ncase (eq_dec b3 b3); intros eqAZ2; auto.\nright; red in |- *; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'1; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H'0; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros b1 b2 c3.\ncase (eqre_dec x a); intros eqAZ; auto.\nleft; red in |- *; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'1.\nintros b1 b2 c3.\ncase (eqre_dec x a); intros diff_x_b2 b2.\nleft; red in |- *; intros H'0 H'1; elim H'1; intros H'3 H'4; clear H'1.\nexists x; exists y1; split; auto.\napply (Eq_eq (op_inv_op_inv_op_inv_op a b c2)).\nred in |- *; intros H'0 H'1; elim H'1; intros H'3 H'4; clear H'1.\nexists x; exists y1; split; auto.\napply (Eq_eq (op_inv_op_inv_inv_op a b c2)).\nred in |- *; intros H'0 H'1; elim H'1; introsQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros b2 c3.\ncase (cmp_dec b3 b4); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0 H'1.\napply (cmp_eq_dec a0 b1); auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0 H'1.\napply (cmp_eq_dec a0 b2); auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0 H'1.\napply (cmp_eq_dec a0 b2); auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0 H'1.\napply (cmp_eq_dec a0 b2); auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0 H'1.\napply (cmp_eq_dec b3 b3Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros b2 c3.\ncase (eq_dec a a0); intros eqAZ; auto.\ncase (eqad_dec a b2); intros eqAZ; auto.\nleft; red in |- *; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'1; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'1; auto.\nright; red in |- *; intros H'0 H'1; elim H'1; intros H'1 H'2; clear H'1; auto.\nright; red in |- *; intros H'0 H'1; elim H'1; intros H'1 H'2; clear H'1; auto.\nright; red in |- *; intros H'0 H'1; elim H'1; intros H'1 H'2; clear H'1; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros b2 c3.\ncase (eq_dec b3 b3); intros diffZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0 H'1.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H'0 H'2.\nexists x; split; auto.\napply (eqit_dec x); auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0 H'2.\nexists x; split; auto.\napply (eqit_dec x); auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0 H'1.\nright; red in |- *; intros H'Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b2 c3.\ncase (eqDec_dec x a); intros eqAZ1; auto.\nleft; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'0 H'2; clear H'0; auto.\nleft; red in |- *; intros H'0 H'0; elim H'0; intros H'1 H'2; clear H'0; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0; auto.\nright; red in |- *; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0; auto.\nleft; red in |- *; intros H'0 H'1; elim H'Qed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; discriminate.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *; auto.\nintros; red in |- *; intros; case x; simpl in |- *; auto.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *.\nintros; red in |- *; intros; case x; simpl in |- *.\nintros; red in |- *.\nintros; red in |- *.\nintros; red in |- *; intros; caseQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 740,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; apply (eqTerm_cons _ _ _ _ _ H'); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H' H'0; apply H'.\napply (eqer_elim _ _ H' H'0).\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H' H'0; rewrite H'; auto.\napply (eqA_trans _ _ _ _ _ H' H'1).\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H' H'0; rewrite H'0; auto.\napply eqAcc_inverse_image with (a := b); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H' H'0; rewrite H'0.\napply eqA_comp_Transitive with a b; auto.\napply comp_rel_inverse_l with b; auto.\napply comp_rel_inverse_r with b; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case (eqreal_dec a b); auto.\nintros b H'0; case (eqreal_dec a b); intros eqAZ1; auto.\nleft; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0; auto.\nleft; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'0; auto.\nrightQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H' H'0; rewrite H'0.\napply eqA_comp_Transitive with a; auto.\napply eqA_comp_Transitive with a; auto.\napply eqA_comp_Transitive with b; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a' b' b' H'0; red in |- *; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H'0 H'0; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'.\napply eqA_dec; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; rewrite H'0; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H'.\ncase b; simpl in |- *; auto.\nintros b H'; apply (eqA_trans _ _ _ _ _ _ _ H' H').\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 757,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition plusTerm : Term -> Term -> Term.\nintros.\napply (Build_term (BC:=op) (BC:=op) (BC:=op) (BC:=op) (BC:=op) (BC:=op)).\nred in |- *.\nintros a b c H'; red in |- *.\nintros H'0.\napply (Build_Map (A:=A) (B:=B) (B:=B) (C:=B) (C:=B) (C:=B) (C:=B));\n simpl in |- *.\nred in |- *; intros H'1; elim H'1; intros H'2 H'3; clear H'1; auto.\nintros H'0.\napply (Build_Map (A:=A) (B:=A) (B:=A) (B:=B) (C:=B) (C:=B) (C:=B) (C:=A) (C:=B) (D:=B) (C:=A) (D:=A) (C:=A) (C:=A) (D:=A) (C:=A) (C:=A) (D:=A) (D:=A) (D:=A) (D:=A) (DDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H' H'0; red in |- *; intros.\napply H'.\napply (Prod_assoc a b c H'0); red in |- *; intros.\napply H'.\napply (Prod_assoc a b c H'); red in |- *; intros.\napply H'; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H' H'0; red in |- *; intros a b H' H'1; case a; case b; simpl in |- *;\n intros a b H'1 H'2; try rewrite H'1; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2; try rewrite H'2;\n try rewrite H'2; try rewrite H'2; try rewrite H'2Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H'; try assumption.\napply (Build_Map (Ap:=fun x => x:A) (y:A) => x:A).\nred in |- *; simpl in |- *.\nintros x y z H'; try assumption.\napply (Build_Map (Ap:=fun x => x:A) (y:A) => x:A).\nred in |- *; simpl in |- *.\nintros x y z H'; try assumption.\napply (Build_Map (Ap:=fun x => y:A) (y:A) => y:A).\nred in |- *; simpl in |- *.\nintros x y z H'; try assumption.\napply (Build_Map (Ap:=fun x:A => x:A) (y:A) => y:A).\nred in |- *; simpl in |- *.\nintros x y z H'; try assumption.\napply (Build_Map (Ap:=fun x => x:A) (y:=A) (z:=A)); auto with *.\nred in |- *; simpl in |- *.\nintros x y z H'; try assumption.\napply\n (Build_Map (Ap:=fun x => x:A)Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\napply Build_Setoid.\nred in |- *; intros; split; intros.\napply Trans with (oneG a); auto.\napply Trans with (oneG a); auto.\napply Trans with (oneG a); auto.\napply Trans with (oneG a); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros; red in |- *; intros; red in H'.\nelim (H (op:=op)).\nintros x y H'0; elim H'0; clear H'0; intros H'1; clear H'0; auto.\nintros; red in H'; elim H'; intros H'0 H'1; clear H'0; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros; apply (Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x : BC => Build_Map (Ap:=fun x :Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros.\napply (Build_Map (Ap:=fun a b => a = b)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun a b => a = b)).\nred in |- *; intros; discriminate.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H' H'0; red in |- *; intros H'1; case H'; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros; red in |- *; intros; apply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred in |- *; intros.\napply (Build_term (I:=I)).\nred inDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros; unfold oppgeneral in |- *; intros; apply (op_inv_l (a := b)); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; intros b3 c4;\n exact (plusA b3 b4).\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'; red in |- *.\napply (op_inv_l (op_inv_l a b) (op_inv_l a b) (op_inv_l a b H')).\napply (op_inv_l (op_inv_l a b) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) (op_inv_r b a) (op_inv_l b a) H').\napply (op_inv_l (op_inv_l a b) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) (op_inv_l b a) H').\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'; red in |- *; intros H'0; elim H'; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *.\nintros b H'; apply H'.\napply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_r b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_r b c3); auto.\nintros b H'; apply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply H'.\napply (Lt_inv_mult_l b c3); auto.\nintros b H'; apply (Lt_inv_multQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'0; red in |- *; intros H'1; elim H'0; clear H'0; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_Inverse with (a := b); auto.\napply eqlaw_comp_carrierl with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_carrierr with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_commutative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_associative with (a := b); auto.\napply eqlaw_comp_Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1; elim H'0;\n [ intros x y z; case z; intros z0 z1; case z2; intros z1 z2;\n apply (addA b2 b3, z3); auto\n | intros x y z z; case z1; intros z1 z2; case z2; intros z2 z3;\n apply (compA b2 b3, z3); auto\n | intros y z z; case z2; intros z3 z4; case z4; intros z4 z5;\n apply (compA b2 b3, z4); auto\n | intros z z0 z; case z4; intros z5 z6 z7; case z8; intros z10 z11 z12;\n apply (compA b2 b3, z5); auto\n | intros z z0 z; case z4; intros z5 z6 z7; case z8; intros z10 z11 z12;\n apply (compA b2 b3, z4); auto\n | intros z z0 z; case z8; intros z8 z9Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; simpl in |- *.\nintros a b H' H'0; red in |- *; intros H'1; elim H'0; intros H'2 H'3; clear H'0;\n clear a b H'0; try assumption.\napply (cmpR_trans _ _ _ _ _ H' H'0); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; red in |- *; intros H'0.\napply (eq_trans _ _ _ _ H' H'); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; red in |- *; intros H'0.\napply H'; auto.\napply (eqA_trans _ _ _ _ _ _ H'0 H1).\napply (eqA_trans _ _ _ _ H'0 H1).\napply (eqA_trans _ _ _ _ H' H1).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'0.\napply H'0; auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; case (eq_A a1 a2); intros a1 a2 a3;\n try discriminate H1; try discriminate H2; try discriminate H2; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3;\n try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3; try discriminate H3Qed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; red in |- *; intros H'1.\napply (eqA_trans _ _ _ _ _ _ H' H'); auto.\napply (eqA_trans _ _ _ _ H' H'); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ H2); auto.\napply (eqA_trans _ _ _ _ _ H2); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; red in |- *; intros H'1; elim H'; intros H'1 H'2; clear H'.\napply (eqA_trans _ _ _ _ _ H' H'2).\napply (eqA_trans _ _ _ _ _ H' H'3).\napply (eqA_trans _ _ _ _ H' H'3).\napply (eqA_trans _ _ _ _ H' H'4).\napply (eqA_trans _ _ _ H' H'3).\napply (eqA_trans _ _ _ H' H'4).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; red in |- *; intros H'0; elim H'; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ H'0); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b H'; red in |- *; intros H'0; elim H'0;\n try (intros; discriminate).\napply (eqA_trans _ _ _ _ _ H' H1).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ H2); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply (eqA_trans _ _ _ _ _ H' H'); auto.\napply (eqA_trans _ _ _ _ H' H'); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ H3); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ H2); auto.\napply (cmp_trans _ _ _ _ _ _ _ H2); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ H1); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'0.\napply H'.\napply (eqA_trans _ _ _ _ _ _ _ _ H'0).\napply (eqA_trans _ _ _ _ _ H'0).\napply (eqA_trans _ _ _ _ H'0).\napply (eqA_trans _ _ _ _ _ H'0).\napply (eqA_trans _ _ _ _ H'1).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H; elim H; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ H2).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'0.\napply (eqA_trans _ _ _ _ _ _ H'0); auto.\napply (eqA_trans _ _ _ _ H'0); auto.\napply (eqA_trans _ _ _ H'0); auto.\napply (eqA_trans _ _ _ H'0); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H H0; red in |- *; intros H1 H2.\napply (eqA_trans _ _ _ _ _ _ H3 H4); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1; elim H'1; intros H'2 H'3; clear H'1 H'2.\nelim (H' a); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply (eqA_trans _ _ _ _ _ _ H' H').\napply (eqA_trans _ _ _ _ H' H').\napply (eqA_trans _ _ _ _ H' H').\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2 H3; split; auto.\napply (cmp_trans _ _ _ _ _ _ _ _ _ H3); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ H2); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ H2 H3).\napply (eqA_trans _ _ _ _ H3 H4).\napply (eqA_trans _ _ _ H3 H4).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2 H3; split; auto.\napply (eqA_trans _ _ _ _ _ _ H3 H4); auto.\napply (eqA_trans _ _ _ _ _ H3 H4); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case b; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (Eq_trans _ _ _ _ _ _ _ _ H2); auto.\napply (Eq_trans _ _ _ _ _ _ _ H1); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_eq _ _ _ _ _ _ _ _ _ _ H1).\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_eq _ _ _ _ _ _ _ H1).\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_eq _ _ _ _ _ H1).\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_eq _ _ _ _ _ H1).\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_eq _ _ _ _ H1).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ H2); auto.\napply (eqA_trans _ _ _ _ _ _ _ H2); auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2 H3; split; auto.\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ H3 H4).\napply (cmp_trans _ _ _ _ _ _ _ H3 H4).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_inv a1 b1 c2); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 737,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros y H' H'0; elim H'0; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; red in |- *; intros H'1; elim H'; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros; rewrite H; auto.\nintros; rewrite H; auto.\nintros; rewrite H; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros x1 y1 z1 z2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ H1); auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros y H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case y; simpl in |- *; auto.\nintros; case z; simpl in |- *; auto.\nintros; case z; simpl in |- *; auto.\nintros; case z; simpl in |- *; auto.\nintros; case z; simpl in |- *; auto.\nintros; case z; simpl in |- *; auto.\nintros; case z; simpl in |- *; autoQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (cmp_trans _ _ _ _ _ _ _ _ H1).\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; red in |- *; intros H'1.\napply (eq_trans _ _ _ _ _ H'1).\napply (eq_trans _ _ _ _ H'1).\napply (eq_trans _ _ _ _ H'2).\napply (eq_trans _ _ _ H'2).\napply (eq_trans _ _ _ H'1).\napply (eq_trans _ _ _ H'2).\napply (eq_trans _ _ H'2).\napply (eq_trans _ _ _ H'3).\napply (eq_trans _ _ H'2).\napply (eq_trans _ _ _ H'3).\napply (eq_trans _ _ _ H'3).\napply (eq_trans _ _ H'3).\napply (eq_trans _ _ H'4).\napply (eq_trans _ _ _ H'4).\napply (eq_trans _ _ H'4).\napply (eq_trans _ _ H'4).\napply (eq_trans _ _ H'4).\napply (eq_trans _ _ H'4).\napply (eq_trans _ _ H'4Qed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; elim H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; elim H; auto.\nintros a1 m2 H1; elim H1; auto.\nintros a2 m1 a2 m2 H1; elim H1; auto.\nintros a1 m2 H1; elim H1; auto.\nintros a2 m3 H1; elim H1; auto.\nintros a3 m3 H1; elim H1; auto.\nintros a3 m4 H1; elim H1; auto.\nintros a4 m5 H1; elim H1; auto.\nintros a5 m5 H1; elim H1; auto.\nintros a5 H1; elim H1; auto.\nintros a5 H1; elim H1; auto.\nintros a5 H2; elim H1; auto.\nintros a5 H2; elim H2; auto.\nintros a5 H2; elim H2; auto.\nintros a5 H2; elim H2; auto.\nintros a5 H2; elim H2; auto.\nintros a5 H2; elim H2; auto.\nintros a5 H2; elim H2; auto.\nintrosQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; elim H; auto.\nintros x y H1; elim H1; elim H2; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1 m2; elim H; auto.\nintros m1Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; red in |- *; intros H1 H2; elim H1; clear H1; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m3; case m3; simpl in |- *; auto.\nintros m1 m2 m3 H1 H2 H3; split; auto.\napply (cmp_trans _ _ _ _ H3 H4).\napply (cmp_trans _ _ _ _ H3 H4).\napply (cmp_trans _ _ _ H3 H4).\napply (cmp_trans _ _ _ H3 H4).\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m2; case m3; case m3; auto.\nintros m1 m2; case m3; case m4; case m4; auto.\nintros m1 m2; case m3; case m4; case m4; auto.\nintros m3 m4; case m4; case m4; case m4; auto.\nintros m1 m3; case m4; case m4; case m4; auto.\nintros m1 m3; case m4; case m4; auto.\nintros m1 m2; case m4; case m4; auto.\nintros m1 m2; case m3; case m4; auto.\nintros m1 m2; case m4; case m4; auto.\nintros m1 m2; case m4; case m4; auto.\nintros m1 m2; case m4; case m4; auto.\nintros m1 m3; case m4; case m4; auto.\nintros m1 m2; case m4; case m4; auto.\nintros m1 m3;Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; elim m1; elim m2; elim m2; elim m3; elim m3; elim m3; auto.\nintros a1 m2 m3 H1 H2 H3; elim H3; elim H3; elim H3; elim H3; intros H1 H2 H3;\n elim H3; intros H3 H4; elim H4; intros H5 H6; clear H5 H6.\napply (cmp_eq_trans _ _ _ _ _ H3 H4 H1 H2 H4).\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; elim H; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 mQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; elim H; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; elim H; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2 H3; elim H3; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros m1 m2 H1 H2; elim H2; auto.\nintros mQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; case H; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros m1 m2 H1; elim H1; auto.\nintros mQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case m1; case m2; simpl in |- *; auto.\nintros a1 m2 m3 H1 H2; case (op_eq_dec m1 m2); intros H3 H4;\n case (op_eq_dec m1 m2); intros H4;\n case (op_eq_dec m1 m2); intros H5 H6;\n case (op_eq_dec m1 m3); intros H6 H7;\n case (op_eq_dec m1 m3); intros H6 H7;\n case (op_eq_dec m1 m3); intros H7 H8;\n case (op_eq_dec m1 m2); intros H8 H9;\n case (op_eq_dec m1 m3); intros H8 H9;\n case (op_eq_dec m1 m3); intros H8 H9;\n case (op_eq_dec m1 m3); intros H9 H9;\n case (op_eq_dec m1 m3); intros H9 H9;\n case (op_eq_dec m1 m3);Qed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; red in |- *; intros H; case H; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0; elim H0; auto.\nintros H0;Qed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2 H3 H4; split; auto.\napply (cmp_trans _ _ _ _ H2).\napply (cmp_trans _ _ _ _ H3).\napply (cmp_trans _ _ _ _ H3).\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; red in |- *; intros H1 H2; elim H1;\n (clear H1 H2); clear H1 H2.\nintros m1 m2 H1 H2; red in |- *; intros H1 H2.\napply (H0 m1 m2); auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m3; simpl in |- *; auto.\nintros m1 m2; case m3; simpl in |- *; auto.\nintros m1 m2; case m3; case m4; simpl in |- *; auto.\nintros m1 m2; case m3; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m3; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2; case m4; simpl in |- *; auto.\nintros m1 m2Qed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m3; simpl in |- *; auto.\nintros m3 m4; case m4; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintros m4 H; case m4; simpl in |- *; auto.\nintrosQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; red in |- *; intros H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; simpl in |- *; auto.\nintros m1 m2 H1 H2; split; auto.\napply (Eq_trans _ _ _ _ _ _ _ _ H1).\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2 H; red in |- *; intros H H0; elim H0; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; auto.\nintros H1 H2; elim H2; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "P b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 714,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a; case a0; simpl in |- *; auto.\nintros a1 A2 H1; elim H1; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; case a1; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (Prod_assoc A1 A2); auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a0; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a0; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a0; case b; simpl in |- *; auto.\nintros a1 a2 A2 H1 H2; split; auto.\napply (eq_trans _ _ _ _ _ _ _ _ _ H2).\napply (eq_trans _ _ _ _ _ H3).\napply (eq_trans _ _ _ _ _ H3).\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; elim A1; auto.\napply (equiv_trans _ _ _ _ _ _ _ A1); auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; elim a; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; case a0; simpl in |- *; auto.\nintros a1 A2 H1; elim H1; auto.\nintros a1 A2 H1; elim H1; auto.\nintros a2 A3 H2; elim H2; auto.\nintros a3 A3 H2; elim H2; auto.\nintros a4 A5 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a6 A7 H2; elim H2; auto.\nintros a6 A7 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elim H2; auto.\nintros a5 A6 H2; elimQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a0; case a1; case b0; simpl in |- *; auto.\nintros a1 a2 A2 H1 H2; split; auto.\napply (Prod_assoc (plusTerm A1 a2) (plusTerm A1 (plusTerm A1 (plusTerm A1 a1) a2)));\n auto.\napply (Prod_assoc (plus Term A1 a2) (plus Term A1 (plusTerm A1 (plus Term A1 a1) a2)));\n auto.\napply (Prod_assoc (plus Term A1 (plus Term A1 (plus Term A1 (plus Term A1 a1) a2)));\n auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a0; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ", c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 718,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; elim H; clear H; auto.\nintros a0 b c0 H1 H2; elim H2; clear H2; intros H3 H4; elim H4; clear H4;\n intros H5 H6.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nrewrite <- H3; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; elim H; elim H0; elim H1; elim H2; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; elim H; auto.\napply (Eq_trans _ _ _ _ _ _ _ H H0).\napply starA_trans with (a := numTerm a0) (c := numAcc a0 b) (c := numAcc a0 c) (c := numAcc a0 c) (c := numAcc a0 c) (c := numAcc a0 c) (c := numAcc a0 c) (r := numAcc a0 c) (r := numAcc a0 c) (r := r);\n auto.\napply lt_wf_ind_r; auto.\napply lt_wf_ind_r; auto.\napply gt_wf_ind_r; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; elim H; elim H; elim H; elim H;\n clear H H0 H1; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2; clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; elim a; elim b; simpl in |- *; auto.\nintros a0 b c0 d0 H H0; elim H0; simpl in |- *; auto.\nintros a0 b c0 H H1 H2; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H0; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H0 H1; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1 H2; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1 H2; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1 H2; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1 H2; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1 H2; elim H2; simpl in |- *; auto.\nintros a0 b c0 H H1;Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c; case b; case c; simpl in |- *; auto.\nintros a0 b1 c1 H H0; split; auto.\nintros a1 a2 b2 c2 H H0; elim H; auto.\nintros a1 a2 a3 b4 H0; elim H; auto.\nintros a1 a3 a4 b5 c2 H0; elim H; auto.\nintros a1 a3 a4 b5 c2 H H0; elim H; auto.\nintros a3 a4 a5 b6 c2 H0; elim H; auto.\nintros a4 a5 a6 c2 H0; elim H; auto.\nintros a4 a5 b5 c2 H0; elim H0; auto.\nintros a5 a6 b7 c5 H0; elim H0; auto.\nintros a5 b6 c2 H0; elim H0; auto.\nintros a5 b6 c2 H0; elim H0; auto.\nintros a5 b6 c2 H0; elim H0; auto.\nintros a5 b6 c2 H0; elim H0; auto.Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; elim H; auto.\nintros a0 b1 c0 H1 H2 H3; split; auto.\nintros a0 b1 c1 H2 H3; split; auto.\nintros a0 b1 c1 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c1 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a0 b1 c2 H3; split; auto.\nintros a1 b1 c2 H3; split; auto.\nintros a1 c1 H3; split; auto.\nintros a1 b1 c2 H3; split; auto.\nintros a1 c2 H3; split; autoQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; elim a; simpl in |- *; auto.\nintros a0 b c0; case c; simpl in |- *; auto.\nintros a1 b c0.\ncase c; simpl in |- *; auto.\nintros a1 b c1.\ncase c; simpl in |- *; auto.\nintros a2 b3.\ncase c; simpl in |- *; auto.\nintros a3 b4.\ncase c; simpl in |- *; auto.\nintros a4 b5.\ncase c; simpl in |- *; auto.\nintros a4 b5.\ncase c; simpl in |- *; auto.\nintros a5 b6.\ncase c; simpl in |- *; auto.\nintros a5 b6.\ncase c; simpl in |- *; auto.\nintros a5 b6.\ncase c; simpl in |- *; auto.\nintros a5 b6.\ncase c; simpl in |- *; auto.\nintros a5 b6.\ncase c; simpl in |- *; auto.\nintros a6 b7.\ncase c; simpl in |- *; auto.\nintros a6 b7.\ncase c; simpl in |- *; auto.Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; elim H; clear H; intros; elim H; clear H;\n elim H; clear H; intros; elim H0; clear H0; intros; elim H1; clear H1;\n elim H1; clear H1; intros; elim H2; clear H2;\n elim H2; clear H2; intros; elim H3; clear H3;\n intros; elim H4; clear H4; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\n intros; elim H5; clear H5; intros; elim H5; clear H5;\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; elim H; auto.\napply (cmp_trans _ _ _ _ _ H H0).\napply star_trans with (y := star_trans _ _ _ _ H H0).\napply star_trans with (y := star_trans _ _ _ H H0).\napply star_trans with (y := star_trans _ _ _ H0).\napply star_trans with (y := star_trans _ _ H H0).\napply star_trans with (y := star_trans _ _ H H0).\napply star_trans with (y := star_trans _ _ H H0).\napply star_trans with (y := star_trans _ _ _ H H1).\napply star_trans with (y := star_trans _ _ H H1).\napply star_trans with (y := star_trans _ _ _ H H0).\napply star_trans with (y := star_trans _ _ _ H H1).\napply star_trans with (y := star_trans _ _ H H1).\napply star_trans with (y := star_trans _ _ H H1).\napply star_trans withQed."
                ]
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 535,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nrevert k x.\ninduction H; intros; simpl; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply (subst_subst_subst_rec_uniq x).\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros; simpl; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction H; simpl; auto.\n  rewrite IHe; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply subst_subst_rec.\n  reflexivity.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof. reflexivity. Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction H.\n  reflexivity.\n  simpl.\n  rewrite IHe.\n  reflexivity.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  induction w; simpl; intros; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof. reflexivity. Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof. intros. simpl. apply (subst_subst_subst_subst_subst_rec_aux v k x). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 583,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_term. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_term. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_spec. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_subst_rec_expr lift_option. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_term. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_expr. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_subst_rec. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_expr. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 659,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_subst_expr_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_subst_expr. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_subst_expr_any. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  simpl_lift.\n  apply TApp.\n  + simpl_subst_expr.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    apply TApp.\n    applyQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_term. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_subst_expr. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_subst. auto.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_expr. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 695,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_expr_var. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_expr_var.\n  rewrite subst_expr_var.\n  rewrite subst_expr_var.\n  auto with arith.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_expr_var. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  auto with simpl_lift_goal.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_expr_var_eq. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_expr_var. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros.\n  simpl_subst_expr_var. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  auto with simpl_lift.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_expr_var. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 702,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_expr_var_type.\n  reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_expr_var.\n  reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_expr_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_expr_var_type. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_expr_expr_var. simpl. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_expr_expr_var_fresh.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst_expr.\n  reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst_expr_expr.\n  reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_expr.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_expr. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_expr. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_expr. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros.\n  simpl_subst_expr.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  unfold red.\n  apply H; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H0). clear H.\n  generalize (app_assoc H2). clear H.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H2). clear H.\n  generalize (app_assoc H2). clear H.\n  generalize (app_assoc H1). clear H.\n  generalize (app_assoc H2). clear H.\n  generalize (app_assoc H1). clear H1.\n  generalize (app_assoc H1). clear H1.\n  generalize (app_assoc H2). clear H.\n  generalize (app_assoc H2). clear H1.\n  generalize (app_assoc H2). clear H1.\n  generalize (app_assoc H2). clear H2.\n  generalize (app_assoc H2). clear H1.\n  generalize (app_assoc H1). clear H2.\n  generalize (Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  apply red_trans with (subst x); auto.\n  apply subst_env_subst_rec; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  unfold red.\n  apply red_closed_ind with (1 := H).\n  intros.\n  apply subst_subst_rec_type.\n  apply subst_subst_rec_type.\n  apply subst_subst_rec_type.\n  apply subst_subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_type.\n  apply subst_rec_Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound.\n  apply red_sound; intros; apply red_sound; intros; apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    apply red_sound; intros;\n    applyQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros t1 t2 H; induction H; intros;\n    try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t2; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t2; try solve [apply red_app_or_app; eauto].\n  destruct t2; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t2; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_app; eauto].\n  destruct t1; try solve [apply red_app_or_appQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros t1 t2 H. induction H; simpl; intros.\n  auto.\n  destruct H0.\n  apply red_app; simpl; auto.\n  apply red_trans with (TApp t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2); auto.\n  apply red_trans with (TApp t1 t2);Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H.\n  apply red_app; auto.\n  apply red_trans with (1 := H).\n  apply red_trans with (1 := H0).\n  apply red_trans with (1 := H0).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H0).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H0).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H2).\n  apply red_trans with (1 := H0).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1).\n  apply red_trans with (1 := H1Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply red_step. apply H. apply redQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; simpl; intros; auto.\n  inversion H; subst.\n  apply type_var_c; auto.\n  apply type_var_c; auto.\n  apply type_var_c; auto.\n  apply type_var_c; auto.\n  apply type_var_c; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. induction H; simpl; intros; auto.\n  apply H; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. induction H; simpl_subst; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_subst_rec; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. induction H; simpl in *; intuition eauto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_subst.\n  constructor.\n  apply IHe. auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_subst; simpl_subst; simpl_subst; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; subst; simpl_subst_var.\n  apply (IHx). auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros k x H. induction H; eauto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; simpl_subst; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; simpl_subst in *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_TApp. eauto with lift_subst. auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_SApp. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_TApp. auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed_TVar. eauto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. auto.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. auto with closed.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H. subst. apply H1. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H; subst.\n  econstructor; eauto withlc.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H. auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  induction 1; intros; subst; simpl_lift; auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 702,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. induction H.\n  subst. eauto.\n  intros. apply H0. auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros.\n  auto.\n  Case \"type_var\".\n    simpl.\n    apply IHG.\n  Case \"type_var\".\n    simpl.\n    apply IHG.\n  Case \"type_var\".\n    simpl.\n    apply IHG.\n  Case \"type_var\".\n    simpl.\n    apply IHG.\n  Case \"type_var\".\n    simpl.\n    apply IHG.\n  Case \"type_var\".\n    simpl.\n    apply IHG.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_subst; auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  inversion H; subst; eauto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion H; subst; eauto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E E t T.\n  induction E; intros; subst; simpl_env; try congruence.\n  (* E' app *)\n  destruct H0; subst.\n  left. eapply step_fun_step; eauto.\n  right. eapply step_fun_step; eauto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H.\n  inversion H; subst; auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion H; subst.\n  apply H0.\n  apply H2.\n  apply H0.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion H; subst; eauto with star.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; auto.\ndestruct H; subst; auto.\ndestruct H; subst; auto.\ndestruct H; subst; auto.\ndestruct H; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert_by.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; simpl_subst;\n  auto.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; eauto.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; simpl_subst; auto.\n  destruct H1.\n  apply IHtyping; eauto.\n  eapply IHtyping; eauto.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; simpl_subst; auto.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; simpl_subst; auto.\n  destruct H; subst; simpl_subst; auto.\n  destruct H; subst; simpl_subst; auto.\n  destruct H; subst; simpl_subst; auto.\n  destruct H; subst; simpl_subst; auto.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; auto.\n  destruct a; simpl in *; auto.\n  destruct H; subst; simpl in *; auto.\n  destruct H; subst; simpl in *; auto.\n  destruct H; subst; simpl in *; auto.\n  destruct H; subst; simpl in *; auto.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  intros E x t2 T1 T2; induction T1; intros; subst; simpl_subst_hyp; eauto withremove.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; auto.\n  apply IHi; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_subst; simpl_subst; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 699,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_subst; eauto using type_correctness.\n  (* We can only write a value of the\n   [type_var e0 e1] when the value of the value of the value [T1]\n   that the value of the value of the value [T2].\n   The proof that the value of the value of the value [T2],\n   we can do not need to show that the value of the value [T2].\n   This lemma is not to be the value of the value of the value [T2],\n   [value_var e0 e1] when the value of the value [T2],\n   and that the value of the value of the value of the value [T2].\n   It is not useful to use the value of the value of the value [T2],\n   we have to do it, as well as well as the value of the value of the value [T1]\n   of the value of the value of the value of the value of the value [T2],\n   and the value of the value of the value of the value [T2],\n   and the value of the value of the value of the value of the value [Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H. induction H; intros; subst; simpl_subst_types;\n  try solve [ econstructor; eauto; eapply H; eauto].\n  (* Case Case preservation *)\n  intros. eapply (H _ H). auto. eapply type_correctness. eapply (H _ H0). auto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H. induction H; intros; subst; eauto.\n  (* Case Case Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t2 := T); auto.\n  (* Case Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t2 := T); auto.\n  (* Case Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t2 := T); auto.\n  (* Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t2 := T); auto.\n  (* Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t2 := T); auto.\n  (* Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t1 := T); auto.\n  (* Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E) (t2 := T); auto.\n  (* Case Case *)\n  destruct H0.\n  apply type_correctness with (t1 := E)Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_env;\n  eauto using type_correctness.\n  (* Case Case Case ***)\n  auto.\n  (* Case Case Case *)\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply type_correctness.\n  apply typeQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H1. induction H1; intros; subst; simpl_subst; auto.\n  (* Case CaseDate. *)\n  induction H; intros; subst; simpl_subst; auto.\n  (* Case Case LINE *)\n  destruct H; subst.\n  left. eapply step_trans; eauto.\n  left. eapply step_trans; eauto.\n  right. eapply step_trans; eauto.\n  left. eapply step_trans; eauto.\n  eapply step_trans; eauto.\n  eapply step_trans; eauto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_subst; auto.\n  (* Case Case \"type_all\". *)\n  destruct IHtyp; subst; simpl_subst; eauto with var.\n  (* Case \"type_all\". *)\n  destruct IHtyp; subst; simpl_subst; eauto with var.\n  (* Case \"type_all\". *)\n  destruct IHtyp; subst; simpl_subst; eauto with var.\n  (* Case \"type_all\". *)\n  destruct IHtyp; subst; simpl_subst; eauto with var.\n  (* Case \"type_all\". *)\n  destruct IHtyp; subst; simpl_subst; eauto with var.\n  (* Case \"type_all\". *)\n  destruct IHtyp; subst; simpl_subst; eauto with var.\n  (* Case \"type_all\".\n    destruct IHtyp; subst; simpl_subst; eauto with var.\n    (* Case \"type_all\".\n      destruct IHtyp; subst; simpl_subst; eauto with var.\n      (* Case \"type_all\".\n        destruct IHtyp; subst; simpl_subst; eauto with var.\n        (* Case \"type_all\".\n          destruct IHtyp; subst; simpl_subst; eauto with var.\n          (*Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_subst; auto;\n  try solve [econstructor; eauto using Typing_erased; eauto].\n  (* TODO: unfold value_type in H; eauto 3. *)\n  induction H; subst; simpl_env; eauto.\n  (* Case Case Case *)\n  destruct IHtyping as [T1 [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n  destruct IHtyping as [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n  destruct IHtyping as [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n  destruct IHtyping as [T1 [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n  destruct IHtyping as [T1 [T2 [T3 [T4 [T5 T6]]]]].\n  destruct IHtyping as [T1 [T2 [T4 [T5 [T6 T7]]]]]].\n  destruct IHtyping as [T2 [T3 [T4 [T6 [T7 T8]]]]]].\n  destruct IHtyping as [T1 [T3 [T4 [T5 [T6 T7]]]]]].\n  destructQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction H; eauto using type_correctness.\n  - (* E_App *)\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n  - (* E_App *)\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n  - (* E_App *)\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n  - (* E_App *)\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n  - (* E_App *)\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\n    eapply type_correctness; eauto.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros t1 t2 H; induction H; intros; subst; simpl_subst_expr;\n  try solve [econstructor; eauto].\n  - (* E_App *)\n    destruct (IHtyp T1 T2) as [T1 [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n    inversion T1; subst.\n    left. exists T3. auto.\n    right. exists T3. auto.\n    right. exists T3. auto.\n  - (* E_App *)\n    destruct (IHtyp T1 T2) as [T1 [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n    inversion T1; subst.\n    left. exists T3. auto.\n    right. exists T3. auto.\n    right. exists T3. auto.\n    right. exists T3. auto.\n    right. exists T3. auto.\n  - (* E_App *)\n    destruct (IHtyp T1 T2) as [T1 [T2 [T3 [T4 [T5 [T6 T7]]]]]].\n    inversion T1; subst.\n    left. exists T3. auto.\n    right. exists TQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros.\n  induction H0; eauto.\n  (* E *)\n  destruct H0.\n  destruct H0.\n  subst.\n  destruct H0.\n  left. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  destruct H0.\n  subst.\n  left. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  right. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  left. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  left. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  right. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  right. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.\n  subst.\n  right. eapply step_fun_step; eauto.\n  (* E0 step. *)\n  destruct H0.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 639,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  destruct x; simpl; auto.\n  destruct (x =? x); simpl; auto.\n  destruct (x =? x); simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  unfold one_plus_one; intros.\n  rewrite one_plus_one_right. apply one_plus_one.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  reflexivity.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros; apply one_plus_x_minus_one_right.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. reflexivity. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  reflexivity.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  unfold one_plus. rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  reflexivity.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl; intros. auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros. unfold one_plus. rewrite plus_comm. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 656,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; simpl.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; simpl.\n  auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  induction o.\n  simpl.\n  auto.\n  simpl.\n  auto.\n  simpl.\n  rewrite IHl.\n  auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  apply same_remove_one_right.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  rewrite raw_insert_zero.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. unfold raw_insert. simpl. auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. reflexivity.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. apply list_insert_one.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. unfold raw_insert.\n  destruct (is_insert _ _ _ H) as [l [Hl Hl]].\n  rewrite Hl, Hl.\n  rewrite Hl, Hl.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. rewrite (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. unfold raw_insert. rewrite map_app, map_app. rewrite map_app. reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct o; reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros A x o e. induction e; simpl; intros.\n  auto.\n  destruct a as [x a].\n  destruct (e a); auto.\n  destruct (e a); auto.\n  contradiction.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros A x o e. functional induction (inf_list (S x) o e); simpl.\n  intros.\n  simpl. rewrite IHt. auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. unfold raw_insert.\n  rewrite is_insert_spec. rewrite is_insert_spec.\n  rewrite is_insert_spec.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct e; simpl.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct e as [e' e'].\n  simpl.\n  auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. rewrite fold_left_rev. auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n  reflexivity.\n  destruct o; simpl.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct (is_insert_value x o e); reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct (is_insert_value x o e) eqn:?.\n  + (* L *)\n    destruct (is_insert_value x o e) eqn:?.\n    + (* L *)\n      destruct e as [ | [x | ] o e' ].\n      * (* L *)\n        destruct (is_insert_value x o e) eqn:?.\n        * (* L *)\n        destruct (is_insert_value x o e) eqn:?.\n          * (* L *)\n          inversion H.\n          * (* L *)\n          inversion H.\n          * (* L *)\n            inversion H.\n          * (* L *)\n            inversion H.\n            * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n              * (* L *)\n              inversion H.\n                * (* L *)\n                inversion H.\n                * (* L *)\n                inversion H.\n                * (* L *)\n                inversion H.\n                * (* L *)\n                inversion H.\n                * (* L *)\n                inversionQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; reflexivity.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; reflexivity.\n  simpl. apply IHt.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; auto.\n  apply empty_eq_insert. auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct (find_empty x); auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct x; destruct o; reflexivity.\n  rewrite IHs; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct x; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct (is_empty_inv _ H); auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  destruct (proj1_sig x) eqn:?.\n  + congruence.\n  + congruence.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. destruct x; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 686,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct a; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros A x a H. destruct a; simpl in *; try congruence.\n  destruct (get x a); auto.\n  congruence.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct a; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; simpl; intros.\n  rewrite lookup_empty in *.\n  congruence.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 685,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct e; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct e; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 661,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros A x y o e H. rewrite H. auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct o; simpl in *.\n  congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. unfold lookup.\n  destruct o.\n  rewrite lookup_empty_None. reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct o; simpl; intros; subst; auto.\n  destruct o; simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destruct (find x o); simpl; auto.\n  destructQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. destruct o; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. unfold lookup. destruct o.\n  rewrite lookup_insert_bingo.\n  auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros A x y o. functional induction (find x (elements m)).\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_mapsto_iff.\n  destruct o; simpl; auto.\n  (* easy *)\n  simpl. rewrite <- elements_Qed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  rewrite lookup_insert.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (is_insert x y) eqn:E; try congruence.\n  destruct (isQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. destruct o; simpl; congruence.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. destruct o; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Otherwise, [lookup x (insert y a e) = Some a]. *)\nProof.\n  intros. unfold insert.\n  destruct x; simpl; try solve [\n    elimtype False; omega].\n  destruct o; simpl; try solve [\n    elimtype False; omega].\n  destruct o; simpl; try solve [\n    elimtype False; omega].\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* FILL IN HERE *) Admitted.\n\n(* ################################################################# *)\n(** * Properties of [insert] *)\n\n(** We now define [find] and [find] on the following proof, the [find]\n    function from the [make], and [lookup] and [lookup]s.  The\n    [lookup] function returns the default element of the type [A] of type [A] in the\n    [lookup] and [lookup]s that are not in the type [A]. *)\n\nInductive option (A: Type) : Type :=\n  | None : option A\n  | Some : option A -> option A.\n\nArguments None {A}.\nArguments Some {A}.\n\n(** [get] is a function that returns a map type, the value of a\n    function that returns the value of type [A] that returns the value of the\n    type of [A] that returns the value of type [A]. *)\n\nArguments get {A}.\nArguments get {A}.\nArguments get {A}.\nArguments get {A B} _ _.\nArguments get {A B} _ _.\nArguments get {A B} _ _.\nArguments get {A B} _ _ _.\nArguments getQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Otherwise, [lookup x (insert y a e) = None]. *)\nProof.\n  induction x; intros; destruct y; simpl; try solve [\n    elimtype False; omega].\n  rewrite lookup_insert_value.\n  rewrite lookup_insert_mid. rewrite H; auto.\n  rewrite IHs. auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* }. *)\nProof.\n  intros. unfold insert.\n  destruct x; simpl; try solve [\n    elimtype False; omega].\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* FILL IN HERE *)\nProof.\n  intros.\n  destruct o; simpl; auto.\n  rewrite lookup_insert_mid. rewrite lookup_insert_mid. auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* }. *)\nProof.\n  intros. unfold lookup. rewrite lookup_insert_insert. rewrite lookup_insert. rewrite lookup_insert_insert. auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  (* WORKED IN CLASS *)\n  induction x; intros; simpl; auto.\n  rewrite lookup_insert_insert_gss. rewrite lookup_insert_gso. auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_insert_gso; auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto.\n  rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto. rewrite lookup_insert_gso; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega].\n  destruct o; simpl; try solve [\n    elimtype False; omega].\n  rewrite lookup_insert_spec.\n  erewrite <- lookup_insert_insert_inv; eauto with coqlib.\n  rewrite <- insert_insert_spec.\n  rewrite <- insert_insert_insert_mid. rewrite <- insert_insert_node.\n  rewrite <- insert_insert_same. rewrite <- insert_insert_node. rewrite <- insert_node. rewrite <- insert_insert_mid.\n  rewrite <- insert_value_insert. rewrite <- insert_value_insert. rewrite <- insert_value_insert.\n  destruct x; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl; try solve [auto with coqlib].\n  destruct y; simpl;Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* FILL IN HERE *)\nProof.\n  induction x; intros; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert x a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert x a); simpl; auto.\n  destruct (insert y a); simpl; auto.\n  destruct (insert x a); simpl; auto.\n  destruct (insert x a);Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* SOLUTION *)\nProof.\n  intros.\n  induction x; intros; destruct y; simpl; try solve [\n    elimtype False; omega].\n  destruct o; simpl; try solve [\n    elimtype False; omega].\n  destruct o; simpl; try solve [\n    elimtype False; omega].\n  rewrite IHm1.\n  rewrite IHm2.\n  rewrite IHm2.\n  rewrite IHm2.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  extensionality x.\n  destruct x.\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. intros A B f; reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  induction A; simpl; intros; auto.\n  destruct (f a); auto.\n  destruct (f a); auto.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nintros.\nextensionality i.\nreflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. intros. rewrite map_app. auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. destruct x; simpl in *; auto.\n  congruence.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  rewrite lookup_insert_spec. rewrite lookup_insert_mid. auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup. rewrite lookup_insert_value by auto.\n  rewrite lookup_insert_value by auto.\n  rewrite lookup_insert_value by auto.\n  auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup. rewrite lookup_insert_mid by auto.\n  rewrite lookup_insert_mid by auto.\n  auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup. apply lookup_insert_empty.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  rewrite lookup_insert_mid.\n  rewrite lookup_insert_mid. auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros A B x e. induction e; simpl; intros; auto.\n  destruct a.\n  destruct (f a); auto.\n  destruct (f a); auto.\n  destruct (f a); auto.\n  destruct (f a); auto.\n  destruct (f a); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  destruct (lookup x (map f e)). auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup.\n  rewrite lookup_insert_value_same.\n  rewrite lookup_insert_value; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros A B x e.\n  induction e; simpl; auto.\n  destruct (f x); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction A; intros; destruct e as [ | [ | ]??; simpl in *; subst; auto; try congruence.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl in *; subst;\n  try solve [auto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction A; intros; simpl in *; subst;\n  try solve [auto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction A; intros; simpl in *; subst; simpl.\n  destruct (f a); auto. destruct (f a); auto. destruct (f a); auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; simpl; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros. destruct a as [ | [ | ]? ]; simpl in *; subst;\n  try solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; simpl in *; subst;\n  try rewrite lookup_insert_relate; auto; try rewrite lookup_insert_value; auto;\n  try rewrite lookup_insert_value; auto; try rewrite lookup_insert; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e; simpl in *; subst;\n  try solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction A; intros; destruct e; simpl in *; subst;\n  try solve [inversion H; auto].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 663,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; simpl.\n  - auto.\n  - destruct (zle h a); auto.\n  - destruct (zle h a); auto.\n    destruct (zle h a); auto.\n    destruct (zle h a); auto.\n    destruct (zle h b); auto.\n    destruct (zle h a); auto.\n    destruct (zle h a); auto.\n    destruct (zle h a); auto.\n    destruct (zle h a); auto.\n    destruct (zle h a); auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; destruct s; simpl in *; try congruence.\n  destruct (zle a a); auto. destruct (zle b a); auto. destruct (zle a a); auto.\n  destruct (zle a a); auto. destruct (zle b a); auto. destruct (zle b a); auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros A B x a b e.\n  revert b H.\n  induction s as [ | [ | ]? IH ]; simpl in *; intros; subst.\n  - destruct a as [ | [ | ]? IH]; simpl in *; subst; try solve [\n    congruence].\n  - destruct s as [ | [ | ]? IH]; simpl in *; subst; try solve [\n    congruence].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; simpl in *;\n  try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  ].\n  destruct (insert_min_dec s a); simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  ].\n  destruct (insert_min_dec s a); simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  ].\n  destruct (insert_min_dec s a); simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  ].\n  destruct (insert_min_dec s a); simpl in *; subst;\n    try solve [\n    congruence\n  | destruct s; simpl in *; subst;\n    try solve [\n    congruence\n  ].\n  destruct (insert_min_dec s a); simplQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros A B x e.\n  destruct (find x s) as [[s|]|]; simpl in *; subst; try solve [\n    congruence\n  | eauto].\n  destruct (ins_ins s a x s) as [[s' s'] |]; simpl in *; subst; try solve [\n    congruence\n  | eauto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros A k s a b e.\n  revert s a b e.\n  induction s; simpl; intros; destruct b;\n    destruct s as [ | [ | ]? ]; simpl in *; subst;\n    try (rewrite lookup_insert; auto).\n  destruct b as [ | [ | ]? ]; simpl in *; subst;\n    try (rewrite IHl; auto);\n    try (rewrite insert_insert; auto);\n    try rewrite IHl; auto.\n  destruct b as [ | [ | ]? ]; simpl in *; subst;\n    try (rewrite IHl; auto);\n    try rewrite IHl; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros. destruct (zle a b).\n  - destruct H as [a [Ha [? [? [??]]]].\n    rewrite (H a), (H0 a), (H1 a), (H2 a), (H2 a), (H3 a), (H3 a), (H4 a).\n    rewrite (H1 a), (H2 a), (H4 a), (H4 a).\n    reflexivity.\n  - destruct H as [a [Ha [? [??]]]].\n    rewrite (H a), (H0 a), (H1 a), (H4 a).\n    reflexivity.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; simpl.\n  - tauto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\n  - destruct s; simpl in *; subst; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; destruct a; simpl in *; try solve [\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_prop _ _ H);\n    try destruct (andb_propQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; destruct a as [ | [ | ]? ]; simpl in *; try solve [inversion H];\n  try solve [inversion H].\n  destruct (andb_prop _ _ H).\n  destruct (andb_prop _ _ H).\n  destruct (andb_prop _ _ H0).\n  destruct (andb_prop _ _ H0).\n  destruct (andb_prop _ _ H1).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  destruct (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 669,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s a b e. generalize e; clear s k. induction s; intros.\n  (* Case [s = S s]. *)\n  destruct s as [ | [ | ]? | [ | ]? | [ | ]? | [ | ]? | | | ]; simpl; auto.\n  (* Case [s = S s] *)\n  destruct s as [ | [ | | ]? | [ | ]? | [ | ]? | | | | ]; simpl; auto.\n  (* Case [s <> S s] *)\n  destruct s as [ | [ | | ]? | [ | ]? | [ | ]? | [ | ]? | [ | ]? | | | ]; simpl; auto.\n  (* Case [s <> S s] *)\n  destruct s as [ | [ | ]? | [ | ]? | [ | ]? | [ | ]? | [ | ]? | | | | ]; simpl; auto.\n  (* Case [s <> S s] *)\n  destruct s as [ | [ | ]? | [ | ]? | [ | ]? | [ | ]? | | | ]; simpl; auto.\n  (* Case [s <> S sQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s a b e. generalize a b; clear a b e. induction s; intros.\n  (* Case [s] is a [s] *)\n  destruct s as [ | [ | ] | [ | ] | [ | ] | [ | ] | ]; simpl in *; subst; simpl in *.\n  (* Case [s] is a [s] *)\n  destruct s as [ | [ | ] | [ | ] | [ | ] | [ | ] | | | | ]; simpl in *; subst; simpl in *.\n  (* Case [s] is a [s] *)\n  destruct s as [ | [ | ] | [ | ] | [ | ] | [ | ] | | | | ]; simpl in *; subst; simpl in *.\n  (* Case [s] is a [s] *)\n  destruct s as [ | [ | ] | [ | ] | [ | ] | | [ | ] | | | | ]; simpl in *; subst; simpl in *.\n  (* Case [s] is a [s] *)\n  destruct s as [ | [ | ] | [ | ] | [ | ] | [ | ] | | | | ]; simpl in *; subst; simpl in *.\n  (*Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros???????.\n  unfold filter, insert. rewrite (insert_app_mid_iff s a b e); auto.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. unfold remove.\n  generalize (max_case_eq k s); intros.\n  destruct s.\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the second case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (le_gt_dec k s).\n  (* Case [s] *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is the first case *)\n  destruct (Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s a b e. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0] *)\n  destruct k; [ | elimtype False; omega].\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct s; [ | elimtype False; omega].\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct s; [ | elimtype False; omega].\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct s; [ | elimtype False; omega ].\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).\n  (* Case [s] = s *)\n  destruct (le_lt_dec k s).Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. unfold Same_insert. rewrite! insert_app. simpl.\n  destruct (le_gt_dec k s); auto.\n  (* Case [s1 = S s2]. *)\n  destruct k.\n  (* Case [s2 = S s2]. *)\n  simpl. rewrite IHs2. rewrite IHs2. rewrite IHs2. reflexivity.\n  (* Case [s1 = S s2]. *)\n  simpl. rewrite IHs2. rewrite IHs2. reflexivity.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. rewrite filter_app.\n  rewrite map_app. simpl.\n  rewrite andb_true_iff. destruct (le_gt_dec k s).\n  (* Case [s] is a valid, which means that [k] is a valid, but is\n   not the same as [k]. *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is a valid, but we can choose [s] that is the order\n   of [s] that is the order. *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is a valid, which means that [k] is the order\n   of [k] and [k] is the order. *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is a valid, but it means that [k] is the order\n   of [k] and [k] is the order. *)\n  destruct (le_gt_dec k s).\n  (* Case [s] is a valid, we know that [k] is the order\n   of [k] is the order, we don't know that [k] is the order\n   of [k] andQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  generalize (is_redblack _ _ (is_redblack _ _ (is_redblack _ _ (proj1_sig _ (proj2_sig _ (proj2_sig _ (proj2_sig _ (proj2_sig _ (proj2_sig _ (proj2_sig _ (proj2_sig _ _ (proj2_sig _ (proj2_sig _ _)))) a) e)).\n  destruct s; simpl; auto.\n  (* Case [s] = [s]. *)\n  destruct k.\n  (* L <> 0 *)\n  simpl.\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n  (* L <> 0 *)\n  destruct (le_lt_dec k s).\n Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros A k s a b e. generalize a; clear a.\n  induction s; intros.\n  (* Case [s] *)\n  simpl. rewrite IHt2. rewrite IHt1. simpl. rewrite IHt2. simpl. reflexivity.\n  (* Case [s] *)\n  simpl. rewrite IHt2. rewrite IHt1. simpl. rewrite IHt2. simpl. rewrite IHt1. simpl. reflexivity.\n  (* Case [s] *)\n  simpl. rewrite IHt2. rewrite IHt1. simpl. rewrite IHt2. simpl. rewrite IHt2. simpl. rewrite IHt2. simpl. reflexivity.\n  (* Case [s' = 0]. *)\n  simpl. rewrite IHt2. rewrite IHt1. simpl. rewrite IHt2. simpl. reflexivity.\n  (* Case [s' = S s']. *)\n  simpl. rewrite IHt2. rewrite IHt2. simpl. rewrite IHt2. simpl. reflexivity.\n  (* Case [s' = S s']. *)\n  simpl. rewrite IHt2. rewrite IHt2. simpl. rewrite IHt2. simpl. reflexivity.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct s as [k' s'].\n  destruct s' as [k'' s'].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].\n  destruct (le_lt_dec k' s') as [H'|H']; [|omega].Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  rewrite insert_insert by auto.\n  auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (le_gt_dec x x).\n  + (* contradiction *)\n    apply insert_leaf; auto.\n  + (* contradiction *)\n    apply insert_value; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (le_gt_dec x a).\n  - apply IHl.\n  - apply IHl.\n  - apply IHl.\n  - apply IHl.\n  - apply IHl.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (le_gt_dec x x).\n  - apply non_empty_1.\n  - apply non_empty_2.\n  - apply non_empty_2.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct e; simpl in *; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  unfold insert.\n  rewrite insert_spec.\n  apply insert_nil.\n  reflexivity.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\nintros.\ndestruct e as [[e?]?].\ndestruct e as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e' _]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e' _]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e' _]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e'?]?].\ndestruct e' as [[e' _]?].\ndestruct e' as [[e'?]?].\ndestruct eQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof. auto. Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof. intros. destruct (eq_dec x x). subst. left; auto. right; auto. Qed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\nintros.\nextensionality a.\ndestruct (le_gt_dec x a); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 697,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct a1; destruct e2; simpl; intros; subst; auto.\n  destruct (compare_eq e e1); auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; auto.\n  case_eq (cmp a1 a2); intros; autoQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2.\n  remember (insert x a1) as b1. remember (insert x a2) as b2. destruct b1; destruct b2; subst; simpl in *; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2.\n  remember (insert x a1 e1) as b1.\n  remember (insert x a2 e2) as b2.\n  remember (insert x a1 e1) as b2.\n  remember (insert x a2 e2) as b3.\n  remember (insert x a2 e2) as b4.\n  remember (insert x a2 e1) as b4.\n  remember (insert x a2 e2) as b4.\n  remember (insert x a1 e1) as b4.\n  remember (insert x a2 e2) as b4.\n  remember (insert x a1 e1) as b4.\n  remember (insert x a2 e2) as b4.\n  remember (insert x a3 e2) as b4.\n  remember (insert x a3 e1) as b4.\n  remember (insert x a2 e2) as b4.\n  remember (insert x a3 e1) as b4.\n  remember (insert x a4 e1) as b5.\n  remember (insert x a3 e1) as b5.\n  remember (insert x aQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros. destruct x; destruct e1; simpl; auto; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2.\n  rewrite (insert_neq_insert _ _ _ H).\n  rewrite (insert_uniq _ _ _ H).\n  reflexivity.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct a1; destruct e2; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e1 e2 H.\n  destruct (insert x a1 a2); auto.\n  destruct (insert x a2); auto.\n  contradiction (H x a1).\n  contradiction (H x a2).\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2.\n  remember (insert x a1) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a1) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a1) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a1) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  remember (insert x a2) as b.\n  rememberQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros A x a1 a2 e1 e2.\n  generalize (insert_invariant _ _ _ _ _ H); intro.\n  remember (insert x a1 a2) as b; destruct b; intuition;\n  inversion H; clear H; subst.\n  destruct H as [H1 H2]. destruct H2 as [H2 H3].\n  rewrite insert_cons in H1.\n  rewrite <- insert_insert in H1 by auto.\n  rewrite <- insert_insert by auto.\n  rewrite <- insert_insert by auto.\n  auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; destruct a1; destruct a2; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using lookup_insert_1, insert_eq_insert_2.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using insert_eq_insert_2.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = None). eauto using lookup_insert_neq_insert_2.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using insert_insert_neq_insert_1.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using lookup_insert_neq.\n  rewrite H. simpl.\n  rewrite H0. simpl.\n  rewrite H0.\n  rewrite H0.\n  rewrite H0. simpl.\n  rewrite H0. simpl.\n  rewrite H0.\n  rewrite H0.\n  reflexivity.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using lookup_insert_bingbingbingbing.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a2 e1) = a1). eauto using insert_neq_insert_1.\n  auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using lookup_insert_neq.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = a2). eauto using lookup_insert_neq.\n  rewrite H. rewrite H0. auto.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a2 e1) = a2). eauto using lookup_insert_neq_insert.\n  congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 658,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lt_dec x2 x1).\n  apply H. rewrite H0. rewrite H1. rewrite H2. auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (length (insert x a1 e1) = length (insert x a2 e1)). omega.\n  simpl.\n  rewrite app_length.\n  rewrite <- app_length.\n  apply beq_nat_refl.\n  simpl.\n  rewrite <- beq_nat_refl.\n  rewrite <- beq_nat_refl.\n  rewrite <- beq_nat_refl.\n  reflexivity.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = x1).\n    rewrite e1; simpl.\n    rewrite e2.\n    rewrite e1; auto.\n  assert (insert x a1 e2 = x2).\n    rewrite e2; simpl.\n    rewrite e3.\n    rewrite e3; auto.\n    rewrite e3; auto.\n  assert (length (insert x a2 e1) = length (insert x a2 e1) + 1).\n    rewrite e1; simpl.\n    rewrite e3.\n    rewrite e3.\n    rewrite e1; auto.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    rewrite e3.\n    reflexivity.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct x1; destruct e2; simpl; auto.\n  destruct H; subst.\n  exists e1.\n  split.\n  simpl.\n  split.\n  destruct (le_lt_dec x2 y1).\n  apply gt_trans with (remove y2 y2); auto.\n  apply gt_trans with (remove y2 y1); auto.\n  apply gt_lt_trans with (remove y2 y2); auto.\n  apply gt_lt_trans with (remove y2 y2); auto.\n  apply gt_trans with (remove y1); auto.\n  apply gt_trans with (remove y2 y2); auto.\n  apply gt_lt_trans with (remove y2 y1); auto.\n  apply gt_lt_trans with (remove y2 y2); auto.\n  apply gt_lt_trans with (remove y2 y1); auto.\n  apply gt_lt_trans with (remove y2 y2); auto.\n  apply gt_lt_trans with (remove y2 y2); auto.\n  apply gt_lt_trans with (remove y2 y1); auto.\n  apply gt_lt_trans with (removeQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (length (insert x a1 e1) = length (insert x a2 e1) - 1). omega.\n  destruct (le_gt_dec x1 y1).\n  - subst x1. destruct le_dec as [[lo lo] hi].\n    - destruct (le_gt_dec lo (mid - 1)); [omega|].\n      destruct (le_gt_dec y2 hi).\n      * subst y2.\n        replace (hi - 1) with (mid - 1) by omega.\n        rewrite (sublist_len_1 _ _ H) by omega.\n        rewrite (sublist_len_1 _ _ H) by omega.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H by omega.\n        simpl in H.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H by omega.\n        rewrite sublist_len_1 in H byQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct x1; destruct e2; simpl in *; try congruence.\n  destruct (le_lt_dec x1 y1); auto.\n  destruct (le_lt_dec x2 y2); try congruence.\n  destruct (le_gt_dec x2 y2); try congruence.\n  destruct (le_lt_dec x2 y1); try congruence.\n  destruct (le_gt_dec x2 y2); try congruence.\n  destruct (le_lt_dec x2 y2); try congruence.\n  destruct (le_lt_dec x1 y1); try congruence.\n  destruct (le_lt_dec x2 y2); try congruence.\n  destruct (le_lt_dec x2 y2); try congruence.\n  destruct (le_lt_dec x2 y1); try congruence.\n  destruct (le_lt_dec x1 y1); try congruence.\n  destruct (le_gt_dec x2 y1); try congruence.\n  destruct (le_lt_dec x2 y2); try congruence.\n  destruct (le_lt_dec x1 y1); try congruence.\n  destruct (le_lt_dec x2 y2Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  remember (compare x1 x2) as n1.\n  assert (length n2 = n1) by omega.\n  destruct n1; simpl in H; try omega.\n  destruct n2; try omega.\n  destruct n2; try omega.\n  destruct n1; try omega.\n  destruct n2; try omega.\n  destruct (lt_eq_dec x2 x); subst; simpl in H; try omega.\n  destruct n1; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in H; try omega.\n  destruct n2; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in H; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in H; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in H; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in H; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in H; try omega.\n  destruct (le_lt_dec x2 x); subst; simpl in HQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a2 e1) = x2). eauto using lookup_insert_uniq.\n  destruct (le_gt_dec x1 y1).\n  subst; exists x2; auto.\n  destruct (le_gt_dec x2 y2).\n  subst; exists x1; auto.\n  destruct (le_gt_dec x2 y1).\n  subst; exists x2; auto.\n  destruct (le_gt_dec x2 y2).\n  subst; exists x1; auto.\n  destruct (le_gt_dec x2 y1).\n  subst; exists x1; auto.\n  destruct (le_gt_dec x2 y2).\n  subst; exists x1; auto.\n  destruct (le_gt_dec x2 y2).\n  subst; exists x1; auto.\n  destruct (le_gt_dec x2 y2).\n  subst; exists x2; auto.\n  destruct (le_gt_dec x1 y2).\n  subst; exists x1; auto.\n  destruct (le_gt_dec x2 y1).\n  subst; exists x2; auto.\n  destruct (leQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (prefix (insert x a1 e1) (insert x a2 e1) = x). eauto using insert_value_relate.\n  destruct a1; destruct e2; simpl in *; try congruence.\n  destruct H1 as [? [? [??]]].\n  exists (insert x a1 e1). split. auto. apply insert_value_same; auto.\n  apply insert_value_same; auto.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (forall i, i < size -> i < size -> i < size -> i < size -> i < size -> i < size).\n  { intros. omega. }\n  assert (forall i, i < size -> i < size -> i < size).\n  { intros. omega. }\n  assert (forall i, i < size -> i < size -> i < size).\n  { intros. omega. }\n  destruct (le_gt_dec i 0).\n  exists (max 0 n). omega.\n  destruct (le_gt_dec i (size n)).\n  destruct (le_gt_dec i (size n)).\n  - destruct (le_gt_dec (size n) (size n)).\n    + subst. rewrite max_l; omega.\n    + destruct (le_gt_dec (size n) (size n)).\n      rewrite max_r; omega.\n      rewrite max_l; omega.\n    + rewrite max_l; omega.\n  - destruct (le_gt_dec i (size n)).\n    + subst. rewrite max_l; omega.\n    + rewrite max_l; omega.\n  - destruct (le_gt_dec (size n)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  induction e; simpl; auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. unfold map. rewrite map_map. apply map_insert.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  unfold map. rewrite map_app. rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. rewrite map_app. rewrite map_app. simpl map.\n  rewrite map_app.\n  rewrite map_app. simpl map.\n  rewrite map_app. reflexivity.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  rewrite map_app. rewrite map_app. rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.\n  rewrite map_app. simpl map.Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. unfold map. rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  reflexivity.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof. intros. unfold map. rewrite map_insert. rewrite map_insert. auto. Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof. intros A B f x a e. rewrite map_app. reflexivity. Qed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros A B f x a e.\n  unfold map. rewrite map_app. reflexivity.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. unfold map. f_equal. apply map_insert.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof. intros. rewrite map_app. apply map_insert_uniq. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction a; intros; simpl in *; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction a; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros. rewrite <- insert_eq. rewrite <- insert_map. auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction a; intros; simpl.\n  rewrite IHx. reflexivity.\n  destruct a; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  induction a; simpl; intros.\n  auto.\n  rewrite IHl. reflexivity.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros. unfold insert.\n  rewrite (map_insert_eq _ _ _ H); auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction a; intros; simpl. auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction a; intros; simpl.\n  auto.\n  rewrite IHl. reflexivity.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros.\n  destruct a as [x1 a1]; destruct b as [x2 a2]; simpl; auto.\n  destruct H; auto.\n  destruct H; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction a; intros; simpl.\n  auto.\n  rewrite IHx. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction A; simpl; intros; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros. apply map_insert.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; simpl; intros; auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  rewrite map_insert. rewrite map_insert_neq.\n  rewrite map_insert. rewrite map_insert_neq.\n  reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; simpl.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  induction e; simpl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction A; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction e; intros; simpl. auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros. apply map_insert.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros. auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros. apply map_ext.\n  intros.\n  rewrite map_map. apply map_ext.\n  intros.\n  rewrite map_app. simpl.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; simpl.\n  f_equal. apply map_map_f_none; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros A B C f g h.\n  induction h; simpl; intros; auto.\n  rewrite <- (map_map f g h H).\n  rewrite <- (map_map f g h H).\n  rewrite map_map.\n  auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros A B C f g h e.\n  induction h; simpl; auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; simpl.\n  rewrite map_map; auto.\n  rewrite map_map; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros; auto.\n  rewrite IHl. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 679,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app;\n  try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_app; try rewrite map_appQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros. apply map_ext.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewrite map_map.\n  apply map_ext.\n  intros.\n  rewriteQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros.\n  induction e; intros; simpl; auto.\n  rewrite IHm1.\n  destruct a.\n  rewrite IHm2. reflexivity.\n  rewrite IHm2. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl.\n  auto.\n  rewrite IHm1. reflexivity.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try rewrite map_map; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction g1; intros;\n  destruct (map_map_fizes H) as (d &? &? &?); eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try rewrite map_app; simpl; auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\n  rewrite <- IHe. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  auto.\n  rewrite map_app. simpl. rewrite <- IHm. trivial.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  simpl map.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewriteQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite map_app; simpl.\n  rewrite mapQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_app. simpl. rewrite map_app. simpl. auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_map.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  auto.\n  rewrite map_app. simpl. auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite map_app; simpl; auto.\n  rewrite IHl; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros. unfold insert. rewrite map_map.\n  rewrite map_map_app. rewrite map_app. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  induction e; intros; simpl.\n  f_equal.\n  rewrite map_app.\n  rewrite <- IHl.\n  reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl in *; auto.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite <- map_map.\n  rewrite map_map.\n  rewrite map_map.\n  reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl.\n  rewrite map_app. rewrite map_app. rewrite map_app. rewrite map_app. simpl. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl.\n  rewrite IHl. reflexivity.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros. rewrite map_map. apply map_ext_map_rec.\n  intros.\n  induction x; destruct a; simpl; auto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros. unfold insert. destruct (f a); destruct (f a); auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_equal.\n  apply map_ext; intros.\n  rewrite map_map_app. f_Qed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  apply map_ext.\n  intros.\n  rewrite map_insert. rewrite map_insert. auto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_ext.\n  rewrite map_map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_ext.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  apply map_ext_map_inv.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros. rewrite map_map_ranish. f_equal.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros.\n  apply map_ext.\n  intros. apply map_ext.\n  intros.\n  apply map_ext.\n  intros. apply map_ext.\n  intros.\n  apply map_ext.\n  intros. apply map_ext.\n  intros. apply map_ext.\n  intros. apply map_ext.\n  intros. apply map_ext.\n  intros. apply map_ext.\n  intros. apply map_ext.\n  intros. apply mapQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_map_fing in H.\n  destruct H as [x [y [H1 H2]]]].\n  rewrite map_map_f in H1.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_map_f in H2.\n  rewrite map_mapQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_map_id.\n  apply map_ext.\n  intros.\n  induction e; simpl; eauto.\n  rewrite IHl. reflexivity.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_map_lanish.\n  reflexivity.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_ext.\n  apply map_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  induction l; simpl; auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. f_equal. auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite fold_left_rev_right. auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof. reflexivity. Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof. induction 1; auto. Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. induction f; simpl; auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof. auto. Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold_right.\n  rewrite fold_right_app.\n  rewrite <- fold_right_app.\n  reflexivity.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  rewrite fold_left_map_f.\n  reflexivity.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  induction f; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 725,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  unfold fold_left. rewrite fold_left_rev.\n  rewrite fold_right_app. rewrite fold_right_app.\n  apply fold_left_app.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  apply fold_rec_node.\n  rewrite fold_right_sepcon_app.\n  rewrite fold_right_sepcon_app.\n  reflexivity.\n  apply fold_right_sepcon_right_sepcon_right.\n  apply fold_right_sepcon_right_sepcon_right.\n  apply fold_right_sepcon_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply fold_right_sepcon_right.\n  apply foldQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. unfold fold. rewrite fold_left_rev_right. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; intros.\n  congruence.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros A B f g.\n  induction e; simpl; intros.\n  congruence.\n  destruct a as [x a].\n  destruct a as [x a]. destruct b as [x a].\n  destruct b as [x a].\n  simpl. rewrite IHl. reflexivity.\n  rewrite IHl. reflexivity.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. unfold fold. rewrite fold_left_map.\n  rewrite fold_right_sepcon.\n  rewrite fold_left_rev.\n  rewrite fold_left_rev. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. rewrite fold_left_rev. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros.\n  unfold fold.\n  rewrite fold_left_app.\n  auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. unfold fold. apply fold_rec_node.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 704,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  apply fold_rec.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f derivation.\n  assert (forall e, P e (raw_rec 0 e)).\n  { induction e; intros.\n    - auto.\n    - auto.\n    - auto.\n    - auto.\n    - auto.\n  }\n  destruct (P e); simpl in *.\n  - auto.\n  - auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f eP.\n  induction e; intros; simpl.\n  - auto.\n  - destruct (f e); auto.\n  - destruct (f e); auto.\n  - destruct (f e); auto.\n  - destruct (f e); auto.\n  - destruct (f e); auto.\n  - destruct (f e); auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros; simpl.\n  auto.\n  destruct (raw_partition_left f e cases).\n  destruct (raw_partition_left (fun e => P e) (fun e => P e (raw_partition_left (fun e => P e) (f e))).\n  destruct (raw_partition_left (fun e => P e) (fun e => P e (raw_partition_left (fun e => P e) (f e)))).\n  destruct (raw_partition_left (fun e => P e) (fun e => P e (raw_partition_left (fun e => P e) (f e))).\n  destruct (raw_partition_left (fun e => P e) (fun e => P e (raw_partition_right (fun e => P e) (f e))).\n  destruct (raw_partition_left (fun e => P e) (fun e => P e (raw_partition_right (fun e => P e) (f e))).\n  destruct (raw_partition_left (fun e => P e) (fun e => P e (raw_partition_right (fun e => P e) (f e))).\n  destructQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros.\n  auto.\n  destruct (H0 _ H1).\n  destruct (IHl _ _ H1).\n  destruct H0. auto.\n  subst. auto.\n  destruct H. auto.\n  subst. auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; simpl; intros.\n  auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destruct (f a); simpl; auto.\n  destructQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros.\n  auto.\n  destruct (raw_partition_left (fun a b => f (g a) (g a)) e) eqn:?.\n  destruct (raw_partition_left (fun a b => f (g a) (g b)) e) eqn:?.\n  destruct a.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  destruct (raw_partition_left (fun a b => f (g a) (g b)) e) eqn:?.\n  destruct a.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  destruct (raw_partition_left (fun a b => f (g a) (g a)) e) eqn:?.\n  destruct a.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHl. auto.\n  (* a case *)\n  apply IHlQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros A B P f BASE.\n  induction P; intros; simpl.\n  auto.\n  destruct (P e); simpl in *.\n  auto.\n  destruct (P e); simpl in *.\n  destruct (P e); simpl in *.\n  auto.\n  destruct (P e); simpl in *.\n  auto.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.\n  intuition.\n  destruct (P e); simpl in *.Qed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  intros.\n  induction H.\n  auto.\n  destruct a as [x e].\n  destruct (raw_partition_exists_aux (fun a b => f (g a) b) (fun a => f (g a) b)) as [o|] eqn:E; simpl.\n  apply IHl. auto.\n  simpl. auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros; auto.\n  destruct (raw_partition_between l f e) as [ | e1 l1 l2 e2]; auto.\n  destruct (raw_partition_between l f e1) as [ | e2 l2 e3]; auto.\n  destruct (raw_partition_between l f e1) as [ | e1 l1 l2 e3]; auto.\n  destruct (raw_partition_between l f e2) as [ | e1 l2 e3]; auto.\n  destruct (raw_partition_between l f e1) as [ | e1 l2 e3]; auto.\n  destruct (raw_partition_between l f e1) as [ | e1 l2 e3]; auto.\n  destruct (raw_partition_between l f e1) as [ | e1 l1 l2 e3]; auto.\n  destruct (raw_partition_between l f e1) as [ | e1 l1 l2 e3]; auto.\n  destruct (raw_partition_between l f e1) as [ | e1 l1 l2 e3]; auto.\n  destruct (raw_partition_between l f eQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction 1; simpl.\n  - auto with arith.\n  - destruct a as [k1 a1]; destruct b1 as [k2 a2]; simpl in *; auto.\n    destruct (H a1) as [Ha1|Ha1].\n    + destruct (H a2) as [Ha2|Ha2].\n      * destruct (H a2) as [Ha3|Ha3].\n        * destruct (H0 a2) as [Ha3|Ha3].\n          * destruct (H0 a3) as [Ha3|Ha3].\n            * destruct (H0 a3) as [Ha4|Ha3].\n              * destruct (H0 a3) as [Ha5|Ha4].\n              * destruct (H1 a3) as [Ha4|Ha5].\n              * destruct (H0 a3) as [Ha5|Ha5].\n              * destruct (H1 a3) as [Ha5|Ha5].\n              * destruct (H1 a3) as [Ha5|Ha5].\n                * destruct (H1 a3) as [Ha5|Ha5].\n                  * destruct (H1 a3) as [Ha5|HaQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction 1; intros.\n  - apply H; omega.\n  - apply H; omega.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  induction e; simpl.\n  - auto.\n  - destruct a.\n    + destruct (length e1) eqn:E; auto.\n      destruct (length e2) eqn:E; auto.\n      exploit IHlength; eauto. intros (e1 & E1 & E2 & E2 & F).\n      exploit IHlength; eauto. intros (e2 & E1 & E2 & F).\n      exists e2; split; auto. split; auto. split; auto.\n      exploit IHlength; eauto. intros (e3 & E1 & E2 & F).\n      exploit IHlength; eauto. intros (e3 & E1 & E2 & E3 & F).\n      exists e3; split; auto. split; auto. split; auto. apply IHlength; auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  destruct (lt_dec k1 k2).\n  apply lt_trans with (k1 + k2); auto.\n  apply lt_trans with (k1 + k2); auto.\n  apply lt_trans with (k1 + k2); auto.\n  apply lt_trans with (k1 + k2); auto.\n  apply lt_trans with (k2 + k2); auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction 1; intros.\n  auto.\n  apply IHn. omega.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction 1; simpl.\n  intros. omega.\n  destruct a; simpl.\n  destruct (e (f a)).\n  destruct (e (f a)).\n  destruct (e a).\n  destruct (e (f a)).\n  destruct (e a).\n  destruct (f a).\n  destruct (f a).\n  destruct (f a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destruct (g a).\n  destructQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction 1; simpl; intros.\n  auto.\n  apply H0. omega. omega.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction 1; intros; simpl.\n  destruct (e a); auto.\n  destruct (e a); auto.\n  destruct (e a); auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2.\n  generalize e k2.\n  induction k1; simpl; intros; auto.\n  destruct (H k1).\n  destruct (H k2).\n  subst k2.\n  simpl.\n  destruct (H k1).\n  subst k2.\n  destruct (H k2).\n  subst k2.\n  simpl.\n  destruct (H k2).\n  subst k1.\n  auto.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  simpl.\n  destruct (H k1).\n  subst k2.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  auto.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  auto.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  auto.\n  simpl.\n  destruct (H k2).\n  subst k2.\n  auto.\n  simpl.\n  destruct (H k1).\n  subst k2.\n Qed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2 H.\n  induction H.\n  - apply H.\n  - destruct H as [x [k2 [H1 H2]]].\n    assert (k1 < k2) by omega.\n    destruct (H0 x); try discriminate.\n    subst x.\n    apply H.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    eapply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    eapply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x))); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x))); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x))); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (fun x => length (proj1_sig x) x)); intro.\n  generalize (list_length_ind (funQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  generalize (size_chunk_pos x). intros.\n  generalize (size_chunk_pos x). intros.\n  generalize (size_chunk_pos x). intros.\n  generalize (size_chunk_pos x). intros.\n  generalize (size_chunk_pos x). intros.\n  generalize (size_chunk_pos x). intros.\n  generalize (size_chunk_pos x). intros. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. generalize (H x); intros.\n  generalize (H0 x); intros.\n  generalize (H1 x); intro.\n  generalize (H2 x); intro.\n  generalize (H2 x); intro.\n  generalize (H4 x); intro.\n  generalize (H2 x); intro.\n  generalize (H4 x); intro.\n  generalize (H5 x); intro.\n  generalize (H5 x); intro.\n  generalize (H5 x); intro.\n  generalize (H6 x); intro.\n  generalize (H7 x); intro.\n  generalize (H6 x); intro.\n  generalize (H6 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H8 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.\n  generalize (H7 x); intro.Qed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  omega.\n  destruct H; omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; intros.\n  simpl. apply Nat.le_0_l.\n  omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  contradiction.\n  destruct a as [k1 a]. simpl. apply IHk. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  generalize (find_empty_false (k, a)).\n  destruct (index x k).\n  destruct (index y k).\n  rewrite e in H; simpl in H. congruence.\n  apply IHn in H; auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  destruct (zle 0 x).\n  subst a. omega.\n  destruct (zle 0 x).\n  destruct (zle 0 x).\n  subst a. omega.\n  destruct (zle 0 x).\n  apply H. omega.\n  destruct (zle (x - k) x).\n  subst a. omega.\n  destruct (zle (x - k) x).\n  destruct (zle (x - k) (x - k)).\n  simpl in H. omega.\n  simpl in H. omegaContradiction.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  destruct a.\n  rewrite e. apply IHl. omega.\n  destruct a.\n  destruct H. omega.\n  destruct H. omega.\n  destruct H. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 698,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof. induction k; simpl; intros; auto. Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite Nat2Z.inj_succ.\n  apply Nat2Z.inj_succ.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  induction k; simpl; auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. unfold empty. rewrite map_length.\n  apply List.Forall_forall.\n  apply in_map. apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n  apply in_map.\n Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  destruct (le_gt_dec k 0).\n  destruct (le_gt_dec k 0).\n  rewrite IHk0. omega.\n  rewrite IHk0. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  auto with arith.\n  destruct a; simpl.\n  destruct (le_gt_dec k 0).\n  apply IHk. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  destruct (length_nil x).\n  simpl. omega.\n  apply Nat.le_trans with k. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  omega.\n  destruct a; simpl in *. omega.\n  destruct (le_gt_dec k 0).\n  + destruct (le_gt_dec k 0).\n    + rewrite IHk.\n      rewrite IHk.\n      rewrite IHk.\n      auto.\n    + rewrite IHk.\n      rewrite IHk.\n      rewrite IHk.\n      auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  induction j; simpl; intros. omega. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  simpl. intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct le_gt_dec as [[H1 H2] | H1].\n  apply le_max_l. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  induction j.\n  + reflexivity.\n  + simpl. intros. apply le_trans with (S i). auto. apply le_S_n.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec j j).\n  + auto.\n  + auto.\n  + auto.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. apply le_lt_trans with (j + i). omega. apply le_max_r. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec m j).\n  omega.\n  omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec j i).\n  omega.\n  omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. apply le_trans with (j + j). omega.\n  omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. apply le_trans with (j+i). omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 705,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  rewrite <- (scalar_mult_r (length x)) at 1.\n  rewrite H.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  reflexivity.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec k x).\n  + rewrite nth_error_Some, hd_error_None. auto.\n  + rewrite nth_error_Some, hd_error_Some, hd_error_None; auto.\n  + rewrite nth_error_Some, hd_error_None; auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct o as [x o].\n  rewrite <- (scalar_nth_error _ _ e).\n  rewrite <- app_assoc. simpl.\n  rewrite <- app_assoc.\n  simpl.\n  rewrite <- app_assoc.\n  reflexivity.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  rewrite -> H.\n  apply Nat.add_1_r.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold mymax.\n  rewrite <- app_length.\n  rewrite length_list_app.\n  rewrite length_list_app.\n  apply le_n_S.\n  omega.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros A x k o e.\n  induction e; simpl; intros.\n  - auto.\n  - destruct (IHfin_cons _ _ _ H).\n    + destruct (IHfin_cons _ _ _ H).\n      * auto.\n      * auto.\n    + auto.\n  - destruct (IHfin_cons _ _ _ H).\n      * auto.\n    + auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (le_gt_dec k x).\n  destruct e; simpl; auto.\n  destruct H; auto.\n  apply IHk; auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec x 0).\n  + (* 0 x <= x *)\n    destruct e.\n    + (* x < k *)\n      simpl.\n      replace (length (filter (fun x => negb (k - x)) 0) with true.\n      rewrite filter_In.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      rewrite negb_true_iff.\n      apply orb_false_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_false_iff.\n      apply orb_false_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_false_iff.\n      apply orb_true_iff.\n      apply orb_false_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_false_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n      apply orb_true_iff.\n     Qed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros A x k o e.\n  unfold mymax.\n  destruct (lt_ge_dec x k).\n  + (* base case *)\n    apply IHl.\n    unfold max.\n    destruct (le_gt_dec x k).\n    + (* base case *)\n      apply IHl.\n      omega.\n    + (* base case *)\n      apply IHl.\n      omega.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold mymax.\n  destruct (raw_min_l k) eqn:Heqk.\n  + rewrite <- Heqk. rewrite <- Heqk. reflexivity.\n  + rewrite <- Heqk. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  omega.\n  rewrite IHn; simpl.\n  rewrite IHn; simpl.\n  rewrite IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.\n  rewrite <- IHn; simpl.Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  revert x k yh1.\n  induction x; simpl; intros.\n  destruct (le_gt_dec k x).\n  omega.\n  destruct (le_gt_dec k x).\n  omega.\n  destruct (le_gt_dec k x).\n  omega.\n  destruct (le_gt_dec k x).\n  omega.\n  destruct (le_gt_dec k x).\n  omega.\n  destruct (le_gt_dec k x).\n  omega.\n  omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  revert x.\n  induction x; simpl; intros.\n  rewrite IHv1.\n  destruct x; simpl in H.\n  rewrite IHx1.\n  apply IHn. omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_dec k x).\n  omega.\n  simpl.\n  destruct (le_gt_Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  unfold mymax.\n  rewrite (linear_nth k).\n  rewrite (linear_nth k).\n  rewrite (linear_nth k).\n  simpl.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_r.\n  apply Nat.add_le_mono_r.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_r.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_r.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_r.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_l.\n  apply Nat.add_le_mono_r.\n  applyQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k dfl1 hi1.\n  induction x; simpl; intros.\n  omega.\n  destruct (le_gt_dec k hi1).\n  + subst. apply IHn. omega.\n  + apply IHn. omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k mr1.\n  unfold mymax.\n  destruct (le_gt_dec k x).\n  - (* case *)\n    assert (length (round_up (round_up (round_up x) (round_up (round_up x) (round_up (round_up x) (round_up x)) (round_up x))) <= k).\n    { destruct (round_up (round_up (round_up x) (round_up (round_up x) (round_up x))) as [Hr|Hr].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destruct Hr as [H1 H2].\n      destructQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k Pk1 o e.\n  remember (raw_insert x (from_insert x (from_insert x (from_insert x (x, e)))) as l.\n  remember (raw_insert x (from_insert x (from_insert x (from_insert x (x, e))) as l.\n  remember (raw_insert x (from_insert x (from_insert x (x, e))) as l.\n  remember (raw_insert x (from_insert x (from_insert x (x, e))) as l.\n  remember (raw_insert x (from_insert x (from_insert x (x, e))) as l.\n  remember (linear_insert x (from_insert x (from_insert x (from_insert x l))) as l.\n  remember (linear_insert x (from_insert x (from_insert x (from_insert x (x, e))) as l.\n  remember (linear_insert x (from_insert x (from_insert x (from_insert x (x, e))) as l.\n  remember (linear_insert x (from_insert x (from_insert x (from_insertQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros; subst.\n  destruct (le_gt_dec k 0); simpl.\n  - destruct (le_gt_dec k (1 + k)) eqn:E; try omega.\n    rewrite E in H0; simpl in H0. omega.\n  - destruct (le_gt_dec k (1 + k)) eqn:E; try omega.\n    destruct k; try omega.\n    destruct (le_gt_dec k (1 + k)) eqn:E; try omega.\n    destruct k; try omega.\n    simpl.\n    apply IHk. omega.\n    simpl. omega.\n    simpl. omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  remember (treeify_g x k) as k'.\n  remember (treeify_g x k') as k'.\n  remember (treeify_g x k) as k'.\n  remember (treeify_g x k') as k'.\n  destruct k'.\n  simpl.\n  intros.\n  rewrite <- Heqs'.\n  rewrite <- Heqs'.\n  simpl.\n  replace (length (treeify_g x k')) with (1 + k').\n  rewrite Heqn.\n  replace (length (treeify_g x k')) with (1 + k').\n  rewrite Heqn.\n  rewrite Heqn.\n  simpl.\n  replace (length (treeify_g x k')) with (1 + k').\n  rewrite Heqn.\n  rewrite Heqn.\n  simpl.\n  replace (length (treeify_g x k')) with (1 + k').\n  rewrite Heqn.\n  reflexivity.\n  omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction e; simpl; intros.\n  rewrite hd_nth_error; try omega.\n  simpl.\n  replace (length (from_nth x l)) with (1 + k + 1).\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  erewrite <- (length_insert_left (x :: k) (x :: k)) by eauto.\n  simpl in H.\n  rewrite app_length in H.\n  apply app_nth_error in H.\n  destruct H.\n  subst.\n  simpl in H.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. induction k; simpl; intros.\n  destruct l; simpl in H; try omega.\n  specialize (IHn _ _ H). omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  destruct (lt_dec k x).\n  + subst. simpl. omega.\n  + simpl. apply IHl. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  destruct (lt_dec k x).\n  subst. apply le_lt_dec. omega.\n  apply le_lt_dec. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  induction e; simpl; intros.\n  destruct a.\n  destruct (le_gt_dec k 0).\n  destruct (le_gt_dec k 0).\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct e. omega.\n  simpl in e. destruct (le_gt_dec k 0).\n  simpl in e. destruct (le_gt_dec k 0Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. rewrite nth_error_rev. apply insert_everywhere1. auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  rewrite <- insert_value_cons. simpl. rewrite firstn_length. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  erewrite length_insert_spec by eassumption.\n  reflexivity.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold insert. rewrite skipn_length.\n  rewrite Nat2Z.inj_succ. apply Nat2Z.inj_le. omega.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold insert.\n  destruct (le_lt_dec k x).\n  - subst k. simpl. omega.\n  - rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    auto.\n    auto.\n  - rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    rewrite nth_error_app.\n    auto.\n    auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_sorted by reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_right by eassumption. apply length_insert_right.\n  apply H. omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite <- insert_insert_prefix. rewrite <- app_ass. auto.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite <- (length_insert_right _ _ _ _ H) by omega.\n  assert (length (insert x a e) < k). omega.\n  rewrite leb_correct in H by omega. simpl in H.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_sorted by reflexivity. simpl. rewrite app_length. reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_relate by reflexivity.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite firstn_rev in H by auto. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H.\n  fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H.\n  rewrite <- app_assoc in H.\n  fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H.\n  fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H.\n  fold (k + 1) in H. fold (k + 1) in H.\n  fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H. fold (k + 1) in H.\n  fold (k + 1) in H. foldQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. eapply length_insert_high_2; eauto.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_preserves in * by reflexivity.\n  erewrite <- (length_insert_less in * by assumption.\n  erewrite map_length in * by assumption.\n  rewrite map_length in H.\n  simpl in H.\n  rewrite app_length in H.\n  destruct a; simpl.\n  simpl in *.\n  omega.\n  simpl in *.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. erewrite length_insert_relate by reflexivity.\n  destruct (andb_prop _ _ H) as (e &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e'' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e'' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e'' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _ H) as (e'' &? &?).\n  rewrite app_ass in H.\n  destruct (andb_prop _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 718,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_relate by eassumption. simpl. auto.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_leaf_1 by eassumption.\n  apply Nat.add_le_mono_l. apply Nat.add_le_mono_r. auto. omega. omega. omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_tree in * by reflexivity.\n  rewrite List.length_insert_local in * by omega.\n  rewrite List.length_insert_local in * by omega.\n  rewrite Nat.add_1_r in H. simpl in H.\n  destruct k; simpl in *; try tauto.\n  simpl.\n  rewrite Nat.add_1_r in H.\n  apply Nat.lt_le_incl in H. destruct H as [H _].\n  rewrite Nat.add_0_r in H. simpl in H.\n  apply Nat.lt_le_incl in H. destruct H as [H _].\n  rewrite Nat.add_0_r in H. simpl in H.\n  apply Nat.lt_le_incl in H. destruct H as [H _].\n  rewrite Nat.add_0_r in H. simpl in H.\n  apply Nat.lt_le_incl in H. destruct H as [H _].\n  rewrite Nat.add_0_r in H. simpl in H.\n  apply Nat.lt_le_incl in H. destruct H as [H _].\n  rewrite Nat.add_0_r in H. simpl in H.Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_local in * by reflexivity. fold (1 + k) at 1. fold (1 + k) at 1. fold (1 + k) at 1.\n  fold (1 + k) at 1. fold (1 + k) at 2. fold (1 + k) at 2. fold (1 + k) at 1. fold (1 + k) at 2.\n  rewrite <- app_assoc. f_equal.\n  rewrite <- app_assoc. f_equal.\n  rewrite <- app_assoc. f_equal.\n  rewrite <- app_assoc. f_equal.\n  rewrite <- app_assoc. f_equal.\n  reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_local by reflexivity.\n  rewrite app_ass. simpl. rewrite app_ass. simpl. apply plus_le_compat_r. omega. omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_everywhere by reflexivity. simpl. apply le_trans with (1 := H). clear H.\n  apply length_insert_everywhere. omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_equation in * by reflexivity.\n  auto.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_searchtree by omega.\n  simpl. apply Nat.max_lub.\n  destruct a.\n  apply Nat.max_lub.\n  simpl. apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n  apply Nat.max_lub.\n Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_relate by reflexivity.\n  reflexivity.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_relate by eassumption. apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite map_map_map_app. simpl. rewrite map_app. rewrite map_app. reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. rewrite map_map. apply map_map.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite map_length. rewrite map_length. rewrite map_length. rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length. rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  simpl map.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  rewrite map_length.\n  reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof. induction e; simpl; intros; auto. Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  rewrite map_map_length. auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  erewrite length_map_general in * by reflexivity.\n  rewrite app_length in H.\n  rewrite app_length in H.\n  rewrite app_length in H.\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  rewrite app_length in H.\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  rewrite app_length in H.\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l; try solve [rewrite app_length in H; omega].\n  simpl in H.\n  destruct l;Qed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; simpl; intros.\n  rewrite IHl.\n  rewrite map_app. simpl.\n  rewrite app_ass.\n  apply IHn.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  erewrite length_map_map. apply map_ext. reflexivity.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. apply length_map_ind; simpl; auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. unfold map. rewrite map_app. rewrite map_app. apply map_length.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k IHk]; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction k; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros A B f e.\n  revert k. induction k; intros; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k IHk]; simpl; intros; congruence.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| k]; simpl; intros; try omega.\n  destruct a; simpl.\n  rewrite IHl by omega.\n  rewrite IHl by omega.\n  rewrite IHl by omega.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k IHk]; simpl; intros.\n  discriminate.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  intros. erewrite Zlength_map.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k]; simpl; intros.\n  simpl. rewrite map_app. simpl map. rewrite IHl. auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|x e]; simpl; intros.\n  - rewrite app_nil_r. apply IHk.\n  - intros. unfold map. simpl. rewrite app_nil_r. apply IHk.\n  - intros. unfold map. simpl. rewrite app_nil_r. apply IHk.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e; simpl; intros.\n  rewrite IHl. simpl. rewrite IHl. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 690,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  unfold agree.\n  intros.\n  destruct (zlt x k).\n  apply H. omega.\n  apply H. omega.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2. functional induction (find x e1); intros.\n  (* case *)\n  inv H.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H1).\n  destruct (andb_prop _ _ H2).\n  destruct (andb_prop _ _ H2).\n  apply IHl. apply H. apply H1.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H1).\n  apply IHl.\n  apply H1.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H1).\n  apply IHl. apply H1. apply H2.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H1).\n  apply IHl. apply H1. apply H.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H1).\n  apply IHl. apply H1.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H1).\n  apply IHl. apply H1.\n  (* case *)\n  inv H. simpl.\n  destruct (andb_prop _ _ H2Qed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree.\n  destruct (zle e1 e2).\n  rewrite e2. rewrite e1. apply bot_identity.\n  rewrite e2. apply bot_identity.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree.\n  rewrite H.\n  apply H.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree.\n  destruct (zle (length e1) (length e2)); auto.\n  exploit IHl; eauto. intros (x & A & B & C).\n  exists (S k).\n  auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite H in H0. unfold maps in H.\n  rewrite H in H0. simpl. apply H. auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. exploit (empty_spec k); eauto. intros [k' [A B]]. subst.\n  exists k'. split. apply get_set; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 H. induction H; simpl; intros.\n  apply H; simpl; auto.\n  apply H; simpl; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (table_lookup x e1) at 1. apply H.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree in H. destruct (find x e1) eqn:E; try discriminate.\n  destruct (find x e2) eqn:E; try discriminate.\n  destruct (find x e2) eqn:E; try discriminate.\n  exploit BELOW; eauto. intros [A B]. subst. rewrite <- A. apply B.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  do 2 intro.\n  eapply agree_empty_left; eauto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree.\n  intros.\n  rewrite <- (agree_empty_left e).\n  auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree.\n  induction e; simpl; intros.\n  rewrite IHl; auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros; unfold agree.\n  rewrite <- map_map.\n  rewrite map_map.\n  apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_ext. apply map_Qed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros A e. unfold agree.\n  destruct e as [ | e1 e2]; simpl.\n  auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  unfold agree; intros; apply H.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros; apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  unfold agree.\n  apply H.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros; unfold agree.\n  rewrite <- (agree_empty_left (map f e)).\n  apply map_ext; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply agree_empty_right.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros. unfold agree. apply agree_empty_right.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply agree_empty_left.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros.\n  change 0 with (id A).\n  apply H.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply H.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply H.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. apply agree_empty_left.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 668,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. rewrite <- agree_add.\n  rewrite <- lub_assoc.\n  apply lub_bot_right.\n  apply lub_bot_right.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. unfold agree. apply agree_same.\n  intros. rewrite <- (same_bits_above l). rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above l).\n  rewrite <- (same_bits_above lQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. apply agree_same; auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. apply agree_same; auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2. revert e1 e2; induction e1; intros; simpl.\n  - rewrite IHl1. rewrite <- IHl1. apply agree_same.\n  - intros. rewrite <- (H x). apply agree_same. apply H.\n  - intros. rewrite H. apply agree_same. apply H.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. unfold agree.\n  rewrite <- agree_add. apply H.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2; functional induction (concat e1 e2); intros.\n  rewrite <- (H0 x); auto.\n  rewrite (H0 x); auto.\n  rewrite (H0 x); auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2. unfold agree.\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2).\n  rewrite (comp_parts A e1 e2 e3).\n  rewrite (comp_parts A e1 e2 e3).\n  rewrite (comp_parts A e1 e2 e3).\n  rewrite (comp_parts A e1 e3).\n  rewrite (comp_parts A e1 e3 e3).\n  rewrite (comp_parts A e1 e3 e3 e1).\n  rewrite (comp_parts A e1 e3 e3 e3 e1).\n  rewrite (comp_parts A e1 e3 e2 e3 e1).\n  rewrite (comp_parts A e1 e3 e2 e3 e2).\n  rewrite (comp_parts A eQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. rewrite <- (same_except_same_except_one_or u v); auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros A e1 e2.\n  rewrite <- (app_assoc (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (map_app (mapQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 692,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    induction o; intros; simpl.\n    auto.\n    destruct o; simpl.\n    auto.\n    destruct o; simpl.\n    apply IHs1; auto.\n    destruct o; simpl; auto.\n    destruct o1; simpl; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o1; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    destruct o1; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o1; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destruct o1; simpl; auto.\n    apply IHs2; auto.\n    destruct o2; simpl; auto.\n    apply IHs2; auto.\n    destructQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    induction o; simpl; intros.\n    auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destruct o; simpl; auto.\n    destructQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    induction o; simpl; intros; auto.\n    congruence.\n    destruct a2; auto.\n    destruct a3; auto.\n    congruence.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub.\n    intros. destruct o; auto.\n    congruence.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub. destruct o; auto.\n    destruct o1; auto.\n    discriminate.\n    discriminate.\n    discriminate.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    induction o; intros; simpl; intuition congruence.\n    destruct o; simpl in H; try congruence.\n    destruct o; simpl in H; try congruence.\n    destruct o; try congruence.\n    destruct o; try congruence.\n    destruct o; try congruence.\n    destruct (IHo1 o1); simpl in H; try congruence.\n    destruct o; try congruence.\n    destruct (IHo2 o2); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo2 o1); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo2 o1); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.\n    destruct (IHo1 o2); simpl in H; try congruence.Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o. unfold osub. unfold osub. case (o1 o); intros; try congruence.\n    rewrite <- H0.\n    auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osam. intros. unfold osam.\n    apply (well_founded_ind lt).\n    intros.\n    destruct a1.\n    destruct s.\n    apply (well_founded_ind lt).\n    intros.\n    exists a2.\n    split; trivial.\n    apply (well_founded_ind lt).\n    intros.\n    destruct a1.\n    destruct s.\n    apply (well_founded_ind lt).\n    intros.\n    exists a1.\n    split; trivial.\n    apply (well_founded_ind lt).\n    intros.\n    destruct s.\n    apply (well_founded_ind lt).\n    intros.\n    exists a2.\n    split; trivial.\n    apply (well_founded_ind lt).\n    intros.\n    destruct s.\n    apply (well_founded_ind lt).\n    intros.\n    exists a1.\n    split; trivial.\n    apply (well_founded_ind lt).\n    intros.\n    destruct s.\n    apply (well_founded_ind lt).\n    intros.\n    destruct s.\n    apply (well_founded_ind lt).\n    intros.\n    apply (well_founded_ind lt).\n    intros.\n    destruct s.\n    apply (well_founded_indQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub; auto.\n    intros.\n    case (ne_dec o o1); simpl; intros.\n    eauto with coqlib.\n    eauto with coqlib.\n    eauto with coqlib.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub. destruct o; reflexivity.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 707,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros a1 a2.\n    destruct a1; destruct a2; simpl; auto.\n    destruct H; auto.\n    destruct H; auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros.\n    apply (well_founded_ind lt).\n    apply (well_founded_ind lt).\n    apply (well_founded_ind lt).\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osam. destruct a1; intros; eauto with lngen.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 738,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    intros a1 a2.\n    destruct a2; try discriminate.\n    destruct (a2 a1); try discriminate.\n    destruct (a2 a2); try discriminate.\n    destruct (a2 a3); try discriminate.\n    destruct (a3 a3); try discriminate.\n    destruct (a3 a3); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a3 a4); try discriminate.\n    destruct (a4 a4); try discriminate.\n    destruct (a5 a6); try discriminate.\n    destruct (a6 a4); try discriminate.\n    destruct (a5 a6); try discriminate.\n    destruct (a6 a6); try discriminate.\n    destruct (a5 a6); try discriminate.\n    destruct (a6 a6); try discriminate.\n    destruct (a6 a6); try discriminate.\n    destruct (a6 a7); try discriminate.\n    destruct (a6 a6Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    intros. unfold osbl. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osls. intros until a2. case_eq (find a1); intros.\n    (* In the case of [find] case, the first case *)\n    exfalso. apply H. eauto.\n    (* In the case of [find] case, the first case *)\n    exfalso. apply H0. eauto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osbl. intros????? H.\n    destruct s; auto.\n    simpl. intros.\n    case_eq (find a1 a2); intros.\n    (* case a2 = a3 *)\n    case_eq (find a1 a2); intros.\n    (* case a3 = a4 *)\n    case_eq (find a1 a3); intros.\n    (* case a4 = a4 *)\n    case_eq (find a1 a3); intros.\n    (* case a4 = a4 *)\n    case_eq (find a1 a2); intros.\n    (* case a4 = a5 *)\n    case_eq (find a2 a3); intros.\n    (* case a4 = a4 *)\n    case_eq (find a1 a3); intros.\n    (* case a4 = a5 *)\n    case_eq (find a1 a3); intros.\n    (* case a4 = a5 *)\n    case_eq (find a1 a3); intros.\n    (* case a5 = a6 *)\n    case_eq (find a1 a3); intros.\n    (* case a6 = a6 *)\n    case_eq (find a1 a3); intros.Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osam. intros until a2.\n    destruct s; auto.\n    inv H.\n    destruct (is_reachable a1 a2); auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intros; subst; eauto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros until a2. generalize (h _ eq_refl). clear h. intros [a1 [a2 [a3 [a4 [a5 [a6 [a6 [a6 [a7 [a8 [a9 [a10 [a10 [a10 [a12 [a12 [a13 [a15 [a11 [a12 [a13 [a14 [b15 [a15 [a15 [a15 [a15 [a15 [a17 [a15 [a17 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [b15 [a15 [a15 [b15 [a15 [b15 [a15 [b15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [a15 [a15 [b15 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [a15 [b15 [a15 [a15 [a15 [b15 [a15 [a15 [b15 [a15 [a15 [a15 [Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros until a2.\n    generalize (unique_inversion _ _ _ _ H0); clear H0; intro; subst; eauto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. unfold osub. exists a1. auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros until a2. generalize (trub_Some_inversion _ _ _ H); clear H. intros [a2 [a3 [a4 [a5 [a6 [a7 [a6 [a7 [a6 [a9 [a10 [a12 [a11 [a12 [a12 [a12 [a12 [a12 [a13 [a13 [a15 [a15 [a14 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [a15 [bQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. unfold osub. destruct s.\n    destruct s1; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s; try discriminate.\n    destruct s;Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. exists (o1 a2).\n    intros. exists (o2 a2).\n    intros. exists (o2 a1).\n    intros. exists (o2 a1).\n    split.\n    apply update_commut.\n    auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. generalize ( osls_None_None_Some_inversion).\n    destruct (find_some _ _ _ H) as [[a2|]|] eqn:H; auto.\n    destruct (find_some _ _ H) as [[a3?]?].\n    exists a2.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) as [[a3?]?].\n    exists a3.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) as [[a3?]?].\n    exists a3.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) as [[a3?]?].\n    exists a3.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) as [[a4?]?].\n    exists a4.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) as [[a4?]?].\n    exists a4.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) as [[a4?]?].\n    exists a4.\n    split; auto.\n    intros.\n    destruct (find_some _ _ H) asQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. generalize (h _ eq_refl). clear h. intros [a2 [??|?]]].\n    congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros s x.\n    case (o x); intros; auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold ne. intros. unfold find. auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold ne. simpl.\n    intros.\n    destruct (e2 x); auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros x H.\n    apply find_empty.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros. unfold osub. eauto with coqlib.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros. apply (wf_ind_until _ _ _ _ _ _ _ _ H0).\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold find. intros until o.\n    generalize (find_symbol_inversion _ _ H).\n    unfold find. intros [a'?].\n    destruct (find_symbol_inversion _ _ H) as [a'?].\n    destruct (find_symbol_inversion _ _ H) as [a'?].\n    exists a'.\n    rewrite H1.\n    rewrite H2.\n    reflexivity.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osam. intros s.\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_external s).\n    generalize (at_Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros x x' Ex.\n    case (classic (exists r, r = Some r)).\n    intros [l' [s' [H1 H2]]]].\n    case (classic (exists r', r' = Some s').\n    intro H2.\n    case (classic (exists r', r' = Some r')).\n    intro H3.\n    case (classic (exists r', r' = Some r')).\n    intro H4.\n    case (classic (exists r', r' = Some r')).\n    intro H5.\n    case (classic (exists r', r' = Some s')).\n    intro H5.\n    case (classic (exists r', r' = Some r')).\n    intro H5.\n    case (classic (exists r', r' = Some r')).\n    intro H5.\n    case (classic (exists r', r' = Some r')).\n    intro H5.\n    case (classic (exists r', r' = Some r')).\n    intro H5.\n    case (classic (exists r', r' = Some r')).\n    intro H6.\n    case (classic (exists r', r' = Some r')).\n    intro H6.\n    case (classic (existsQed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros.\n    case_eq (find x e2); intros.\n    destruct (find x e2); intros.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e1); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e1); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e1); try congruence.\n    destruct (find x e1); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e2); try congruence.\n    destruct (find x e3); try congruence.\n    destruct (find x e1); try congruence.\n    destruct (findQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 745,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold ne_ty. intros.\n    apply (well_founded_ind (fun s => forall x, s = None -> forall y, s = y -> s = s).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> s = s)).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> forall y, s = y -> s = s).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> s = s)).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> s = s)).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> s = s)).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> s = s).\n    intros. apply (well_founded_ind (fun s => forall x, s = None -> s = s)).\n    intros. apply (well_founded_ind (fun s => forall x, s = s -> s = s)).\n    intros. apply (well_foundedQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold nom_interp. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold gc. intros e1 e2.\n    generalize dependent e1.\n    induction e1; intros; auto.\n    destruct e2; auto.\n    destruct (IHto1 o2); auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfoldprecise, nom_empty, nom_empty.\n    intros e.\n    unfold nom_to_val, nom_to_val.\n    destruct (h e). auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros e. unfold treeify.\n    apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_founded_ind (fun (x : A) (e : A) => e) e).\n    intros. unfold e. apply (well_foundedQed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfoldprecise; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold gc. intros e1 e2.\n    apply (well_founded_ind (fun a a' => exists e', clos_refl_trans _ a a' /\\ e1 = e2)).\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold Init.\n    intros e'.\n    induction e; simpl; auto.\n    destruct (e a); auto.\n    destruct (e a); auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold subsume. auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 729,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros o1 o2 o3.\n    unfold Efftransl. simpl.\n    case (o1 o2); intros.\n    (* We must use this case, we can use the [match_states] to [match_states]. *)\n    intros.\n    destruct (match_states_dec id (s1#1) (s2#2)); auto.\n    congruence.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfoldgvar. eauto using osam_inf.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold translub. intros. destruct o1. auto.\n    eauto using ne_in_app.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfoldgc. eauto using osam_cons.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold subsume. eauto using osam_preserve.\n    intros o1 o2 s3 H H0 H2.\n    rewrite H2 in H0.\n    rewrite <- H2 in H0.\n    rewrite H1 in H0.\n    rewrite H2 in H0.\n    rewrite H1 in H1.\n    rewrite H2 in H0.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H0.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H3 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H2 in H1.\n    rewrite H3 in H1.\n    rewrite H2 in H1.\n    rewrite H3 in H1.\n    rewrite H3 in H1.\n    rewrite H3 in H1.\n    rewrite H3 in H1.\n    rewrite H3 in H1.\n    rewrite H3 in H1.\n    rewrite H3 in H1.\n    rewrite HQed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold EPo. eauto using osub_transitive.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold nom. eauto using sco_ok.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold subsume. eauto using ne_wf_ind.\n    unfold ne_wf. intros.\n    destruct (IHo_in_dec A a1).\n    eauto using ne_in_dec.\n    eauto using ne_in_dec.\n    eauto using ne_in_dec.\n    eauto using ne_in_dec.\n    eauto using ne_in_dec.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold 80. eauto using osub_transitive.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold subsume. eauto using alloc_variables_incr.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 730,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfoldNDmk. intros e1 e2 e3 H H0.\n    generalize (h2 _ H0); intros [a1 [ h1?']].\n    eauto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using pmimpl_reflexive.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using gc_wf.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume; intros e1 e2 e3 H H0 H1 H2.\n    generalize (sg_pos_pos_pos e1 e2); intro.\n    generalize (sg_pos_pos e1 e2); intro.\n    generalize (sg_pos_pos e1 e2); intro.\n    generalize (sg_pos_pos e2 e3); intro.\n    generalize (sg_pos_pos e3 e3); intro.\n    generalize (sg_pos_pos e3 e3); intro.\n    generalize (sg_pos_pos e3 e3); intro.\n    generalize (sg_pos_pos e3 e4); intro.\n    generalize (sg_pos_neg e3 e4); intro.\n    generalize (sg_pos_pos e3 e4); intro.\n    generalize (sg_pos_pos e3 e4); intro.\n    generalize (sg_pos_pos e3 e4); intro.\n    generalize (sg_pos_pos e3 e4); intro.\n    generalize (sg_pos_pos e3 e4); intro.\n    generalize (sg_pos_neg e3 e4); intro.\n    generalize (sg_pos_Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. auto using node_wf_ind.\n    unfold node_wf; intros e1 e2 [a1' [a2' [A [B [C [D [E [E [E [E [E [E [E [E [E [E [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [E' [EQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold nformula. intros e1 e2 e3 H.\n    generalize (IHi2 _ _ H); intros [a1 [h2 [h3 [h4 [h5 [h6 [h6 h7]]]]]].\n    generalize (h6 _ h2); intros [a2 [h6 [h7 [h9 [h7 [h9 [h9 [h10 [h9 [h9 [h10 [h9 [h10 [h10 [h11 [h12 [h12 [h12 [h13 [h15 h14]]]]]]]].\n    generalize (h6 _ h3); intros [a2 [h9 [h10 [h12 [h12 [h13 [h13 [h15 [h14 [h15 h15 h15 h16]]]]].\n    generalize (h6 _ h3); intros [a3 [h10 [h11 [h13 [h15 [h15 [h15 [h15 h15 h15 h15]]]]].\n    generalize (h6 _ h3); intros [a3 [h10 [h12 [h10 [h11 [h12 [h15 [h15 h16]]]]]]]].\n    generalize (h6 _ h4Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros e1 e2 e3 H H0.\n    generalize (sgal_choice e1 e2); intros [a1 [ h2?]]].\n    generalize (sgal_choice e2 e3); intros [a2 [ h2??.\n    generalize (sgal_choice e1 e2 e3); intros [a3 [ h3??.\n    generalize (sgal_choice e1 e2 e3); intros [a3 [h4 h5]]].\n    generalize (sgal_choice e2 e3); intros [a4 [ h4 h5]].\n    generalize (sgal_choice e3 e1 e2 e3); intros [a5 [h6 h7]]].\n    generalize (sgal_choice e3 e2 e3); intros [a5 [h6 h7]].\n    generalize (sgal_choice e3 e3); intros [a5 [h6 h7]]].\n    generalize (sgal_choice e1 e2 e3); intros [a5 [h6 h7]]].\n    generalize (sgal_choice e3 e1 e2 e3); intros [a5 [h6 h7]]].\n    generalize (sgal_choice eQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros e1 e2 e3 H H0.\n    generalize (INV1 _ _ _ _ _ _ H0); intros [a1 [h2 Heq]]].\n    eauto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold subsume. auto using make_wf.\n    intros e1 e2 [a1' [a2' [a2' [a3' [a3' [a4' [a5' [a6' [a6' [a6' [a7' [a8' [a9' [a9' [a9' [a10' [a10' [a10' [a11' [b11' [a11' [a11' [a12' [b11' [a11' [a11' [a12' [a13' [a15' [b11' [a13' [b11' [a15' [a11' [b11' [b11' [b11' [a11' [a12' [a11' [a11' [a12' [b11' [a11' [b11' [b11' [a11' [a12' [a11' [a12' [a13' [b11' [a11' [a13' [b15' [b11' [a15' [b15' [b11' [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 722,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. intros e.\n    generalize (init_list_empty _ _ _ _ H); intros [a1 [a2 [h1 h2]]].\n    destruct (init_list_empty _ _ _ H); auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfoldNDmk. auto with *.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. auto using init_sig.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. intros e1 e2.\n    generalize (@init_state A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0); intros [a1 [a2 [a3 [a4 [H5 H6]]]].\n    generalize (@init_state A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H4); intros [a2 [a3 [a4 [a5 [H6 H7]]]].\n    generalize (@init_state A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H4); intros [a1 [a3 [a4 [a5 [a6 [a6 [a6 [a7 [a9 [a10 [a10 [a11 [a12 [a11 [a11 [a12 [a12 [a13 [a14 [b11 [a12 [a13 [a13 [a15 [a15 [a15 [b15Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfolddefinitions.empty. intros e.\n    apply (raw_empty_1 e).\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfoldmorphX. intros e.\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@empty (A:=A)).\n    generalize (@Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold BDDconfig. intros e.\n    generalize (raw_empty_1 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_1 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_1 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_1 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_1 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_2 e).\n    generalize (raw_empty_3 e).\n    generalize (raw_empty_1 e).\n    generalize (raw_emptyQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold subsume. auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros e.\n    generalize (e.(empty)).\n    generalize e.(empty)).\n    generalize e.(empty)).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty)).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalize e.(empty).\n    generalizeQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 714,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros. unfoldregular. apply init_is_empty_1.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros e1 e2 He1 He2. unfold BDDor. simpl. apply (treeify_g_is_redblack _ _ _ He1 He2).\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros. apply (raw_insert x e1 e2).\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros e1 e2 EQ.\n    generalize (raw_remove_empty_spec e1 e2 H); intro.\n    generalize (raw_remove_empty_spec e1 e2 H); intro.\n    generalize (raw_remove_empty_spec e1 e2 H0); intro.\n    generalize (raw_remove_empty_spec e1 H0); intro.\n    generalize (raw_remove_empty_spec e2 H0); intro.\n    generalize (raw_remove_empty_spec e1 H0); intro.\n    generalize (raw_remove_empty_spec e1 H0); intro.\n    generalize (raw_remove_empty_spec e2 H0); intro.\n    generalize (raw_remove_empty_spec e1 H0); intro.\n    generalize (raw_remove_empty_spec e1 H0); intro.\n    generalize (raw_remove_empty_spec e2 H0); intro.\n    generalize (raw_remove_empty_spec e1 H0); intro.\n    generalize (raw_remove_empty_spec e2 H0); intro.\n    generalize (raw_remove_empty_spec e2 H0); intro.\n    generalize (Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros e1 e2 H. unfold subsume. intros e1 e2 H.\n    generalize (xelements_remove_ok e1 e2 H).\n    generalize (xelements_remove_ok e2 e1 H).\n    generalize (xelements_remove_ok e1 H).\n    generalize (xelements_remove_ok e2 e3 H).\n    generalize (xelements_remove_ok e2 e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e1 H0).\n    generalize (xelements_remove_ok e1 H0).\n    generalize (xelements_remove_ok e1 H0).\n    generalize (xelements_remove_ok e2 H1).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2 H0).\n    generalize (xelements_remove_ok e2Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros e1 e2.\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (raw_remove_ok e1) (raw_remove_ok e2) e2)).\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (raw_remove_ok e2) e2)).\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (raw_remove_ok e2) e2)).\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (raw_remove_ok e2) e2)).\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (raw_remove_ok e2) e1)).\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (raw_remove_ok e2) e2)).\n    generalize (raw_remove_ok (raw_remove_ok (raw_remove_ok e1) (Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros.\n    generalize (raw_remove_empty_is_empty (A:=A)).\n    generalize (raw_remove_empty_is_empty (A:=B)).\n    generalize (raw_remove_empty_is_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n    generalize (raw_remove_ok_empty (B:=B)).\n   Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros e1 e2 He1 He2.\n    generalize (raw_insert_preserves_nodes _ _ _ _ He1 He2).\n    change (node_OK (raw_remove x o1 e1) (raw_remove x o2 e2)).\n    change (node_OK (raw_remove x o1 e1) (raw_remove x s2 e2)).\n    change (node_OK (raw_remove x s1 e1) (raw_remove x s2 e2)).\n    apply fold_right_app.\n    apply node_OK_app_tail.\n    apply node_OK_app_head.\n    apply node_OK_app_tail.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros e1 e2. unfold subsume. intros e1 e2 [a1 [a2 [a3 [a4 [H1 H2]]]]].\n    generalize (raw_insert_value_correct _ _ _ H1); intros [a1 [a2 [a3 [a4 [H2 H3]]]]].\n    generalize (raw_insert_value_correct _ _ _ _ H2); intros [a1 [a3 [a4 [H4 H5]]]].\n    generalize (raw_insert_value_correct _ _ _ _ H1); intros [a2 [a4 [a5 [H6 H7]]]]].\n    generalize (raw_insert_value_correct _ _ _ _ H2); intros [a3 [a4 [a5 [a5 [H6 H7]]]]].\n    generalize (raw_insert_value_correct _ _ _ _ H4); intros [a4 [a5 [a6 [a7 [a10 [H10 H11]]]]]].\n    generalize (raw_insert_value_correct _ _ _ H5); intros [a4 [a5 [a6 [a10 [H11 H12]]]]].\n    generalize (raw_insert_value_Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. intros e1 e2 H.\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a1 [a2 [a3 [H1 H2]]]].\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a2 [a3 [H1 H2]]]].\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a3 [a4 [H1 H2]]]].\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a4 [a5 [H2 H3]]]].\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a4 [a5 [H1 H2]]]].\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a5 [a5 [b [H1 H2]]]].\n    generalize (raw_remove_ok _ _ _ H); clear H; intros [a5 [a6 [H1 H2]]]].\n    generalize (raw_remove_ok _ _ _ _ H); clear H; intros [a5 [a5 [a6 [H1 H2]]]].\n   Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ".\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros o e1 e2.\n    generalize (checker_get_leaf (hd e1) (hd e2)).\n    generalize (checker_get_leaf (hd e2) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (tl e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (tl e2) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leaf (hd e1) (tl e2)).\n    generalize (checker_get_leafQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros.\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Map (A:=A)).\n    apply (Build_Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    generalize (node_insert_correct _ _ _ _ H); intros [a1 [a2 [Ha1 Hb2]]]].\n    generalize (node_insert_correct _ _ _ Hb1); intros [a2 [Ha2 Hb3]].\n    generalize (node_insert_correct _ _ _ Hb2); intros [a3 [Ha3 Hb4]]].\n    generalize (node_insert_correct _ _ _ Hb4); intros [a4 [Ha4 Hb5]]].\n    generalize (node_insert_correct _ _ _ Hb4); intros [a5 [Ha5 Hb5]]].\n    generalize (node_insert_correct _ _ Hb5); intros [a5 [Ha6 Hb6]]].\n    generalize (node_insert_correct _ _ Hb5); intros [a5 [Ha6 Hb5]]].\n    generalize (node_insert_correct _ _ _ Hb5); intros [a6 [Ha6 Hb6]]].\n    generalize (node_insert_correct _ _ _ Hb5); intros [a6 [Ha6 Hb6]]]].\n    generalize (node_insert_correct _ _ _ Hb5); intros [a6 [Ha7 Hb8]]]].\n    generalize (node_insert_correct _Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros.\n    generalize (node_cons _ _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _ _ H); clear H.\n    generalize (node_cons _ _Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros.\n    repeat rewrite Same_insert_empty_None. apply node_OK.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros.\n    rewrite find_leaf_None.\n    rewrite H.\n    rewrite H0.\n    rewrite H0.\n    reflexivity.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros. rewrite filter_find_empty_None. apply alloc_rev.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros. rewrite fold_right_rec_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_node_ul.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold subsume. intros o e1 e2 He.\n    generalize (node_height_left_rev_right tl); intros [a1 [a2 [Ha1 [Ha2 Hb2]]]]].\n    generalize (node_height_right_one tl); intros [a2 [Ha2 [Hb3 Hb4]]].\n    generalize (node_height_right_one tl); intros [a3 [Ha4 [Hb5 Hb5]]]].\n    generalize (node_height_right_one tl); intros [a4 [Ha5 [Hb6 Hb6]]]]].\n    generalize (node_height_right_one tl); intros [a4 [Hb5 [Hb6 Hb7]]]]].\n    generalize (node_height_right_one tl); intros [a4 [Hb6 [Hb7 Hb8]]]].\n    generalize (node_height_right_one tl); intros [a4 [Hb5 [Hb8 Hb8]]]].\n    generalize (node_height_right_one tl); intros [a4 [Ha5 [Hb8 Hb8]]]].\n    generalize (node_height_right_one tl); intros [a5 [Ha5 [Hb8 Hb9]]]]].\n    generalize (node_height_right_one tlQed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    generalize (node_insert_spec (elements s) (elements s) (elements s) /\\\n       (forall x, In x (insert x e1) ->\n       node_insert (node_insert x s) (node_insert x s) /\\\n       node_insert (node_insert x s) (node_insert x s) /\\\n       node_insert (node_insert x s) (node_insert x s) = node_insert (node_insert x s) (node_insert x s) /\\\n       node_insert (node_insert x s) (node_insert x s) = node_insert (node_insert x s) (node_insert x s) /\\\n       node_insert (node_insert x s) (node_insert x s) = node_insert (node_insert x s) (node_insert x s) /\\\n       node_insert (node_insert x s) (node_insert x s) = node_insert (node_insert x s) (node_insert x s) /\\\n       node_insert (node_insert x s) (node_insert x s) = node_insert (node_insert x s)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 719,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros.\n    rewrite hd_nil.\n    destruct (hd_error_dec (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (node_height (S n))) (S n))) (node_height (Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    generalize (node_cons_inversion _ _ _ H); clear H; intros [a1 [a2 [Ha1 Ha2]]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a2 [Ha2 Ha3]]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a3 [Ha4 Hb4]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a4 [Ha4 Hb5]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a4 [Ha4 Hb5]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a4 [Ha5 Hb5]]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a5 [Ha5 Hb5]]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a4 [Ha5 Hb5]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a4 [Ha5 Hb5]].\n    generalize (node_cons_inv _ _ H); clear H; intros [a5 [HaQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros.\n    unfold subsume.remove.\n    destruct o1; destruct o2; simpl; auto.\n    repeat lookup_remove; eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros o1 o2 e1 e2.\n    generalize (node_cons_inv _ _ _ _ _ _ _ _ H); clear H. intros [a1 [a2 [a3 [a4 [a5 [Ha6 [Ha6 [Ha6 [Ha6 [Ha6 [Ha6 [Ha6 [Ha6 [Ha6 [Ha7 [Ha6 [Ha6 [Ha8 [Ha7 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha9 [Ha8 [Ha8 [Ha8 [Ha8 [Ha9 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha9 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha9 [Ha9 [Ha8 [Ha8 [Ha9 [Ha9 [Ha8 [Ha9 [Ha8 [Ha8 [Ha8 [Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros.\n    repeat (split; auto).\n    do 2 rewrite make_insert_node_None; auto.\n    repeat (split; auto).\n    repeat (split; auto).\n    rewrite make_insert_node_None; auto.\n    repeat (split; auto).\n    rewrite make_insert_node_None; auto.\n    repeat (split; auto).\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n    rewrite make_insert_node_None; auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros o1 o2 e1 e2.\n    generalize (node_height_zero e1 e2).\n    generalize (node_height_zero e1).\n    generalize (node_height_zero e2).\n    generalize (node_height_one e1).\n    generalize (node_height_zero e1).\n    generalize (node_height_one e2).\n    generalize (node_height_one e2).\n    generalize (node_height_one e1).\n    generalize (node_height_one e2).\n    generalize (node_height_one e2).\n    generalize (node_height_one e2).\n    generalize (node_height_one e1).\n    generalize (node_height_one e1).\n    generalize (node_height_one e2).\n    generalize (node_height_one e2).\n    generalize (node_height_one e2).\n    generalize (node_height_one e2).\n    generalize (node_height_one e1).\n    generalize (node_height_one e2).\n    generalize (node_height_one e1).\n    generalize (node_height_one e2).\n    generalize (node_heightQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros o1 o2 e1 e2.\n    generalize (node_is_insert (is_insert_value _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0); intros [a1 [a2 [a3 [a4 [Ha1 [Ha2 Ha2]]]]].\n    generalize (node_is_insert _ _ _ _ _ _ _ _ _ _ H0); intros [a2 [a3 [Ha2 [Ha3 [Ha4 [Ha4 [Ha4 [Ha4 [Ha4 [Ha5 [Ha4 [Ha5 [Ha4 [Ha5 [Ha5 [Ha5 [Ha5 [Ha6 [Ha6 [Ha6 [Ha6 [Ha7 [Ha7 [Ha6 [Ha7 [Ha8 [Ha6 [Ha8 [Ha8 [Ha8 [Ha7 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros o1 o2 e1 e2.\n    generalize (node_is_insert (node_is_insert x o1 e1) (node_is_insert (node_is_insert x o2 e2) (node_is_insert (node_is_insert x o1) (node_is_insert x o2) e2)).\n    destruct (split_or_app_or_app_or_app_or_app l l l0 l0 l0) as [a [Ha1 [Ha2 [Ha3 [Ha3 [Ha4 [Ha5 [Ha5 [Ha5 [Ha6 [Ha6 [Ha7 [Ha7 [Ha8 [Ha8 [Ha8 [Ha8 [Ha8 [Ha9 [Ha8 [Ha8 [Hb9 [Ha10 [Ha8 [Ha8 [Ha8 [Ha9 [Ha10 [Ha8 [Ha10 [Ha8 [Ha9 [Ha10 [Ha10 [Ha9 [Ha10 [Ha10 [Ha10 [Ha10 [Ha10 [Ha11 [Ha11 [Ha10 [Ha11 [Ha10 [Ha10 [Ha11 [Ha12 [HaQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros. rewrite ask_cons_inversion. apply (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. intros o1 o2 e1 e2.\n    generalize (node_height_zero _ _ H); intros [a1 [a2 [a3 [b3 [b4 [c4 [e1 [e2 [e3 [e3 [e4 [e4 [e5 [e6 [e7 [e6 [e6 [e6 [e7 [e9 [e9 [e11 [e12 [e13 [e14 [e14 [e15 [e15 [e15 [e15 [e1 [e11 [e15 [e11 [e12 [e14 [e15 [e17 [e15 [e17 [e1 [e17 [e15 [e1 [e15 [e1 [e11 [e12 [e1 [e2 [e1 [e2 [e1 [e2 [e3 [e2 [e3 [e4 [e4 [e1 [e3 [e4 [e3 [e4 [e5 [e1 [e2 [e3 [e1 [e3 [e4 [e5 [e6 [e6 [e3 [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 708,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    apply (Build_Map (A:=A) (B:=A) (B:=A) (B:=A) (B:=A)).\n    intros.\n    apply (Build_Map (A:=B) (B:=B) (B:=B)).\n    intros.\n    apply (Build_Map (A:=A) (B:=B)).\n    intros.\n    apply (Build_Map (A:=A) (B:=B)).\n    intros.\n    apply (Build_Map (A:=A) (B:=B)).\n    intros.\n    apply (Build_Map (A:=A) (B:=B)).\n    intros.\n    apply (Build_Map (A:=A) (B:=A)).\n    intros.\n    apply (Build_Map (A:=A) (B:=A) (B:=B)).\n    intros.\n    apply (Build_Map (A:=A) (B:=A) (B:=B)).\n    intros. apply (Build_Map (A:=A) (B:=B)).\n    intros. apply (Build_Map (A:=A) (B:=A) (B:=A)).\n    intros. apply (Build_Map (A:=Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold Vprog, compose.\n    repeat f_equal.\n    apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros; auto.\n    destruct a1; destruct a2; destruct b2; destruct c; simpl in *; auto;\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destruct c; simpl in *; auto.\n    destructQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f.\n    induction e1; simpl; intros.\n    (* Base. *)\n    destruct a as [a1 a2].\n    destruct (split_list_norepet (f a1)).\n    (* Base. *)\n    case_eq (split_list_norepet (f a2)).\n    (* Base. *)\n    intros.\n    generalize (split_list_norepet (f a1)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a1)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a2)).\n    generalize (split_list_norepet (f a1)).\n    generalize (split_list_norepet (f a2)).\n    generalizeQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    apply (well_founded_induction_type (fun a => match e1 with | Some a => a | None => True end)).\n    (* Recursive case *)\n    intros.\n    destruct x as [x a].\n    (*Case [x] is the case of [x] *)\n    case (le_gt_dec x x); [ case (le_gt_dec x x); intros;\n      [ right; left; exists (f x);\n        try reflexivity; reflexivity\n        | right; reflexivity\n        | left; reflexivity\n        | right; reflexivity ].\n    (* Recursive case *)\n    intros.\n    destruct x as [x a].\n    (* Case [x] is the case of [x] *)\n    case (le_gt_dec x x); [ intros;\n      [ left; exists (f x);\n        try reflexivity;\n        left; exists (f x);\n        try reflexivity;\n        try reflexivity\n        | left; reflexivity\n        | left; reflexivity\n        | right; reflexivity\n        | right; reflexivity\n        | left; reflexivity\n        | right; reflexivity\n        | right; reflexivity\n        | left; reflexivity\n        | right; reflexivity\n        | left; reflexivity\n        | right; reflexivity\n        | right; reflexivity\n       Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold compose.\n    rewrite (raw_insert_commute_inversion f).\n    unfold compose.\n    apply map_ext; apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n    rewrite map_map.\n    apply map_ext; auto.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    (* Base equality *)\n    destruct a1 as [a1 a2].\n    (* Base equality *)\n    destruct (IHl1 a1).\n    (* Base equality *)\n    simpl.\n    apply IHl1.\n    apply (IHl2 (a :: a2)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl1.\n    apply (IHl2 (a :: a1)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl2.\n    apply (IHl2 (a :: a2)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl2.\n    apply (IHl1 (a :: a2)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl2.\n    apply (IHl2 (a :: a1)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl2.\n    apply (IHl2 (a :: a1)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl2.\n    apply (IHl2 (a :: a2)).\n    assumption.\n    (* Base equality *)\n    simpl.\n    apply IHl1.\n    apply (IHl2 (a :: a1Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros f Hf Hf.\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f Hf].\n    destruct Hf as [f HfQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    apply (well_founded_induction (fun a a => forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)).\n    intros.\n    apply (well_founded_induction (fun a a' => forall a1 a2, sub a1 a2 -> sub a1 a2 -> sub a1 a2 -> f a1 a2)).\n    intros.\n    apply (well_founded_induction (fun a a' => forall a1 a2, sub a1 a2 -> sub a1 a2 -> f a1 a2 -> f a1 a2)).\n    intros.\n    apply (well_founded_induction (fun a a' => forall a1 a2, sub a1 a2 -> sub a1 a2 -> f a1 a2 -> f a1 a2).\n    intros.\n    apply (well_founded_induction (fun a a' => forall a' a', sub a a' -> sub a a' -> f a' a').\n    intros.\n    apply (well_founded_induction (fun a a' => forall a1 a2, sub a1 a2 -> f a1 a2 -> fQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct (raw_partition_f_is_empty (fun a1 a2 => (f a1 a2, f a2 a3)).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 => (f a1 a2, f a2 a3)).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 => (f a1 a2, f a2 a3)).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 => (f a1 a2, f a2 a3)).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 => (f a1 a2, f a2 a3))).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 => (f a1 a2, f a3 a4)).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 => (f a1 a2, f a3 a4)).\n    intros.\n    apply (raw_partition_is_empty (fun a1 a2 =>Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; intros.\n  omega.\n  rewrite IHn; omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; intros.\n  omega.\n  omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\ninduction n; intros; simpl; auto.\nrewrite IHn; simpl; auto.\nrewrite IHn; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; intros; auto.\n  apply IHn; auto with arith.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; intros.\n  omega.\n  simpl.\n  omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  apply Z_one_zero.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  rewrite <- (Z.add_1_r n).\n  apply Z.add_lt_mono_pos_r.\n  apply Z.add_lt_mono_pos_r.\n  apply Z.add_lt_mono_pos_r.\n  apply Z.add_le_mono_nonneg.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\n  apply Z.add_le_mono_nonneg; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  destruct n; auto.\n  destruct m; simpl.\n  auto.\n  destruct n; auto.\n  simpl.\n  destruct n; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  destruct n; simpl; auto.\n  destruct n; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 650,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  induction n1; simpl; intros.\n  omega.\n  omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct n1; simpl in *.\n  - rewrite app_length in H. rewrite app_length in H. omega.\n  - destruct n2; simpl in *.\n    - rewrite app_length in H. rewrite app_length in H. omega.\n    - rewrite app_length in H. rewrite app_length in H. omega.\n    - rewrite app_length in H. rewrite app_length in H. rewrite app_length in H. omega.\n  - rewrite app_length in H. rewrite app_length in H. rewrite app_length in H. rewrite app_length in H.\n    omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  generalize (length_concat e1 n); clear n n1.\n  induction n1; intros.\n  - auto.\n  - simpl. rewrite IHn1.\n    rewrite <- IHn2.\n    apply IHn1.\n    omega.\n  - simpl. rewrite IHn1.\n    rewrite <- IHn2.\n    apply IHn1.\n    omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros A e2.\n  rewrite <- (concat_concat e1 e2).\n  rewrite <- (concat_concat (map (fun x : list A => x) (concat e1 e2)).\n  rewrite <- (concat_concat (map (fun x : list A => x) (concat e1 e2)).\n  rewrite (concat_concat (map (fun x : list A => x) (concat e1 e2))).\n  rewrite <- (concat_concat (map (fun x : list A => x) (concat e1 e2))).\n  rewrite <- (concat_concat (map (fun x : A => x) (concat e1 e2))).\n  rewrite <- (concat_concat (map (fun x : A => x) (concat e1 e2))).\n  rewrite <- (concat_concat (map (fun x : A => x) (concat e1 e2))).\n  rewrite <- (concat_concat (map (fun x : A => x) (concat e1 e2))).\n  rewrite <- (concat_concat (map (fun x : A => x) (concat e1 e2)))).\n  rewrite <- (concat_concat (map (fun x : A => xQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  rewrite <- app_length.\n  apply split_app.\n  omega.\n  omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  induction n1; simpl; intros.\n  rewrite IHn1 in H.\n  omega.\n  omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  generalize (length_concat _ _ _ _ H); intro.\n  generalize (length_concat _ _ _ H0); intro.\n  generalize (length_concat _ _ _ H); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H1); intro.\n  generalize (list_length_concat _ _ _ H1); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H0); intro.\n  generalize (list_length_concat _ _ _ H1); intro.\n  generalize (list_length_concat _ _ _ H1); intro.\n  generalize (list_length_concat _ _ _ H1); intro.\n  generalize (list_length_concat _ _ _ H1); intro.\n Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros A e1 n1 H.\n  induction n1; simpl; intros.\n  - rewrite app_length in H. omega.\n  - rewrite app_length in H. omega.\n  - rewrite app_length in H. omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 670,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; intros; simpl.\n  rewrite <- IHl1. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2 e3.\n  assert (H: forall e1 e2,\n    arities e1 e2 = ok_arities n e2 -> arities e1 = ok_arities n e2 ->\n    forall e, arities e = ok_arities n e -> arities e = ok_arities n e.\nProof.\n  intros A e1 e2 e3.\n  assert (H: forall e, arities e = ok_arities n e).\n    intros. rewrite H0.\n    apply beq_nat_true in H.\n    apply beq_nat_false in H.\n    apply beq_nat_false in H.\n    apply beq_nat_true in H.\n    apply beq_nat_false in H.\n    apply beq_nat_false in H.\n    apply beq_nat_true in H.\n    rewrite <- beq_nat_true in H.\n    simpl in H.\n    elimtype False.\n    apply beq_nat_false in H.\n    apply beq_nat_false in H.\n    simpl in H.\n    elimtype False.\n    apply beq_nat_true in H.\n    apply beq_nat_false in H.\n    apply beq_nat_true in HQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  rewrite H. auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2 e3. unfold agree, compose.\n  rewrite <- agree_app.\n  rewrite <- agree_app.\n  apply map_ext; auto.\n  intros.\n  rewrite map_app.\n  apply map_ext; auto.\n  intros.\n  rewrite map_app.\n  apply map_ext; auto.\n  intros.\n  rewrite map_app.\n  apply map_ext; auto.\n  intros.\n  rewrite map_app.\n  apply map_ext; auto.\n  intros.\n  rewrite map_app.\n  apply map_ext; auto.\n  intros.\n  rewrite map_app.\n  apply map_ext; auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2.\n  apply (ext_concat e1 e2).\n  apply (ext_concat e2 e1).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e1 e2).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e2 e1).\n  apply (ext_concat e2 e1).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e2 e2).\n  apply (ext_concat e2 e3).\n  apply (ext_concat e2 e3).\n  apply (ext_concat e3 e2).\n  apply (ext_concat e1 e2).\n  apply (ext_concat e2 e3).\n  apply (ext_concat e2 e3).\n  apply (ext_concat e2 e3).\n  apply (ext_concat e2 e3).\n  apply (ext_concat e3 e3).\n  apply (ext_concat e2 e3).\n  apply (Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2 n1 k n2 H H0.\n  rewrite <- H0.\n  rewrite <- (map_app e1 e2) at 1.\n  rewrite <- (map_app e1 e2).\n  rewrite <- (map_app (map e1 e2)).\n  rewrite H0.\n  rewrite <- (map_app (map e1 e2)).\n  rewrite H0.\n  apply map_ext2; auto.\n  intros.\n  apply H; auto.\n  rewrite <- (map_app (map e1 e2)).\n  rewrite H1.\n  rewrite H2.\n  apply map_ext2; auto.\n  intros.\n  apply H; auto.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  apply map_ext2; auto.\n  intros.\n  apply H; auto.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2 e3.\n  generalize e1 e2; clear e1 e2.\n  induction e2; simpl; intros; auto.\n  apply IHl.\n  rewrite <- e2. apply IHl.\n  rewrite <- e2. apply IHl.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  rewrite IHx; auto.\n  rewrite IHx; auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros A e1 e2; revert e1; induction e2; intros; simpl.\n  - auto.\n  - rewrite IHl, IHl. intros [a1 [a2 [? [??]]]].\n    rewrite IHl, IHl, IHl, IHr, IHr.\n    intros [a2 [a3 [a4 [a4 [a5 [a6 [a7 [a8 [a9 [a9 [a10 [a11 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a12 [a13 [a14 [a15 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [a15 [a15 [a15 [b15 [a15 [a15 [a15 [a15 [a15 [a15 [b15 [b15 [a15 [a15 [b15 [a15 [a15 [a15 [b15 [a15 [b15 [a15 [a15 [a15 [a15 [a15 [a15 [b15 [a15 [b15 [a15Qed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  apply (well_founded_ind (fun a b c => forall a1 a2,\n    In a1 (map f e1) ->\n    map f e1 a2 ->\n    forall e1 e2,\n    arities e1 = ok_arities e2 ->\n    map f e1 a2 ->\n    map (fun a b => map f e1 a2) (map f e2) (map f e1).\n  intros.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H0.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H1.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H4.\n  apply H3.\n  apply H3.\n  apply H1.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 672,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  auto.\n  destruct o; simpl; auto.\n  destruct (split_app_or _ _ _ H H0); auto.\n  apply IHl; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros.\n  auto.\n  rewrite IHl. rewrite concat_app. rewrite IHl. auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  destruct (split_eq n x) as [ | c l].\n  - inversion H; subst; auto.\n  - inversion H; subst; auto.\n    apply IHl; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros. induction n; simpl; intros.\n  auto.\n  rewrite IHl. rewrite (IHl (concat (concat (concat l) (concat (concat l) (concat l))).\n  rewrite app_length. rewrite IHl. rewrite app_length. auto.\n  rewrite IHl. rewrite (app_length _ _ _ H). auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  auto.\n  apply IHl. auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros A n x defa. induction n; simpl; intros.\n  auto.\n  destruct a; simpl in *.\n  destruct a; simpl in *.\n  destruct b; simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0); auto.\n  simpl in *.\n  destruct (split l0);Qed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  apply IHl.\n  rewrite IHl. apply List.incl_app.\n  apply IHl.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHl. apply List.incl_app.\n  rewrite IHlQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  destruct l; simpl in H.\n  discriminate.\n  destruct (IHl x). congruence.\n  destruct (IHl x). congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros. induction n; simpl; auto.\n  rewrite IHn. apply IHn.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros. destruct n; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  rewrite IHl. rewrite IHl. reflexivity.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros. unfold make_elem.\n  simpl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  intros.\n  induction n; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl.\n  auto.\n  rewrite IHm1; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros.\n  auto.\n  simpl. rewrite IHn; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  auto.\n  destruct a. simpl in H. destruct a. simpl in H. destruct a. simpl in H. destruct H. auto.\n  destruct a. simpl in H. destruct H. destruct H. auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  intros.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  replace a with (nil ++ a :: nil).\n  simpl. auto.\n  rewrite IHl. clear IHl.\n  revert x H0; induction n; intros; destruct a; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  induction l; intros; simpl. auto.\n  destruct H; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  revert x H0; induction n; intros; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  induction l; intros; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  induction l; intros; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  destruct H; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  induction l; intros; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  destruct H; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  destruct H; simpl in *; auto.\n  rewrite IHl; clear IHl.\n  destruct H; simpl in *; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros.\n  simpl. auto.\n  rewrite IHl. rewrite app_ass. auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl in *.\n  auto.\n  rewrite IHl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat. (replicate. a)] is just an iterated version of [insert. a]. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; intros; simpl.\n  auto.\n  rewrite IHm. rewrite <- H. reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  unfold union.\n  rewrite List.map_app.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (Permutation_app (map (@fst A) (list_structid A) n a)) by (auto with typeclass_instances).\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  induction n; simpl; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros. unfold insert. rewrite list_cell_eq.\n  rewrite list_cell_eq.\n  simpl.\n  rewrite <- (H a).\n  reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; intros.\n  auto.\n  rewrite IHm. auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; intros.\n  simpl. auto.\n  rewrite IHl. rewrite <- app_ass. auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (map_app (map (@fst _) (map (@fst _) (list_prod A) (list_prod A) (list_prod A)) a)).\n  rewrite <- map_app.\n  rewrite map_app.\n  rewrite map_app.\n  reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros. unfold insert.\n  rewrite <- insert_map.\n  apply pred_ext.\n  apply pred_ext; normalize.\n  rewrite IHl.\n  rewrite map_app.\n  reflexivity.\nQed."
                ]
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 571,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2.\nmove: (getS s1 l s2 r n (getS s1 r n (getS s1 r n (getS s1 r n (getS s2 l n (getS s2 r n)))) H1.\nby rewrite H2; apply: (H2 (fun s1 s2 r n (getS s1 r n (getS s1 r n (getS s1 r n (getS s2 r n)))) H1).\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2; rewrite /semS.\nmove=>H1 H2; rewrite /semS.\nmove: {1 2} {1 2} (semS s1 r n pf H1 s2 H2); rewrite /semS.\nmove=>H1 H2; rewrite /semS.\nmove=>H1 H2; move: {2 2} (semS s2 r n pf H1 s2 H2); rewrite /semS.\nmove=>H1 H2; move: {2 3} (semS s2 r n pf H1 s2 H2); rewrite /semS.\nmove=>H1 H2; move: {2 3} (semS s1 s2 r n pf H1 s2 H2); rewrite /semS.\nmove=>H1 H2; move: {2 3} (semS s1 s2 r n pf H1 s2 H2); rewrite /semS.\nmove=>H1 H2; move: {2 3} (semS s2 s2 r n pf H1 s2 H1); rewrite /semS.\nmove=>H1 H2Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof. by move=> H1 H2 H3; apply: H2. Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> H1 H2.\nhave H3: (a_step (S s2) (fun s2 s3 => s1 = s2 /\\ s2 = s3 /\\ s1 = s3 /\\ s2 = s3); last by apply: H3.\nmove=> H1 H2.\nhave H5: (a_step (S s2) (fun s2 s3 => s1 = s3 /\\ s2 = s3 /\\ s1 = s3 /\\ s2 = s3 /\\ s1 = s3 /\\ s3 = s3); last by apply: H3.\nmove=> H1 H2.\nhave H5: (a_step (S s2) (fun s2 s3 => s1 = s2 /\\ s2 = s3 /\\ s1 = s3 /\\ s1 = s3 /\\ s1 = s3 /\\ s2 = s3); last first.\n- move=> H1 s2 H3.\n  have H5: (a_step (S s2) s1 s3 = s3 /\\ s1 = s2 /\\ s1 = s3 /\\ s1 = s3); last firstQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=> H1 H2; apply: (proj1 (H2 H1)) => [s1' [s2' [H3' H4'']]] H4];\nby rewrite H4'' H4'' H4'' H4''.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof. by case: l s1 s2 => s1 s2 r; case: n s2 => s1 s2 r; case: n s2 => s1 s2; case: n s1 s2 => s1 s2; case: n s1 s2. Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>[s1 s2 r'] s2 [n0 H1] H2.\nby rewrite /semS /getS /getS /getS.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros H1 H2; inversion H1; subst.\n  - (* i*)\n    remember (getS s1 l) as p; destruct p.\n    + (* i *)\n      remember (getS s2 l) as p; destruct p.\n      + (* i*)\n        remember (getS s1 l) as p; destruct p.\n        * (* i = i *)\n        remember (getS s2 l) as p; destruct p.\n          * (* i = i *)\n          destruct p.\n            * (* i = i *)\n            destruct p.\n            * (* i = i *)\n              destruct p.\n              * (* i = i *)\n              destruct i.\n              * (* i = i *)\n              destruct i.\n              * (* i = i *)\n              destruct p.\n              * (* i = i *)\n              destruct i.\n              * (* i = i *)\n                destruct p.\n                * (* i = i *)\n                destruct i.\n                * (* i = i *)\n                destruct i; inversion H2; subst; clear H2.\n                * (* i = i *)\n                destruct i; inversion H2; subst; clear H2.\n                * (* i = i *)\n                destruct i; inversion H2; subst;Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2 s1 s2 r H1 H2 H3 H4.\nmove: (getS s1 l) s2 s2 s2 s2 H1 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14.\nmove: (getS s1 r) s2 s2 s2 s3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15.\nmove: (getS s2 r) s2 s2 s3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H15 H16 H17 H18 H19 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H39 H40 H39 H40 H41 H42 H43 H44 H45 H45 H46 H47 H48 H49 H47 H48 H49 H47 H48 H49 H46 H47 H48 H49 H47Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n(* We start the result of the \"safe\" with a small step. *)\n(*\nLemma step_deterministic' n (c : safe G) l s1 s2 r n (pf : a_step pf s1 s2) n (pf' : b_step pf' s2 r) n (pf'' : b_step pf' s2 r),\n(a_step pf' s1 s2 r -> namhr_step c s1 s2 r -> r = r) ->\n(forall s1 s2 r, s1 s2 r -> r = s2 r) ->\n(forall s1 s2 r, s1 s2 r -> r = s2 r) ->\n(forall s1 s2 r, s1 s2 r -> s1 = s2 r) ->\n(forall s1 s2 r, s1 s2 r -> s1 = s2 r) ->\n(forall s1 s2 r, s1 s2 r -> s1 = s2 r) ->\n(forall s1 s2 r, s1 s2 r -> s1 = s2 r) ->\n(forall s1 s2 rQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "X Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H; apply: (step_step H).\nby apply: (step_step H).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 s1 s2 [s1 s2] [s2 s2] [s2 s2] H2; case: f=>s1 s2 H2;\ncase: f=>s2 H3; rewrite {s1}E1 in H4; case: f=>s3 H4;\ncase: f=>s3 H4; first by rewrite /step_refl.\nby rewrite /step_refl.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by move=>H1 s; apply: H1. Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 H2; rewrite /valid_seq.\nby apply: H2; apply: H1.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 [s H2] [s H3]; split; first by apply: (H2 H3).\nby apply: (safe_step H2 H3).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 H2 s H; apply: H2; apply: H1.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by move=>H; apply: H. Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 H2 x; rewrite /valid /= => H1 H2.\nby rewrite (proof_irrelevance H1 H2).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 H2; apply: (step_wf H1).\nby apply: (step_wf H2).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H1 H2.\nhave H2: s \\In has (S s) s by apply: (step_refl H2).\nby apply: (step_trans H1 H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "let in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by move=>H; apply: H. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s; rewrite -pf. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>H; rewrite /seq_safe /= => H1; exists s. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by exists s2, (f (safe_step S)). Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case=>s H; rewrite /step_star /step_star /safe_safe. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by exists s1, (f (safe_safe S)). Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by move=>H; apply: safe_step_safe. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by exists s1, (f (safe_safe S)). Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nmove=>H1; move: (step_star H1) =>H2.\nby rewrite H1 in H1; apply: (safe_corestep H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ";\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: (safe_step_safe S). Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>H1 H2; case H1: (S (step_inter S s1 s2 r)); last by case.\nby case: (S (step_star S s2 s2 r)); case.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: (safe_step_safe H). Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S1 S2; move: (step_sem S1) => S2 S2; apply: (safe_step S2).\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>H.\ncase: (S (S _ _ _ _ _ _ _ H)).\nby rewrite (safe_step H).\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case: S => //= s1 s2 r H; exists s2, s2. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H1 s; case: s=>s H1 s H2; apply: H2.\n- by rewrite -filter_predI; case: ifP => // _; apply: H2.\n- by rewrite -filter_predI; case: ifP => // _; apply: H2.\n- by rewrite -filter_predI; case: ifP=> // _; apply: H2.\nby rewrite -filter_predI; case: ifP=> // _; apply: H2.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: H; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2 x; rewrite /seq_spec; apply: H2.\nby case: H1 H2=>H; apply: H2.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (H 0%N); apply: (H 0%N); apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (try_to_forms H). Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (H (fun s => s \\In map_disj s)). Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H1 H2; apply: H2. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (H \\in H) => /=;\nby apply: (H \\in H) => //; apply: H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nhave H: s \\In unh W -> s = s.\n- move=>H; move: H=>[x]; apply: H; apply: H.\nhave H': s \\In unh W -> s = s.\n  by move=>H; apply: H; apply: H'.\nmove=>H; apply: H'; apply: H'.\nmove=>x; apply: H'.\nmove=>H; apply: H'; apply: H'.\nmove=>H'; apply: H'; apply: H'.\nmove=>H'; apply: H'.\nmove=>x; move: H'; move: H'; move: H'; move: H'; move: H'.\nmove=>H; move: H'; move: H'; move: H'.\nmove=>H; move: H''; move: (H' x) H'.\nmove=>H; move: (H' x) H'.\nmove=>H; move: (H' x) H'.\nmove=>H; move: (H' x) H'.\nmove=>H; move: (H' x) H'.\nmove: (H' x) H'.\nmove: (H'Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof. by case: s=>s H; apply: tryrecv_act_step_sound. Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof. by case: s=>s H; exists r; rewrite?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?H?Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H; elim: s H=>H; first by case=>H; exists H.\ncase=>H; case=>H; first by move=>H; exists H.\ncase=>H; first by move=>H; exists H.\ncase=>H; case=>H; first by case=>H; exists H.\nby case=>H; exists H.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H; case: s => [s d] /=;\nby exists (pf' r); rewrite /is_left /is_left /is_left /is_left /is_left /is_left /is_left/is_left.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nelim: s => [|s1 IHs1] s1 IHs1] s2.\n- by exists nils1; rewrite?eqxx.\n- by exists s2; rewrite?eqxx.\nby exists s2; rewrite?eqxx.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H; case: s H=>H; case: s H=>H; case: s H=>H; case=>H; case=>H; case=>H; case=>H; case=>H;\nmove: H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H;\nmove: H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H;\nmove: H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case=>H; case;\nmove=>H; case=>H; case=>H; case=>H; case=>H; case=>H; caseQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H; split; first by exists s; split=> // a s; apply: tryrecv_forms.\nby exists a; apply: tryrecv_forms.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof. by move=>H; split; [exists (fun x => sval (proj1_sig (H x))). Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2; apply: (iffP idP)=> [|[[x [H1 H2]]]|[x [H1 H2]]]|[x [H1 H2]].\nexists x; exists x.\nby rewrite (H2 H3) (H3 H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from sc (f' : clause_atom => e' r) s1 r) => /= [l m] U.\nelim: r H=>s1 [rt][T] U.\n- by case=>r [rt][T] U; rewrite /tryrecv_form_step.\ncase=>r [cl][T] U; case=>r [rt][T] U; rewrite /tryrecv_form_step.\nby case=>r [cl][T] U; rewrite /tryrecv_form_step.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms of sc (findP r)), r); first by case=>r m] /=; last first.\n- move=>H; exists r, r.\n  by move=>H; rewrite H; move/H=>H; apply: H.\nmove=>H; exists r, r.\nby move=>H; rewrite H; move/H=>H; apply: H.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from t, r) is (fun _ => True)) => /= [[l[m [t]][t]][l' A E1] D1 E1 E2] E2.\nby exists r', s, r', s2, r'; split=>//; exists r', s2, r'.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrec ts_step.\ncase: (classic (exists l m tms, tryrec ts_step s1 s2 r) E H)=>H.\n- by case=>[l][m][t][H1] H1]; exists r; split=>//; exists t.\n- by case=>[r][m][t][t][H1] H2; exists r; split=>//; exists t.\n- by case=>[r][t][H1] H2; exists r; split=>//; exists t.\n- by case=>[r][m][t][t][H1] H2; exists r; split=>//; exists t.\n- by case=>[r][t][m][H1] H2; exists r; split=>//; exists t.\n- by case=>[r][t][m][t][H1] H2; exists r; split=>//; exists t.\n- by case=>[r][t][H1] H2; exists r; exists r; split=>//; exists t.\n- by case=>[r][t][t][t][H1] H2; exists r; split=>//; exists t.\nby case=>[rQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; case: (classic (exists l m tms2 : def (SSr r r)) => H1 H2.\n- by case=>l [H1 H2]; apply: tryrecv_form.\n- by case=>l [H1 H2]; apply: tryrecv_form.\n- by case=>r [H1 H2]; apply: tryrecv_form.\n- by case=>l [H1 H2]; apply: tryrecv_form.\n- by case=>r [H1 H2]; apply: tryrecv_form.\n- by case=>r [H1 H2]; apply: tryrecv_form.\n- by case=>r [H1 H2]; apply: tryrecv_form.\n- by case=>r [H1 H2]; apply: tryrecv_form.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms & exists r', exists r', exists r', r' = r' /\\ r' = r' /\\ r' = r')).\n- move=>H; exists s1, r, r'; rewrite /tryrecv_form_step.\n  case: (classic (exists r', exists r', r' = r' /\\ r' = r' /\\ r' = r'))).\n  - move=>H; exists r', r'.\n    by case: (getP r' r' H1) => [r' r']; case: (getP r' r') => H1 H2; rewrite H2.\n  - move=>H; exists r', r'.\n    by case: (getP r' r'); case=>r' r']; case=>r' s' r''.\n- move=>H; exists r', r'.\n    by case: (getP r' r'); case=>r' s'' r''; case=>r' s'' r''.\n- move=>H; exists r'', r''.\n  by case: (getP r' r'); caseQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_form_step.\ncase: (classic (exists l m tms1, tryrecv_form m s1 r) E)=>T1.\n- move=>H; exists (fun r m tms2 => T1 s2 r).\n  by exists (fun r m tms2 => T1 s2 r).\n- move=>H; exists (fun r m tms1 => T1 s2 r).\n  by exists (fun r m tms2 => T1 s2 r).\n- move=>H; exists (fun r m tms2 => T2 s2 r).\n  by exists (fun r m tms1 => T1 s2 r).\n- move=>H; exists (fun r m tms2 => T2 s2 r).\n  by exists (fun r m tms2 => T2 s2 r).\nby exists (fun r m tms2 => T1 s2 r).\nby exists (fun r m tms2 => T2 s2 r).\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_form_step; case: (classic (exists l m tms of r)) =>H1 [r][H1 H2];\ncase: (classic (exists l m tms & r = r)) => H1;\ncase: (classic (exists l m tms & r = r))=>H2;\ncase: (classic (exists l, r = r /\\ r = r))=>H1 H2;\ncase: (classic (exists r, r = r /\\ r = r))=>H3;\ncase: (classic (exists l', r = r /\\ r = r')); intro H3;\ncase H3: (exists r', r = r' /\\ r' = r'));\ncase H3; intros H4 _;\ncase H4: (exists r', r' = r' /\\ r' = r'));\ncase H4: (exists r', r' = r' /\\ r' = r'));\ncase H4: (exists r', r' = r'));\ncase H4; intros H5 _;\ncase (H6 r' H7) H8; intros H8 _;\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrec ts_step_star.\ncase=>[s1 s2] [n] [n] [n] [n] H; first by exists n.\nmove=>H; exists n; split=>//.\nby case: H=>// H _; rewrite H.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_form_step_star;\nby move=>y [H1][T1][T2][T3][T4][T5][T6][T6][T7][T7][T7][T7][T7][T7][t7][T8][T8][T9][T9][T9][T9][t11][T12][T12][T12][T12][T12][T22][t22][t22][t22][t22][t22]\nH.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /tryrecv_form_step.\ncase: (classic (exists l m tms1, tryrecv_form s1 r n (S n) s1)) => [[r1 r1] r2] H;\nexists r, r, r1, r2.\n- by case=>l1 r1] H; case=>l2 r2] H;\nexists r, r1, r2.\n- by case=>l2 r2] H; case=>l2 r2] H;\nexists r, r1.\nby case=>r2 r2] H; case=>r2 r2;\nexists r, r2.\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>H; apply: tryrecv_form_step_inter =>s1 s2 r.\nby case: (classic (exists r, r \\In s1, r)) => //=; case=>r s2; case=>s2; [left|right]; apply: tryrecv_form => // H.\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>D E; rewrite /tryrecv_form_step.\ncase: (classic (exists l m, exists r, s1 r = s2 r /\\ r = s1 r)) => /= [r1 r1 r2];\nmove: (netort_form_step_form_step_form_step_form_step_form_step_external _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /tryrecv_form_step.\ncase: (classic (exists l m tms1, tryrecv_form_step s1 s2 r) => /= [r1 r1] /=.\n- by move=>H; apply: tryrecv_form_step_type; rewrite H.\nmove=>H; apply: tryrecv_form_step_form; rewrite H.\ncase: (classic (exists l m, in_seq s1 s1 r)) => /= [l1 r1] /=.\n- by move=>H; apply: tryrecv_form_step_form; rewrite H.\ncase: (classic (exists l m, in_seq s1 r1 r1)) => /= [r1 r1] /=.\n- by move=>H; apply: tryrecv_form_step_form; rewrite H.\nby move=>H; apply: tryrecv_form_step_form; rewrite H.\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nelim: s1 S s2 S s2 S s2 S s2 S s2 S s2 S s1 S s2 S s2 S s2 S s2 S s2 S s2 S s2 S s1 S s2 S s2 S s2 S s2 S s2 S s2 S s3 S s2 S s3 S s3 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s4 S s5 S s4 S s4 S s4 S s4 S sQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case: S=>s1 s2 r; case: S=>s1 s2 r; case: S=>s2 s2; case: S=>s2 s2; case: S=>s1 s2; case: S=>s1 s2; case: S=>s1 s2; case: S=>s2 s3. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /tryrecv_form_step.\ncase=>s1 s2 [s2][t1] [s2] [s2] [s3][t2] t2.\nrewrite /tryrecv_form_step =>H; exists t1; exists s2.\nby apply: (IH (S (s2:=s2)); rewrite (IH (S (s2:=s2)));\nrewrite (IH (S (s2:=s2)));\nby rewrite (IH (S (s2:=s2)));\nby rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));\nrewrite (IH (S (s2:=s2)));\n rewrite (IH (S (s2:=s2)));Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 743,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nelim: s => [|x s IH] /= [x]; first by rewrite!mem_head.\nelim: s => [|x s IH] /= x; first by rewrite!mem_head.\ncase=>x s IH] /= /andP[s1'x]; first by rewrite!mem_head.\nby case=>s2'x; rewrite!mem_head.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nelim: s => //= s t_asym [s t_asym][t_asym [s_refl t_asym]]]].\nrewrite /is_sess; case: ifP => //= [t_asym|t_asym s_asym];\nrewrite /is_sess; case: ifP => // _; apply: IHss.\nrewrite /is_sess; case: ifP => /= [s_asym|t_asym];\nby rewrite /is_sess; case: ifP => //= _; apply: IHss.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nsplit=>[|H]; first by move=>H; apply: H.\nby apply: H; apply: H.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\ncase=>H1 H2; case=>H2 H3; case=>H3 H4; apply: H2.\nrewrite /is_assim /=!getS_proj1_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=.\ncase=>H3 H4; apply: H2.\nrewrite /is_assim /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sig /=!getS_proj2_sigQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (H1 H2); apply: (H2 H3).\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (H1 (H2 (H1 :+ s)));\nby apply: (H2 (H2 (H2 :+ s)));\nby apply: (H2 (H2 (H1 :+ s)));\n apply: (H2 (H2 :+ s)));\nby apply: (H2 (H2 :+ s)));\napply: (H2 (H2 :+ s)));\napply: (H2 (H2 :+ s)));\nby apply: (H2 (H2 :+ s));\napply: (H2 (H2 :+ s)));\napply: (H2 (H2 :+ s)));\napply: (H2 (H2 :+ s)));\nby apply: (H2 (H2 :+ s)));\napply: (H2 (H2 :+ s)));\napply: (H2 (H2 :+ s)));\nby apply: (H2 (H2 :+ s)));\nby apply: (H2 (H2 (H2 :+ s)));\nby apply: (H2 (H2 :+ s)));\nby apply: (H2 (H2 :+ s)));\napply: (H2 (H2Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nsplit=>H1 H2 H3; first by apply: (H3 _ H3); apply: (H3 _ H3).\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>[n] [n] U; split; first by case=>H1 H2; apply: (IHvs_ok H2).\nby case=>H2 [H3 H4]; apply: (IHvs_ok H4).\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (H \\in dom s) => /=.\nby apply: IH=>//; apply: (IH=>//; apply: (IH=>//; apply: (IH=>//; apply: IH=>//; apply: IH=>//; apply: (IH=>//; apply: IH=>//; apply: IH=>//; apply: IH=>//; apply: IH=>//; apply: IH=>//; apply: IH=>//; apply: IH=>//; apply.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (H1 H2).\n- by apply: (H2 H1).\n- by apply: (H2 H1).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>H1 H2; apply: (safe_safe_bupd H1) =>s [s1' [s2' [H3 H4]] | ];\n  rewrite /tryrecv_form_and.\nby apply: (safe_safe_bupd H2) =>s [s1' [s2' [H4 H5]] | ];\n  rewrite /tryrecv_form_and.\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>H1 H2; split; first by case=>H1 H2; apply: H1.\nby apply: (IHes_step_test H2) => //; apply: H2.\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>H1 [s1 H2]; split; first by apply: (IHss (s:=s1)); apply: (IHss (s:=s1)).\nby apply: (IHss (s:=s1)).\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>H1 H2; apply: (safe_safe_adj _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by move=>H; apply: (safe_safe_det H); apply: (safe_safe_det H); apply: (safe_safe_det H). Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>H1 [s H2] [s]; split; first by case=>H1 H2; apply: (H2 _ H3).\nby case=>H1 [s H2]; case=>H1 H2; apply: (H2 _ H3).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nhave [s1 s2] [s1 s2] [s1 s2] [s2] [s2] /= [s2] /= [s2] /= [s2] /= [s3] /=.\ncase: s1 s2 s2 s2 s2 /= [s1] [s2] /= [s2] /=; first by rewrite (s2P s1) (s2P s2).\ncase: s1 s2 s2 => [|s1 s2] /= [s2] /=; first by rewrite (s2P s2).\ncase: s2 s2 => [|s2] s2] /=; first by rewrite (s2P s2).\ncase: s2 s2 => [|s2] s2] /=; first by rewrite (s2P s2) (s2P s2).\ncase: s2 s2 => [|s2] s2] /=; first by rewrite (s2P s2).\nby case: s2 => // H _; rewrite (s2P s2) (s2P s2).\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>H; apply: send_form_step_some; split=>H.\n- by case: ifP => _; case=>s' H; apply: H.\n- by case=>s' H; apply: H.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nelim: s S => [|x s IH] s /=; first by move=>H; apply: IH.\nmove=>H1; case=>H2; case=>H3; case=>H4; case=>H5; move/(_ _ H5) H6.\ncase=>H7; case=>H7; case=>H8; move/(_ _ H5) H6; move/(_ _ H7) H8.\nby case=>H9; move/(_ _ H5 H6) H7; move/(_ _ H7) H8.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nby case: f=>s S s [s' [H1 H2] H3; split; [apply: (H1 H2)].\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nelim: s => [|a s IH] s IH /= [|b s]; first by exists a.\nby exists (t_ref a); rewrite IH /=?IH.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nsplit=>H; first by exists f'; rewrite /=?H.\ncase: ifP => //= H; apply/andP; split; last by rewrite /=?H.\nby rewrite /=!sstep_star.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nelim: s => [|b s IHs] [c' r'] /=; first by rewrite /send_form_step.\ncase=>H [H1 H2]; case=>H [H1 H2]; case=>H1 H2; case=>H1 H2; case=>H;\ncase=>H1 H1; case=>H; case=>H1; case=>H; case=>H1; case=>H2;\ncase=>H; case=>H1; case=>H2; case=>H3;\ncase=>H; case=>H; case=>H3; case=>H3; case=>H4; case=>H4; case=>H5;\n case=>H5; case=>H5; case=>H5; case=>H6; case=>H6; move=>H7; case=>H7;\ncase=>H7; case=>H8; case=>H8; case=>H8; case=>H7; case=>H8; case=>H8; case=>H8;\n case=>H8; case=>H8; case=>H8; case=>H8; case=>H8; caseQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>s S; elim: s S => //= s1 s2 S H; rewrite /send_form_step.\nrewrite /send_form_step /sstep /= => S1 [c1 S2]; exists c1.\nby rewrite /send_form_cat /= => S2 [c2 S2]; rewrite /send_form_step.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>s S s S H; case=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H; case=>s S H;\n case=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; case=>s S H; case=>s S H; case=>s S H;\ncase=>s S H; case=>s S H; caseQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 479,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>H1 H2; apply: H1;\n[exists n, h = last (dstep d); apply: H2 | exists n, h = next level fs & dvalid d].\napply: H1;\n[exists (last (dstep d)); apply: H2 | exists n, h = next level fs & dvalid d].\nby apply: H1; exists n, h = next level fs & dvalid d].\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>H; apply: (H (dclosed d)); rewrite/dIrr_valid.\ncase: ifP => // _; last by case: ifP.\n- by move=>H; move/eqP=>->; rewrite H=> ->.\nby move=>H; move/eqP; move/eqP=>H; move/eqP=>H; move/eqP=>H; move/eqP=>H.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby move=>H; apply: H; case: H=>n [H1] /H1; exists n.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> H; case: H=>H1 H2; case: H2=>H2 H3; apply: H1.\nmove: H2=>[x][H3 H4] H4; move: H4=>[y][H5] H5; apply: H5.\nmove: H5=>[y][H5] H6; apply: H5.\nby apply: H2.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case/andP: H; apply: H. Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case=> n [n] [n ->] [m] [n ->] [n] [n] [n ->] [n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n] /andP[n]Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nintros H1 H2; apply: H1; case: H2=>H3 H4; case: H3=>H4;\n[apply: H4 | apply: H4 | apply: H5].\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>H1 H2; apply: (H1 (H2 (H3 H3))); apply: H2.\nmove=>m; move: (H1 m); apply: H1.\nby case: ifP H1=>m; rewrite /proj1_sig /= H1 H2 H3.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>H1 H2; apply: H2.\napply: H1; apply: H2.\napply: H2; apply: H2.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>H1 H2; apply: H1.\nby apply: H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 505,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by move=>H1 H2; apply: (H1 H2); apply: H2. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\ncase H: H=>H1 H2; case H1: H1 H2 H3 H4 H5; exists n; auto.\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\ncase=>H; case H; rewrite /unsig; case: ifP =>H1 H2;\n  rewrite /unsig; case: ifP=>H2;\n  by apply: H2.\nmove=>H1; case: ifP=>H1 H2; first by rewrite /unsig; case: ifP H1.\nby rewrite H1 H2 H1 H2 H3 H4 H5 H6.\nQed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by move=>H1 H2; apply: H2. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 535,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case; case=> // H1; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: h=>n H; apply/eqP; rewrite H; apply/eqP; apply/eqP. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nmove=>H; case: ifP=>[H|H].\n- by case: ifP=>[H|H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\n- by case: ifP=>[H|H].\nby case: ifP=>[H|H].\nQed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=>d; rewrite /l2 d_def. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case; case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 686,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n => [|n] /=; constructor; auto. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nmove=> C D; rewrite /lup; case: n=> [|n] C D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D D DQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> D; apply: (iffP idP) => [] [m]; exists (d, m); rewrite?ddvdE?d?dK. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n => // n _; exists 0. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case=> n x y ->. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; split=> // m; exists m. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nmove=> n d; elim: n d => [|n IHn] [|m] d /=; last by exists 0.\nby rewrite!(mulnC, d) //!exprM!intCK.\nQed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n=> [|n] [|m] [|m] [|m] //= /H ->. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n=> //= n ->. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: n=> //= m; rewrite /lref_def; case: n. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: C n v H=>[n]; exists (n, n); rewrite?add0n. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ <-; rewrite H. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ H [_ _ H]]. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case: C => _ [] // /prefix_path H; apply: H. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nmove=> H; case: C H=> /= H1 /=; case: C H1=>//= H2; rewrite {H2}H1.\nby case: C H2=>// H3 _; rewrite {H3}H3.\nQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=> H; case: C=> H /= H /= _; case: C=> H /= _; case: C=> _ _ <-; case: C=> _ _ ->.\nQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ []. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ _ ->. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => _ []. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by case=> H; rewrite /dsat /dded. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: n m=> [|n] [|n] [|n] [|m] //=; rewrite find0n; case: n=> // ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: n m. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nby case: m => [|m] H //=; rewrite findPt; case=>e pf; apply: H.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case=> //= n f; rewrite!nthPt //; case: eqP. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; rewrite nth_default; case: m; rewrite nth_default; case=> // []. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: H => _ []. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case: m => [|m] [|n] //=; rewrite nthPt //; case=> [[]] //; apply. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: m=> [|m]; rewrite!getKn. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by case=> H1 H2; rewrite findPt; case=> // H1; case=>H2; apply/eqP. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: m. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": ".\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby move=>H; apply: findPtUn; [left | exists n, m].\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H1 H2; rewrite /fun /=. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d :+ (d' :+ (d'))))).\nby case: (d :+ (d :+ (d :+ (d :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d' :+ (d'd'))))).\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby move=>H; apply/andP; split; move=> m ->; rewrite findPt; case=> //; case=>->.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: C=>e _ /(_ n H)/eqP. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (del H)=>m ->; rewrite findPt /=; case=> // ->. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; apply: fext; rewrite has_predT. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H1 H2; rewrite!semVector.nil_id. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; apply: jmet_in_pfim to dmr. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; apply: dyn_tp; apply: fret_in_pf. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case=>H1 H2; case: H1=>H2; rewrite findPt; case=>H1 H2; case=>H1; case=>H2; case=>H3; rewrite H3. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; apply: H. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; apply: H. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case=>H1 H2; rewrite /semFmapSize. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H; case: (dreg d m) => [m'|] [|n] [|n] //=;\nby rewrite findPt //; case: eqP => // _; apply: H.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: m => _ []. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: H => _ /(_ n H)/H; apply: H. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H1 H2; apply: H1.\nby apply: H2.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case: d m => _ _ []. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; apply: H. Qed."
                ]
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H'0; try assumption.\napply Trans with (G y); auto with algebra.\napply Trans with (G y); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros; rewrite <- (is_assoc_l (G:=G) (G:=G) (G:=G) (G:=G) (G:=G) (G:=G) (G':=G) (G':=G) (G':=G) (G':=G) (G':=G') (G':=G') (G':=G') (G':=G) (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (G':=G') (GQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (G (ring_mult x (ring_mult y x)) (ring_mult (ring_mult x y) (ring_mult y x)).\napply Trans with (ring_mult (ring_mult x (ring_mult y x)) (ring_mult (ring_mult x y) (ring_mult y x))).\napply Trans with (ring_mult (ring_mult x y) (ring_mult (ring_mult x y) (ring_mult y x))).\napply Trans with (ring_mult (ring_mult x y) (ring_mult (ring_mult x y) (ring_mult y x))).\napply Trans with (ring_mult (ring_mult (ring_mult x y) (ring_mult y x))).\napply Trans with (ring_mult (ring_mult x y) (ring_mult y x)).\napply Trans with (ring_mult (ring_mult (ring_mult x y) (ring_mult y x))).\napply Trans with (ring_mult (ring_mult (ring_mult x y) (ring_mult y x))).\napply Trans with (ring_mult (ring_mult xQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros; apply H1; auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (G x); auto with algebra.\napply Trans with (G y); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (G x y); auto with algebra.\napply Trans with (G y z); auto with algebra.\napply Trans with (G y z); auto with algebra.\napply Trans with (G y z); auto with algebra.\napply Trans with (G y z); auto with algebra.\napply Trans with (G y z); auto with algebra.\napply Trans with (G y z); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros H1 H2 H3.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\napply Trans with (ring_mult (R:=R) (x:=R)); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros P H' H'0 H'1; try assumption.\napply Trans with (G x); auto with sets.\napply Trans with (G x); auto with sets.\napply Trans with (G x); auto with sets.\napply Trans with (G x); auto with sets.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros x y z H' H'0; try assumption.\napply Trans with (G x); auto with algebra.\napply Trans with (G y); auto with algebra.\napply Trans with (G y); auto with algebra.\napply Trans with (G y); auto with algebra.\napply Trans with (G y); auto with algebra.\napply Trans with (G y); auto with algebra.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply Trans with (ring_mult x (monoid_unit G)); auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* use of neutral *)\nelim (H9 x H1); intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H6; intros;\n clear H6 H7 H8 H9 H10 H11.\n(* on signed *)\nelim (H9 x H2); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n clear H6 H7 H8 H9 H10 H11.\n(* on signed *)\nelim (H9 x H3); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10 H11.\n(* on signed *)\nelim (H9 x H3); intros; elim H6; intros; elim H6; intros; elim H6;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim H; intros; elim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H2; intros; elim H4;\n clear H4 H5 H6 H7 H8 H9.\n(* use of neutral *)\nelim (H9 x H2); intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7;\n clear H7 H8 H9 H10 H11.\n(* use of neutral *)\nelim (H10 x H2); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10 H11.\n(* on the right *)\nelim (H12 x H3); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7;\n clear H6 H7 H8 H9 H10 H11.\n(* on the right *)\nelim (H12 x H2); intros; elim H6; intros; elim H6; intros; elim H6; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros; elim H; intros; elim H; intros; elim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H8; intros; elim H7; intros; elim H8; intros; \n elim H8; intros; elim H8; intros; elim H7; intros; elim H7; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 y1); intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros;\n elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 y1); intros; elim H0; intros; elim H1; intros; elim H1; intros; elim H2; intros;\n elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H6Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros;\n elim H6; intros; elim H7; intros; elim H7; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H10; intros; elim H10; intros; \n elim H9; intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H11; intros; elim H12; intros; elim H12; intros; elim H12; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim (H0 y1); intros; elim H0; intros; elim H0; intros; elim H2; intros; elim H2; intros; elim H4;\n clear H4 H5 H6 H7 H8.\n(* use of neutral *)\nelim (H0 x1); intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* on scalar *)\nelim (H0 x1); intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n clear H4 H5 H6 H7 H8 H9 H10.\n(* on scalar *)\nelim (H0 x1); intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H5;\n clear H4 H5 H6 H7 H8 H9 H10.\n(* on scalar *)\nelim (H0 x1); intros; elim H2; intros; elim H2; intros; elim H2;\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H6;\n clear H5 H6 H7 H8 H9.\n(* use of neutral *)\nelim (H10 x H2); intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H4;\n clear H2 H5 H6 H7 H8 H9 H10.\n(* use of neutral *)\nelim (H10 x H2); intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H4;\n clear H2 H5 H6 H7 H8 H9 H10.\n(* use of neutral *)\nelim (H10 x H2); intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H4;\n clear H2 H5 H6 H7 H8 H9 H10.\n(* of neutral *)\nelim (H10 x H2); intros; elim H2; intros; elim H2; intros; elim HQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros; elim H8; intros;\n clear H5 H6 H7 H8 H9.\n(* use of neutral *)\nelim (H9 x H3); intros; elim H6; intros; elim H8; intros; elim H9; intros;\n clear H7 H9.\nelim (H8 x H3); intros; elim H9; intros; elim H9; intros; elim H10; intros; \n clear H10 H11 H12 H12 H12 H13 H14.\n(*case of neutral *)\nelim (H14 x H3); intros; elim H5; intros; elim H10; intros; elim H10; intros;\n clear H11 H12 H13 H14 H15 H16.\n(* on the left *)\nelim (H16 x0 H1); intros; elim H9; intros; elim H12; intros;\n clear H12 H13 H14 H15 H16.\n(* on the right *)\nelim (H16 x0 H1); intros; elim H12; intros; elim H12; introsQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H3; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10.\n(* use of neutral *)\nelim (H7 x0 H2); intros; elim H3; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10 H11.\n(* on the left *)\nelim (H8 x0 x1); intros; elim H3; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10 H11.\n(* on the right *)\nelim (H8 x0 x1); intros; elim H3; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10.\n(* on the right *)\nelim (H8 x0 x1); intros; elim H3; intros; elim H6; intros; elim H6;\n clear H6Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros.\nrewrite <- (opp_involutive x) in H0; rewrite <- (opp_involutive x) in H0; rewrite <- H0 in H0;\n rewrite <- H0 in H0; rewrite <- H1 in H0;\n rewrite <- H1; rewrite <- H1; rewrite <- H1; rewrite <- H2;\n rewrite <- H1; rewrite <- H2; rewrite <- H2; reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (inv_opp (Add x y) (Add y x)); elim (inv_opp (Add x y) x y H);\n auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (inv_left x y H); trivial.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (add x y)); intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n clear H2 H3 H4 H5 H6.\nrewrite <- (inv_inv x y H3) in H0; rewrite (inv_inv x y H3) in H0; assumption.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H (Add x y) (Add x y)); intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n clear H4 H5 H6 H7 H8.\nelim (H x2); intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros;\n clear H5 H6 H7 H8 H9 H9 H10.\n(* on the left *)\nelim (H x2); intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros;\n clear H5 H6 H7 H8 H9 H10.\n(* on the right *)\nelim (H x2); intros; elim H5; intros; elim H6; intros; elim H7; intros; elim H7; intros;\n clear H5 H6 H7 H8 H9 H10.\n(* on the left *)\nelim (H0 x2); intros; elim H5; intros; elimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* use of neutral *)\nelim (H0 y H0); intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H6; intros;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on the left *)\nelim (H H0); intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros;\n clear H7 H8 H9 H10 H11 H12.\n(* on the right *)\nelim (lem_cartesian_propertie a a' a'); intros; apply H; assumption.\n(* with a' = a' *)\nelim (lem_cartesian_propertie a' a'); intros; apply H; assumption.\n(* with a' = a' *)Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim (H x y H); intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7; intros; elim H8; intros; elim H8; intros; elim H9; intros; \n elim H6; intros; elim H6; intros; elim H8; intros; elim H9; intros; elim H10; intros; elimQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (inv_is_distrib (Inv x) (Inv y)); elim (Inv x y); auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H H0 H1; elim H0; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; \n elim H7; intros; elim H6; intros; elim H7; intros; \n elim H6; intros; elim H7; intros;Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n clear H4 H5 H6 H7.\n(* on natural *)\nelim (H1 x H2); intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* on natural *)\nelim (H1 x H2); intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* of var *)\nelim (H1 x H3); intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11.\n(* of var *)\nelim (H1 x H3); intros;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold opp at 1.\nrewrite opp_involutive.\nrewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive (opp x)); trivial.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold Rdiv in |- *.\nrewrite (mult_comm (fun x => mult (mult x x)) (opp x)).\nrewrite (mult_comm (fun x => mult (mult x x)) (opp x)).\nrewrite (mult_comm (fun x => mult (mult x x)) (opp x)).\nrewrite (mult_comm (fun x => mult (mult x x)) (opp x)).\nrewrite (mult_comm (fun x => mult (mult x x)) (mult x)).\nrewrite (mult_comm (fun x => mult (mult x x)) (mult x)).\nrewrite <- (mult_comm (fun x => mult (mult x x)) (opp x)).\nrewrite <- (mult_comm (fun x => mult (mult x x)) (mult x)).\nrewrite <- (mult_comm (fun x => mult (mult x x)) (mult x)).\nrewrite <- (mult_comm (fun x => mult (mult x x)) (mult x)).\nrewrite <- (mult_comm (fun x => mult (mult x x)) (mult x)).\nrewrite <- (mult_comm (fun x => mult (mult x x)) (multQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_opp x).\napply opp_opp; auto.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold on_empty in |- *.\nsplit; [ try assumption | try assumption ].\nsplit; [ try assumption | try assumption ].\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj; try assumption.\napply opp_inj;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in H.\nrewrite <- (opp_involutive x) in HQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x) in H; rewrite H; rewrite H0; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold is_midpoint, Py;simpl.\nrewrite (opp_involutive x); rewrite (opp_involutive x); rewrite (opp_involutive x); reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold multiplication in |- *.\nelim (H x); intros; elim H2; intros; elim H2; intros; elim H4; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7;Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nunfold Opp, respectful, opp, opp, opp; simpl; intros.\napply (ring_opp (x + -x)); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x); rewrite <- (opp_involutive x); trivial.\nrewrite opp_opp; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.\nrewrite opp_involutive; trivial.Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x) in H.\nelim H; intros; elim H2; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H14.\n(* [x+y] *)\nelim H; intros; elim H2; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6;\n clear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H14.\n(* [x+y] *)\nelim H; intros; elim H3; intros; elim H3; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H6;\n clear H6 H7 H8 H9 H10 H11 H12 H13 H14.\n(* [x+y] *)\nelim H0Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp y)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (opp_involutive (opp x)) in H.\nrewrite (Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_repeat (fun x y => opp_mult (x + y)) (opp_mult x y));\n apply opp_add; auto.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intros.\nelim H; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5; intros; elim H6; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; \n elim H7; intros; elim H8; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nunfold not in |- *; intros.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.\nrewrite (opp_involutive x) in H.Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x));\n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x));\n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x));\n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); \n rewrite (opp_involutive (opp x)); rewrite (opp_involutive (opp x)); \nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive (opp x)) in |- *; rewrite <- (opp_involutive x).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp y)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (opp x)).\nrewrite <- (opp_involutive (oppQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x).\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x) at 1.\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (oppQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_involutive x) at 1.\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (oppQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_inj (opp_involutive (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp_involutive (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp_opp (opp (opp y))))))))).\napply opp_involutive; auto.\napply opp_involutive; auto.\napply opp_involutive; auto.\napply opp_involutive; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H H'; elim H'; intros; elim H'; intros; clear H'.\nelim (opp_involutive (O*x)); intros; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; rewrite opp_seq.\nrewrite opp_seq.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivial.\nrewrite opp_seq; trivialQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\napply (opp_inj (opp:=opp)).\nred in |- *; intros.\nelim H; intros; elim H0; intros; elim H0; intros; clear H0 H1; intros; elim H0; intros; clear H0 H1;\n intros; elim H1; intros; clear H1 H2; intros; elim H2; intros; clear H1 H2;\n intros; elim H2; intros; clear H2 H3 H4 H5; intros; elim H3; intros; clear H3 H4 H5; \n intros; elim H5; intros; clear H5 H6; intros; elim H6; intros; clear H6; \n intros; elim H6; intros; clear H6; intros; elim H6; intros; clear H6; \n intros; elim H6; intros; clear H6; intros; clear H6; elim H6; intros; clear H6; \n intros; elim H6; intros; clear H6; intros; clear H6; intros; elim H6; \n intros; clear H6; intros; elim H6; intros; clear H6; \n intros; elim HQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros H; rewrite H; apply opp_0; auto.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; symmetry  in |- *;\n apply (opp_inj (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_involutive (opp_Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; rewrite <- opp_involutive; rewrite <- opp_involutive; rewrite <- opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite <- opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite <- opp_involutive; rewrite <- opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; elim H; intros; rewrite H; rewrite H0; trivial.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; unfold Opp, Opp, Opp, Opp, Opp, multiplication in |- *;\n repeat rewrite (opp_involutive O); simpl in |- *; auto with zarith.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintro H; rewrite <- (opp_involutive (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp (opp_opp (opp (opp (opp_opp (opp (opp y)))))))))))).\nrewrite H; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive; rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  destruct H as [H0|H0].\n  (* Check that this is in the paradox *)\n  exact H0.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x y.\ncase (ex_intro P H x); intros.\nexists (fun y : A => P y /\\ R y x)); split.\nred in |- *; intros.\nelim H; intros.\nsplit; auto.\napply H0; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0.\n  match goal with\n  | |- (forall y : A, R y y) ->?P x =>\n      match goal with\n      | |- (forall y : A, R y y) ->?P x =>\n        match goal with\n        | |- (forall y : A, R y y) ->?P x =>\n          match goal with\n          | |- (forall y : A, R y y) ->?P y =>\n            match goal with\n            | |- (forall y : A, R y y) ->?P y =>\n              match goal with\n              | |- (forall y : A, R y y) ->?P y =>\n              match goal with\n              | |- (forall y : A, R y y) ->?P y =>\n              match goal with\n                | |- (forall y : A, R y y) ->?P y =>\n              match goal with\n                | |- (forall y : A, R y y) ->?P y =>\n                match goal with\n                | |- (forall y : A, R y y) ->?P y =>\n                match goal with\n                | |- (forall y : A, R y y) ->?P y =>\n                  match goalDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0; elim H; intros H'1 H'2; clear H'1.\n  elim H'2; intros H'3 H'4; elim H'4; clear H'2.\n  clear H'4.\n  elim H'3; intros H'4 H'5; elim H'5; clear H'5.\n  clear H'4.\n  elim H'4; intros H'5 H'6; elim H'6; clear H'6.\n  clear H'5.\n  elim H'6; intros H'6 H'7; elim H'7; clear H'6.\n  clear H'6.\n  clear H'5.\n  elim H'6; intros H'6 H'7; elim H'7; clear H'6.\n  clear H'6.\n  clear H'6.\n  elim H'6; intros H'7 H'8; elim H'7; clear H'6.\n  clear H'7.\n  clear H'6.\n  clear H'7.\n  elim H'6; intros H'7 H'8; elim H'7; clear H'6.\n Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  dependent inversion 1 as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion H as [P H].\n  dependent inversion HDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0; case (ex_intro _ _ H); clear H; intros H0.\n  case (ex_intro _ _ H); clear H; intros H1.\n  left; auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x.\ncase H; intros H'0 H'1; clear H'1.\nsplit; [ intros H'3; elim H'3; intros H'4 H'5; clear H'3 | intros H'5 ];\n auto.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H P H0.\n  split; intro.\n  apply H0.\n  apply H0.\n  apply H1.\n  assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nintros A P H x0.\ndestruct H0.\napply H0.\napply H0.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H x0; elim H; intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S x0 x1).\nsplit; trivial.\napply inv_trans with (S x1); auto with arith.\napply inv_trans with (S x1); auto with arith.\napply inv_trans with (S x0); auto with arith.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction S using (well_founded_ind (fun x y => left; exists x : S, I x y); trivial.\nintros x0 y0 y1 y2 y3 H1 H2 H3.\nelim H3; intros x1 y2 y3 H4.\nexists (S x1 y1).\nexists (S x1 y2).\nsplit.\napply inv_step.\napply inv_trans with y1; assumption.\napply inv_step.\napply inv_trans with y2; assumption.\napply inv_trans with y1; assumption.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S x0).\napply (inj_ind (S x0)).\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nsimple induction 1; simpl in |- *; intros.\nelim (H _ _ H0).\nelim H2; intros.\nexists x0; auto.\nelim H3; intros.\nexists x0; auto.\nelim H3; intros.\nexists x1; auto.\nelim H4; intros.\nexists x2; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x2; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x2; auto.\nelim H5; intros.\nexists x2; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x1; auto.\nelim H5; intros.\nexists x2; auto.\nelim H5; intros.\nexists x2; auto.\nelim H5; intros.\nexists x1;Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (fun x y => (fun x y => (fun x y => (fun x y => (fun x y => (fun x y => (fun x y => x y) = I) /\\ I = I) /\\ I = I).\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit; trivial.\nsplit;Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S (S (S x0)).\nrewrite (IH x0).\nrewrite <- H1; rewrite <- H2; apply inv_inv12.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros; try assumption.\nexists (S x0).\napply inv_step.\nelim H0; trivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nsimple induction 1; intros; try discriminate.\nexists x0; exists y; exists y; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists x0; auto.\nelim H; intros.\nexists x1; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists I; split; trivial.\nelim H1; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z.pow at 1 in |- *.\nrewrite <- Z_sub_0_l.\napply Z_mult_nonneg; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  intros; simpl in |- *; elim x; simpl in |- *; auto.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  unfold Z.lt.\n  rewrite Z_sub_0_r.\n  apply Z_sub_0_r.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\ntrivial with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\ntrivial.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nintros x; red in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n constructor.\napply Z_sub_eq_0_abs.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group.\nintros x.\nrewrite <- Z_group_nat_o_P.\nunfold Zminus, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group, Z_to_group.\nintros x.\nrewrite <- (Z_group_nat_o_P x).\nrewrite <- (Z_group_nat_o_P x).\nrewrite <- (Z_group_nat_o_P x).\napply Z_of_P_eq_Z_eq_Z_eq.\nrewrite Z_of_P_eq_Z_oQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nintros x H'; try assumption.\napply Z_mult_1_l.\nunfold Z.succ.\napply Z.opp_involutive.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nintros x; unfold Z.pow in |- *; simpl in |- *.\napply Z_mult_1_l; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z, Z in |- *; simpl in |- *.\nintros H; discriminate.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\ngeneralize Z_power_pos_pos; intros p; elim p.\nunfold Z_power_pos in |- *; simpl in |- *.\nintros H; rewrite H; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.pow in |- *.\nintros H; rewrite H; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nunfold Z in |- *; simpl in |- *.\nrewrite Zmult_comm; rewrite Zmult_comm; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nsplit; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.of_nat in |- *.\nintros H; elim H; intros; auto.\napply Z_mult_l; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nauto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nunfold opp at 1 in |- *.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *.\nintros.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comp.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comp.\napply Z_mult_comm.\napply Z_mult_comm.\napply Z_mult_comp.\napplyQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_upper_bound, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_nat, Z_of_natQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_upper_bound, Z, Z, Z, Z, Z, Z, Z, Z.pow, Z, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow, Z.pow.\nintros; apply Z_div_exact; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\napply Z_mult_l; auto with zarith.\nred in |- *; auto with zarith.\nsplit; auto with zarith.\napply Z_mult_l; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nunfold Z in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nunfold char_mult in |- *; auto with zarith.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros x H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarith.\nintros a H'; try assumption.\napply Build_abelian_stable_stable_stable; auto with zarithQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zeg Fy, Z_of_nat in |- *.\napply Z_mult_n_O; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zeg:_, Z4 in |- *; auto.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zact, Zpr, Zdiv, Zdiv in |- *.\napply Z_mult_morphism.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_of_nat, Z in |- *; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZernZ, ZernZ, ZernZ, ZernZ, Zmk_nat, ZernZ, Zfactor_bound, Zfactor_bound, Zfactor_bound.\nintros p Hp; unfold Zfactor_bound in |- *.\nrewrite Z_mult_comm.\napply Zmult_gt_0_lt_compat; auto with zarith.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nrewrite <- Heq.\nunfold Zfactor_bound in |- *.\nrewrite <- Heq.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nrewrite <- Heq.\nunfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nintros p Hp; unfold Zfactor_bound in |- *.\nunfold Zfactor_bound in |- *.\nunfoldQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zdiv in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZAdd in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zegode, Zer at 1 in |- *.\nsimpl in |- *.\nunfold Zer at 1 in |- *.\nsimpl in |- *.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_assoc.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_commQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Zer in |- *.\nunfold Zer in |- *.\nunfold Zer in |- *.\nunfold Zer in |- *.\nunfold Zer in |- *; simpl in |- *.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_comm.\nrewrite Zmult_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold ZCMZ, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z, Z.abs in |- *.\nintros; red in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red in |- *; auto with zarith.\nintros; red inQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; right; case x; simpl in |- *; auto.\nintros H; right; red in |- *; intros H; discriminate.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; right.\ngeneralize H; clear H; simpl in |- *; case x; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros; rewrite H; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H.\ngeneralize (Z_div_mod_eq_full x H).\nunfold div in |- *.\nintros x H0; generalize (Z_div_mod_eq_full x H).\nunfold div in |- *.\nintros x H1; generalize (Z_div_mod_eq_full x H0); unfold div in |- *.\nintros x H1; generalize (Z_div_mod_eq_full x H1); unfold div in |- *.\nintros x H2; generalize (Z_div_mod_eq_full x H0); unfold div in |- *.\nintros x H2; generalize (Z_div_mod_eq_full x H1); unfold div in |- *.\nintros x H3; generalize (Z_div_mod_eq_full x H3); unfold div in |- *.\nintros x H3; generalize (Z_div_mod_eq_full x H3); unfold div in |- *.\nintros x H3; generalize (Z_div_mod_eq_full x H3); unfold div in |- *.\nintros x H3; generalize (Z_div_mod_eq_full x HQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; unfold inversable_carrier in |- *.\nintros x H; rewrite H; simpl in |- *.\napply (invVfullZ x) with (Z_of_nat 0);\n auto with zarith.\n(* pos n *)\nintros x0; elim x0; intros; simpl in |- *.\napply (invVfullZ x) with (Z_of_nat 1); auto with zarith.\n(* pos n *)\nintros; simpl in |- *.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros H1 H2; rewrite H1; rewrite H2; ring.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x; case x; case x; intros; simpl in |- *; auto.\nintros; right; red in |- *; auto.\nintros; left; red in |- *; auto.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; apply H1; applyQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; intros.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; left; discriminate.\nintros; right; red in |- *; intros; discriminate.\nintros; left; discriminate.\nintros; left; discriminate.\nintros; right.\nred in |- *; intros; discriminate.\nintros; right.\ngeneralize H; clear H; simpl in |- *.\nintros; discriminate.\nintros; right.\ngeneralize H; clear H; simpl in |- *.\nintros; discriminate.\nintros; right.\ngeneralize H; clear H; simpl in |- *.\nintros; discriminate.\nintros; right.\ngeneralize H; clear H; simpl in |- *.\nintros; discriminate.\nintros; right.\ngeneralize H; clear H; simpl in |- *.\nintros; discriminate.\nintros; right.\ngeneralize H; clear H; simpl in |- *.\nintros; discriminate.\nintros; left.\ngeneralize H; clear H;Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; intros H; elim H; intros H1; elim H1; intros H2; elim H2; intros H3 H4;\n elim H4; intros H5 H6; elim H6; intros H7 H8;\n elim H6; intros H9 H10; elim H10; intros H11 H12;\n elim H12; intros H13 H12; elim H12; intros H13 H14;\n elim H12; intros H12 H13; elim H13; intros H13 H14;\n elim H14; intros H15 H16; elim H17; intros H16 H17;\n elim H18; intros H18 H19; elim H18; intros H18 H19;\n elim H18; intros H18 H20; elim H18; intros H18 H19;\n elim H18; intros H18 H20 H18; elim H18; intros H17 H18;\n elim H18; intros H18 H19; elim H18; intros H18 H19;\n elim H18; intros H18 H19; elim H18; intros H20 H20;\n elim H18;Qed."
                ]
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 334,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* Proof of lem_reunion_vide                                             *)\nunfold Vide in |- *; intros.\napply axs_extensionnalite; unfold iff in |- *; split; intros.\nunfold Vide in H.\nelim (axs_reunion (reunion (reunion (reunion (singleton 0))) v2); intros.\nelim H0; clear H0 H1; intros.\nexists (paire (singleton x) (paire (singleton x) (paire (singleton x) (paire (singleton x) (paire x v2)) H0);\n intros.\nrewrite H2; clear H2 H3; intros.\nelim H; clear H; intros.\nexists x; exists (paire x v2); split;\n [ auto with zfc | split; [ auto with zfc | reflexivity ] ].\n\nunfold Vide in |- *.\nelim (axs_reunion (reunion (paire x v2)) v2); intros.\nelim H0; clear H0 H1; intros.\nexists x; exists (paire x v2); split;\n [ auto with zfc | split; [ auto with zfc | reflexivity ] ].\nunfold Vide in |- *.\nelim (axs_reunion (paire x v2) v2); intros.\nelimQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; auto with zfc.\n\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *.\nintros; apply axs_extensionnalite; unfold iff in |- *; split; intros.\nelim H; intros; elim H0; intros.\nsplit; [ intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H2 | idtac ].\nelim H; intros; elim H0; intros; elim H1; intros; clear H1;\n elim H2; intros; clear H2; intros.\nunfold Vide in H0.\nelim H0; intros.\nunfold Vide in H1.\nelim H1; intros.\nunfold Vide in H1.\nelim H1; intros.\ngeneralize (H2 x H4); intros.\nunfold Vide in H4.\nelim H3; intros.\nunfold Vide in H4.\nelim H4; intros.\nunfold Vide in H4.\nelim H4; intros.\nelim H4; intros.\nunfold Vide in H4.\nelim H4; intros.\nunfold Vide in H4.\nelim H4; intros.\nunfold Vide in H4.\nelim H4; intros.\nelim H4; intros.\nunfold Vide in HQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* Proof of lem_reunion_vide.\n\n(* Proof of lem_reunion_vide.\n\n(* Proof of lem_reunion_vide.\n\nunfold Vide in |- *; intros.\nelim H; clear H; intros; clear H H0.\nelim (lem_vide_propertie x x0); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_paire (singleton x) (paire x x0)); intros.\nunfold Vide in H0.\nelim (axs_Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E H; elim H; clear H; auto with algebra.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* The empty set *)\n\nDefinition empty : Prop := empty.\nDefinition empty_is_empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty empty.\n\nDefinition empty : Prop := empty.\n\n(* The empty set is empty in the empty set *)\n\nDefinition empty : Prop := empty.\n\nDefinition empty_not_empty : False := empty.\n\n(* The empty set is empty in the empty set *)\n\nDefinition empty_not_empty : Prop := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_not_empty : False := empty.\n\nDefinition empty_Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* Proof of lem_reunion_vide                                            *)\nintros; apply axs_extensionnalite; intros.\nelim H0; intros; elim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H1; intros; clear H1.\nelim H2; intros; clear H1.\nelim H1; intros; clear H1.\nelim H2; intros; clear H2.\nelim H2; intros; clear H2.\nelim H3; intros; clear H3.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear H4.\nelim H4; intros; clear HQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nintros E H; elim H; clear H; intros.\nelim H0; clear H0; intros.\nelim (lem_vide_propertie x x0); intros.\nelim H1; clear H1; intros.\nelim (lem_vide_propertie x x0); intros.\nelim H1; clear H1; intros; elim H1; clear H1; intros.\nelim (lem_vide_propertie x x0); intros.\nelim H1; clear H1; intros.\nelim (lem_vide_propertie x x1); intros.\ngeneralize H1; rewrite H3; intros.\nrewrite H4; rewrite H5; reflexivity.\n\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* Proof of lem_reunion_vide                                              *)\nunfold Vide in |- *; intros.\nelim H; clear H; intros.\nelim H1; clear H1; intros; clear H1; intros.\nelim H2; clear H2; intros; clear H2; intros.\nelim H3; clear H3; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros; clear H5; intros.\nelim H5; clear H5; intros.\nelim H6; clear H5; intros; clear H5; intros.\nelim H6; clear H5; intros.\nelim H6; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H6; clear H6; intros.\nelim H5; clear H5; intros.\nelim H5; clearQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* The empty set *)\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\n(* The empty set *)\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\n(* The empty set *)\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\n(* The empty set *)\n\nDefinition empty : Prop := empty.\n\n(* The empty set *)\n\nDefinition empty : Prop := empty.\n\n(* The empty set *)\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\nDefinition empty : Prop := empty.\n\n(* The empty set *)\n\nDefinition empty : Prop := empty.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n(* Proof ofut_vide_vide_vide_is_empty_vide_vide. *)\nintros E H; elim H; intros; elim H; intros; elim H; intros.\nelim (lem_vide_vide E); intros; elim H1; intros; elim H1; intros.\nelim (lem_vide_vide E); intros; elim H1; intros; elim H2; intros.\nelim (lem_vide_vide E); intros; elim H3; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H4; intros; elim H5; intros.\nelim (lem_vide_vide E); intros; elim H5; intros; elim H5; intros; elim H5; intros.\nelim (lem_vide_vide E); intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H6; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elimQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; cut (F (fun x : E => ~ In E x)).\nintro; split; [ try assumption | idtac ].\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *; intros; apply H; assumption.\nred in |- *;Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; red in |- *; intros.\nelim H; intros x E; elim x; intros H0 H1; clear H.\nelim H; intros; elim H1; intros; clear H1.\nsplit; [ exact (proj2 H1).\nsplit; [ exact (proj2 H2).\nsplit; [ exact (proj1 H2).\nsplit; [ exact (proj2 H3).\nsplit; [ exact (proj2 H3).\nsplit; [ exact (proj1 H3).\nsplit; [ exact (proj1 H3).\nsplit; [ exact (proj2 H3).\nsplit; [ exact (proj2 H3).\nsplit; [ exact (proj2 H3).\nsplit; [ exact (proj2 H4).\nsplit; [ exact (proj1 H4).\nsplit; [ exact (proj1 H4).\nsplit; [ exact (proj1 H4).\nsplit; [ exact (proj1 H4).\nsplit; [ exact (proj1 H4).\nsplit; [ exact (proj1 H4).\nsplit; [ exact (proj2 H4).\nsplit; [ exact (Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n(* The empty set *)\n\nTheorem empty_def_empty_is_empty_is_empty : forall E : Ens, ~ empty E -> False.\nunfold not in |- *; intros E H; cut False.\nsimple induction 1; intros.\nelim H; intros; elim H0; intros; elim H1; intros.\nelim H; intros; elim H1; intros.\nelim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5;\n clear H5; intros.\nelim H6; intros; elim H6; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n clear H7; intros.\nelim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8;\n clear H8; intros.\nelim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H8; intros; elim H7;\n clear H7;Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n(* The empty set *)\n\nTheorem empty_def_vide : forall A : Ens, ~ empty A.\n(* The empty set *)\n\nTheorem empty_def_vide : forall A : Ens, ~ empty A.\n(* Proof of_empty_def_vide.\n*)\nintros A H; elim H; intros H0 H1; elim H1; intros H2 H3; elim H3;\n intros H3 H4; elim H4; intros H5 H6; elim H6; intros H7 H8;\n elim H7; intros H8 H9; elim H9; intros H11 H12; elim H13;\n intros H15 H15; elim H15; intros H16 H17; elim H15; intros H16 H17;\n elim H17; intros H18 H20; elim H18; intros H20 H21; elim H18;\n intros H18 H20; elim H18; intros H20 H21; elim H18; intros H18 H20;\n elim H20; intros H18 H21; elim H19; intros H20 H20; elim H18; intros H20 H21;\n elim H25;Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n(* The empty set *)\nTheorem empty_is_empty_is_empty_is_empty_is_empty_not_empty :\n forall (F : Ens -> Prop) (E : Ens),\n (forall x : E, ~ In x E -> ~ In x F) -> ~ In x F.\n(* Proof of empty_is_empty_is_empty_is_empty_not_empty_not_empty_is_empty_not_empty_not_empty_is_empty_is_empty_not_empty_not_empty\n    empty_is_empty_is_empty_is_empty_is_empty_not_empty_is_empty_is_empty\n    empty_is_empty_is_empty_is_empty_is_empty_is_empty_not_empty\n    empty_is_empty_is_empty_is_empty\n    empty_is_empty_is_empty_is_empty_is_empty_is_empty\n    empty_is_empty_is_empty_is_empty\n    empty_is_empty_is_empty_is_empty\n    empty_is_empty_is_empty_is_empty\n    emptyQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; unfold not in |- *; intros E H; elim H; intros.\nelim (lem_vide_is_empty E H); intros.\nelim H; intros; elim H0; intros; elim H1; intros.\nunfold Vide in |- *; apply H; assumption.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros; split; intros; split;\n [ exact (lem_vide_vide_is_empty E) | idtac ].\nunfold not in |- *; intros; apply H; assumption.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n(* The empty set *)\n\nTheorem empty_is_empty_is_empty_is_empty_is_empty :\n forall (F : Ens) (f : is_empty E), ~ empty E -> ~ empty E -> False.\nunfold not in |- *; intros F f H; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.\nsplit.\nunfold not in |- *; intros; apply H; clear H.Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; apply H; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; elim H; intros H1 H2; elim H2; intros H3 H4;\n elim H3; intros H1 H2; elim H3; intros H4 H5;\n elim H5; intros H6 H7; elim H7; intros H8 H9; elim H10;\n clear H7 H8.\nelim H; intros H1 H2; elim H3; intros H6 H7; elim H7;\n clear H5 H6 H7.\nelim H; intros H1 H2; elim H4; intros H6 H7; elim H7;\n clear H5 H6.\nelim H; intros H1 H2; elim H2; intros H1 H2; elim H2;\n clear H; intros H1 H2; elim H2; intros H2 H3; elim H3;\n clear H3; intros H1 H2; elim H3; intros H4 H5 H6; elim H7;\n clear H3; intros H1 H2 H3; elim H3; intros H4 H5; elim H5;\n clear H5; intros H1 H2 HDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; elim H; intros; elim H; intros; elim H; intros;\n elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5;Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; exists (fun x : E => x).\nelim H; intros x H'; elim H'; intros H'0 H'1; clear H'.\nelim (lem_cartesian_propertie (couple x y) (couple x y)); intros; apply H'2;\n auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; elim H; auto with zfc.\n\nDefinition indprod (E F' : Ens) := union (cart E F) (cart F F').\n\nDefinition CoS : Ens := Set.\n\nDefinition F : Ens := Set.\n\nDefinition D : Ens := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\n\nDefinition D := Set.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\napply (Build_Map (E:=E) (F:=fun f : E => f)).\nred in |- *; auto with algebra.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintro E; elim E; auto with zfc.\n\nTheorem single_neg_pos : forall E : Ens, ~ (exists x : E, x = couple x E).\nintro E; elim E; auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; elim H; clear H; intros; elim H; clear H; intros;\n elim (lem_vide_inter_vide_vide A e H); intros;\n elim H0; intros; elim H0; intros; elim H0;\n intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H2; intros; elim H3; intros;\n elim H4; intros; elim H4; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros;\n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H5; intros; \n elim H6; intros; elim H6; intros; elim H5; intros; \n elim H6; introsDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; elim H; intros H'0; elim H'0; intros H'1; elim H'0; intros H'2 H'3;\n elim H'3; intros H'3 H'4; elim H'5; intros H'5 H'6;\n elim H'6; intros H'6 H'7; elim H'7; intros H'8 H'9; clear H'6 H'8;\n elim H'8; intros H'9 H'10; clear H'8 H'9; elim H'9; intros H'10 H'10;\n elim H'10; intros H'10 H'11; clear H'10; intros H'10 H'11; clear H'11;\n elim H'11; intros H'10; clear H'11; intros H'12 H'12; clear H'10;\n elim H'12; intros H'13 H'12; clear H'10; intros H'13; clear H'13;\n elim H'13; intros H'13 H'14; clear H'13;\n elim H'13; intros H'14 H'Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H; try assumption.\nelim H; intros x E'; elim E'; intros H'0 H'1; elim H'1;\n clear H'1.\nexists (e x); auto with zfc.\n\nTheorem single_neg_neg :\n forall E : Ens, ~ In E E -> ~ Equal E E.\nunfold not in |- *; intros E H; elim H; intros H0 H1; elim H1;\n clear H1.\nexists (e x); auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' x; elim x; auto with zfc.\n\nDefinition right_empty : forall E : Ens, ~ E -> False.\nintros E E' x; elim x; auto with zfc.\n\nDefinition right_empty : forall E : Ens, ~ E -> False.\nintros E E' x; elim x; auto with zfc.\n\nTheorem single_def : forall E : Ens, ~ ~ E -> False.\nintros E E' x; elim x; auto with zfc.\n\nTheorem single_def : forall E : Ens, ~ In E E -> False.\nintros E E' x; elim x; auto with zfc.\n\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 537,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (lp_alire (couple A' B)).\nred in |- *; intros A' B' H; red in |- *; intro H0; elim H0;\n clear H0; intros H0 H1; elim H1;\n clear H1; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; introsQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Sym, Gram, un, single, un, un, un, un, un in |- *; intros A A' B H; split;\n [ assumption | idtac ].\nred in |- *; intro; red in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in |- *; intro; red in H; apply H.\nred in |- *; intro; red in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in H; apply H.\nred in |- *; intro; red in |- *; intro; red in H; apply H.Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (Asubce_of_Map (Ap:=fun f : E => match f return Prop with\n                              | true => True\n                            | false => True\n                              end)).\nintros A A' B B H'.\napply (Asubce_of_Map (Ap:=fun f : E => match f return Prop with\n                              | false => True\n                                 | false => True\n                            end)).\nintros A A' B B H'.\napply (Asubce_of_Map (Ap:=fun f : E => match f return Prop with\n                              | false => True\n                                  | false => True\n                              end)).\nintros A A' B H'.\napply (Asubce_of_Map (Ap:=fun f : E => match f return Prop with\n                              | true => True\n                            | false => True\n                           end)).\nintros A' B B H'.\napply (Asubce_of_Map (Ap:=fun f : E => match f return Prop with\n                              | false => True\n                                | false => True\n                           end)).\nintros A A' B H'.\napply (Asubce_of_Map (Ap:=fun f : E => match f return Prop with\n                              | true => True\n                                 | falseQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (inc_to_inc (fun A' B' : Ens => EQ (Var A' A') (compc A' B'))).\nred in |- *; intros A' B' H b.\nelim H; intros x0; elim x0; clear x0.\nelim b.\nunfold paort in |- *; intros A' B' H b.\nelim b.\nunfold paort in |- *; intros A' H b.\nelim b; intros x1 H1; elim H1; clear H1.\nelim b; intros H1 H2; elim H2; clear H2.\nelim H; intros H2 H3; elim H3; clear H3.\nelim (H x1); intros H3 H4; elim H4; clear H4.\nelim H4; intros H5 H6; elim H6; clear H6.\nelim (H x1); intros H6 H7; elim H7; clear H7.\nelim (lem_cartesian_propertie (couple x0 x2) (couple x3 x3)); intros; apply H6;\n clear H6 H7; intros.\nexists x1; splitQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (inc_par A B).\napply (inc_par A' B).\nexact (inc_par A' B).\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 A)))); auto with zfc.\n\nexact (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 A)))); auto with zfc.\n\nexact (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 A)))); auto with zfc.\n\nexact (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3))));))));\n auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A A' B.\napply (inc_co_fun A A' B (inc_co_fun A' B)).\nexact (inc_co_fun A' B (inc_co_fun A' B)).\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A A' B.\napply (incident_equality A' B); auto with algebra.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (paort A B A' B).\nexact (paort A B A' B).\nexact (paort A' B A' B').\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (mport_lr (empty A) (empty A) (empty A) H).\nexact (axort_lr (empty A) (empty A) H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 603,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Drant in |- *.\nunfold blro in |- *; simpl in |- *; intros A B' H H0; elim H0; intros a H H0;\n elim H0; intros x0 H1; elim H1; intros H2 H3; elim H3; intros H4 H5;\n elim H5; intros H5 H6; elim H6; intros H6 H7;\n elim H7; intros H7 H8; elim H7; intros H8 H9; clear H7 H8.\nelim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold paident in |- *; simple induction A; simpl in |- *; intros;\n elim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold singleer, right in |- *; simpl in |- *.\nintros; split.\napply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply NNPP; intro; apply not NNPP; intro; apply not NNPP; intro; apply not NNPP; intro; apply NNPP; intro; apply not_all_not_in_empty_not_empty.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Albeta in |- *.\nintros A B A' B' H H0; split.\nintros; elim (H0 (a x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Frant in |- *.\nintros; split.\nsimple induction x; simpl in |- *.\nexists false; auto with zfc.\n\nintros; elim (H x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Provide_union in |- *; simpl in |- *; intros A B B' H H0; split.\napply paire_unicity.\napply (lem_tout_vide_contains_empty_is_empty A B).\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Laup in |- *; simpl in |- *.\nintros; split.\nintro; apply NNPP; intros x y H0; elim H0; intros.\nunfold paort in |- *; elim H0; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold paort in |- *; elim H1; intros.\nunfold pbort in |- *; elim H1; intros.\nunfold pbort in |- *; elim H2; intros.\nunfold pbort in |- *; elim H1; intros.\nunfold pbort in |- *; elim H2; intros.\nunfold pbort in |- *; elim H2; intros.\nunfold pbort in |- *; elim H3; intros.\nunfold paort in |- *; elim H4; intros.\nunfold pbort in |- *; elim H4; intros.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold pbire in |- *; simpl in |- *; intros A B B B' H H0; split;\n [ elim (H0 (camen_before_two_reads A B' H1)); intros x H0; elim H0;\n intros x H0; elim H0; intros H1 H2; elim H2; intros H3 H4; elim H4;\n intros H5 H6; elim H5; intros H6 H7; elim H6; intros H7 H8; elim H9;\n intros H9 H10; elim H10; intros H12 H13; elim H13; intros H14 H15;\n elim H15; intros H15 H16; elim H16; intros H17 H18; elim H18;\n intros H18 H18; elim H18; intros H18 H18; elim H18;\n intros H18 H18; elim H18; intros H18 H18; elim H18;\n intros H20 H21; elim H18; intros H18 H20; elim H18; intros H18 H20;\n elim H18; intros H18 H20 H21; elim H18; intros H20Qed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold FSC,herire in |- *; simpl in |- *; intros A B B' H H0; red in |- *;\n intros A B' H H0; split.\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nintros.\napply (incident_eq A B); auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold pbire in |- *; simpl in |- *; intros.\nsplit; [ apply (H E' A); auto with zfc | idtac ].\nunfold not in |- *; intro; apply H; clear H.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold pbire in |- *; simpl in |- *; intros; split; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold not in |- *; unfold not in |- *; unfold not in |- *; intros; elim H; intros; clear H H0.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros; apply (mapcanon_rRelub (sym_d E)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold pbire in |- *; simpl in |- *; intros; split.\nintros; elim (H (e x)); auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintro E; apply (IN_mapcanonire A B); auto with algebra.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Provide in |- *; simpl in |- *; intros; split; [ exact I | idtac ].\nintros; exists x; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold pbort in |- *; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nintros; apply (distinct_removes (Seqtl E) (Seqtl E)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold pbire in |- *; simpl in |- *; intros; split.\nintros; apply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |- *; intros.\napply (H (F:=fun E' : Ens => True)).\nred in |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Linire in |- *; simpl in |- *; unfold app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, app_asser, plus_asser, app_asserQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *; split.\nsimple induction x.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *; intros; split.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold pbire in |- *; simpl in |- *; intros; split.\nred in |- *.\nsplit.\nred in |- *.\nsplit; [ auto with zfc | idtac ].\nred in |- *.\nsplit; [ auto with zfc | idtac ].\nred in |- *.\nsplit; [ auto with zfc | idtac ].\nred in |- *.\nsplit; [ auto with zfc | idtac ].\nred in |- *.\nsplit; [ auto with zfc | idtac ].\nred in |- *; intros.\nelim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Vide in |- *; simpl in |- *; intros; split.\nelim H; intros x E'; elim E'; intros H'0 H'1; clear E E H'.\nexists (x x); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *; intros; split.\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold 51 in |- *; simpl in |- *; unfold app in |- *; unfold app in |- *;\n auto with zfc.\n\nTheorem IN_ehlist_right :\n forall A B C : Ens, IN B (Cartesian A B) (rRelam A B).\nunfold Laup in |- *; simpl in |- *; unfold app in |- *; unfold app in |- *;\n auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *; intros; split.\nintro; apply IN_Diam; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold FSetite in |- *; simpl in |- *; unfold app in |- *;\n auto with zfc.\n\nLemma pbire_left_right :\n forall (A B C : Ens) (rRel : SUB B C) (rRel : SUB B C),\n In_ehlist (rRel :: A) (rRel :: B) -> In_ehlist (rRel :: A) (rRel :: B) -> In_ehlist (rRel :: A) (rRel :: B) -> In_ehlist (rRel :: B) (rRel :: B) -> In_ehlist (Opet E' A) (rRel :: B) (rRel :: B).\n(* Proof of lem_projQuotient_eq_left                                              *)\nintros; exists x; split; [ idtac | split; [ idtac | reflexivity ] ].\nelim (lem_cartesian_propertie x x0 x1 x2 x0); intros; generalize (H1 H0);\n clear H H1 H2; intros.\nelim H; intros; elim H; intros; elim H0;\n intros; elim H1; intros; elim H1; intros; elim H1;\n intros; elim H2; intros; elim H3; intros; elim H4;\n intros;Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Provide, In in |- *; simpl in |- *; intros.\nsplit.\nred in |- *; intros.\napply (H (A:=A) (B:=A)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold pbire in |- *; simpl in |- *; unfold not in |- *; intro; red in |- *; intros A H H0; elim H0;\n elim (H0 (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\n(* The definition of empty set *)\n\nTheorem empty_set_1 : forall A : Ens, ~ empty A -> ~ empty A.\n(* Proof of empty set_1. *)\nintros A H; elim (H0 (empty A)); auto with algebra.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros; apply NNPP; split; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\n(* A, we can be proved in the empty set *)\n\nTheorem single_empty_is_empty : forall E : Ens, ~ empty empty.\n(* A, B, B, empty A *)\nintros; apply empty_empty_is_empty; auto with algebra.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nintros; split.\nintro; elim (H (In_NotIn _ _ H)); auto with zfc.\n\nelim (H (In_NotIn _ _ H)); auto with zfc.\n\nTheorem paident_eq_inc_right :\n forall A B C : Ens, EQ A B -> EQ B C -> EQ C (PAIR A B) (PAIR C A).\nProof.\nintros; split.\nintro; elim (H (In_NotIn _ _ H)); auto with zfc.\n\nelim (H (In_NotIn _ _ _ H)); auto with zfc.\n\nelim (H (In_NotIn _ _ _ H)); auto with zfc.\n\nelim (H (In_NotIn _ _ _ H)); auto with zfc.\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Provide_hyp in |- *.\nintros; split.\nelim (IN_irrefl (IN_irrefl (IN_irrefl (IN_irrefl (P:=A))).\nauto with algebra.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros; exists A; split; auto with zfc.\n\nLemma Sym_Idire_right : forall A B : Ens, EQ (PAIR A B) (PAIR A B).\nunfold Comp in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\n(* The definitions of empty set *)\n\nTheorem empty_not_empty_has_empty_has_empty :\n forall (A : Ens) (x : E), ~ In x (empty E) -> ~ In x empty.\n(* Proof of empty set *)\nintros A x H'; elim H'; intros H'0; clear H'0.\nelim H'; intros H'0; clear H'0.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nintros; red in |- *; red in |- *; intros A A H H0; elim H;\n intros x H; elim H; intros H1 H2; elim H2;\n intros H2 H3; elim H3; intros H5 H6; elim H6; intros H6 H7; elim H7;\n intros H8 H9; elim H8; intros H9 H9; elim H9; intros H10 H11; elim H11;\n intros H13 H14; elim H12; intros H13 H14; elim H14; intros H14 H15;\n elim H14; intros H15 H15; elim H15; intros H15 H16; elim H16;\n intros H16 H17; elim H16; intros H17 H17; elim H17; intros H15 H16; elim H17;\n intros H17 H18; elim H18; intros H17 H18; elim H18; intros H18 H19;\n elim H18; intros H20 H20; elim H18; intros H20 H17; elim H18;\n intros H17 H18; elim H18; intros H17 H18; elim H18Qed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\n(* The second one has a right order *)\n\nTheorem Iam_Out_proof :\n forall (A : Ens) (i : IN A (PAIR A i)), IN A (PAIR A i).\nintros A i i.\napply (IN_fltam A i).\napply (IN_shiftliftam A i).\napply (IN_shiftliftam A i).\napply (IN_shiftliftam A i).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\napply (Build_Map (fun E : Ens => E) (s := s) (s := s) (x := x) H).\nred in |- *; intros.\nelim (H0 (s:=s) (x:=s) H0); auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nintro E; split; [ try assumption | idtac ].\nred in |- *; intros.\nelim (H E0 (proj1 E))); auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\n(* Proof of_empty_subset_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_empty_emptyQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold not in |- *; intros; split; [ exact (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H)))).\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nintros.\napply (empty_is_empty E).\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold not in |- *; intros E; split; intros.\nelim (H E); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nred in |- *; intros.\napply H.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold not in |- *; intros.\napply (H (part E) (empty E)).\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold not in |- *; intros.\nsplit; intros.\napply H.\nelim (H0 (empty E)); auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\n(*\nTheorem empty_is_empty : forall A : Ens, ~ empty A.\n(*\nTheorem empty_is_empty : forall A : Ens, ~ empty A.\n(*\nTheorem empty_is_empty : forall A : Ens, ~ empty A.\n(*\nTheorem empty_is_empty : forall A : Ens, ~ empty A.\n(*\nTheorem empty_is_empty : forall A : Ens, ~ empty A.\n(*\nDefinition empty : Ens := empty A.\n(*\nDefinition empty : Ens := empty A.\n(*\nDefinition empty : Ens := empty A.\n\nDefinition empty : Ens := empty A.\n\nDefinition empty : Ens := empty empty A.\n\nDefinition empty : Ens := empty A.\n\nDefinition empty : Ens := empty empty A.\n\nDefinition empty : Ens := empty empty A.\n\nDefinition empty : Ens := empty empty A.\n\nDefinition empty : Ens := empty empty A.\n\nDefinition empty : Ens := empty empty empty A.\n\nDefinition empty : Ens := empty empty empty empty empty empty empty empty empty empty empty empty empty.\n\nDefinition empty : Ens := empty empty empty empty empty empty empty empty empty empty empty empty emptyQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nintros E E' A B H'0; try assumption.\napply H'.\nexact (H'0 A B).\nexact (H'0 A B).\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold not in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold not in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold singleton in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold na in |- *; simpl in |- *; intros E E' H0; try exact H0.\nelim (H0 (Empty E)); auto with zfc.\n\nTheorem empty_not_empty : ~ empty empty.\nunfold not in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nintros.\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\napply (In_singleton (A:=E)).\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold app, empty in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nintros E E' A B H H0.\nelim H; intros a0 E; elim E; intros H1 H2; clear H H0.\nelim (H a0); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H1 H2); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H1 H2); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H0 a); intros H1 H2; clear H H2.\nelim (H0 H1); intros H1 H2; clear H H2.Qed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold cart, var in |- *; simpl in |- *.\nunfold cart, var in |- *; simpl in |- *; unfold cart in |- *.\nintros E F; split; [ try assumption | idtac ].\nunfold not in |- *; intros.\nelim (H (F x)); auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Img in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nintros A A A' H; elim H; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros.\napply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj3 (proj2 (proj2 (proj2 (proj3 (proj2 (proj3 (proj2 (proj2 (proj3 (proj3 (proj3 (proj2 (proj3 (proj2 (proj3 (proj3 (proj3 (proj3 (proj2 (projQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\n\nTheorem Sing_idempotent : forall A A' : Ens, EQ A A' -> EQ A (Sing A').\nunfold Sing in |- *; intros A A' H; elim (mapcanon_range A); auto with algebra.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold IF in |- *; intros A A' H; elim (DiABC_If A A' H); auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold IF, empty in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nintros A A' H; elim H; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nintros.\napply (Build_Map (A:=A) (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (C:=A') (B:=A') (B:=A') (C:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (C:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A) (B:=A') (B:=A') (B:=A') (B:=A') (B:=A) (B':=A') (B':=A') (B:=A') (B:=A') (B':=A') (B':=A') (B':=A') (B:=A') (B:=A') (B':=A') (B:=A') (B:=AQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros.\napply (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj3 (proj2 (proj3 (proj2 (proj2 (proj2 (proj3 (proj2 (proj3 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nintros.\napply (Build_Map (A:=A) (B:=A') (B:=A') (B:=A') (B:=A') (C:=A') (B:=A') (B:=A') (C:=A') (B:=A') (C:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (C:=A') (B:=A') (B:=A') (B:=A') (B':=A') (B:=A') (B:=A') (B:=A') (B:=A') (C:=A') (B:=A') (B:=A') (B:=A') (B:=A) (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B:=A') (B':=A') (B':=A') (B':=A') (B:=A') (B':=A') (B':=A') (B':=A') (B':=A') (B':=A') (B:=A') (BQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; apply EQ_backwards; apply EQ_backwards; apply EQ_backwards;\n auto with zfc.\n\nTheorem cart_eq : forall E1 E2 : Ens, EQ (PAIR E1) (gval E2) -> EQ E1 E2.\nintros; apply EQ_backwards; apply Singleton_pr1; auto with zfc.\n\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Doubleton in |- *; intros; apply EQ_symm; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros.\nunfold Sing in |- *; simpl in |- *.\nelim (PAIR_empty_2 E1); intros.\nelim (PAIR_empty_3 E2); intros.\nelim (PAIR_empty_3 E1); intros.\nelim (PAIR_empty_3 E2); intros.\nelim (PAIR_empty_3 E1); intros.\nelim (PAIR_empty_3 E3); intros.\nelim (PAIR_empty_3 E3); intros.\nelim (PAIR_empty_3 E3); intros.\nelim (PAIR_empty_3 E3); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 E4); intros.\nelim (PAIR_empty_3 EQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; intros; apply EQ_symm; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold pairwise in |- *; intros; apply EQ_symm; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold FSetInter in |- *; intros; apply EQ_ zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold cart in |- *; intros; apply EQ_hd; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sing in |- *; intros; apply EQ_symm; assumption.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold IF in |- *; intros; apply EQ_ casetype with (c := A) (a := A');\n auto with algebra.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold cart in |- *; intros; apply EQ_symm; apply EQ_symm;\n auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; red in |- *.\nintros x y z H0.\napply H; auto with sets.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nintros; red in |- *; intros.\nelim (H0 x); intros.\nelim (H1 x); intros.\nelim (H2 x); intros.\nelim (H3 x0); intros.\nelim (H4 x0); intros.\nelim (H5 x0); intros.\nelim (H6 x0 x1); intros.\nelim (H5 x0); intros.\nelim (H6 x1); intros.\nelim (H6 x1); intros.\nelim (H6 x2); intros.\nelim (H7 x0); intros.\nelim (H7 x2); intros.\nelim (H6 x2); intros.\nelim (H6 x2); intros.\nelim (H7 x0); intros.\nelim (H7 x3); intros.\nelim (H7 x3 x4); intros.\nelim (H7 x4); intros.\nelim (H6 x2); intros.\nelim (H7 x3); intros.\nelim (H7 x4); intros.\nelim (H7 x4); intros.\nelim (H6 x3); intros.\nelim (Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros.\napply (Build_Map (Ap:=fun x : Ens => P (proj1_sig x)))).\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; apply (Build_Setoid (Ap:=fun x y => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y : Ens => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y : Ens => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y : Ens => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y : Ens => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y : Ens => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (Ap:=fun x y : Ens => P x y /\\ P y)).\nred in |- *; intros; apply (Build_Setoid (ApDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nintros; red in |- *; intros; apply (H0 x); auto with sets.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P H'; try assumption.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; apply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\nred in |- *; intros.\napply Ap_comp; auto with algebra.\nred in |- *; intros.\napply Ap_comp; auto with algebra.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; apply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens =>Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P H; exact H.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nintros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *; intros.\napply (Build_Map (Ap:=fun x : Ens => P x -> sig A P)).\nred in |- *;Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp in |- *; intros; split; intros x p; exact (f x).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros A f x H; try exact (f x).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros A f fr P.\napply (post (sig A (fun x : A => P (f x)))).\nexact (Comp_inr A (fun x : A => P (f x))).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nsimple induction 1; intros; auto with zfc.\napply (H0 (fun x => P (f x))).\nauto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, Next, Next, FA, Comp, re_pr in |- *; intros; elim H;\n intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4;\n intros; elim H4; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H6; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; elim H5; intros; \n elim H5; intros; elim H5; intros;Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros; auto with sets.\napply (pr1 (sig A (fun x => P (f x))).\napply (pr2 (sig A (fun x => P (f x)))).\nred in |- *; intros; apply (H x).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nintros; red in |- *; intros; split; intros; auto with sets.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros A f.\nexact (Comp_inr A f x0).\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nsimple induction 1; intros A f fr P H; elim (gc (sig A (fun x => P (f x)))).\nelim (A (fun x => P (f x))).\n\nelim H; intros x0 p; exact (f x0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 319,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0; try assumption.\nelim H'; intros H'1 H'2; try exact H'2; clear H'2.\nelim H'; intros H'3 H'4; try exact H'4; clear H'4.\nelim H'; intros H'4 H'5; try exact H'5; clear H'4.\nelim H'4; intros H'5 H'6; try exact H'5; clear H'4.\nelim H'5; intros H'6 H'7; try exact H'7; clear H'5.\nelim H'5; intros H'6 H'7; try exact H'7; clear H'5.\nelim H'7; intros H'7; try exact H'7; clear H'5.\nelim H'5; intros H'6 H'7; try exact H'7; clear H'5.\nelim H'7; intros H'8 H'9; try exact H'9; clear H'5.\nelim H'5; intros H'8 H'9; try exact H'10; clear H'5.Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold MAP, MAP in |- *.\nintros A A' B B' H' x y H'0; try assumption.\nelim (SUM4 E E' (fun x : E => x) x); intros x0 H'1; try assumption.\nelim H'1; intros H'2; try exact H'2; clear H'1.\nelim (SUM5 E E' (fun x : E => x) x); intros x1 H'2; try assumption.\nelim H'2; intros H'3 H'4; try exact H'2; clear H'2.\nelim (SUM6 E E' (fun x : E => x) x); intros x1 H'4; try exact H'4; clear H'4.\nelim (SUM7 E E' (fun x : E => x) x); intros x1 H'4; try exact H'4; clear H'4.\nelim (SUM6 E E' (fun x : E => x) x); intros x1 H'5; try exact H'5; clear H'5.\nelim (SUM6 E E' (fun x : E => x) x);Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0; try assumption.\nelim H'0.\nelim H'1.\nelim H'1; intros H'3 H'4; try exact H'4; clear H'1.\nelim H'2.\nelim H'2.\nelim H'3.\nelim H'5; intros H'6 H'7; try exact H'7; clear H'2.\nelim H'7; intros H'8 H'10; try exact H'10; clear H'1.\nelim H'5; intros H'8 H'10; try exact H'10; clear H'3.\nelim H'6; intros H'8 H'10; try exact H'10; clear H'4.\nelim H'7; intros H'9 H'10; try exact H'10; clear H'5.\nelim H'10; intros H'10; try exact H'10; clear H'10.\nelim H'10; intros H'10; try exact H'10; clear H'10.\nelim H'10; intros H'10; try exact H'10;Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold EQ in |- *.\nintros A A' B B' C' H'0; try assumption.\nelim (blam (couple A' B' C')); auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0; try assumption.\nelim (masing ( :!=: E)); auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0; try assumption.\nelim (compatible_non_zero A B); intros H'2; try exact H'2.\nelim (compatible_non_zero B' B'); intros H'3; try exact H'3.\nelim (compatible_non_zero B' B'); intros H'4; try exact H'3.\nelim (compatible_non_zero B' B'); intros H'4; try exact H'4.\nelim (compatible_non_zero B' B'); intros H'5; try exact H'6.\nelim (compatible_non_zero B' B'); intros H'6; try exact H'7.\nelim (compatible_non_zero B' B'); intros H'6; try exact H'7.\nelim (compatible_non_zero B' B'); intros H'8; try exact H'8.\nexists H'; split; [ try assumption | idtac ]; auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'0; try assumption.\nelim H'0; intros H'1 H'2; try exact H'2; clear H'0 H'1.\nelim H'1; intros H'2 H'3; try exact H'2; clear H'1 H'2.\nelim H'2; intros H'3 H'4; try exact H'3; clear H'2 H'4.\nelim H'2; intros H'5 H'6; try exact H'6; clear H'2 H'6.\nelim H'6; intros H'7; try exact H'6; clear H'2 H'6.\nelim H'6; intros H'7 H'8; try exact H'7; clear H'2 H'6.\nelim H'7; intros H'8 H'9; try exact H'9; clear H'2 H'7 H'8.\nelim H'9; intros H'9 H'10; try exact H'10; clear H'2 H'10.\nelim H'10; intros H'10; try exact H'10;Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' C' H'0; try assumption.\nelim (SUM5 E E' A' B' C' B' C' H'1); intros x y; try assumption.\nelim H'0; intros x0 y0; elim H'1; intros H'3 H'4; try exact H'4;\n clear H'0.\nelim (SUM6 E E' A' B' C' x y); intros x1 y2; elim H'2; intros H'4 H'5; try exact H'5;\n clear H'2.\nelim (SUM6 E E' A' B' x1); intros x2 y3; elim H'2; intros H'4 H'5; try exact H'5; clear H'2.\nelim (SUM6 E E' A' B' x2); intros x3 y4; elim H'4; intros H'5 H'6; try exact H'6; clear H'2.\nelim (SUM6 E E' A' B' x2); intros x4 y5; elim H'4; intros H'5 H'6; tryQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nintros A A' B B' H'0; try assumption.\nelim (paident_eq A' B); intro H'1; try exact H'1; clear H'.\nelim (paident_eq B A'); intro H'2; try exact H'2; clear H'.\nelim (paident_eq B B); intro H'3; try exact H'2; clear H'.\nelim (paident_eq B A'); intro H'4; try exact H'4; clear H'4.\nelim (paident_eq B B'); intro H'5; try exact H'5; clear H'5.\nelim (paident_eq B B'); intro H'6; try exact H'6; clear H'.\nelim (paident_eq B B'); intro H'7; try exact H'7; clear H'.\nelim (paident_eq B' B'); intro H'7; try exact H'6; clear H'.\nelim (paident_eq B' B'); intro H'7; try exact H'7; clear H'.\nelim (paident_eq B B'); intro H'8;Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros.\nunfold MAP in |- *.\nelim (SUM5 _ _ A' B' C' H0).\nintros.\nunfold Map in |- *.\nelim (SUM5 _ _ A' B' C' H1).\nintros.\nelim H1; intros.\napply H1; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 647,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' H H0 H1; apply H; auto with algebra.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' H' x.\nelim x.\nelim x; simpl in |- *; auto with zfc.\n\nelim x; simpl in |- *; auto with zfc.\n\nelim x; simpl in |- *; auto with zfc.\n\nelim x; simpl in |- *; auto with zfc.\n\nelim x; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold equality in |- *; simpl in |- *.\nintros A A' B B' H; elim H; elim H; elim H;\n clear H; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear H2; intros H1 H2; elim H2;\n clear HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' B' H.\nelim (H (Refl A') (Refl A') (Refl B') (Refl B')).\nintros x H'; elim H'.\nelim (H' (Refl A') (Refl B')).\nintros x H'; elim H'.\nelim (H' (Refl A') (Refl B')).\nintros x0 H'1; elim H'1.\n\napply EQ_symm; apply H'; auto with algebra.\n\napply EQ_symm; apply H'; auto with algebra.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' H B' H.\napply (eqF_inj_left (eqF A' B) (eqF B' A')); auto with algebra.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' C B' H H0 H1.\ncut (EQ (couple A' B) (couple B' B') (couple B' B')).\nsimpl in |- *.\nsimple induction 1.\napply EQ_refl.\n\nelim (H1 (couple A' B' C)); intros.\nelim H2; intros.\napply EQ_trans with (singleton A'); auto with algebra.\napply Sym_sym; apply (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H)))))));\n auto with algebra.\n\nelim (H1 (couple A' B' C)); intros.\nelim H2; intros.\napply EQ_trans with (singleton A'); auto with algebra.\n\nelim (H1 (couple A' B' C)); intros.\nelim H2; intros.\napply EQ_trans with (singleton A'); auto with algebra.\n\nelim (H0 (couple A' B' C)); intros.\nelim H2; intros.\napply EQ_trans with (singleton A'); auto withQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' H.\napply (eqF_inj_left (eqF A' B) (eqF A' B') (eqF B' A'));\n auto with algebra.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' H.\napply NNPP; intro.\ncut (Equal (Couple A A') (Couple B' B') (Couple B' B')).\nsimpl in |- *.\nelim (H (First A')); simpl in |- *.\nintros x0 H1; elim x0; simpl in |- *; auto with algebra.\napply EQ_trans with (eqF A' x0); auto with algebra.\napply EQ_trans with (eqF A' x0); auto with algebra.\n\nelim (H (First A')); simpl in |- *.\nintros x0 H1; elim x0; simpl in |- *; auto with algebra.\napply EQ_trans with (eqF A' x0); auto with algebra.\n\napply EQ_trans with (eqF A' x0); auto with algebra.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros A A' B B' H.\nelim (H (Law A' A') (Law B' A')); intros x0 H'0; elim H'0;\n simpl in |- *; auto with algebra.\napply EQ_sym; apply Singleton_inv; auto with algebra.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold MAP in |- *; simpl in |- *.\nintros.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply Extensionality_Ensembles.\napply ExtensionalityQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nred in |- *; simpl in |- *.\nsimple induction 1; intros.\nelim (H1 (f x)); intros.\nelim (H2 (f x)); intros.\nelim (H3 (f x)); intros.\nelim H4; intros.\nexists x0.\nexists x0.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x2.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelim H3; intros.\nexists x1.\nsplit; [ assumption | assumption ].\nelimQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold MAP in |- *.\nintros A A' B B' C.\napply (Build_Map (A:=A) (B:=A') (C:=A') (D:=A') (E:=A') (B:=A') (E:=A') (E:=A') (E:=A') (E':=A') (E':=A') (E':=A') (F:=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (F:=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A'') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=A') (E':=AQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nred in |- *; simpl in |- *.\nunfold app_rel in |- *; simpl in |- *; auto with *.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A A' B B' H'; red in |- *.\nelim H'; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'1.\nelim (H'0 tt).\nintros.\nunfold Prod in |- *.\nelim (H'0 tt); intros.\nunfold Prod in |- *.\nelim (H'0 tt); intros.\nelim H'3; intros.\nelim H'3; intros.\nelim H'4; intros.\nelim H'5; intros.\nelim H'5; intros.\nelim H'5; intros.\nelim H'5; intros.\nelim H'5; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'6; intros.\nelim H'7; intros.\nelim H'7; intros.\nelim H'6; intros.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros.\nunfold Par in |- *.\nunfold Prod, Ar2 in |- *.\nelim A'.\nintros.\nelim H.\nintros.\nelim H.\nintros.\nelim H.\nintros.\nelim H0.\nintros.\nelim H2.\nintros.\nelim H4.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelimQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nsimple induction 1; intros; auto with algebra.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6; intros; elim H6; intros; elim H7; intros;\n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; elim H7; intros; elim H7;Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nsimple induction 1; intros; try reflexivity.\nelim H0; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nelim H4; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A A' B B.\napply (Build_Map (A:=A) (B:=A') (B:=A') (C:=A') (C:=A') (C:=A') (C:=A') (C:=A') (C:=A') (C:=A') (C:=A') (E':=A') (C:=A') (C':=A') (C':=A') (C:=A') (C:=A') (C':=A') (C':=A') (C:=A') (C':=A') (C':=A') (C:=A') (C:=A') (D':=A') (C':=A') (C':=A') (C':=A') (C':=A') (D:=A') (D':=A') (C':=A') (C':=A') (C':=A') (D':=A') (C':=A') (C':=A') (C':=A') (C':=A') (C':=A') (C':=A') (D':=A') (C':=A'') (D':=A') (C':=A') (D':=A') (D':=A'') (D':=A') (CQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nred in |- *; intros A A' B' H.\nred in |- *; intro.\nelim (H1 (couple A' B' H)); intros.\nelim (H2 H3); intros.\nelim (H2 (couple A' B' H)); intros.\nelim (H3 (couple A' B' H)); intros.\nelim (H4 (couple A' B' H) H); intros.\nelim (H4 (couple A' B' H)); intros.\nelim (H5 (couple A' B' H)); intros.\nelim (H6 (couple A' B' H)); intros.\nelim (H6 (couple A' B' H)); intros.\nelim (H7 (couple A' B' H)); intros.\nelim (H6 (couple A' B' H)); intros.\nelim (H7 (couple A' B' H)); intros.\nelim (H6 (couple A' B' H)); intros.\nelim (H7 (couple A' B' H)); intros.\nelim (H7 (couple A' B' H)); intros.\nelim (H7 (couple A' B' H)); introsQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold MAP in |- *.\nsimple induction 1; intros; elim H0; intros.\nelim (H2 b); intros.\nelim H2; intros.\nelim H3; intros.\nelim (H2 b); intros.\nelim H4; intros.\nelim (H5 b); intros.\nelim H5; intros.\nelim (H6 b); intros.\nelim (H6 b); intros.\nelim H6; intros.\nelim (H6 b); intros.\nelim (H6 b); intros.\nelim H6; intros.\nelim (H6 b); intros.\nelim (H6 b); intros.\nelim H6; intros.\nelim (lem_cartesian_propertie A' x0 x1); intros.\nelim H6; intros.\nelim H6; intros.\nelim (H6 b); intros.\nelim (lem_cartesian_propertie (couple x0 y0) x1); intros.\nelim H7; intros.\nelim H7; intros.\nelim (lem_cartesian_propertie (couple x0 y0) x1); intros.\nelim H7; intros.\nelim (lem_cartesianQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "simple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold cart in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold MAP in |- *; intros; auto with algebra.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold rImg in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Compatible in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold EqA in |- *; intros; auto with algebra.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold EqA in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold MAP in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Compatible in |- *; intros; auto with algebra.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold rImg in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold rImg in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": ".\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nunfold rImg in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold cart in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold collidesWith in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold rdom, rdom, rdom, rdom, rdom, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV,EQ, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV, EV,EQ, EV, EV,EQ, EV, EV, EV, EV,EQ, EV, EV, EV, EV, EV,EQ in |- *.\n\nTheorem union_b_right :\n forall A B C : Ens, EQ (union_b A C) (union_b B C).\nunfold union_b, union_b, union_b, union_b, union_b, union_b, union_b, union_b, union_b, union_b, union_b,Qed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold rImg in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold rdom in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold cart in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros; red in |- *; intros.\nelim (H1 (couple A' B)); auto with zfc.\n\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nunfold Compatible in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nintros E1 E2' E1' E2' F1' F2'.\nelim (IN_comp_general (E:=E) (E:=E) (E:=E) (E:=E) (E:=E) (E:=E) (E':=E) (E':=E')\n  (fun x : E1' x : E2' =>\n   couple (couple x) (couple x (couple x (couple x (couple x (couple x (couple x))))); \n auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros E1 E2; try exact E1; clear E1.\n\ngeneralize (rRel_equiv_comp_l (couple x y) (couple y x));\n generalize (rRel_equiv_comp_l (couple x y) (couple y x)));\n generalize (rRel_equiv_comp_l (couple y x) (couple y x));\n generalize (rRel_equiv_comp_l (couple x y) (couple y x));\n generalize (rRel_equiv_comp_l (couple y x) (couple y x)));\n generalize (rRel_equiv_comp_l (couple y x) (couple y x));\n generalize (rRel_equiv_comp_r (couple y x) (couple y x)));\n generalize (rRel_equiv_comp_l (couple y x) (couple y x));\n generalize (rRel_equiv_comp_r (couple y x) (couple y x));\n generalize (rRel_equiv_comp_l (couple y x) (couple y x));\n generalize (rRel_equiv_comp_r (couple y x) (couple y x));\n generalize (rRel_equiv_comp_l (Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Img in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold cart in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold cart in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold convert in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nunfold rImg in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nsimple induction E''.\nintros A x y z H' H'0; try assumption.\nelim (IN_EXType (fun A : Ens => In A x -> In B C) (fun A : Ens => In A y /\\ In A y) H');\n intros x0 H'1; try assumption.\nelim H'1 x0; intros y0 H'2; try assumption.\nelim H'2; intros H'3 H'4; try exact H'4; clear H'2 H'4.\nelim H'3; intros H'4 H'5; try exact H'4; clear H'3 H'4.\nelim H'5; intros H'5 H'6; try exact H'5; clear H'5 H'6.\nexists x0; split; [ try assumption | idtac ].\napply H'1.\napply Trans with (union A (couple y0 x1)); auto with zfc.\n\nexists x0; split; [ try assumption | idtac ].\nelim H'5; intros H'6 H'7; try exact H'7; clear H'5 H'6.\nelim H'5; introsQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nintro X; split; intro; elim X; intros.\nexists (App A B); split; auto with zfc.\n\nred in |- *; intros.\nelim X; intros.\nexists (App A B); split; auto with zfc.\n\nexists (App A B); split; auto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nintros x y z H'; try assumption.\nelim (IN_EXType (fun A : Ens => In A (App A B) (App A B)) H');\n intros z H'; elim H'; intros H'0 H'1; clear H'.\nelim (IN_EXType (fun A : Ens => In A (App A B) (App A B))).\nintros z H'; elim H'; intros H'0 H'1; clear H'.\nelim H'; intros H'0 H'1; clear H'.\nelim (IN_EXProp (fun A : Ens => In A (App A B) (App A B))).\nintros z H'; elim H'; intros H'1 H'1; clear H'.\nelim H'; intros H'1 H'2; clear H'.\nelim H'1; intros H'2; clear H'.\nelim (IN_InType (fun A : Ens => In A (App A B) (App A B))).\nintros z H'; elim H'; intros H'0 H'1; clear H'.\nelim H'; intros H'1 H'2; clear H'.\nelim H'Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nintros.\ncut (exists x : E, In (couple A B) E).\nintro x; exists (App A B); split; [ try assumption | idtac ].\nelim (IN_propertie A B x); intros x0 H1; elim H1; clear H1; intros H1 H2.\nexists (App A B); split; [ try assumption | idtac ].\nelim (IN_propertie A B x0); intros x1 H1; elim H1; clear H1; intros H1 H2.\nexists (App A B); split; [ try assumption | idtac ].\nelim (IN_propertie A B x); intros x1 H2; elim H2; clear H2; intros H3 H4.\nexists (App A B); split; [ try assumption | idtac ].\nelim (IN_dec A B x); intros x1 H2; elim H2; clear H2; intros H3 H4.\nexists (App A B); split; [ try assumption | idtac ].\nelim (IN_dec A B x); intros x1 H2; elim H2; clear H2; intros H4 H5.\nexists (Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nintros E E' H'.\nelim (IN_CompType (fun A : Ens => exists x : E, In A B)).\nintros x H'; elim H'.\n\nelim (IN_CompType (fun A : Ens => exists x : E, In A B)).\nintros x0 H'; elim H'.\n\nelim (IN_CompSet (fun A : Ens => exists x : E, In A B)).\nintros x0 H'0; elim H'0; intros H'1 H'2; clear H'0.\nexists x0; exists x0; auto with zfc.\n\nelim (IN_CompSet (fun A : Ens => exists x : E, In A B)).\nintros x0 H'0; elim H'0; intros H'1 H'2; clear H'0.\nexists x0; exists x0; auto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nsimple induction E'; intros.\napply (Empty_set (fun A : Ens => existsType _ : Ens, IN A A)); auto with zfc.\n\nred in |- *.\nsplit; [ try assumption | try assumption ].\nelim H; intros x H; elim H; intros H0 H1; elim H0;\n intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6;\n elim H5; intros H6 H7; elim H7; intros H8 H9; elim H9;\n intros H10 H11; elim H11; intros H12 H13; elim H13; intros H13 H14;\n elim H14; intros H14 H15; elim H14; intros H15 H15; elim H15;\n intros H15 H16; elim H15; intros H16 H17; elim H17; intros H17 H18;\n elim H18; intros H17 H18; elim H18; intros H18 H19; elim H18; intros H18 H20;\n elim H18; intros H18 H18; elim H18; intros H18 H19;\n elim HQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nsimple induction E' as [A0 f1 E1' A1 f2' E2'].\nred in |- *.\nintro x; try assumption.\nelim x; intros H'0 H'1; try exact H'1; clear H'1.\nexists x; auto with algebra.\n\nintros A0 f1.\napply (Equal_trans (Equal_part_set A0) (Equal_part_set A0)) A0); auto with algebra.\napply Trans with (union A0 (Equal_part_set A0)) (union A0 (Equal_part A0)) A1);\n auto with algebra.\napply Trans with (union A0 (Equal_part_set A0) (Equal_part_set A0)) A1);\n auto with algebra.\napply Trans with (union A0 (Equal_part_set A0) (Equal_part A0) (Equal_part_set A0)) A1);\n auto with algebra.\napply Trans with (union A0 (Equal_part_set A0) (Equal_part_set A0)) A1);\n auto with algebra.\napplyQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A0 E' H'0; try assumption.\nexists (Prod (fun A : Ens => exists A : Ens, IN A A0).\napply Set_Of_th2.\napply (Prod_assoc A0 A0 A1 A2).\n\napply (Prod_assoc A0 A1 A2); auto with algebra.\n\napply (Prod_assoc A0 A1 A2); auto with algebra.\n\napply (Prod_assoc A0 A1 A2); auto with algebra.\n\napply Trans with (Prod A0 A1); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 A2); auto with algebra.\n\napply Trans with (Prod A1 AQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nintros A E E' A x H'; try assumption.\nelim H'; intros x E'; elim H'0; intros H'1 H'2; elim H'2;\n clear H'1.\nexists x; split; [ try assumption | idtac ].\napply Trans with (Union (Singleton A) x); auto with zfc.\n\napply Sym; auto with zfc.\n\nunfold App in |- *.\nexists (App (App (App (App (App (App (Inj A) (App (App (App A B) (App (App A B) (App (App A B) (App (App A B) (App (App A B) (App A B)) (App A B))) (App A B))) x);\n auto with zfc.\n\nexists x; split; [ idtac | try assumption ].\napply Trans with (App (App (App (App (App (App (App A B) (App (App (App A B) (App (App A B) (App (App A B) (App A B) (App (App A B) (App A B))) x)));\n auto with zfc.\n\napply EQQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nred in |- *.\nintros E E' F; try assumption.\nelim F; intros A E' E'; try assumption.\nelim E; intros A E' E'; try assumption.\nexists A; exists A; exists B; exists B; exists E; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 399,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition EQC : Ens -> Ens -> Type.\nDefinition EQC : Ens -> Ens -> Prop :=\n  Build_Setoid (fun A B => A -> B)\n    (fun (A B : Ens) (h : EQC A B) =>\n     Build_Setoid (fun B : Ens => A -> B)\n       (fun (A B : Ens) (h : EQC A B) =>\n         Build_Setoid (fun B : Ens => A -> B)\n       (fun (A B C : Ens) (h : EQC A B) =>\n         Build_Setoid (fun B : Ens => B -> B)\n       (fun (A B C : Ens) (h : EQC A B) =>\n         Build_Setoid (fun B C : Ens => B -> B)\n       (fun (A B C : Ens) (h : EQC A B) =>\n         Build_Setoid (fun B C : Ens => B -> B -> C)\n       (fun (A B C : Ens) (h : EQC A B) =>\n         Build_Setoid (fun B C : Ens => B -> C)\n       (fun (A B C : Ens) (h : EQC A B) =>\n         Build_Setoid (fun B C : Ens => BDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n refine (fun a : nat => a).\n\nRecord Setoid : Type := { a : A; b : A }.\n\nRecord Setoid : Type := { a : A ; b : B }.\n\nRecord Setoid : Type := { a : A; b : A}.\n\nRecord Setoid : Type := { a : A ; b : A ; b : A ; b : A ; b : A ; b : B ; b : A ; b : A ; b : A ; b : B ; c : B ; c : B ; c : B ; c : A ; c : A ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c : B ; c :Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nexact (Build_Map (C:=C)).\nexact (Build_Map (C:=C)).\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition SUBC : Ens -> Ens -> Prop :=\n  forall (X Y Z : Ens) (p : IN X Y), IN X Y -> IN Y Z -> IN Y Z.\n\n\nDefinition EQC : Ens -> Prop := forall (X Y Z : Ens) (p : IN X Y), EQC X Z -> IN Y Z -> IN Y Z.\n\nDefinition EQC : Ens -> Prop := forall (X Y Z : Ens) (p : IN X Y), EQC X Z -> IN X Z.\n\n\nDefinition EQC : Ens -> Prop :=\n  forall (X Y Z : Ens) (p : IN X Y), IN X Z -> IN Z X -> IN Z X.\n\n\n\nDefinition EQC : Ens -> Prop :=\n  forall (X Y Z : Ens) (p : IN X Y), EQC X Z -> IN X Z -> IN Z X.\n\n\n\nDefinition EQC : Ens -> Prop :=\n  forall (X Y Z : Ens) (p : IN X Y), EQC X Z -> EQC X Z.\n\nDefinition EQC : Ens -> Prop :=\n  forall (X Y Z : Ens) (p : IN X Y), EQC X Z ->Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\n refine\n (Build_Setoid Prop\n         (fun X : Ens => (X -> Y -> Prop)\n         (fun X : Ens => (X -> Y -> Prop)\n         (fun X : Ens => ((P -> Prop) -> Prop) -> False)\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False)\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens => ((P -> Prop) -> False))\n         (fun X : Ens =>Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQC : Ens -> Prop :=\n  forall (A B : Ens),\n   (A -> B) -> (forall (A B : Ens), (A -> B) -> (forall (A B : Ens), (A -> B) -> (forall (A B : Ens), B) -> (forall (A B : Ens), A -> B).\n\nDefinition EQC : Ens -> Prop :=\n  forall (A B : Ens) (a : A),\n   (A -> B) -> (forall (A B : Ens), (A -> B) -> (forall (A B : Ens), A -> B) -> (forall (A B : Ens), (B -> A) -> B).\n\nDefinition EQC : Ens -> Prop :=\n  forall (A B : Ens) (a : A), (A -> B) -> (A -> B) -> (A -> B).\n\nDefinition EQC : Ens -> Prop :=\n  forall (A B C : Ens) (a : A), (A -> B) -> (C -> A) -> (A -> B).\n\nDefinition EQC : Ens -> Prop :=\n  forall (A B C : Ens) (a : A), (ADefined.",
                    "Definition EQC : Ens -> Ens -> Type.\napply (Build_Setoid _ _ (fun x y => x) (fun x y => y) H).\nexact (Build_Setoid _ _ (fun x y => y)).\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nrefine\n  (fun (x y : Prop) (h : x = y) =>\n   (fun h : x = y) =>\n   (fun h : x = y) =>\n   ((fun h : x = y) =>\n   ((fun h : x = y) => h h = h) /\\ ((fun h : x = y) => h h = h))\n   (fun h : x = y) =>\n   ((fun h : x = y) => (fun h : x = y) => h h = h))\n   (fun h : x = y =>\n   (fun h : x = y) =>\n   ((fun h : x = y) => h h = h) /\\ ((fun h : x = y) => h h = h))\n   (fun h : x = y =>\n   (fun h : x = y) =>\n   ((fun h : x = y) => h h = h) /\\ ((fun h : x = y) => h h = h))\n   (fun h : x = y =>\n   (fun h : x = y) =>\n   ((fun h : x = y) =>\n   ((fun h : x = y) => h h = h) /\\Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nProof.\nintros x y H.\napply (Build_Setoid (fun A : Ens => A) x y H).\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\napply (Build_Setoid (fun _ : relation => True)).\nexact (Build_Setoid (fun _ : relation => True)).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 502,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CIN : Ens -> Ens -> Type.\nintros x y.\ncase x.\ncase y.\ncase y.\nexact (fun x : A => x).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nred in |- *.\nintros a; exists (A:=A) (g:=fun x : A => g (f x)).\nexact (fun x : A => g (f x)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros F H.\napply (Build_Setoid (C:=C) (A:=B) (B:=C)).\nexact (fun x : A => B).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros C1 C2.\napply (Build_Prop (C:=C1) (C:=C2)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\napply (Build_C (C:=C)).\nexact (C:=C)).\nexact (C':=C').\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros A B f g.\nrefine (fun x : C => g (f x)).\nexact (fun x : C => g (f x)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\napply (Build_C (C:=C)).\nexact (C':=C').\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros F G.\napply (Build_C (fun x : C => eq1 x (g y))).\nexact (Build_C (fun x : C => eq2 x (g y))).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros x y.\napply (Build_Setoid (C:=C)).\nexact (fun x : C => Build_Setoid (C:=C)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros A B g f.\nrefine (fun x : A => g (f x)).\nexact (fun x : A => g (f x)).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 551,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CINC : Ens -> Ens -> Type.\napply (Build_C _ (fun X : Ens => EQC X)).\nexact (fun X : Ens => IN X (e X)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\napply (sigT (fun x : A => True)).\nexact (sigT (fun x : A => True)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\napply (Build_C (C:=C)).\nexact (C:=C).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros x.\napply (Build_C (C:=C)).\nexact (fun c : C => EQC (c c))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros; exact (sigT (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\napply (Build_C (C:=C)).\nexact (fun x : C => S (C:=C)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintro; exact (fun g => g (C:=fun x : A => g (C:=g x)))).\nexact (fun g => CER (fun x : A => g (C:=g x))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros x y.\napply (Build_C (fun y : C => EQC X (e y))).\nexact (fun x : A => EQC X (e y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (sigTprod _ (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros.\nexact (fun g : Prop => g (f g))).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 589,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E3 -> EQC E3 E4.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E2 ->Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nintros.\napply EQC_refl.\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_transQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E1 -> EQC E2 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E1 -> EQC E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E1 -> EQC E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E2 -> EQC E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans :\n forall E1 E2 : Ens, EQC E1 -> EQC E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E1 -> EQC E3 -> EQC E3.\nProof EQC_trans.\n\nTheorem EQCQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\napply (Build_C_empty (C:=C)).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_transQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof CIN.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F -> EQC E F.\nProof CIN.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F -> EQC E F.\nProof CIN.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F.\nProof CIN.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F.\nProof CIN.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F.\nProof D_symm E F G.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F.\nProof EQC_trans F G.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E F -> EQC E F.\nProof EQC_trans F G.\n\nTheorem EQC_trans : forall E F G : Ens, EQC E FQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nexact (fun X : Ens => IN X E).\n\nTheorem EQC_trans : forall A B C D E : Ens, EQC E -> B <> D -> C <> D -> C <> D -> E <> E.\nProof.\nintros A B C D E F H0.\nexact (fun X : Ens => IN X F).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof (fun E : Ens => EQC E).\n\nLemma EQC_refl : forall E : Ens, EQC E.\nProof (fun E : Ens => EQC E).\n\nLemma EQC_trans : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2.\nProof (fun E : Ens => EQC E).\n\nTheorem EQC_trans : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2.\nProof (fun E : Ens => EQC E).\n\nTheorem EQC_trans : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2.\nProof (fun E : Ens => EQC E).\n\nTheorem EQC_trans : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2.\nProof (fun E : Ens => EQC E).\n\nTheorem EQC_trans : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2.\nProof (fun E : Ens => EQC E).\n\nTheorem EQC_trans : forall E1 E2 : EnsQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof COf_pr1 (fun A : Ens => EQC E).\n\nTheorem EQC_refl : forall E : Ens, SUB C E.\nProof COf_pr2 (fun A : Ens => EQC E).\n\nTheorem EQC_trans : forall A B C : Ens, IN A B C -> C= C.\nProof COf_pr1 (fun A : Ens => EQC A C).\n\nTheorem EQC_trans : forall A B C D : Ens, IN C D -> C=D.\nProof COf_pr2 (fun A : Ens => EQC A C).\n\nTheorem EQC_trans : forall A B C D : Ens, IN C D -> C=D.\nProof COf_pr2 (fun A : Ens => EQC A C D).\n\nTheorem EQC_trans : forall A B C D : Ens, IN C D -> C=D.\nProof COf_pr1 (fun A : Ens => EQC A C D).\n\nTheorem EQC_trans : forall A B C D : Ens, IN C D -> C=D.\nProof COf_pr2 (fun A :Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 602,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1.\nintros x y z H; elim H; intros H1 H2; elim H2;\n intros H1 H2 H3; elim H3; intros H4 H5; elim H5;\n intros H5 H6; elim H7; intros H8 H9; elim H9; intros H10 H11;\n elim H10; intros H12 H13; elim H12; intros H13 H14;\n elim H13; intros H14 H15; elim H15; intros H15 H16; elim H16;\n intros H15 H16; elim H17; intros H17 H18; elim H18; intros H18 H18;\n elim H18; intros H18 H19; elim H18; intros H18 H19;\n elim H18; intros H18 H19; elim H18; intros H18 H20;\n elim H18; intros H18 H20; elim H20; intros H20 H21;\n elim H22; intros H18 H18; elim H18; intros H17 H18; elim H18;\n intros H18 H19; elim H18; intros H20 H21; elim HQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1.\nintros E1 E2.\napply EQC_trans with (A:=A) (B:=A) (f:=fun y : A => EQC X y).\napply EQC_trans with (A:=A) (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (g:=fun y : A => EQC X y).\napply EQC_trans with (B:=A) (g:=fun y :Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2 E3.\napply EQC_trans with (f y); auto with zfc.\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1.\nintros A E1 E2.\napply (EQC_trans (fun y : A => EQC X (e y))).\napply (EQC_trans (fun y : A => EQC X (e y))).\napply (EQC_trans (fun y : A => EQC X (e y))).\napply (EQC_trans (fun y : A => EQC X (e y))).\napply (EQC_trans (fun y : A => EQC X (e y))).\napply (EQC_trans (fun y : A => EQC X (e y))).\napply (EQC_trans (fun y : A => EQC X (e y))).\nexact (EQC_trans (fun y : A => EQC X (e y))).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nintros E1 E2.\napply (Build_Map (A:=A) (B:=A)).\napply (Build_Map (A:=A) (B:=A)).\napply (Build_Map (A:=A) (B:=A)).\napply (Build_Map (A:=A) (B:=A)).\napply (Build_Map (A:=A) (B:=A)).\nred in |- *; simpl in |- *.\nintro x; red in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.\nintro.\napply Ap2_comp.\nred in |- *; simpl in |- *.Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E.\nintros A E1 E2; simpl in |- *; auto with zfc.\n\nexact (fun A B : Ens => EQC E1 E2).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1.\nintros A E1 E2.\nsimpl in |- *.\nsplit; intros.\nunfold CIN in |- *.\napply (fun A : Ens => A)\n  with (A := E1) (B := A) (C := A) (x := A) (x := A) (x := A) (l := A) (r := A) (r := A) (r := A) (r := A) (r := A) (r := r) (r := A) (r := A) (r := A) (r := A) (r := r) (r := A) (r := A) (r := A) (r := r) (r := A) (r := r) (r := r) (r := r) (r := r) (r := A) (r := r).\nexact (fun A B : Ens => B)\n  (fun A B : Ens => B)\n  (fun A B : Ens => B)\n  (fun B : Ens => B)\n   (fun A : Ens => B)\n   (fun B : Ens => B)\n   (fun B : Ens => B)Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E.\nintros E1 E2.\napply EQC_trans with (C:=CIN E1) (C:=CIN E3).\napply EQC_trans with (C:=CIN E3).\napply EQC_trans with (C:=CIN E3) (C:=CIN E3).\napply EQC_trans with (C:=CIN E3).\napply EQC_trans with (C:=CIN E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=CIN E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=CIN E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=COf E3).\napply EQC_trans with (C:=COf E3).\napply EQQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction 1; intros E1 E2.\napply EQC_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros; elim X4; intros; elim X4; intros.\nelim (a x); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; intros; auto with zfc.\n\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e1 x1).\napply EQC_trans with (e1 x1).\napply EQC_trans with (e1 x1).\napply EQC_trans with (e0 x1).\napply EQC_trans with (e0 x1Qed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; intros; try exact (EQC_refl E1).\nelim (a x); intros.\nexists x0.\napply X with (e0 x1); auto with zfc.\n\nunfold COf in |- *.\nelim (a x); intros.\nexists x0.\napply X with (e0 x1); auto with zfc.\n\nelim (a x); intros.\nexists x0.\napply X with (e0 x1); auto with zfc.\n\nelim (a x); intros.\nexists x1.\napply X with (e0 x1); auto with zfc.\n\nunfold COf in |- *.\nelim (a x); intros.\nexists x1.\napply X with (e0 x1); auto with zfc.\n\nexists x1.\napply X with (e0 x1); auto with zfc.\n\nunfold COf in |- *.\nelim (a x); intros.\nexists x1.\napply X with (e0 x1); auto with zfc.\n\nelim (a x); intros.\nexists x1.\napply X with (e0 x1); autoQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; intros;\n apply EQC_refl; ( elim X2; intros).\nelim (a x); intros.\nexists x0; auto with zfc.\n\nunfold CIN in |- *.\nelim (a x); intros.\nexists x; auto with zfc.\n\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros; elim X3; intros; elim X5; intros; elim X5;\n intros; elim X5; intros.\nelim (a x); intros.\nexists x0; apply X3 with (e0 x1); auto with zfc.\n\nexists y; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros; elim X3; intros; elim X3; intros;\n elim (a0 x1); intros.\nexists x0.\napply X with (e0 x1); auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E2; intros;\n try assumption.\nelim (a x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\n\napply EQC_trans with (e0 x); auto with zfc.\n\napply EQC_trans with (e0 x); auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E3; intros; auto with zfc.\n\napply EQC_trans with (c1 := c1); auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; intros; auto with zfc.\nelim (a x); intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simple induction E3; intros;\n simpl in |- *; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E.\nintros A E1 E2.\napply EQC_trans with (a := x); auto with zfc.\n\nunfold EQC in |- *.\napply EQC_trans with (a := x); auto with zfc.\n\nunfold EQC in |- *.\napply EQC_trans with (a := x); auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; intros; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros; elim X3; intros; elim X4; intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; intros; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; intros; auto with zfc.\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simple induction E'; intros.\nelim (a x); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; intros; auto with zfc.\n\nexists (couple x y); auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E'.\nintros; exists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros; elim X4; intros; elim X5; intros.\nexists x0.\napply X with (e0 x1); auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E.\nintros E E' H.\napply H.\napply H.\napply H.\napply (H (F:=fun x : E => EQC E (e x) (e x))); auto with zfc.\n\nTheorem EQC_inr : forall E E' : Ens, EQC E E' -> EQC E'.\nsimple induction E.\nintros; split; (elim X2; intros; elim X3; intros; elim X3; intros.\nelim (a x0); intros.\nexists x0; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simpl in |- *; intros;\n exists x; auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros; auto with zfc.\nelim (CnR_com_c E E'); auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\n\nTheorem CINC_EQC : forall E E' : Ens, CEx E E' -> CEx E'.\n\nTheorem Cne_F_If : forall E : Ens, CEx E -> CEx E.\nintros E H'.\napply H'.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros; try exact (CIN_EQC E H H0).\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CIN_EQC (Eq E' H0))); intros.\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CIN_EQC (Eq E' H0)); intros.\nelim (CNot_EQC (Eq E' H0)); intros.\nelim (CNot_EQC (Eq E' H0)); intros.\nelim (CNot_EQC (Eq E' H0))); intros.\nelim (CNot_EQC (Eq E' H0)); intros.\nelim (CNot_EQC (Eq E' H0)); intros.\nelim (CNot_EQC (Eq E' H0));Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E'; intros; auto with zfc.\nelim (CdL E' H); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\n(* End of proof of lem_EQC. *)\n\nTheorem Cne_antisym : forall E E' : Ens, EQC E E' -> E <> E'.\n(* Proof of lem_eq_sym                                              *)\nintros; apply lem_eq_trans with (e x); auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros; try exact (Ccr_intro C E' H).\napply Cne_E_E_F.\napply H0.\napply H0.\napply H.\napply H.\nexact (Cel_intro C E' H0).\n\nexact (Cel_intro C E' H0).\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros.\nelim (CIN_case (fun A : Ens => forall x : E, In U E'' -> ~ In U E'' x)\n    (fun A : Ens => forall x : E, In U E'' x -> In U (e0 x) -> In U (e0 x) E'').\nexact (forall A : Ens, In U E'' -> CEx E (e0 x) (e1 x)).\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E' E''.\napply (IN_Equal (E:=E) (s:=E) (s:=E') (s:=s) (s:=s) (s:=s) (s':=s) (s':=s).\napply (IN_Equal (E:=E) (s:=s) (s':=s) (s':=s) (s':=s') (s':=s'').\nauto with *.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E; intros; try assumption.\nelim (CIN_Axiom A B C E' H0).\n\nexact (CIN_sound_right (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s':=s).\n\nexact (CIN_symm (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s':=s) (s:=s) (s:=s) (s':=s) (s':=s) (s':=s) (s':=s) (s':=s) (s':=s) (s':=s) (s':=s') (s':=s) (s':=s) (s':=s'').\n\nexact (CIN_trans (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (s':=s) (s':=s) (s':=s) (s':=s)Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nred in |- *.\nsimple induction E''; simpl in |- *; intros.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E => True) | idtac ].\nred in |- *.\nsplit; [ exact (fun x : E =>Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nintros E E' E'' H0; try assumption.\nelim H0; intros.\nelim (H0 E'' H1); intros.\nexists x; auto with zfc.\n\nelim (H0 E'' H1); intros.\nexists x; auto with zfc.\n\nelim (H0 E'' H1); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros E E' E'' H.\napply (H E'' (e0 y)); auto with zfc.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; intros; try assumption.\nelim (CIN_sound_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right E E' (fun x : A => EQC E')); auto with sets.\nelim (CIN_compatible_cons_right (fun x : A => EQC E')); auto with sets.\nelimQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; intros; auto with zfc.\nelim (CIN_symm_right E'' H H0); intros; auto with zfc.\nelim (CIN_symm_right E'' H0); intros; auto with zfc.\n\napply (CIN_symm_right E'' H0); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H0); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1); intros; auto with zfc.\n\napply (CIN_symm_right E'' H1);Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nred in |- *; intros E E' H'0.\nelim H'0; intros.\nelim (IN_A_intro E E'0 H'1); intros.\nexists x; auto with zfc.\n\nelim (IN_A_intro E E'0 H'0); intros.\nexists x; auto with zfc.\n\napply CIN_EX; auto with zfc.\n\napply CIN_EX; auto with zfc.\n\napply CIN_EX; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nred in |- *; intros.\nsplit; intros.\nelim (H1 (IN_intror (fun x : A => exists y : E, In (couple x y) E'').\nelim (H1 (IN_intror (fun x : A => EQC E'' /\\ In A E'')).\nelim (H1 (IN_introl (fun x : A => exists y : E, In (couple x y) E'').\nelim (H2 (IN_intror (fun x : A => exists y : E, In (couple x y) E'').\nelim (H3 (IN_intror (fun x : A => exists y : E, In (couple x y) E'').\nelim (H3 (In_introl (fun x : A => In (couple x y) E'').\nelim (H3 (In_intror (fun x : A => exists y : E, In (couple x y) E'').\nelim (H3 (In_introl (fun x : A => exists y : E, In (couple x y) E'').\nelim (H4 (In_intror (fun x : A => exists y : E, In (couple x y) E'').\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nunfold CIN in |- *; simpl in |- *; intros.\nelim H; intros.\nelim (CIN_Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_ Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_ Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_ Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_Parameter_of_cp_right (e0 y) (e0 y)); intros.\nelim (CIN_Parameter_of_cp_Qed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CIN_trans_right (e0 y) (e0 x) (e0 x)); intros.\nexists (e0 x); exists x0.\napply X1; exists y; auto with zfc.\nelim (CIN_cons_right (e0 y) (e0 y)); intros.\nexists (e0 x); exists x; auto with zfc.\n\nelim (CIN_cons_right (e0 y) (e0 y)); intros.\nexists (e0 y); exists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CIN_Axiom_left E E'' x z H); intros.\nexists y.\napply CIN_trans with (e0 x); auto with zfc.\n\nunfold CIN in |- *.\nelim (CIN_Axiom_right E E'' x z H); intros.\nexists z; auto with zfc.\n\nelim (CIN_elim_right E E'' x z H); intros.\nexists z; auto with zfc.\n\nelim (CIN_elim_right E E'' x z H); intros.\nexists z; auto with zfc.\n\napply CIN_trans with (e0 x); auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nintros; apply CIN_sound_right; assumption.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CIN_sound_right E E'); auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CIN_sound_right _ _ H); intros.\nelim (CIN_sound_right _ _ H0); intros.\nelim (CIN_sound_right _ _ H0); intros.\nelim (CIN_sound_right _ _ H0); intros.\nelim (CIN_sound_right _ _ H0); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H0); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ H1); intros.\nelim (CIN_sound_right _ _ _ H3); intros.\nelim (CINQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CIN_antisym_right E E'' H0); intros.\nelim (CIN_antisym_right E E'' H0); intros.\nelim (CIN_antisym_right E E'' H1); intros.\nelim (CIN_antisym_right E E'' H1); intros.\nelim (CIN_antisym_right E E'' H3); intros.\nelim (CIN_antisym_right E E'' H1); intros.\nelim (CIN_antisym_right E E'' H2); intros.\nelim (CIN_trans_right E E'' H3); intros.\nelim (CIN_antisym_right E E'' H4); intros.\nelim (CIN_antisym_right E E'' H4); intros.\nelim (CIN_antisym_right E' H4); intros.\nelim (CIN_trans_right E E'' H4); intros.\nelim (CIN_antisym_right E E'' H5); intros.\nelim (CIN_irrefl_or_intror (x = x) (CEQ H4)); intros.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; intros.\nelim H; intros.\nelim (IN_trans _ _ (IN_sym E'' (Add_add_S_S A B) y z H0) H1).\nelim (IN_trans _ _ (IN_sym E'' (Add_add_S A B) y z H0) H2).\nelim (IN_trans _ _ (IN_sym E'' (Add_add_S_S A B) y z H0) H3).\nelim (IN_trans _ _ (IN_trans _ _ (Add_add_S_S A B) y z H0) H3).\nelim (IN_trans _ _ (IN_trans _ _ (IN_trans _ _ (Add_add_S A B) z H0) H3)).\nelim (IN_trans _ _ (IN_trans _ _ (Add_add_S A B) z H0) H3)).\nelim (IN_trans _ _ (IN_trans _ _ (IN_trans _ _ (Add_add_S_S A B) z H0) H3)).\nelim ( IN_trans _ _ (Qed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CPi_trans (Var x) (Var y)); intros.\nexists y; auto with zfc.\n\nelim (CPi_trans (Var x) (Var y)); intros.\nexists y; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim X0; intros Xl Xr; elim X0; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nsimple induction E; simpl in |- *; intros.\nelim (CIn_dec A (singleton x)); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nred in |- *; intros.\nelim Xl; intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nunfold C, C, C, C, C, D.\nintros; apply CER_refl.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nred in |- *.\nintros; apply CIN_trans with (e0 y); auto with zfc.\n\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nsimple induction E; simpl in |- *; intros.\nelim Xr; intros.\nelim (CEx_intro Xl Xr); intros.\nexists x; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nunfold CEx, CINC, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, CLE, DLE, CLE, DLE, DLE, CLE, DLE, DLE, DLE, DLE, DLE, DLE.\nintros.\napply H1; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nunfold CAS, CAS, CAS, CAS, CAS, CAS, CAS.\nintros.\nsplit; [ try assumption | idtac ].\nsplit; [ try assumption | idtac ].\nsplit; [ try assumption | idtac ].\nsplit; [ try assumption | idtac ].\nelim X1; intros y0 z0; exists z0; auto with zfc.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nsimple induction E; simpl in |- *; intros.\nelim (CIN_cons_left (e0 y) (e0 y)); intros z0 p; elim (Aeq y0); intros z1 p0; elim (sigmaJ y0);\n intros z2 p0; elim (NoneP z2); intros z2 p0; elim ( )\") z2 p0; intros z3 p0;\n elim (NoneP z3 z4); intros z5 p1; elim (NoneP z5);\n intros z5 p1; elim (NoneP z5 z5); intros z6 z7; elim (NoneP z5);\n intros z6 z7 z8; elim (NoneP z5 z6); intros z7 z8; elim (NoneP z5 z6);\n intros z6 z7 z8; elim (NoneP z9 z9); intros z9 z10; elim (NoneP z9);\n intros z8 z9; elim ( ints z5 z6 z7); intros z9 z10; elim (Raising z5 z6);\n intros z8 z9; elim (Raising z5 z6 z7); intros z9 z10; elim (Closed z5Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nsimple induction E; simpl in |- *; intros.\nelim Xl; intros; auto with zfc.\nelim X0; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nintros; apply CIN_sound; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CEx_elim_right (e0 y0) x); intros.\nexists y0.\napply CIN_cons; auto with zfc.\n\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nintros; unfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; simpl in |- *; intros.\nelim (CIN_Add_elim E E' H0 x y z); intros.\nexists (S x y); auto with zfc.\n\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold C Next in |- *; intros.\nelim (CIN_sound_left E E' H); intros z H0; elim H0; intros z H0; elim H1; intros H1 H2;\n elim (commutz y z); intros z0 H3; elim H3; intros H5 H6;\n elim (commutz z0); intros z1 H4; elim H5; intros H6 H7;\n elim (commutz z1); intros z2 H4; elim H5; intros H6 H7;\n elim (commutz z2 z2); intros z3 H4; elim H5; intros H5 H6;\n elim (commutz z2 z3); intros z4 H5; elim H5; intros H6 H7;\n elim (commutz z3 z4); intros z5 H6; elim H6; intros H7 H7;\n elim (commutz z4 z5 z5); intros z6 H7; elim H7; intros H8 H9;\n elim (commutz z5 z5 z6); intros z7 H8; elim H5; intros H8 H9;\n elim (Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E'; simpl in |- *; intros.\nelim X1; intros Xr; elim Xr; intros.\nelim Xr; intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nintros; apply CIN_trans with (s := x) (s := y); auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nintros; exists (s, s) (s',s')); split;\n [ idtac | apply CEx_introl with (e x); auto with zfc ]\n | idtac ].\napply CIN_cons; auto with zfc.\n\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nintros; apply CEx_trans with (s := s) (s := s) (s := s) (s := s);\n auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nsimple induction E''; intros.\nelim H; intros y0 z0; exists z0; apply EQC_ CNRS; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\napply CEx_intro.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CPC, CINC in |- *; auto with sets.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E E' E'' H'0; red in |- *; intros.\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'1).\nelim (IN_assoc_3 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'0 H'1).\nelim (IN_assoc_3 H'1).\nelim (IN_assoc_3 H'1).\nelim (IN_assoc_3 H'1).\nelimQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with sets.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; intros; auto with zfc.\napply CEx_intro; apply H; apply H0; apply H0; apply H0; assumption.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E E' E'' H'0; try assumption.\nelim H'0; intros H'2 H'3; elim H'3; intros H'4 H'5; elim H'6;\n intros H'5 H'6; elim H'7; intros H'7 H'8; elim H'8;\n intros H'7 H'9; elim H'7; intros H'10 H'11; elim H'12; intros H'14 H'15;\n elim H'15; intros H'15 H'16; elim H'15; intros H'15 H'16; elim H'17;\n intros H'18 H19; elim H'17; intros H'18 H'23;\n elim H'17; intros H'18 H'18; elim H'18; intros H'18 H'18;\n elim H'23; intros H'15 H'16; elim H'17; intros H'20 H'20;\n elim H'17; intros H'19 H20; elim H'17; intros H'16 H'18;\n elim H'18; intros H'23 H'23; elimQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros; apply CEx_intro; apply CEx_intro; apply CEx_intro; apply CEx_intro; apply CEx_intro; apply CEx_intro; apply CEx_intro; apply CEx_intro; apply CEx_intro; assumption.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E E' E'' H H0.\ngeneralize (inc_sp_inc_inc_inc_inc_inc_inc_inc_inc_1).\nunfold Cinc in |- *.\nelim H0; intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6.\nelim (inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_inc_incQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros; apply CINC_trans with (s:=s) (s:=s) (s:=s) (s:=s) (s:=s) (x:=x) (s:=s);\n try assumption.\nelim (CEx_right (s:=s) (s:=s) (s:=s) (x:=x) (s:=s) (x:=x) (s:=s) (x:=s) (s:=x) (s:=s) (x:=s) (x:=s) (x:=s) (s:=s) (x:=s) (x:=s) (s:=s);\n try assumption.\nelim (CEx_right (s:=s) (s:=s) (s:=s) (x:=s) (x:=s) (x:=s) (s:=s) (x:=s) (s:=s) (x:=s) (s:=s) (x:=s) (s:=s) (x:=s) (x:=s) (s:=s) (s:=s) (x:=s) (s:=s) (x:=s) (x:=s)Qed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros; apply C INC_sym; apply CINC_sym; apply C INC_sym; apply CEx_sym; apply CEx_sym; apply CEx_sym; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f X1 X2; apply X1.\napply CIN_sound_right with A; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros.\napply CEx_trans with (s2 := s) (s2 := s2) (s3 := s4);\n auto with sets.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros E E' E'' H E''.\napply CEx_trans with (s2 := x) (s2 := x) (s2 := x); auto with sets.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f X1 X2 E0 i; apply X2.\napply CIN_sound_right with A f X2; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CRA in |- *; simpl in |- *; intros.\nelim X1; intros z0 z1 z2; exists z1.\napply CIN_sound_right with z1; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros.\napply CEx_elim.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros E E' H E'' H0.\napply CIN_sound_right with (s := s) (s' := s); auto with sets.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CRA in |- *; simpl in |- *;\n intros.\nelim (CEx_elim_right E' A x A x0); intros.\nexists x0; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nintros; apply CINC_trans with (s := s) (s' := s').\nelim H; auto with sets.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n(* Proof ofut_vide_under_vide_under_vide_under_vide_vide_under_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n(* Proof ofut_vide_est_everythingC. *)\nsimple induction 1; intros; simpl in |- *; intros.\nelim (O_or_empty_1 E); intros.\nexists x; apply EQC_everything with (e x); auto with zfc.\n\napply CLE_intro_right; assumption.\n\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; intros; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; intros; auto with sets.\nelim (X2 E0); intros X1 X2; elim (X1 X2); intros X1 X2; elim (X1 X2);\n intros X1 X2; elim (X1 X2); intros X1 X2; elim (X1 X2); intros X1 X2.\nexists X1; apply X1; assumption.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; intros; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros; apply (OIN_EX E); auto with sets.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; intros; try assumption.\nelim (X2 E0); intros X1.\nexists X1; exists X1; exists X2; split; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros; apply CIN_sequence with (C := E) (C := E) (C := E) (C := E) (C := E) (C := D) (C := E) (C := D) (c := C) (c := c).\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nsimple induction E; intros; try exact I; clear I;\n intros.\nelim (X2 E0); try assumption; intros.\nexists x0; apply X1; exists x; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold Cne in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold singleton in |- *; simple induction A; simpl in |- *; intros A a0 b0.\nelim (lem_cartesian_propertie (couple x y) (couple x y)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros.\nunfold ParC in |- *.\nelim (H (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros A A' B; try assumption.\nsplit; [ try assumption | idtac ].\nintro; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold ColC, singleton in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold distinct in |- *; simple induction A; simpl in |- *; intros.\nelim (H (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold singleton in |- *; unfold singleton in |- *; unfold singleton in |- *; unfold singleton in |- *;\n intros A A' B H; split; [ try assumption | idtac ].\nelim (H (a x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold singleer, empty in |- *; simple induction A'; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold BB, Cne in |- *; auto with algebra.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros.\nunfold Par in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nintros.\nelim (paident_eq_dec (paident_eq_dec (paident_eq_dec (paident_eq_dec (paident_eq_dec (Ax A A) (Ax A' B)));\n try assumption; intros.\nelim (paident_eq_dec (paident_eq_dec (paident_eq_dec (Ax A' A') (Ax A' B)));\n try assumption; intros.\nelim (paident_eq_dec (paident_eq_dec (Ax A' A) (Ax A' B))); intros.\nexists x; apply (paident_eq_dec (paident_eq_dec (paident_eq_dec (Ax A' A) (Ax A' B)));\n try assumption; intros.\nelim (paident_eq_dec (paident_eq_dec (Ax A' A') (Ax A' B))); intros.\nexists x0; apply (paident_eq_dec (paident_eq_dec (paident_eq_dec (Ax A' A') (Ax A' B)));\n try assumption; intros.\nexists x; apply (paident_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Probl_union in |- *.\nintros; split.\nsimple induction x; simpl in |- *.\nexists (x0 x1); auto with zfc.\n\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold alro at 1 in |- *.\nunfold blro at 1 in |- *; auto with algebra.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Syue in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x; simpl in |- *.\nexists (x0 x1); auto with zfc.\n\nunfold In in |- *; split.\nelim (H0 (e x)); auto with zfc.\n\nunfold In in |- *; split.\nelim (H0 (e x)); auto with zfc.\n\nunfold In in |- *; split.\nelim (H0 (e x)); auto with zfc.\n\nintros.\nelim (H0 (e x)); auto with zfc.\n\nelim H0; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Laire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists x; auto with zfc.\n\nintros; exists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Syant in |- *.\nsimpl in |- *.\nintros; split.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro; apply H.\nunfold not in |- *; intro;Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Grer, Grer, I, C, C, D, C, D, D, D, C, D, D, D, D, C, D, D, D, C, D, C, D, D, D, D, D.\nintros A B B' H; split;\n [ idtac\n | idtac\n | idtac\n | idtac\n | idtac\n | idtac ]; auto with algebra.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nintros A B B' H.\napply NNPP.\nunfold not in |- *; auto with algebra.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Laire in |- *.\nintros; split.\nsimple induction x.\nexists (empty E); auto with zfc.\n\nexists (empty E); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold BBet, BB, BB, BB, BB, BB, B' in |- *.\nintros; split.\nsimple induction x.\nexists y; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold pael, B' in |- *.\nintros.\nsplit.\nsplit.\nintros; auto with zfc.\nelim (H (c x)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, DPC, COf, COf, DOf, COf, COf, COf, COf, DOf, COf, DAdd, COf, COf, COf, DOf, DOf, COf, DOf, DOf, DOf, DIV, DOf, DOf, COf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOfQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CHom in |- *; simpl in |- *.\nintros; split.\nsimple induction x.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN, CIN, CIN in |- *; simpl in |- *; intros.\nelim (IN_ Nzire_rightC H); intros.\nelim (IN_ Nzire_rightC H); intros.\nelim (IN_clear utire_rightC H); intros.\nelim (IN_clear Wire_rightC H); intros.\nelim (IN_clear Wne H0); intros.\nelim (IN_clear Wne H1); intros.\nelim (IN_clear Wne H1); intros.\nelim (IN_clear Wne H3); intros.\nelim (IN_clear Wne H3); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H5); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H4); intros.\nelim (IN_clear Wne H4Qed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CPi in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Cdisj in |- *; simpl in |- *.\nintros; split.\nintros; exists (a, x); split; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN, CIN, CIN, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, CProd, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, CMul, COf, COf, COf, COf, COf, COf, CEV, CMul, COf, CTwo, COf, CProd, CSE, COf, COf, COf, CEV, COf, COf, COf, COf, COf, COf, CMul, COf, CProd, COf, COf, CSE\n*)\n\nSection COf_th.\nVariable F : Ens.\nVariable X Y : Ens.\nHypothesis i :Qed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\nintro; apply CIN_ contributors; auto with zfc.\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\n\nelim (CIN_subsire_right (Ax E) (Ax E' H)).\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CPi, CPi, CPi in |- *; simpl in |- *; intros; auto with zfc.\n\nelim (IN_unpickleire_right (couple A B) (paire A B' C)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN in |- *; simpl in |- *; intros;\n apply CIN_ Bidne_preserve_def with (s:=A) (s:=A) (s:=A);\n auto with zfc.\n\nTheorem COf_rRelet : forall A B C : Ens, EQC A B -> EQC A B.\nintros; split.\napply COf_rRelet.\nunfold In, Cia in |- *; simpl in |- *; intros; auto with zfc.\n\napply COf_rRelet.\nunfold In, Cia in |- *; simpl in |- *; intros; auto with zfc.\n\napply COf_rRelet.\nunfold In, Cia in |- *; simpl in |- *; intros; auto with zfc.\n\napply COf_rRelet.\nunfold In, Cia in |- *; simpl in |- *; intros; auto with zfc.\n\nelim (X2 E0); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, COf, DOf, COf, DOf, DOf, COf, COf, COf, COf, COf, DOf, DOf, COf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, DOf, COf, DOf, DOf, DOf, DOfQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold rRel                   in |- *; simpl in |- *; intros; split.\nintro; apply H.\nunfold not in |- *; left; reflexivity.\n\nunfold not in |- *; left; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; left; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not in |- *; right; reflexivity.\n\nunfold not inQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold pbident in |- *; simpl in |- *; unfold COf in |- *;\n intros A B C; exists x; split;\n [ try assumption | try assumption ].\nunfold COf in |- *.\nintros x y H'; elim H'; intros H'0 H'1; try exact H'0; clear H'1.\nelim (COf_Couple_right x y); intros H'2 H'3; try exact H'3; clear H'2.\nexists x; split;\n [ try assumption | try assumption ].\nelim (COf_Couple_right x y); intros H'3 H'4; try exact H'4; clear H'4.\nexists x; split;\n [ try assumption | try assumption ].\nelim (COf_Couple_right x y); intros H'4 H'5; try exact H'4; clear H'4.\nexists x; split;\n [ try assumption | try assumption ].\nelim (COf_Couple_right x y); intros H'5 H'6; try exact H'6; clear H'5.\nexists x; split;\n [ try assumption | idtac ].\nelim (COf_Qed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN, CAdd, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CEQ in |- *.\n\nTheorem CIN_PAIR : forall E F : Ens, D <> E -> F <> E -> F <> E.\nintros E F G; try assumption.\nelim (CIN_PAIR (restricted_to_env E) (restricted_to_env E) (restricted_to_env E) (restricted_to_env E) A) H0);\n intros X H; elim (H (s:=s) (s:=s) (s:=s) (s:=s) (s':=sQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CLT, CLT, CLT.\nintros.\nsplit.\nintros.\nsplit; [ elim (H (e x)); auto with zfc | idtac ].\nintro; left; auto with zfc.\n\nelim (H (e x)); auto with zfc.\n\nelim (H (e x)); auto with zfc.\n\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN in |- *.\nintros; split.\nintro; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN in |- *.\nintros; exists (C If A' E); exists (C If A' E'); exists (C If A' E'); exists (C If A' E'); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN, CIN, CIN, CIN, CIN in |- *.\nintros; split.\nintro; apply CIN_ contributors; auto with algebra.\nintro; apply CIN_ contributors; auto with algebra.\nintro; apply CIN_ contributors; auto with algebra.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *; unfold CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, CHom, D' : category.\nintros.\napply (Build_Map (A:=A) (B:=B) (C:=B) (C:=B') (C':=B') (C':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=C') (D':=D') (D':=D') (D':=C') (D':=C') (D':=C') (D':=D') (D':=D') (D':=C') (D':=D'') (D':=D') (D':=C') (D':=D') (DQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *.\nintros; split.\nintro; apply CIN_ Bid; auto with zfc.\n\nunfold not in |- *; simpl in |- *; auto with zfc.\n\nintro; apply CIN_ contributors; apply CIN_ \">=ire; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Laire in |- *; simpl in |- *; unfold C Free, C, D' in |- *;\n simpl in |- *; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros; elim (th2 (H A) (H' A)); auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros; apply (iram_IdsOf A (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton A) (Singleton C) (Singleton C) (Singleton C) (Singleton A) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton A) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton A) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C) (Singleton C)Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros; exists x; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold indC, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN.\nintros; exists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold app_t, app_t, app_t, app_t, app_t, app_t, app_t, A, B, C, A, C, A, C, A, C, A, C, A, C, A, C, B, C, B, C, A, C, B, C, A, C, C, A, C, B, C, C, A, C, C, B, C, C, C, A, C, C, C, A, C, B, C, C, A, C, C, B, C, C, C, C, A, C, C, B, C, A, C, A, C, C, B, C, A, C, D, C, B, C, C, D, C, C, A, C, C, C, C, C, B, C, D, C, A, C, D, C, D, D, C, D, D, C, D, C, D).\nintros; elim (coordinates_of_point_equality C); intros.\nexists x; exists x; split;\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN in |- *; simpl in |- *.\nintros; split; [ try assumption | idtac ].\nunfold CIN in |- *; simpl in |- *.\nelim (CIN_ [_|_0 E); auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold app_t in |- *.\nintros; exists A; split; auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Ener, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CEQ in CIN, CEQ in |- *.\n\nTheorem CIN_symm : forall A B C : Ens, C IN A (PAIR C B) -> C = B.\nintros A B C C.\napply (well_definedness_Out_proof_back A B C A B C); auto with algebra.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros.\nunfold CIN in |- *.\nelim (IN_Ax_eq (Ax A B) (Ax A E)); intros.\nelim (Ax A B); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nintros E E' A B H' H'0; try assumption.\napply Trans with (A := E) (B := A); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CIN, CIN, CIN in |- *.\nunfold CIN, CIN in |- *.\nintros.\ncut (Equal (cart C (cart C (cart C (couple x y))) (C:=C) (inv_inv A B)).\nintros.\nelim (CIN_propertie (cart C (couple x y)) (C:=C) (inv_inv A B)).\nintros.\nelim H0.\nelim H1.\nelim (CIN_propertie (couple x y) (couple x y)); intros.\nelim H2.\nelim H2.\nelim H2.\nelim (CIN_propertie (couple x y) (couple x y)); intros.\nelim H3.\nelim H3.\nelim (CIN_propertie (couple x y) (couple x y)); intros.\nelim H4.\nelim H4.\nelim H5.\nelim (CIN_propertie (couple x y) (couple x y)); intros.\nelim H6.\nelim H5.\nelim (CIN_propertie (couple x y) (couple x y)); intros.\nelim H6.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN.\nintros.\napply CIN_Irreflexive; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CLT in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_singleton : forall E : Ens, CIN E (singleton E).\nunfold CIN, CIN, CIN, CLT in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_singleton : forall E : Ens, CIN E (singleton E).\nunfold CIN, CIN, CIN, CIN, CLT in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_singleton : forall E : Ens, CIN E (singleton E).\nunfold CIN, CIN, CLT in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold s, s, s, s, s, s, s, s, s in |- *.\nintros; exists (couple A B); auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN.\nintros E E' A B C.\nunfold CIN, CIN, CIN, CIN, CIN, CIN.\nintros C IN.\nelim (CEQ_symm A B C); intros.\nelim (CEQ_symm A B C); intros.\nelim (CEQ_trans A B C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans A B C); intros.\nelim (CEQ_trans A B C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans A B C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans B A C); intros.\nelim (CEQ_trans A B A); intros.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CLT, CLT, CLT, CLT, CEQ, CLT, CLT, CLT, CLT, CLT, CLT, CLT.\n\nTheorem CIN_EX : forall E : Ens, CIN E (Cons E (Cons E (Cons E (Cons E (Cons E (Cons E (Cons E (Cons E E)))))).\nred in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_EX : forall E : Ens, CIN E (Singleton E) -> COf E.\n(* CORORORTSCTCTREION *)\nred in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN in |- *.\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN, CIN in |- *.\nintros; elim H0; intros.\nexists x0; exists x1; exists x1; auto with zfc.\n\ngeneralize (CIN_ kc1 (couple x y)); intro h; elim h; intros.\nexists x0; exists x1; exists y; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN, CIN, CIN, CIN, CIN, CIN, CIN in |- *.\nintros.\napply CIN_ kc with (c := c); auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CI in |- *.\nunfold CI in |- *.\nauto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet,\n   FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet,\n   Ctypes, environments, FSet, FSet, FSet, FSet, FSet, FSet,\n   Clight_function, FSet, FSet, FSet, FSet,\n   Ctypes, tactics, andFSet, tactics.\n\n(* Module  Definition_eq := Induction for FSet, FSet, FSet, FSet, FSet, FSet, FSet, FSet,\n   Ctypes, tactics. *)\n\nSection Set_eq.\nVariable  L : Type.\nVariable  L' : forall x : L.t.\nVariable  L'' : forall s : s'', In x s'' -> In x s'' -> In x s''.\n\nLemma lem_FSet_Prop : forall s s' : Ensemble L,\n (forall x : _, In x s' <-> In x s) ->\n (forall x : _, In x s -> In x s'').\nintros.\napply (H x); auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold bot in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold cartesian in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nintros; unfold cart in |- *; simpl in |- *.\nintuition auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold semi in |- *; simpl in |- *; unfold CLE in |- *; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfoldglob in |- *; simpl in |- *; intros.\nelim (CIN_kc2 (A:=B) (B:=B)); auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold rRel3 in |- *; simpl in |- *; unfold CAB in |- *;\n auto with zfc.\n\nTheorem CIN_singleton_E : forall E : Ens, CIN E (singleton E) -> CIN E (singleton E).\nunfold singleton in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold eH, CIN in |- *; simpl in |- *; intros; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfoldSelect in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 351,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun x : cart x E => ~ In x E)).\nred in |- *; auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun x : Ens => ~ In (Add E (Add E x)) (Id E'))\n    (fun x : Ens => ~ In (Add E (Add E x)) (Id E'))\n    (fun x : Ens => ~ In (Add E (Add E x)) (Id E'))).\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : nat := empty.\n\nDefinition empty : natDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (E:=N)).\napply (Build_Map (Ap:=fun i : fin n => Ap (c i) i)); auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun a : E => a)).\nred in |- *.\nintros a a' H'0; try assumption.\nelim (pa x); intros.\nelim (pa x); intros.\nelim (pa x); intros.\nelim (pa x); intros.\nelim (pa y); intros.\nelim (pa x); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); intros.\nelim (pa y); introsDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun a : E => a)).\napply (Build_Map (Ap:=fun a : E => a)).\napply (Build_Map (Ap:=fun a : E => a)).\nred in |- *.\nintros.\napply Ap2_comp; auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun a : E => a)).\napply (Build_Map (Ap:=fun a : E => a)).\nred in |- *.\nintros a; try assumption.\napply Trans with (Id a); auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun i : nat => i:nat) (v:nat) => v (S i)).\napply (Build_Map (Ap:=fun i : nat => i:nat) (v:nat) => v (S i)).\nred in |- *.\nintros.\napply Ap_comp; auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun a : E => a)).\nred in |- *; intros a b c c.\nelim c.\nintros c c.\nelim c.\nintros c c0.\nelim c.\nintros c c1.\nelim c0.\nintros c1 c2.\nelim c2.\nintros c2 c3.\nelim c1.\nintros c3 c4.\nelim c4.\nintros c4 c5.\nelim c5.\nintros c5 c5 c6.\nelim c5.\nintros c5 c5.\nelim c5.\nintros c6 c6.\nelim c6.\nintros c6 c7.\nelim c6.\nintros c5 c6.\nelim c6.\nintros c6 c6.\nelim c6.\nintros c6 c7.\nelim c7.\nintros c7 c8.\nelim c6.\nintros c7 c8.\nelim c6.\nintros c7 c8.\nelim c8.\nintros c8 c9.\nelim c7.\nintros c11 c12.\nelim c9.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (Ap:=fun i => i)).\napply (Build_Map (Ap:=fun i : fin n => i)).\nred in |- *.\nintros.\napply Ap_comp; auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\napply (Build_Map (A:=Set)).\napply (Build_Map (A:=Set)).\napply (Build_Map (A:=Set)).\napply (Build_Map (A:=Set)).\napply (Build_Map (A:=Set)).\napply (Build_Map (A:=Set)).\nred in |- *.\nintros.\nred in H.\napply H.\nred in |- *; auto with algebra.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold In, In, In, IN, FSet_empty in |- *; intros.\napply H.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; split; auto with algebra.\nexact (Union_empty X).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; apply (Build_Map (Ap:=fun X : Ens => Ens) (c : E) => EQ_symm C c).\nexact (IN_semantics (cart_succ E) (cart_succ E)).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; red in |- *; intros; auto with algebra.\nelim (IN_E 0 H); intros.\nelim (IN_E 0 H); intros.\nelim (IN_E (Add_inv E) x0); intros.\nelim (IN_E (Add_inv E) x0); intros.\nelim (IN_E 0 H); intros.\nelim (IN_E (Add_inv E) x0); intros.\nelim (IN_E (Add_inv E) x0); intros.\nelim (IN_E 0 H0); intros.\nelim (IN_E (Add_inv E) x0); intros.\nelim (IN_E (Add_inv E) x0); intros.\nelim (IN_E 0 H); intros.\nelim (IN_E (Add_inv E) x1 x0); intros.\nelim (IN_E (Add_inv E) x1 x2); intros.\nelim (IN_E 0 H0); intros.\nelim (IN_E (Add_inv E) x1 x0); intros.\nelim (IN_E 0 H0); intros.\nelim (Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros; split; [ exact (EQ_refl (IN_Setoid_empty E));\n intros; apply (EQ_trans (Add_empty E) (Add_empty E));\n intros; apply (EQ_trans (Add_empty E) (Add_empty E)));\n auto with algebra.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; red in |- *; intros; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nunfold Add, Negation, In, Setoid_Theory, In, Setoid_Theory, In, Setoid_Theory, In, Setoid_Theory, app_comm, app_comm, app_comm, app_comm, app_comm, app_comm.\n\nTheorem Sym :\n forall (E F G : Ens) (a : E),\n In a (Cons a E) <-> In a (Cons a F) /\\ ~ In a F.\nProof.\nintros E F G a a.\nsplit.\nexact (H (S a)).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nunfold In, Setoid_rect, Setoid_Theory.\nintros E F G; split; intros.\napply (H (S x)).\nexact (H (S x)).\nexact (H (S x)).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintro; red in |- *; intros; auto with algebra.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintro; red in |- *; auto with algebra.\nintros x y H'; try assumption.\napply H'; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 484,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_Of_th, Set_Of_th, Set_Of_th, Set_Of_th, Set_Of_th, Set_Of_th in |- *;\n apply Set_Of_th with (cp := E); auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintro; red in |- *; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\napply Extensionality_Ensembles; intros; split; intros.\n apply Extensionality_Ensembles; introsQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_Of_th, Set_Of_th in |- *;\n apply Set_Of_th with (Y := E); auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros; unfold Set_of_nat, Top.\nexact (Singleton_of_nat E).\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_Of_th, Set_Of_th in |- *;\n apply Set_Of_th.\nexact (Singleton E).\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set in |- *; unfold not in |- *; intros; auto with zfc.\napply Ex_Prop_of_nat; auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_Of_th in |- *; unfold Set_Of_th in |- *;\n apply Set_Of_th with (a := E) (b := E); auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_of_nat in |- *; unfold Set_of_nat in |- *;\n apply Definition_of_nat_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_P.\napply Definition_of_Qed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_of_nat, FA in |- *;\n apply Set_of_nat_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_of_P_ofQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold Set_of_nat in |- *; unfold Its_empty in |- *;\n apply IN_Intersection with (a := E) (b := E).\nexact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 554,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'; red in |- *; intros; auto with zfc.\napply H; auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nunfold In in |- *; unfold In, Add, In, Add, In in |- *; intros.\napply Set_of_equivalence with (B := E') (B := E); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E'; unfold IN, Add, Add, Add, Add, FA, Set_of_succ in |- *.\nintros.\napply Set_of_equivalence with (A := E') (B := E'); auto with algebra.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'; red in |- *; unfold Add in |- *; intros; auto with zfc.\napply Set_of_Map with (A := E) (B := E') (c := E' x) (c := E' x) (c := E' x).\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; red in |- *; unfold Set_succ in |- *;\n apply IN_Union with (wsam E' E'); auto with algebra.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E'; unfold Setoid_empty in |- *; unfold IF_empty in |- *;\n apply Set_Sum_empty.\nintros.\napply Set_Sum_empty.\napply Set_Sum_empty.\napply Set_Sum_empty.\napply Set_Sum_empty.\nexact (Build_Map_empty X).\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\n(*\nTheorem IF_sub : forall E : Ens, IN E (Singleton E).\nintros E; unfold IF in |- *; unfold IN in |- *;\n apply IN_Union with (a := E) (b := a) (c := b) (c := d) (c := d) (c := d) (c := d) (x := d) (c := d) (c := d) (x := d) (d := d) (d := d) (d := d) (d := d) (x := d) (d := d) (d := d) (x := d) (d := d) (x := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (x := d) (d := d) (d := d) (d := d) (d := d) (d := d)Qed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold IN in |- *; split; intros.\napply In_Union with (Singleton E (Singleton E)) (Singleton E); auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napply H; auto with zfc.\nred in |- *; intros.\napplyQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold IN in |- *; unfold IN in |- *;\n apply IN_Union with (m := E) (y := x); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold IN in |- *; unfold IN in |- *;\n apply IN_Union with (a := E) (b := E); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E; unfold In in |- *; intros.\napply Ex_Prop.\napply Ex_Prop.\napply Ex_Prop.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; intros; discriminate.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E; unfold E in |- *; unfold E in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *; \n apply Set_Of_stable; unfold Setminus in |- *; \n apply Set_Of_stable; unfold Setminus in |- *; \n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable; unfold Setminus in |- *;\n apply Set_Of_stable;Qed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E H; unfold E in |- *.\nelim (compl_not_In E F); auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; intros.\napply (IN_Intersection (Equal (Singleton E) E) (Singleton E)).\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold not in |- *; intros.\napply (Not_F E (Singleton E)).\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F H; unfold Extensionality in |- *;\n apply Extensionality_Ensembles; split;\n [ apply E_not_In; apply E_not_In; apply E_not_In; apply E_not_In; assumption\n | apply E_not_In; apply E_not_In; assumption\n | apply E_not_In; assumption\n | apply E_not_In; assumption\n | apply E_not_In; assumption\n | apply E_not_In; assumption ].\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E H; split; intro H.\napply H.\napply H.\napply H.\napply H0.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E H; red in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E; unfold And in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; unfold not in |- *;\n unfold not in |- *; unfold not in |- *; intros.\nelim (IN_Prop (Equal (Empty E) E) (Empty_set E)); intros;\n right; apply IN_Union with (a := E) (s := s) (s := s) (s := s).\nelim (Union_intro (Singleton E) (Singleton E) (Singleton E))); intros;\n right; red in |- *; intros.\nelim (Singleton_inv_inv _ H0); intros; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n H'; red in |- *; intro H'; elim H'.\nintros n H'; red in H'; elim H'.\nintros n H'; red in H'; elim H'.\nintros n H'0; red in |- *; intro H'; elim H'.\nintros H'1; elim H'.\nintros n H'; red in H'; elim H'.\nintros H'1; elim H'.\nintros H'2; elim H'.\nintros H'3; elim H'.\nintros H'3 H'4; elim H'4; intros H'5 H'6; clear H'4 H'6.\nintros H'4; elim H'4; intros H'6 H'7; clear H'4 H'6.\nintros H'7; elim H'.\nintros H'8 H'9; elim H'.\nintros H'10 H'11; elim H'12; intros H'12 H'13; clear H'3 H'13.\nexists (S n); auto with zfc.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n H; split; auto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintro n; elim n.\nintros n H; elim H.\nintros n H; elim H.\nintros n H; elim H.\nintros n H; elim H.\nintros n H; elim H.\nintros; elim H.\nintros; elim H.\nintros; left; apply IN_symm_right with (f a); auto with zfc.\nelim H.\nintros; left; apply IN_symm_right with (f a); auto with zfc.\n\nintros; right; apply IN_symm_left with (f a); auto with zfc.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; elim n.\nunfold not in |- *.\nelim (IN_Let A (Singleton A f) (Singleton A f) (Singleton A f)).\n\nintros n0 H'; elim (H' n0).\nunfold not in |- *; intro.\nelim (H' (Singleton A f) (Singleton A f)); intros a e.\nexists a; auto with zfc.\n\napply In_Singleton; assumption.\n\nintros n0 H'; elim (H' n0).\nunfold not in |- *; intro.\nelim (H' (Singleton A f) (Singleton A f)); intros a e.\nexists a; auto with zfc.\n\nunfold not in |- *; intro.\nelim (H' n0).\nunfold not in |- *; intro.\nelim (H' (Singleton A f) (Singleton A f)); intros a e.\nexists a; auto with zfc.\n\nelim (H' (Singleton A f) (Singleton A f)); intros a e.\nexists a; auto with zfc.\n\nexists (Empty_set A (Singleton A f)); auto with algebra.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nred in |- *; intros; split; red in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintro n; elim n.\nintros; left; apply IN_Union with (Singleton A f); auto with zfc.\n\nintuition.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nred in |- *.\nintros n H'; red in |- *; intros a s; elim s.\nelim (H' a s); intros a s.\nexists (S s).\nexists (S s).\nexists (S s).\nexists (S s).\nexists (S s); auto with zfc.\n\nelim (H' a s); intros a s.\nexists (S s).\nexists (S s); auto with algebra.\n\nelim (H' a s); intros a s.\nexists (S s).\nexists (S s).\nexists (S s); auto with algebra.\n\nexists (S s).\nexists (S s).\nexists (S s).\nexists (S s); auto with algebra.\n\napply Trans with (S (S s)); auto with algebra.\n\nelim (H' a s); intros a s.\nexists (S s).\nexists (S s).\nexists (S s); auto with algebra.\n\nelim (H' a s); intros a s.\nexists (S s).\nexists (S s); auto with algebra.\n\napply Trans with (S (S s)).\nauto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; apply (IN_Strict_set_empty (Singleton A) f) with (Empty_set A); auto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; elim (IN_Theorem_Sn n).\nintros n; elim (IN_Theorem_Sn n).\nintros n0 H1; elim (IN_Theorem_Sn n0).\nintros n0 H1; elim (IN_Theorem_Sn n0).\nintros n1 H2; elim (IN_Theorem_Sn n1).\nintros n1 H2; elim (IN_Theorem_Sn n1).\nintros n2 H3; elim (IN_Theorem_Sn n1).\nintros n2 H3; elim (IN_Theorem_Sn n2).\nintros n3 H4; elim (IN_Theorem_Sn n1).\nintros n3 H4; elim (IN_Theorem_Sn n1).\nintros n3 H4; elim (IN_Theorem_Sn n2).\nintros n4 H5; elim (IN_Theorem_Sn n3).\nintros n5 H6; elim (IN_Theorem_Sn n3).\nintros n5 H6; elim (IN_Theorem_Sn n1).\nintros n4 H6; elim (IN_Theorem_Sn n3).\nintros n5 H6; elim (Qed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nred in |- *.\nintro n; elim (IN_card (fun n : nat => n) T).\nintros n0 H; elim H.\nintros n1 H; elim H.\nintros n2 H; elim H.\nintros n2 H; elim H.\nintros n3 H; elim H.\nintros n3 H; elim H.\nintros n3 H; elim H.\nintros n3 H; elim H.\nintros n3 H0; elim H0.\nintros n3 H; elim H0.\nintros n3 H0; elim H0.\nintros n3 H0; elim H0.\nintros n3 H0; elim H0.\nintros n3 H; elim H0.\nintros n4 H0; elim H0.\nintros n3 H0; elim H0.\nintros n4 H0; elim H0.\nintros n3 H0; elim H0.\nintros n4 H1; elim H1.\nintros n4 H1; elim H1.\nintros n5 H1; elim H1.\nintros n1 H0; elim H1.\nintros n2 H; elim HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nintros; exists (S n); auto with sets.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nred in |- *.\nintros; exists (fun n : nat => ~ In (Nat n) (fun n : nat => ~ In (Nat n) (f n)).\nred in |- *; intro; exists (fun n : nat => ~ In (Nat n) (f n)).\nred in |- *; intro; exists (fun n : nat => ~ In (Nat n) (f n)).\nred in |- *; intro; exists (fun n : nat => ~ In (Nat n) (f n)).\nelim (H (fun n : nat => ~ In (Nat n) (f n))).\nintro; left; auto with zfc.\n\nelim (H (fun n : nat => ~ In (Nat n) (f n))).\nintro; left; auto with zfc.\n\nelim (H (fun n : nat => ~ In (Nat n) (f n))).\nintro; right; auto with zfc.\n\nelim (H (fun n : nat => ~ In (Nat n) (f n))).\nintro; right; auto with zfc.\n\nright; auto with zfc.\n\nright; auto with zfc.\n\nright; auto with zfc.\n\nright;Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; exists n; auto with algebra.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; exists (fun n : nat => ~ (exists n : nat, n = S n)).\nelim (alt_In_EXType (fun n : nat => ~ (exists n : nat, n = S n)).\nintros n H.\nelim (IN_EXProp (fun n : nat => ~ (exists n : nat, n = S n)).\nintros n H0; elim H0; intros n H1; elim H1; intros n H1.\nexists (fun n : nat => ~ (exists n : nat, n = S n)).\nsplit; [ try assumption | idtac ].\napply H1; exists n; auto with zfc.\nintros n H0; elim H0; intros n H1.\nexists (fun n : nat => ~ (exists n : nat, n = S n)).\nsplit; [ try assumption | idtac ].\napply H1; exists n; auto with zfc.\napply H1; exists n; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; exists n; auto with zfc.\n\nTheorem In_couple_inv1 : forall E : Ens, In E (couple_inv1 E) (couple_inv2 E).\nintros; exists n; auto with zfc.\n\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nunfold not in |- *; intros.\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\nred in |- *; intros.\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\nred in |- *; intros.\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\nred in |- *; intros.\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\napply Set_Of_th with (P := fun n : nat => EQ (Nat n) (f a)).\nredQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nunfold In in |- *.\nintros; split; intros; auto with sets.\nexists (S n); auto with sets.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; simpl in |- *.\nexists (fun n : nat => n); auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n; simpl in |- *.\nexists (S n); auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nunfold not in |- *; intros.\nsplit; intro.\nelim (IN_EXType (fun n : nat => False) E (fun p : nat => False) H).\nintros n H'; elim H'0; intros; auto with zfc.\n\napply E_not_in_EXType with (fun n : nat => False) H'.\nred in |- *; intro; red in H'; apply H'.\nred in |- *; intro; red in H'.\napply H'; auto with zfc.\n\napply (IN_Nat_fun n).\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; elim E; intros n E; elim E; intros p E0; clear E0.\nexists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n; intros.\nelim (IN_Nat_exists (fun p : nat => EQ (Nat p) E)).\nintro; left; red in |- *; intro; elim H; intros; clear H; intros; clear H;\n elim (IN_Nat_exists (fun p : nat => EQ (Nat p) E)).\nintro; left; red in |- *; intro; elim H; intros; clear H; intros; clear H;\n elim (IN_Nat_exists (fun p : nat => EQ (Nat p) E).\nintro; right; red in |- *; intro; elim H; intros; clear H; intros; clear H;\n elim (IN_Nat_dec (fun p : nat => EQ (Nat p) E)).\nintro; left; red in |- *; intro; elim H; intros; clear H; intros; clear H;\n elim (IN_Nat_dec (fun p : nat => EQ (Nat p) E)).\nintro; left; red in |- *; intro; elim H; intros; clear H; intros; clear H;\n elim (IN_Nat_dec (fun p : nat => EQ (Nat p) E)).\nintro;Qed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *; exists n; auto with algebra.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; elim E; intros n E; elim E; intros n E.\nexists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nintros; simpl in |- *; exists n; auto with zfc.\n\napply S_pred with n; auto with zfc.\n\nunfold In in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; elim E; simpl in |- *; auto with zfc.\nintros n H'.\nexists n; auto with zfc.\n\nexists n; auto with zfc.\n\nexists (n + S n); auto with zfc.\n\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros; simpl in |- *.\nelim (IN_Nat_dec n 0); intros n H1.\nelim (H1 (IN_Nat_dec n0 n1)); intros n1 H2.\nelim (H2 (IN_Nat_dec n1 n1)); intros n2 H3.\nexists n; auto with zfc.\n\nexists (S n); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nsplit; [ try assumption | idtac ].\nred in |- *.\nexists (Union (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (singleton n))))))))) x)).\nred in |- *.\nsplit; [ try assumption | idtac ].\nred in |- *.\nexists (Union (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (singleton n)))))))) x)))).\nred in |- *.\nexists (Union (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (if b)))));)))));\n auto with *.\nred in |- *.\nintro; exists (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Qed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold reflexivity in |- *.\nintros x y z H.\nunfold Z in |- *.\nelim (IN_Union (Singleton x) (Singleton y) H).\nintros; exists x.\nauto with zfc.\n\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; red in |- *; intros; apply H; clear H; intro; clear H.\napply Trans with (Union (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (singleton n))))))))))) x)).\napply Sym.\napply Trans with (Union (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (singleton n)))))))))) x)));\n auto with zfc.\n\napply Sym.\napply Sym.\napply Sym.\napply Add_compatible_Union.\napply Trans with (Union (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (Singleton (singleton n))))))))))) x)).\napply Sym.\napply SymQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintros x y.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napply Sym.\napplyQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nunfold IN in |- *.\nintros n H'; split; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelim H'; intros.\nelimQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold SUB in |- *.\nintros x y H; elim H; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Included, In in |- *.\nintros x.\ncut (In (Singleton x) (Singleton x)) /\\ ~ In (Singleton x) (Singleton x)).\nintros.\napply H.\nunfold In in |- *.\nelim (H0 x); intros; exists (Singleton x); auto with zfc.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Add, In, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add, Add)\n in |- *.\nintros n e.\napply H with (Add (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E E) (Add E (Add E (Add E (Add E (Add E (Add E (Add E E) (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add E (Add EQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold EQ in |- *.\nintros x; simpl in |- *.\nelim (IN_Union (Singleton x) (Singleton x)); auto with zfc.\n\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintros x; red in |- *; intros x0.\nexists (Union_commutative (Singleton x) x).\nsplit; [ exact (Union_commutative (Singleton x) (Singleton x) x0).\nred in |- *.\nauto with algebra.\nQed."
                ]
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 255,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; apply H; reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H H'; rewrite H'; auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; destruct H; reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; rewrite H; reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; rewrite H; reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y; rewrite eq_sym; auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H H0. rewrite H0. reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. apply eq_trans with y; auto. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; destruct H; reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros x y H; unfold eq, eq, eq; destruct compare; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 285,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now apply eq_trans with y. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now apply eq_trans with y; assumption. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros x y z [x1 x2]; destruct z; auto. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros x y z H H0 H1. now apply H. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now transitivity y. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 321,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros x y z H Hyz. specialize (Hxy Hyz). rewrite Hxy. constructor. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. rewrite <- lt_iff. apply lt_trans with y; assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. eapply lt_trans. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros x y z H H0. eapply lt_trans; eassumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with y. assumption. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 357,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. exfalso. assumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply (StrictOrder_Irreflexive x). Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. etransitivity; eassumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. assumption. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply eq_sym. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros x y. unfold eq, eq. intuition. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. contradict H. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros?? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 404,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y. apply eq_sym, eq_trans with y. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now apply eq_sym. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply eq_sym, CompOpp_eq. assumption. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y. unfold eq. exact I. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply LT. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. rewrite H. reflexivity. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now rewrite <- 2 lt_not_eq in Hlt. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros x y; destruct (CompSpec2Type (compare_spec x y)). Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. exact I. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. unfold eq, eq; intros. intuition. Qed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n as [| n IH]; simpl; auto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; simpl; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nintros.\nrewrite <- (mult_comm n 1).\nrewrite <- mult_n_O.\nrewrite <- mult_n_O.\nreflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; simpl; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n rewrite <- (multZ_eq n 1).\n rewrite <- (multZ_eq n 1).\n reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; unfold Zle in |- *; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros; unfold multZ in |- *; elim (mult_comm (S n1)); auto with arith.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 728,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite <- (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite mult_assoc.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_plus_distr_l.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm y x).\n rewrite (mult_comm y x).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm y x).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite (mult_comm xQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x y).\n rewrite (mult_comm x y).\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite H.\n rewrite mult_comm.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite plus_comm.\n rewrite mult_comm.\n rewrite mult_plus_distr_l.\n reflexivity.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n apply mult_POS_mult_neg.\n apply le_mult_neg_1.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.\n apply le_mult_neg_2.Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n apply le_antisym.\n assumption.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos x)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite (mult_comm (pos y)) at 2.\n rewrite mult_comm.\n rewrite mult_plus_distr_r.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply mult_nonneg_nonneg.\n apply le_O_n.\n apply mult_nonneg_nonneg.\n apply le_O_n.\n apply le_O_n.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite (mult_comm x).\n rewrite (mult_comm y).\n rewrite (mult_comm x).\n apply mult_comm.\n assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nintros; elim x.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintrosQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\n(* pos n *)\n intros; elim n.\n simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n (* neg n *)\n simpl in |- *; reflexivity.\n (* neg n *)\n intros; elim n.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; elim n.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* pos n *)\n intros; simpl in |- *; reflexivity.\n (* posQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ", multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* posQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |-Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos 0 *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *.\nelim (Odd_mult_n_O n0 x).\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; exact (mult_numerator_l n0 x).\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *.\nelim (Odd_mult_n_O n0 x).\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; exact (mult_1301_l n0 x).\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; apply prime_gt_0.\n(* pos n *)\nintros; simpl in |- *; apply prime_gt_0.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivityQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; apply le_trans with (pos n);\n [ apply (pos_abs (pos n) (pos_abs (pos n))); auto with arith ].\n(* pos n *)\nintros; simpl in |-Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; assumption.\n(* pos n *)\nsimpl in |- *; symmetry Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim x.\nrewrite <- (mult_comm x y); rewrite <- (mult_comm y x); rewrite (mult_comm y x); reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim x.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim x; simplQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (mult_n_O n); reflexivity.\n(* posQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nintros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nunfold Zminus in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimplQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintro x; elim x; clear x.\nintros x0 H; rewrite H; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros x; unfold oppZ in |- *; apply (mult_diag_reverse x).\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nintros n0 H; rewrite H; rewrite H0; reflexivity.\nintros n0 H; rewrite H; rewrite H0; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H0; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; reflexivity.\nintros n0 H; rewrite H; rewrite H; rewrite H; rewrite H; reflexivity.Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintro x; elim x.\nintros x0 H'; elim H'; intros.\nrewrite (tech_opp_pos x0).\nrewrite <- (tech_opp_pos x0).\nelim (inv_opp_zero (inv_opp_zero (inv_opp_zero (inv_opp_zero (inv_opp_opp (inv_opp_opp (inv_opp_opp (inv_opp_opp (inv_opp (inv_opp_opp (inv_opp (inv_opp (inv_opp (inv_opp_opp (inv_opp (inv_opp_opp (inv_opp (inv_opp (inv_opp (inv_opp_opp (inv_opp (inv_opp (- inv_opp (- inv_opp (inv_opp (inv_opp (inv_opp (- inv_opp (- inv_opp (inv_opp (inv_opp - inv_opp (- inv_opp (- inv_opp (inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (- inv_opp (-Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *;Qed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nreflexivity.\nintros n0 H; rewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_negZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_negZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewrite (tech_add_posZ n0).\nrewriteQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; unfold plusZ in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nintros; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintro x; elim x.\nintros n H; rewrite (tech_mult_posZ y); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nintros; simpl in |- *.\nrewrite minus_Sn.\nrewrite H; reflexivity.\n(* pos n *)\nintros x y H; rewrite (tech_mult_posZ y z); rewrite H; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nintros; simpl in |- *; apply mult_EGAL_complete; auto.\nintros; simpl in |- *; apply mult_EGAL_complete; auto.\nintros; simpl in |- *; apply mult_EGAL_complete; auto.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros; elim x; simpl in |- *; auto.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; rewrite (tech_opp_pos_pos x); reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n H; rewrite (tech_mult_pos_pos n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_mult_pos_pos n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_mult_pos_pos n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_mult_pos_neg n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_pos_neg n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_pos n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_pos_neg n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_pos n 0); rewrite H; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_opp_pos_pos n 0); rewrite H; reflexivity.\n(*Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; unfold multZ in |- *; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; rewrite mult_comm; reflexivity.\n(* pos n *)\nintros n H; rewrite (tech_mult_negZ x) in H; rewrite H; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nintros x; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros n; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos n *)\nintros n0; rewrite (tech_oppZ x); reflexivity.\n(* pos nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_mult_pos_Z 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ (pos n)); rewrite H; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite (tech_opp_posZ 0); rewrite H; reflexivity.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 744,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; elim (mult_n_O _ H); intros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimpl in |- *; apply le_refl.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)\nsimple induction m.\n(* pos n *)Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros; rewrite (tech_mult_posZ y), (mul_n_O x) in H.\nrewrite (tech_mult_posZ x 0); reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y), (mul_n_O x) in H.\nrewrite (mul_n_O y) in H.\nrewrite (tech_mult_posZ y 0) in H.\nrewrite (mult_comm y (pos x)); reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y) in H.\nrewrite (tech_opp_posZ y (neg x)); reflexivity.\n(* pos n *)\nintros y H; rewrite (tech_opp_posZ y 0) in H.\nrewrite (tech_opp_posZ y 0); reflexivity.\n(* pos n *)\nintros; rewrite (tech_opp_posZ y 0) in H.\nrewrite (tech_opp_posZ y 0) in H.\nrewrite (tech_opp_posZ y 0) in HQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nreflexivity.\nintros n; rewrite (tech_opp_involutive (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos)))));\n   simpl in |- *; reflexivity.\nelim (pred_predX (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (neg (pos (pos (neg (pos (pos (neg (pos (pos (pos (pos))))))))))) N);\n simpl in |- *; reflexivity.\nelim (pos_Rl (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (pos (neg (neg (pos (negQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x; simpl in |- *; auto with zarith.\nintros; simpl in |- *; rewrite opp_multKr; rewrite opp_multKr; ring.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite opp_multKr; rewrite opp_multKr; rewrite opp_multKr; ring.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite opp_multKl; rewrite opp_multKr; rewrite opp_multKr; ring.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite opp_multKr; rewrite opp_multKr; rewrite opp_multKr; ring.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite opp_multKr; rewrite opp_multKr; rewrite opp_multKr; ring.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros; simpl in |- *; rewrite opp_multKr; rewrite opp_multKr; rewrite opp_multKr; ring.\n(* pos n *)\nintros; simpl in |- *; rewrite opp_multKr; rewrite opp_multKr; rewrite opp_multKr; ring.Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimpl in |- *.\nrewrite <- (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite (mult_n_O x).\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_Sm.\nrewrite mult_n_O.\nrewrite mult_n_Sm.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_Sm.\nrewrite mult_n_O.\nrewrite mult_n_Sm.\nrewrite mult_n_Sm.\nrewrite mult_n_O.\nrewrite mult_n_O.\nrewrite mult_n_Sm.\nrewrite mult_nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nintros x; rewrite (tech_mult_negZ x 0); reflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x; simpl in |- *; reflexivity.\nintros; simpl in |- *; apply sym_equal; apply eq_sym; apply eq_sym; apply eq_add_S; assumption.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos n *)\nsimple induction n.\nsimpl in |- *.\nunfold oppZ in |- *.\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _ x).\nrewrite (mult_n_O _Qed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nreflexivity.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_neg_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_neg_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_mult_neg_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H; rewrite (tech_opp_posZ n0); rewrite H; reflexivity.\n(* pos n *)\nintros n0 H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  case (decZ (absZ x)).\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\n  intro.\n  apply zero_zero.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  replace x with (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat n)))))\n    (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat (Zabs_nat n))))))))).\n  rewrite abs_absZ.\n  apply Zabs_ind; simpl in |- *; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  cut (absZ x = 0).\n  intro.\n  cut (absZ x = 0).\n  intro.\n  apply H.\n  apply eq_abs_0.\n  assumption.\n  apply zero_zero_succ_nat_eq_succ.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  simple induction x.\n  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction 1; intros; auto with arith.\nsimple induction 1; intros.\napply neg_abs_0.\napply pos_abs_1.\napply pos_abs_1.\napply pos_abs_1.\napply pos_abs_1.\napply pos_abs_1.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_1.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_1.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_1.\napply pos_abs_1.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\napply pos_abs_2.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nintro.\nelim (zero_absZ x).\nintros.\nelim H.\nelim (zero_absZ x).\nintros.\nelim H0.\nelim H1.\nelim H2.\nelim H3.\nelim H4.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.\nelim H5.Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.  unfold negZ in |- *.  apply zero_zero_zero_zero. \nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  intros.\n  apply neg_absZ.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\n  unfold sign_absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ, absZ,Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x; simple induction 1; intros; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros x H; elim H; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n intros; apply pos_eq_nat_dec; auto.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x H; elim H; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simpl in |- *; intros.\nelim (O_le_dec x 0); intros.\nelim H1; simpl in |- *.\nrewrite H1; reflexivity.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x.\n simpl in |- *.\n apply neg_absZ.\n assumption.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\n exact neg_absZ.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\n exact I. intro; simpl in |- *.\n exact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros x H; elim H; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\n intros; elim x; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold sign_absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold signZ in |- *; unfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nsplit; simpl in |- *; auto with real.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nsplit.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexactQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold incrZ in |- *; split; intros.\napply neg_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napply abs_eq_pos.\napplyQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nsplit; unfold EqLn, Negation in |- *; simpl in |- *; intros; discriminate.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold refZ in |- *; unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; unfold absZ in |- *;\n unfold absZ in |- *; \n unfold absZ in |-Qed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nconstructor; unfold reflexive, symmetric, symmetric, absZ in |- *;\n unfold Rgt, oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; simpl in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n apply Zle_Qed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold neutralZ in |- *; intros; elim H.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nexact I.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; intros.\nunfold lt_absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nintros; elim H; simpl in |- *.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; intros H1 H2; rewrite H1; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *.\nauto.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; intros H1; rewrite H1; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |- *; reflexivity.\nintros; elim H.\nunfold negZ in |-Qed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H.\nunfold negZ in |- *; reflexivity.\nunfold not in |- *; intros; elim H; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *.\nintros; left; trivial.\nintros; left; trivial.\nintros; right; trivial.\nintros; left; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 742,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nreflexivity.\n (* pos n *)\nintros; elim H.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold negZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold gtZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfoldQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros n; elim n.\nunfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *;Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintro n; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold negZ in |- *; unfold ltZ in |- *;\n unfold posZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n apply le_trans with (S (pred (pred n)) (pred (pred (pred n)));\n auto with real.\n (* (pos n) *)\n intros; elim H1.\n (* (pos n) *)\n intros; elim H2.\n (* (pos n) *)\n intros; elim H2.\n (* (pos n) *)\n intros; elim H2.Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n unfold ltZ in |- *; \n applyQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nintros; elim H.\nunfold lt_absZ in |- *; unfold ltZ in |- *;\n unfold negZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; simpl in |- *;\n intros.\nelim (lt_irrefl n).\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros.\nunfold lt_absZ in |- *; unfold ltZ in |- *; simpl in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; \n simpl in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; \n unfold ltZQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n apply lt_irrefl.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n (* nil *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (pos n) *)\nintros; elim H0.\n(* (neg n) *)\nintros; elim H0Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltZ in |- *; \n unfold ltZ in |- *;\n unfold ltZ in |- *; unfold ltQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\ninduction y; simpl; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nsimple induction x1; simple induction y; simpl in |- *; auto.\nintros; apply nat_of_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_P_Q_P_Q.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  case x; case y; simpl; reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfoldAAA,AAA,points, eq_refl.\nintros.\nunfold eq_sym, eq_sym in |- *.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite plus_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc_reverse.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_assoc.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_commQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold Gao, le in |- *.  elim y; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\ninduction y; simpl; intros; auto with arith.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nintros.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite mult_assoc.\nrewrite (mult_comm y).\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nintros.\ncase (Z_eq_dec y 0); intros.\nrewrite H.\nrewrite H0.\nreflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nintros.\nrewrite <- (mult_comm x1).\nrewrite <- mult_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite plus_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite plus_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewriteQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nintros.\nunfoldponens_eq in |- *.\nunfold app_eq in |- *.\nelim y; elim y; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nintros; unfoldinciples, neg, opp, predZ, predZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ,oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ,oppZ, oppZ, oppZ,oppZ, oppZ, oppZ.opp, oppZ.oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ, oppZ,oppZ, oppZ, oppQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\n auto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\n auto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros.\nelim H; simpl in |- *; auto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros.\napply pred_ext; tauto.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nsimple induction x.\n(* pos n *)\nintros x y; apply pred_prime_bezout; assumption.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_ authors x).\n(* pos n *)\nintros n1 H.\nsimpl in |- *; symmetry  in |- *; exact (pred_ authors x).\n(* pos n *)\nintros n1 H.\nsimpl in |- *; symmetry  in |- *; exact (pred_prime_divide_r n1 n1 H).\n(* pos n *)\nsimpl in |- *; exact (pred_prime_gt_0 n1 n1 H).\n(* pos n *)\nintros n1 H.\nsimpl in |- *; exact (pred_prime_gt_0 n1 n1 H).\n(* pos n *)\nsimpl in |- *; exact (pred_prime_gt_0 n1 n1 H).\n(* pos n *)\nsimpl in |- *; exact (pred_prime_gt_0 n1 n1 H).\n(* pos n *)\nsimpl in |- *; exact (pred_prime_gt_0 n1 n1 H).\n(* pos n *)Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_l n 0 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_noteq_r n 0 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_succZ_r n 0 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_succZ_l n 0 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_predZ_r n 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_succZ_r n 0 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_predZ n n 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_Hgt n 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_Hgt n 0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_Hgt n 0).\n(*Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_r x).\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_r x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_succZ_l x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ_r x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ_r x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_itself_r x).\n(* pos n *)\nsimpl in |- *; exact (pred_ORlist_l x).\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (pred_predZ_r x).\n(* pos n *)\nsimpl in |- *; exact (pred_predZ_r x).\n(* pos n *)\nsimpl in |- *; exact (pred_succZ_r x).\n(* pos n *)\nsimpl in |- *; exact (pred_Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ n0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_succZ_l n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_predZ_l n0 n0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_succZ n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_OZ_l n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_predZ_r n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_ny n0 n0).\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_ny n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_ny n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_predZ_r n0 n0).\n(* pos n *)\nsimpl in |- *; exact (pred_ZERO n0 n0).\n(* pos n *)Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nsimple induction x.\nsimpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nintros; elim H; simpl in |- *; auto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite pred_absolu_r; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_r; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_r; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_r; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_min; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_min; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_min; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_min; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_absolu_min; simpl in |- *; auto with arith.\n(* pos n *)\nintros; simplQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nintros; unfold pred_PBO in |- *; rewrite pred_Sn_m; reflexivity.\n(* pos n *)\nintros; rewrite pred_Sn_m; reflexivity.\n(* pos n *)\nintros; simpl in |- *; symmetry  in |- *; exact (pred_Sn_m n0).\n(* pos n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (pred_Sn_m n0).\n(* n *)\nintros; simpl in |- *; elim (Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *;Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimple destruct n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_inlist_l (S n0) y). \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_inlist_l (S n0) y). \n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_predn_r (S n0) y).\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_predn_r (S n0) y).\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; symmetry  in |- *; exact (pred_ **************************************************************)\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 740,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nintros; elim x.\nsimpl in |- *; rewrite pred_Onotbool_r; trivial.\nintros; rewrite pred_oZ_eq3; rewrite pred_Rlength_eq3; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x; simpl in |- *; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nsimpl in |- *; rewrite pred_addZ_l; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; rewrite pred_succZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nintros; elim x; auto with arith.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nintros; elim x.\nreflexivity.\nintros; rewrite pred_predZ; trivial.\nintros; rewrite pred_ authors; trivial.\nintros; rewrite pred_ authors; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimpl in |- *; rewrite pred_ caseEq_refl; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_prime_positive; trivial.\n(* pos n *)\nsimple destruct n.\nsimplQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nsimpl in |- *; rewrite pred_succZ_r; trivial.\nintros; rewrite pred_predZ; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimple induction n.\n (* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n (* pos n *)\nsimple induction n.\n (* pos n *)\nsimple induction n.\n (* pos n *)\nsimple induction n.\n (* pos n *)\nsimple induction n.\n (* pos n *)\nsimple induction n0.\n (* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nintros; rewrite pred_ Renamings_eq3.\napply pred_ semSem_r.\napply pred_ semSem_r.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_ Version.\napply pred_succ_diag.\napply pred_ Version.\napply pred_succ_diag.\napply pred_succ_diag.\napply pred_succ_diag.\napply pred_succ_diag.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_lexfg n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_fibonacci n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_negQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* pos n *)\nsimple induction n.\n(* pos 0 *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_fibonacci n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_things n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\ndo 2 rewrite (Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x; trivial.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* succ n *)\nsimple induction n.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nintros.\ndo 2 rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nintros.\ndo 2 rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nintros.\ndo 2 rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nintros.\ndo 2 rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nsimpl in |- *; rewrite pred_pos_pred_pos; trivial.\n(* pos n *)\nintros.\ndo 2 rewrite pred_pos_Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_posQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\nunfold pred at 1 in |- *; reflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pred_succ_pred_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_succ; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred_succ_pred; simpl in |- *;\n intros; simpl in |- *; rewrite pred_succ_pred_pred_pred; simpl in |- *;\n intros; simplQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nsimpl in |- *; rewrite pred_scmult; trivial.\nintros; rewrite pred_predn; trivial.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nintros; elim x.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_EGAL_complete; rewrite pred_addZ_l; trivial.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_prime_eq; rewrite pred_prime_eq; rewrite pred_prime_eq;\n apply pred_prime_pos.\n(* pos n *)\nintros; simpl in |- *; rewrite pred_prime_eq; rewrite pred_prime_eq; rewrite pred_prime_eq;\n apply pred_prime_pos.\n(* pos n *)\nsimpl in |- *; rewrite pred_prime_eq; rewrite pred_prime_eq; rewrite pred_prime_eq;\n apply pred_prime_pos.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction 1.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)\nsimple induction n0.\n(* pos n *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 751,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_predn; trivial.\nintros; rewrite pred_Peano_dec.\nelim H; reflexivity.\n(* pos n *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* pos n *)\nsimple induction n.\n(* (neg n) *)\nintros; simpl in |- *; rewrite pred_two_power_pos_fibonacci; trivial.\n(* (neg n) *)\nsimple induction n.\nsimpl in |- *; rewrite pred_prime_divisors; trivial.\n(* (pos n) *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n.\n(* (pos m) *)\nsimple induction n.\n(* (pos m) *)\nsimple induction m.\n(* (pos m) *)\nsimple induction n.\n(* (pos m) *)\nsimple induction n.\n(* (pos m) *)\nsimple induction n.\n(* (neg m) *)\nsimple induction m.\n(* (pos m) *)\nsimple induction m.\n(* (pos m) *)\nsimple induction m.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* pos n *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction p.\nsimpl in |- *; rewrite pred_pos_pred_succ.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewrite minus_Sn_m.\nrewriteQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nunfold succ in |- *; reflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x; simpl in |- *; auto with arith.\nintros; rewrite tech_add_pos_succZ; trivial.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\nreflexivity.\nintros; rewrite neg_pred_pos.\nreflexivity.\nintros; rewrite neg_pred_pos.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\nreflexivity.\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintro; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 747,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\n(* pos n *)\nintros; rewrite pred_succ_pred_pos; rewrite pred_succ_pred_pos; reflexivity.\n(* pos n *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\nsimpl in |- *; rewrite pred_succ_pred_pos; reflexivity.\n(* (neg n) *)\nsimple induction n.\n(* (neg n) *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n.\n(* (pos n) *)\nsimple induction n0.\n(* (pos n) *)\nsimple induction n0.\n(* (neg n) *)\nsimple induction n0.\n(* (neg n) *)\nsimple induction n0.\n(* (neg n) *)\nsimple induction n0.\n(* (pos n) *)\nsimple induction n0.\n(* (pos n) *)\nsimple induction n0.\n(* (pos n) *)\nsimple induction n0.\n(* (pos n) *)\nsimple induction n0.\n(* (pos n) *)Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros;rewrite H; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros;rewrite H; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |- *; rewrite pred_pos_pos.\nreflexivity.\nsimpl in |-Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n (* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; rewrite pred_pos_pred_pos; rewrite H; reflexivityQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite H; rewrite H; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite H; reflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nsimpl in |- *; apply pred_Sn_m.\nintros; rewrite H; reflexivity.\n(* pos n *)\nsimple induction nQed."
                ]
            }
        ],
        "UnifySL": [
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "port Logic.MinimunLogic.ProofTheory.Minimun.\nRequire Import Logic.MinimunLogic.ProofTheory.RewriteClass.\nRequire Import Logic.PropositionalLogic.ProofTheory.Intuitionistic.\nRequire Import Logic.PropositionalLogic.ProofTheory.DeMorgan.\nRequire Import Logic.PropositionalLogic.ProofTheory.GodelDummett.\nRequire Import Logic.PropositionalLogic.ProofTheory.Classical.\nRequire Import Logic.PropositionalLogic.ProofTheory.RewriteClass.\nRequire Import Logic.SeparationLogic.ProofTheory.SeparationLogic.\nRequire Import Logic.SeparationLogic.ProofTheory.DerivedRules.\nRequire Import Logic.SeparationLogic.ProofTheory.RewriteClass.\nRequire Import Logic.Extensions.ProofTheory.Stable.\n\nLocal Open Scope logic_base.\nLocal Open Scope syntax.\nImport PropositionalLanguageNotation.\nImport SeparationLogicNotation.\n\nClass Corable (L: Language) {minL: MinimunLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\n",
                "context_tokens": 639,
                "proof_start_offset": 2647,
                "proof_end_offset": 2756,
                "proof": "Lemma corable_truep: corable TT.\nProof.\napply (@truep_stable L _ _ Gamma corable corable_pstable); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_prop_p_stable _ _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_andp _ _ _ TT). Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_imp_derives _ _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_imp_derives _ _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_prop_p_stable _ _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_prop_p_stable M _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply @corable_andp. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_prop_p_stable L _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_andp _ _ _ _ _ _) _. Qed.",
                    "Lemma corable_truep: corable TT. apply corable_truep. apply corable_truep. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "unLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 3431,
                "proof_end_offset": 3600,
                "proof": "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\nintros.\nrewrite andp_comm.\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ _ (x && y)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@wand_frame_l _ _ (x * y)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ x y z); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_sepcon_andp_sepcon1 L _ _ _ H). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ _ Gamma corable_p); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@sepcon_comm _ _ x y); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ x y z); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_sepcon_andp_sepcon1 L _ _ (y && z)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@allp_left _ _ _ Gamma && (y && z)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_sepcon_andp1 L _ _ _ Gamma corable_p); auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "ogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\nLemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 3602,
                "proof_end_offset": 3802,
                "proof": "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\nintros.\nrewrite sepcon_comm.\nrewrite (sepcon_comm x z).\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ _ x y z). Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply @wand_frame_r; auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply corable_sepcon_andp1; auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ _ A x y z); auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (H x y z). auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply @corable_andp_sepcon1; auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply corable_andp_sepcon1; auto.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 737,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct (Z.gcd_greatest a b d) as (c & d & H1 & H2).\n exists c.\n split.\n rewrite <- Z.gcd_greatest; auto with zarith.\n intros b c d H1.\n rewrite <- Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcd_greatest; auto with zarith.\n intros b c d H H0.\n rewrite Z.gcdQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H; apply Zis_gcd_sym.\n apply Zis_gcd_sym.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.\n apply Zis_gcd_for_euclid2.Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct d as [a b c d].\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n destruct (H (b - c)) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c) eqn:H; trivial.\n unfold Zgcd_bound.\n destruct (b - c)Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n apply Zis_gcd_for_euclid with (a:=b) (b:=d) (c:=d) (c:=d) (c:=d).\n intros (e,H).\n destruct H as (g,(H1,H2)).\n destruct H1 as (g,(H3,H4)).\n destruct H4 as (g,(H5,H6)).\n destruct H5 as (g,(H5,H6)).\n destruct H5 as (g,(H5,H6)).\n destruct H6 as (g,(H7,H8)).\n destruct H7 as (g,(H8,H9)).\n destruct H8 as (g,(H8,H9)).\n destruct H9 as (g,(H9,H10)).\n destruct H9 as (g,(H9,H10)).\n destruct H8 as (g,(H8,H9)).\n destruct H8 as (g,(H9,H10)).\n destruct H8 as (g,(H9,H10)).\n destruct H10 as (g,(H8,H9)).\n destruct H10 as (g,(H9Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\napply Zis_gcd_for_euclid with (a:=b) (c:=d) (d:=d) (d:=d) (d':=d') (d':=d').\nintros; apply Zis_gcd_for_euclid with (a:=b) (c:=d) (d':=d') (d':=d');\nintros; apply Zis_gcd_for_euclid with (a:=d) (c:=d') (d':=d') (d':=d') (d':=d').\nintros; apply Zis_gcd_for_euclid with (a:=d) (d:=d) (d':=d');\nintros; apply Zis_gcd_for_euclid with (a:=d') (d':=d') (d':=d') (d':=d').\nintros; apply Zis_gcd_for_euclid with (a:=d) (d':=d') (d':=d').\nintros; apply Zis_gcd_for_euclid with (a:=d') (d':=d') (d':=d').\nintros; apply Zis_gcd_for_euclid with (a:=d) (d':=d') (d':=Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n destruct d; simpl; intros; auto.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros.\n apply Zgcd_pol_pos.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H H0; apply Zgcd_bound; auto with zarith.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nunfold Zgcd_eq.\ndestruct (dec_bool 0 b) as [H0|H0].\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napply Zgcd_opp.\n(* a case analysis on whether a hypothesis is a \"abs\" *)\napplyQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d.\n pose (q:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z) (r:=z)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 742,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  assert (H:= Zneq_bool_eq x y H).\n  apply Zneq_bool_eq; auto.\n  apply Zeq_bool_eq; auto.\n  apply Zeq_bool_eq; auto.\n  apply Zeq_bool_eq; auto.\n  apply Zeq_bool_eq; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H H0; case H; intros H1; subst; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; intros H1; auto.\n  apply Zneq_bool_false in H; auto.\n  apply Zneq_bool_false in H; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; red; intros; subst; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H.\n  apply Zneq_bool_false in H; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  case (Z_lt_gt_dec x y); intros.\n  subst; auto with zarith.\n  intros; discriminate.\n  auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H.\ndestruct (Z.eq_dec x y); destruct (Z.eq_dec y y); auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; constructor; intuition (auto with zarith).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case H; intros H1; subst; intuition (discriminate H1).\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros.\n apply Zneq_bool_true; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zneq_bool_false in H; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false; red; intros; discriminate.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_true; generalize H0; clear H0; unfold Zneq_bool.\n case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_false; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zlt_bool_iff; generalize H0; clear H0; unfold Zneq_bool.\n case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zneq_bool_true; generalize H0; clear H0; unfold Zneq_bool.\n case (x?= y)%Z; auto; \n try (intros; discriminate); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zneq_bool_false; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H H0; apply Zneq_bool_false in H; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?=y)%Z; auto; \n try (intros; discriminate); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; hnf; intros; subst; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nunfold not; intros; intros;\nconstructor; intros;\napply (H p); auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply (H (M (M p)) (M (M p)) (M p)).\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp.\n  apply hoare_wp; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; apply hoare_wp; intros.\n  destruct H as [? [??]].\n  generalize (H p); clear H; case H; clear H; intros.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoare_seq with x.\n  apply hoareQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  inversion H; subst.\n  destruct p; simpl; auto.\n  contradiction.\n  destruct p; simpl; auto.\n  contradiction.\n  destruct p; simpl; auto.\n  contradiction.\n  destruct p; simpl; auto.\n  contradiction.\n  destruct p; simpl; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; red; intros.\n  destruct H.\n  generalize (H p); clear p; case p; intros; subst.\n  apply H; auto.\n  apply H; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; intro; apply H.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nunfold not; intros; red; intros.\napply H; auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; split; intros.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (step p); intros; auto.\n  generalize (H p); clear H; case (stepQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply H.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply hoare_extensionality; intros.\ndestruct x; destruct y; destruct z; simpl; auto;\n try (apply hoare_wp; intro; apply hoare_wp; intro; apply hoare_wp; intro; apply hoare_wp;\n  apply hoare_wp; intro; apply hoare_wp;\n  apply hoare_wp; intro; apply hoare_wp; intro; apply hoare_wp;\n  apply hoare_wp; intro; apply hoare_wp;\n  apply hoare_wp; intro; apply hoare_wp;\n  apply hoare_wp; intro; apply hoare_wp;\n  apply hoare_weaken; intro; apply hoare_wp;\n  apply hoare_wp; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_wp;\n  apply hoare_weaken; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_weaken;\n  apply hoare_weaken; intro; apply hoare_Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n unfold excluded_middle.\n intros.\n unfold all_coplanar.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H0.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H.\n intros.\n apply H0.\n intros.\n apply H0.\n intros.\n apply HQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n generalize (no_overlap p post).\n unfold not_safe.\n intros.\n generalize (no_overlap p post).\n rewrite (no_overlap p post).\n apply: (no_overlap p post).\n intros.\n generalize (no_overlap p post).\n rewrite (no_overlap p post).\n apply not_safe.\n intros.\n generalize (no_overlap p post).\n rewrite (no_overlap p F).\n apply not_safe.\n intros.\n generalize (no_overlap p F).\n rewrite (no_overlap p F).\n apply not_safe.\n intros.\n generalize (no_overlap p F).\n rewrite (no_overlap p F).\n apply not_safe.\n intros.\n generalize (no_overlap p F).\n rewrite (no_overlap p F).\n apply not_safe.\n intros.\n generalize (no_overlap p F).\n rewrite (no_overlap p F).\n apply not_safe.\n intros.\n generalize (no_overlap p F).\n apply not_safe.\n intros.\n generalize (no_overlap p F).\n rewrite (no_overlap p F).\n apply notQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply hoare_wp; intro; auto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply wp_hnf; intros.\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\n(*   apply hoare_seq with p. *)\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; intros.\n generalize (step_deterministic p post); intros.\n generalize (step_deterministic p post); intros.\n generalize (step_deterministic p post); intros.\n generalize (step_deterministic p post); intros.\n generalize (step_deterministic p st); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministic p F); intros.\n generalize (step_deterministicQed."
                ]
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 322,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros.\n  apply lt_minus_O.\n  apply lt_mult_n_Sm.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; elim (lt_irrefl n); auto.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m H; elim (lt_n_O n); auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n m H; elim (lt_n_O n); auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n m H; elim H; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m H; elim H; auto with arith.\nintros n0 H; elim H; auto with arith.\nintros n0 H; elim H; auto with arith.\nintros m0 H; elim H; auto with arith.\nintros m1 H; elim H; auto with arith.\nintros m2 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m3 H; elim H; auto with arith.\nintros m4 H; elim H; auto with arith.\nintros m4 H; elim H; auto with arith.\nintros m3 H; elim H;Qed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H.\napply lt_trans with (m + n).\napply lt_trans with m.\napply lt_trans with (m + n).\napply le_plus_minus_r.\napply le_plus_minus_r.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros.\n  induction  n as [| m Hrecm];\n    [ intros H1 H2; inversion H2 | auto with arith ].\n  simpl; intros H1; inversion H2; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H; rewrite H; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m H'; elim H'; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 414,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case a; simpl in |- *; auto with arith.\nintros m1 H1; rewrite H1; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nintros m H1; elim H1; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 H1; apply Hrec; apply le_plus_O; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a b; case a; case b; simpl in |- *; auto with arith.\nintros m1 H1; elim H1; intros H2; clear H1.\napply le_minus_O; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros m1 H1; apply Hrec; apply le_plus_minus_O; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nintros a b; elim a; simpl in |- *; auto.\nintros m H1; elim H1; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros m H1; apply Hrec; apply lt_n_S; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case b; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros m H1; Contradict H1; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 439,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0; rewrite H0; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; apply le_mult_simpl_r; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; apply lt_minus_O; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; elim H; simpl in |- *; auto.\nintros n1 Hrec b H H0; apply Hrec; apply le_trans with (2:= b); auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; elim H; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; apply S_n_n; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; elim H; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H1 H2; rewrite H1; ring.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nintros a b c H H0; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 524,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; apply plus_minus; auto with arith.\nrewrite <- minus_plus_minus; auto with arith.\nrewrite minus_plus_simpl_r; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl_r with (p := b + c).\nrepeat rewrite plus_comm; rewrite (plus_comm b c).\nrepeat rewrite plus_comm; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; rewrite plus_comm; apply plus_minus_simpl_4; auto.\nrewrite minus_plus_simpl_r; auto with arith.\nrewrite minus_plus_simpl_r; auto with arith.\nrewrite plus_comm; rewrite (mult_comm c).\nrewrite plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite (mult_comm b c).\nrewrite (mult_comm b c).\nrepeat rewrite plus_assoc.\nrewrite (mult_comm b c).\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite <- le_plus_minus; auto with arithQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite (plus_comm b c).\nrepeat rewrite <- minus_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (mult_comm b c).\nrepeat rewrite plus_comm; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite plus_comm; rewrite plus_comm.\nrewrite minus_plus_simpl_l; auto with arith.\nrewrite plus_comm; rewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc; auto with arith.\nrepeat rewrite plus_assoc; auto with arith.\nrewrite plus_comm; rewrite <- plus_minus; auto with arith.\nrewrite plus_comm; rewrite minus_plus_simpl_r; auto with arith.\nrepeat rewrite plus_comm; rewrite plus_comm; auto with arith.\nrewrite plus_comm; rewrite plus_comm; rewrite minus_plus_simpl_r; auto with arith.\nrewrite plus_comm; rewrite plus_comm; rewrite minus_plus_simpl_r; auto with arith.\nrewrite <- le_plus_minus; auto with arith.\nrewrite plus_comm; rewrite minus_plus_simpl_l; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_comm; auto with arith.\nrepeat rewrite plus_comm; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; apply plus_minus; auto with arith.\nrewrite minus_plus_simpl_r_reverse with (p := b + c).\nrepeat rewrite plus_comm.\nrewrite (mult_comm b c).\nrepeat rewrite plus_assoc; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; rewrite plus_comm; apply le_plus_minus; auto with arith.\nrewrite plus_comm; apply le_plus_minus; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; rewrite <- H; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite plus_comm; auto with arith.\nrewrite plus_comm; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 593,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case b; case b; case b; simpl in |- *.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- H; auto with arith.\nintros H H0; case H; intros H1; subst.\nrewrite <- HDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case b; simpl; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b H.\ncase (eq_bool_dec a b); intros H1;\nrewrite (eq_bool_elim _ H1); intros H2;\nrewrite (eq_bool_elim _ H2); intros H3;\n rewrite (eq_bool_elim _ H3); intros H4;\n rewrite (eq_bool_elim _ H4); intros H4;\n rewrite (eq_bool_elim _ H4); intros H5;\n rewrite (eq_bool_elim _ H4); intros H5;\n rewrite (eq_bool_elim _ H4); intros H5;\n rewrite (le_bool_elim _ H5); intros H5;\n rewrite (le_bool_elim _ H5); intros H6 H7;\n rewrite (le_bool_elim _ H6); intros H7;\n rewrite (le_bool_elim _ H6); intros H6 H7;\n rewrite (le_bool_elim _ H7); intros H7;\n rewrite (le_bool_elim _ H7); intros H8;\n rewrite (le_bool_elim _ H8); intros H8;\n rewrite (leDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\n  decide equality; auto with bool.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; case b; case b; simpl in |- *; auto.\nintros b0 H H0; case b0; simpl in |- *; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\n  intros a b.\n  case (eq_bool_dec a b); intros H1;\n  [ left; exists a; auto with arith | right; auto with arith ].\n  case (eq_bool_dec a b); intros H2;\n  [ right; exists a; auto with arith | right; auto with arith ].\n  case H1; intros H2;\n  [ right; exists a; auto with arith | left; exists a; auto with arith ].\n  right; exists a; auto with arith.\n  right; exists a; auto with arith.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b.\ncase b; case b; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\n  destruct a.\n  left; auto with bool.\n  left; auto with bool.\n  right; auto with bool.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b.\ndestruct (eq_bool_dec a b).\nsubst; auto.\nintros b; case (eq_bool_dec a b).\nsubst; auto.\nintros b; case (eq_bool_dec a b).\nsubst; auto.\nintros b; case (eq_bool_dec a b).\nsubst; auto.\nintros H H0; case (eq_bool_dec b b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.\nintros H1 H2; case (eq_bool_dec a b).\nsubst; auto.Defined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b.\ncase a; simpl; auto.\nintros b H1; case H1; auto.\nintros b H1; case H1; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case a; case b; simpl in |- *; auto.\nintros m H; rewrite H; auto with arith.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b H; case (le_bool b a0); auto with arith.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b H.\napply le_antisym; auto.\napply le_antisym; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b H H0; case H; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  induction a; simpl in |- *; auto.\n  case a; simpl in |- *; auto.\n  case a; simpl in |- *; auto.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros; discriminate.\n  intros;Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b H H0; case (le_bool_dec a b); case (le_bool a b); case (le_bool a b); auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b H; case (le_bool_correct1 a b H); auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\n  intros a b H; case (le_bool_dec a b); case (le_bool b b); intros H1.\n  rewrite H1; auto with arith.\n  destruct (le_bool b a0); case (le_bool b b0); intros H2.\n  rewrite H2; auto with arith.\n  case (le_bool b b0); case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  rewrite H3; auto with arith.\n  case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  case (le_bool b b0); intros H3.\n  rewrite H3; auto with arith.\n  case (le_Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nintros a b; case a; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1; case b; simpl in |- *.\nintros n0 H1Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl inQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n H0; apply le_antisym.\nintros n0 H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n0 H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; apply le_antisym.\nintros n H1; applyQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\n  intros a b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H H0; case b; simpl in |- *; auto.\nintros n H0 H0; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; apply H.\napply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n H1; apply H.\napply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a b; case a; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; apply H.\napply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H b H H0.\napply le_bool_correct1; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b H; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; apply le_S_n; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros n H H0; case b; simpl in |- *; auto.\nintros n H H0; case b; simpl in |- *; auto.\nintros n H H0; case b; simpl in |- *; auto.\nintros n H H0; case b; simpl in |- *; auto.\nintros H H0; case H; auto.\nintros H H0; case H; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H; case a; simpl in |- *; auto.\nintros n H H0; inversion H0.\nintros n0 H0; case b; simpl in |- *; auto.\nintros n0 H0 H1; apply H.\napply le_n.\napply H.\napply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H b H H0.\napply le_bool_correct1 in H; auto.\napply le_bool_correct2 in H; auto.\napply le_bool_correct2 in H; auto.\napply le_bool_correct2 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct4 in H; auto.\napply le_bool_correct4 in H; auto.\napply le_bool_correct3 in H; auto.\napply le_bool_correct3Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a b H H0.\napply le_bool_correct1; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H H0; inversion H0.\nintros m H H0; inversion H0.\nintros m H0 H1; inversion H1.\nintros m H0 H1; inversion H1.\nintros m H1; inversion H1.\nintros m H0 H1; inversion H1.\nintros m H H0 H1; inversion H1.\nintros m H H1; inversion H1.\nintros m H0 H1; inversion H1.\nintros m H1; inversion H1.\nintros m H H1; inversion H1.\nintros m H1; inversion H1.\nintros m H H1; inversion H1.\nintros m H1; inversion H1.\nintros m H1; inversion H1.\nintros m H H1; inversion H1.\nintros m H1; inversion H1.\nintros m H1; inversion H1.\nintros m H1; inversion H1.\nintros m H1; inversion H1.\nintros m H1; inversion H1.\nintros m H1; inversion H1.\nintros mQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b H H0; elim H; intros H H0.\napply le_n_S; auto.\napply le_trans with b; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nintros; inversion H1.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a b H H0.\napply le_bool_correct1 in H.\nelim H; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *; auto.\nintros n0 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros H1; inversion H1.\nintros n0 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros m1 H1; case b; simpl in |- *; auto.\nintros H1; inversion H1.\nintros m1 H1; caseQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros n H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros n0 H1; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H; inversion H.\nintros m H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "Proof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 736,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros; rewrite <- app_assoc; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\ninduction l1; simpl in |- *; auto.\nintros l2 l1 H; rewrite <- H; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros; rewrite length_app; simpl; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros; elim (length_app l1 l2); auto.\nintros; elim (length_app l2 l1); auto.\nintros; elim (length_app l2 l2); auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; intros l2 H.\nrewrite plus_comm; apply plus_reg_l with (l1 := l2); auto.\nrewrite plus_comm; apply plus_reg_l with (l1 := l2); auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros; elim l1; clear l1; simpl in |- *; auto.\nintros l1 l2 H1; case H1; intros l2 (l3, Hl3); exists l3;\n try rewrite <- app_assoc; try rewrite <- app_assoc;\n try rewrite <- app_assoc; try rewrite <- app_assoc;\n try rewrite <- app_assoc; try rewrite <- app_assoc;\n try rewrite <- app_assoc; try rewrite <- app_assoc;\n try rewrite <- app_assoc; try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc; try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_assoc;\n try rewrite <- app_Qed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; apply length_app; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\ninduction l1; destruct l2; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1; simpl in |- *; auto.\nintros; case H; auto; intros l2 (l3, (l4, l5))).\nexists (a1 :: l3); exists l3; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 731,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 l4 H0.\napply H; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H0.\nelim H; simpl in |- *; auto.\nintros l1 l2 l3 H0.\nelim H0; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 l4 l1; elim l2; simpl in |- *; auto.\nintros l1 l2 l3 l4; rewrite H; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H1 H2.\nelim H1; clear H1; intros l2 l3 H3 H4; subst.\napply H3; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H0; elim H0; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H H0.\nrewrite app_inv_head in H0; elim H0; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H1.\nelim H1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H1; rewrite H1; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H0.\napply in_app_or_app; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 488,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros n t; induction n.\n  - intros.\n    inversion H; subst.\n    inversion H; subst.\n    inversion H; subst; clear H; subst; clear H; subst; clear H; subst; clear H; subst; clear H.\n    destruct t; inversion H; subst; clear H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear H; subst; clear H.\n    destruct t0; inversion H; subst; clear H.\n    destruct t0; inversion H; subst; clear HQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  intros n t; induction n; intros.\n  - destruct t; [exact (le_refl _) |].\n    simpl in H; destruct H.\n    - destruct t; [exact (le_refl _) |].\n      simpl; auto with arith.\n    - destruct t; [exact (le_refl _) |].\n      simpl in H.\n      destruct (le_dec n (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (S n) (max (Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n.\nunfold height_bound in H.\ncase_eq (forallb (fun m : nat => aeq (arities n) (length l)) n); intro.\ncase_eq (forallb (fun m : nat => aeq (arities n) (length l)) n); intro.\napply leb_complete in H.\ndestruct H as [m [H1 H2]]].\ncase_eq (forallb (fun m : nat => aeq (arities m) (length l)) n); intro.\napply leb_complete in H2.\ndestruct H2 as [H3 H4].\nelim (H3 n).\napply leb_complete in H3.\ndestruct H3 as [m [H4 H5]]].\ncase_eq (forallb (fun m : nat => aeq (arities m) (length l)) n); intro.\napply leb_complete in H3.\ndestruct H3 as [H4 H5].\nelim (H1 n).\napply leb_complete in H3.\ndestruct H4 as [m [H5 H6]].\ncase_eq (forallb (fun m : nat => aeq (arities m) (length l)) n);Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\ninduction n.\nintros.\ndestruct l as [| n].\ndestruct l as [| n].\nunfold height in H.\nsimpl in H.\ndestruct (decompose_nat n t).\nomega.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\nunfold not; intros.\ndestruct l as [| r l].\nunfold height in H0.\ndestruct l as [| r l].\nunfold height in H0.\ndestruct l.\ndestruct l as [| r0].\nunfold height in H1.\ndestruct l as [| r0].\ndestruct l0 as [| r0].\nsimpl in H1.\nunfold height in H1.\ndestruct l0 as [| r0].\nunfold height in H1.\ndestruct l as [| r0].\nunfold height in H1.\ndestruct l as [| r0].\nunfold height in H1.\ndestruct l as [| r0].\ndestruct l0 as [| r0].\nunfold height in H1.\ndestruct l as [| r0].\nunfold height in H1.\ndestruct l0 as [| r0].\nunfold height in H1.\ndestruct l0 as [| r0].\nunfold height in H1.\ndestruct l0 as [| r0].\nunfold height in H1.\ndestruct l0 as [| r0].\nunfold height in H1.\ndestruct l0 as [| r0].\nunfold height in HQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n.\ncase (le_dec n 0); intros h; try (right; omega);\n try (right; omega).\nintros n H.\ncase (le_lt_dec n (size t) / 2); intros h; try (right; omega);\n try (right; omega).\nintros n H1.\ncase (le_dec n (size t) / 2); intros h'; try (right; omega);\n try (right; omega).\nintros n H1.\ncase (le_dec n (size t) / 2); intros h'; try (right; omega).\nintros H1.\ncase (le_dec n (size t) / 2); intros h''; try (right; omega).\nintros H2.\ncase (le_dec n (size t) / 2).\nintros h''; try (right; omega).\nintros h''; try (right; omega).\nintros n' H1.\ncase (le_dec n' (size t) / 2).\nintros h''; try (right; omega).\nintros H2.\ncase (le_dec n' (size t) / 2).\nintros hQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t l.\nunfold height_S.\ninduction n.\nintros.\ndestruct l as [ | i t].\nsimpl.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl in H.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl in H.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl in H.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl.\nunfold height in H.\ndestruct (le_dec n (S n)).\nrewrite H in H.\nomega.\nsimpl in H.\nunfold height in H.\ndestruct (le_Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\npose (m n := S n) in *.\nassert (H := height_bound n (max (n + m) (tree_heightP t) n) H).\nassert (H1 := max_l n (max (n + m) (tree_heightP t) n) H).\nrewrite max_l in H1 by assumption.\napply le_trans with (max (tree_heightP t) n) (tree_heightP t)).\napply max_l; trivial.\napply max_l; trivial.\nrewrite max_l in H1 by assumption.\napply le_trans with (max (tree_heightP t) n) (tree_heightP t)); trivial.\napply max_l; trivial.\napply max_l; trivial.\napply max_l; trivial.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n; induction n; intros.\ninversion H.\ninversion H0.\ninversion H0.\ninversion H.\ninversion H1.\ninversion H2.\ninversion H0.\ninversion H1.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t; induction n;\ntry solve [inversion 1 | inversion 1];\ntry solve [inversion 1 | inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];\ntry solve [inversion H1];Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 533,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n t; elim l; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; absurd (0 < n); auto.\napply H; auto with arith.\nintros n H1 H2; absurd (n < n); auto.\napply H; auto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln; elim (lt_dec n 0); intro H;\n [ elim H; simpl in |- *; auto with arith; fail | intro; discriminate ].\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n m H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln; generalize (le_dec n (length l) (length l)); simpl in |- *; \n intros; absurd (0 <= n) by omega.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln; elim n; simpl in |- *; auto.\nintros n0 t0 H; elim (le_dec n0 n); intros; auto.\nintros n1 t0 H1 H2; elim H1; simpl in |- *; auto.\nintros n1 t0 H1; elim (le_dec n1 n); intros; auto.\nintros n2 t0 H1; elim (le_dec n2 n); intros; auto.\nintros n3 H2; elim H2; simpl in |- *; auto.\nintros H3 H4; elim H4; simpl in |- *; auto.\nintros n3 H4; elim (le_dec n3 n); intros; auto.\nintros n3 H4; elim (le_dec n3 n); intros; auto.\nintros n3 H4; elim (le_dec n3 n); intros; auto.\nintros n3 H4; elim (le_dec n3 n); intros; auto.\nintros n3 H4; elim H4; simpl in |- *; auto.\nintros n3 H4; elim (le_dec n3 n); intros; auto.\nintrosQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln; elim (le_dec n 0); intros H1.\nreplace (S n) with (S (S (S n))) by auto with arith.\nreplace (S n) with (S (S (S (S n))) by auto with arith.\nrewrite H1.\napply lt_le_trans with (S n); auto with arith.\nrewrite <- H1.\napply lt_le_trans with (S n); auto with arith.\nrewrite <- H1.\napply lt_le_trans with (S n); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 594,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n t l H; elim H; simpl in |- *; auto.\nintros n0 l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln; elim n; simpl in |- *; auto.\nintros; discriminate.\nintros n0 l1 l2 H H0; case H0; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n t l H; elim H; simpl in |- *; auto.\nintros n0 t1 t2 l1 H1; case (le_or_lt n0 n1); auto.\nintros n2 l2 H2; case (le_or_lt n2 n2); auto.\nintros; discriminate.\nintros n2 l2 H3; case (le_or_lt n2 n2); auto.\nintros; discriminate.\nintros n2 l2 H3; case (le_or_lt n2 n2); auto.\nintros; discriminate.\nintros n3 l2 H3; case (le_or_lt n3 n3); auto.\nintros; discriminate.\nintros; discriminate.\nintros n3 l1 l2 H3; case (le_or_lt n3 n3); auto.\nintros; discriminate.\nintros n3 l2 l3 H4; case (le_or_lt n3 n3); auto.\nintros; discriminate.\nintros n3 l1 l2 H3; case (le_or_lt n3 n3); auto.\nintros; discriminate.\nintrosQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros; discriminate.\nintros n0 l1 l2 H H0; case (le_lt_dec n0 (length l1) (length l2)); auto.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros n0 ln1 l1 H H0; case (le_lt_dec n0 n1); auto.\nintros n1.\nrewrite (le_lt_dec n2 n1); auto with arith.\nintros H0; case (le_lt_dec n2 n2); auto.\nintros H1; case (le_lt_dec n2 n1); auto.\nintros H1; rewrite (le_lt_dec n2 n2); auto with arith.\nintros H1; case (le_lt_dec n2 n2); auto.\nintros H1; rewrite (le_lt_dec n2 n2); auto with arith.\nintros H1; case (le_lt_dec n2 n1); auto.\nintros H1; rewrite (le_lt_dec n2 n2); auto with arith.\nintros H1; case (le_lt_dec n2 n2); auto.\nintros H1; rewrite (le_lt_dec n2 n2); auto with arith.\nintros H1; case (leQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H H0; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros; discriminate.\nintros n0 ln1 t2 l1 H H0; case H0; simpl in |- *; auto.\nintros; discriminate.\nintros n0 cc1 t2 l1 l2 H H0; case H0; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros n ln t l H H0; elim H; simpl in |- *; auto.\nintros n0 l1 l2 H0; case (le_lt_dec n0 n1); auto.\nintros; absurd (n1 < n1); auto with arith.\nintros n1 l2 H H0; elim H0; simpl in |- *; auto.\nintros; absurd (n1 <= n1); auto with arith.\nintros H H0; absurd (n1 < n1); auto with arith.\nintros H1; absurd (n1 <= n2); auto with arith.\nintros H1; absurd (n1 <= n2); auto with arith.\nintros H2; absurd (n1 < n2); auto with arith.\nintros H2; absurd (n1 <= n2); auto with arith.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof using.\nintros nnode t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 244,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H.\nintros H'; elim H'.\nintros H'0 H'1; elim H'1; auto.\nintros H'1; elim H'1; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H0.\ncase (Z_le_lt_dec a b); intros H1; try exact H1; clear H1.\ncase (Z_le_dec a b); intros H2; try exact H2; clear H2.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.\nabsurd (0 < b); auto with arith.Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b Ha Hb H H0.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a).\nintro H'.\ncut ((a -> ~ b) -> a).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a).\nintro H'.\ncut ((a -> ~ b) -> a).\nintro H'.\ncut ((a -> ~ b) -> a) \\/ b).\nintro H'.\ncut ((a -> ~ b) -> a).\nintro H'.\ncut ((a -> ~ b) ->Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H.\napply H.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H0; apply H.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b Hb.\napply (Build_Map (A:=A) (B:=C) (c:=d) a c H H0).\nexact I.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H0; elim H; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H0; elim H; elim H0; intros H1 H2; elim H2; intros H3 H4; elim H4; intros H5 H6; elim H6; intros H7 H8;\n clear H7; apply H1; apply H2; apply H3;\n apply (H1 (Build_finiteT H4)).\napply Trans with (a * b); auto with algebra.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H.\ncut (a = a).\nintro; discriminate.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminate H.\nintros; discriminateQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros.\napply H.\nexact (Build_Map (Ap:=fun a0 : nat => a0) a b H H0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 277,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\n intuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\n intuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintros.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\n intuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\n intuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 305,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\n intuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed."
                ]
            }
        ],
        "PolTac": [
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\nTheorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n\n",
                "context_tokens": 668,
                "proof_start_offset": 1675,
                "proof_end_offset": 2086,
                "proof": "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 < nat_of_P p1)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate);\n try (intros; discriminate); \n try (intros; discriminate);\n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \n try (intros; discriminate); \nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le; auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napply Nge_le.\napplyQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; case (N.ge_le n m); intros H1; auto.\napply lt_le_weak; auto.\napply lt_le_weak; auto.\napply lt_le_weak; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; rewrite <- (Nat2N.id (N.of_nat n)); auto.\nrewrite <- (Nat2N.id (N.of_nat n)); auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m H; rewrite <- (Nat2Z.id n); rewrite <- (Nat2Z.id n); rewrite <- (Nat2Z.id n);\n simpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le; auto with arith.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_le; apply Nge_le; apply Nge_le; apply Nge_le; apply Nge_le; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).\nintros x y z H; rewrite H; auto.\nQed.\n\nTheorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).\nintros x y z H1 H2; red; apply Rge_trans with z; auto.\nQed.\n\n(* For RGroundTac *)\n\n\n",
                "context_tokens": 746,
                "proof_start_offset": 32895,
                "proof_end_offset": 33883,
                "proof": "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; auto.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1);ring.\nintros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; unfold Z2R; simpl.\nrewrite Z2R_IZR; auto.\nrewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_minus; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; unfold Z2R; rewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_IZR.\nchange (IZR p) with (IZR p).\nrewrite Z2R_IZR.\nrewrite Z2R_IZR.\nnow rewrite Z2R_IZR.\nnow rewrite Z2R_IZR.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_mult_distr_r_reverse.\nrewrite Z2R_mult_distr_l_reverse.\nrewrite Z2R_mult_distr_r.\nrewrite <- H1.\nrewrite Z2R_mult_distr_r.\nrewrite <- H2.\nrewrite Ropp_mult_distr_r.\nrewrite <- H2.\nring.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; unfold Z2R; rewrite Z2R_mult; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_minus; rewrite Z2R_minus; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_opp; rewrite Z2R_opp; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_IZR_INZ.\nunfold IZR; simpl.\nrewrite <- INR_IZR_INZ.\nrewrite <- INR_IZR_INZ.\nrewrite <- INR_IZR_INZ.\nrewrite <- INR_IZR_INZ.\nrewrite <- INR_IZR_INZ.\nrewrite <- IZR_INZ.\napply Z2R_correct.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\n",
                "context_tokens": 6,
                "proof_start_offset": 24,
                "proof_end_offset": 107,
                "proof": "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H1 H2.\napply Rnot_lt_lt with (1:= H1).\nnow apply Rnot_lt_lt.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H.\napply Pol_test2.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\ndestruct (lt_dec x y) as [H|H].\ncontradict Hx.\ncontradict Hx.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict Hy.\ncontradict HyQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\nassert (Hx: forall n, (n <= m)%nat -> (n <= m)%nat).\napply Rlt_le_trans with (1 := Hx).\napply Rle_trans with (1 := Hx).\napply Rle_trans with (1 := Hx).\napply Rle_trans with (1 := Hx).\napply Rle_trans with (1 := Hx).\napply Hx.\napply Rle_trans with (2 := Hx).\napply Rle_trans with (2 := Hx).\napply Hx.\napply Rle_trans with (2 := Hx).\napply Rlt_le.\napply Hx.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n  intros x y.\n  apply (Rlt_irrefl _ (Rlt_trans _ _ _ (Rlt_trans _ _ _ (Rlt_trans _ _ _ H1 H2))).\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y.\ndestruct (le_gt_dec x y) as [H|H].\ncontradict H.\ncontradict H.\nnow apply Rnot_lt_lt.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradictQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y.\ndestruct (Rle_dec x y) as [H|H].\nrewrite <- (Rplus_0_l x).\napply Rplus_le_compat_l.\napply H.\nnow apply Rplus_le_compat_l.\napply H.\nnow apply Rplus_le_compat_l.\napply H.\nnow apply Rplus_le_compat_l.\nnow apply Rplus_le_compat_l.\nnow apply Rplus_le_compat_l.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy; unfold pow.\nrewrite pow_add, pow_add, pow_add; simpl; trivial.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\nrewrite Hx, Hy.\nnow apply (Rle_trans _ _ Hx).\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y H; case (Rle_dec x y); intros H1; auto.\nContradict H1; rewrite H1; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 109,
                "proof_end_offset": 188,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern y at 2; rewrite <- (Rmult_1_l (y * x)).\nrewrite Rmult_1_r, Rmult_1_r.\nchange (x * y = 0).\napply Rmult_lt_compat_r.\napply Rmult_lt_0_compat.\napply pow_pos_ge.\napply Rle_trans with (2 := H).\napply Rmult_le_compat_r.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_ge.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npattern x at 1 ; rewrite <- (Rmult_1_l x).\napply Rmult_lt_compat_l.\napply (pow_lt_0_compat _ _ Hx).\napply Rmult_lt_compat_r.\napply (pow_lt_0_compat _ _ Hx).\napply Rmult_lt_compat_r.\napply (pow_lt_1_compat _ _ Hx).\napply Rmult_lt_compat_r.\napply (pow_lt_0_compat _ _ Hx).\napply Rmult_lt_compat_r.\napply (pow_lt_0_compat _ _ Hx).\napply (pow_lt_0_compat _ _ Hx).\napply Rmult_lt_compat_r.\napply (pow_lt_0_compat _ _ Hx).\napply Rmult_lt_compat_l.\napply (pow_lt_1_compat _ _ Hx).\napply (pow_lt_0_compat _ _ Hx).\napply (pow_lt_1_compat _ _ Hx).\napply Rmult_lt_compat_r.\napply (pow_lt_0_compat _ _ Hx).Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\napply Rlt_le_trans with (2 := H1).\napply Rmult_lt_compat_l.\napply Rle_lt_trans with (1 := H1).\napply Rplus_lt_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H1).\napply Rplus_le_compat_l.\napply Rle_transQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 2 ; replace x with (y + 0) by ring.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1, y at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at level, z at level 0, z at level 0, z at level 0, z at level 0, z at level 0, z at level 0, zQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1 ; replace y with (y + y).\napply Rle_lt_trans with (1 := H).\napply Rmult_le_compat_r.\napply Rlt_le, Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rlt_le, Rmult_lt_compat_r.\napply Rlt_le, Rinv_0_lt_compat.\napply (Z2R_lt 2).\napply Rle_trans with (1 := H).\napply Rmult_le_compat_r.\napply Rlt_le, Rmult_le_compat_r.\napply Rlt_le, Rmult_lt_0_compat.\napply Rlt_le, Rmult_lt_compat_r.\napply Rlt_le, Rmult_lt_0_compat.\napply Rlt_le, Rmult_lt_0_compat.\napply Rlt_le, Rinv_0_lt_compat.\napply (Z2R_lt 2).\napply Rgt_not_eq.\napply (Z2R_lt 2).\napply Rgt_not_eq.\nnow apply (Z2R_lt 2).\napplyQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1 ; rewrite <- (Rmult_1_l x).\npattern y at 1 ; rewrite <- (Rmult_comm x).\npattern y at 1 ; rewrite <- (Rmult_comm x).\n pattern y at 2; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern y at 2; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern y at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm x).\n pattern x at 1; rewrite <- (Rmult_comm x).\n pattern y at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern x at 1; rewrite <- (Rmult_comm y).\n pattern y at 1; rewrite <- (Rmult_comm yQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1 in |- *; rewrite <- (Rmult_comm x).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (2 := Hxy).\nrewrite Rmult_assoc, <- bpow_plus, Rmult_1_r, Rmult_1_r, Rmult_1_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_l with (2 := Hxy).\nrewrite Rmult_assoc, <- bpow_plus, Rmult_1_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_r with (2 := Hxy).\nrewrite Rmult_assoc, <- bpow_plus, Rmult_assoc.\nrewrite <- (Z2R_Zpower 2 1).\napply Rmult_lt_compat_r.\napply Rinv_0_lt_compat.\napply Z2R_lt.\nrewrite <- Z2R_mult, Rmult_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 2; rewrite <- (Rmult_comm x).\npattern y at 2; rewrite <- (Rmult_comm y).\npattern y at 2; rewrite <- (Rmult_comm y).\npattern y at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern y at 2; rewrite <- (Rmult_comm y).\npattern x at 1; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm x).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm x).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm x).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm y).\npattern x at 2; rewrite <- (Rmult_comm y).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\n Rle_trans with (1:=H).\napply Rle_trans with (2:=H).\napply Rle_trans with (2:= H).\napply Rle_trans with (1:=H).\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 84,
                "proof_start_offset": 191,
                "proof_end_offset": 311,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2 ; rewrite <- (Rmult_comm x).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern x at 1 ; rewrite <- (Rmult_comm x).\npattern y at 1 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern x at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern x at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern y at 2 ; rewrite <- (Rmult_comm y).\npattern (x + y).\nrewrite H at 2 ; rewrite <-Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 3 ; rewrite Rplus_0_r.\nring.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2 ; replace y with (x + y * (x + y)).\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nrewrite Rmult_comm.\nrewrite Rmult_assoc.\nrewrite <- Rmult_assoc.\nrewrite <- Rmult_plus_distr_r.\nrewrite Rmult_plus_distr_l.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rmult_le_compat_r.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply Rlt_le.\nnow apply Rlt_le.\nnow apply Rlt_le.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2 3 ; replace x with (2 * (x + y) * (x + y)).\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_l.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_l.\n2: apply Rmult_le_compat_l.\n2: apply Rmult_le_compat_l.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_l.\n2: apply Rmult_le_compat_r.\n2: apply Rmult_le_compat_l.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *; replace y with (2 * (x + y)).\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_l with (r := 1%nat).\nnow apply Rmult_lt_compat_r.\napply Rinv_0_lt_compat.\napply Rmult_lt_reg_r with (r := 1%nat).\nnow apply Rmult_lt_compat_r.\napply Rmult_lt_reg_l with (r := 1%nat).\nnow apply Rmult_lt_compat_r.\napply Rinv_0_lt_compat.\nnow apply (Z2R_lt 0 2).\nnow apply (Z2R_lt 0 2).\nnow apply (Z2R_lt 0 2).\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2 ; rewrite <- (Rmult_1_r x).\nrewrite Rplus_0_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_pos.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\napply pow_pos_nonneg.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2; rewrite <- Rplus_0_l.\nreplace (x + y * x + y * y) with (x + y * x + y * x + y * y).\nrewrite Rplus_0_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napplyQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2; replace x with (2 * (x + y)).\n2: unfold x; simpl; ring.\nintros; ring.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1, x at 1, x at 1, x at 1, x at 1, x at 1, x at 1, x at 1, x at 1,  at 1, x at 1, x at 1, x at 1,  at 1,  at 1, x at 1, x at 1,  at 1,  x at level 1, x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0, x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0,  x at level 0, Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 145,
                "proof_start_offset": 314,
                "proof_end_offset": 436,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 ; rewrite Rmult_1_r.\nrewrite Rmult_comm.\npattern z at 2 ; rewrite <- Rplus_0_r.\nrewrite Rplus_0_l.\nrewrite Rplus_0_r.\nrewrite Rplus_0_l.\nrewrite Rplus_0_l.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0_Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_0_l.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_0_l.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 1 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 1 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- Rplus_assoc.\npattern z at 1 ; rewrite <- Rplus_assoc.\npattern z at 2 ; rewrite <- RplusQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2.\nrewrite Rplus_0_l.\nrewrite Rplus_0_l.\nrewrite Rplus_0_l.\nreplace (x + y) with (x + y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 1 in |- *.\nrewrite Rplus_0_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compatQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 1 in |- *.\nrewrite (Rmult_comm x y).\nrewrite Rmult_assoc.\nrewrite Rmult_assoc.\nrewrite Rmult_1_l.\napply Rmult_le_compat_l.\napply Rle_trans with (2 * (y + z)).\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rlt_le.\napply (Rabs_pos x).\nrewrite Rmult_1_l.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rlt_le.\napply (Rabs_pos y).\nrewrite Rmult_1_l.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rlt_le.\napply (Rabs_pos y).\nrewrite Rmult_1_l.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rlt_le.\napply (Rabs_pos y).\nrewrite Rmult_1_l.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rlt_Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 1 3; replace z with (x + z).\nreflexivity.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *; replace z with (x + z).\nrewrite H0; rewrite H1; ring.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 1 in |- *.\nrewrite Rmult_1_r.\nrewrite Rmult_plus_distr_l.\nrewrite Rmult_plus_distr_l.\nrewrite Rmult_plus_distr_l.\nrewrite Rmult_comm.\nrewrite Rmult_plus_distr_l.\nrewrite Rmult_plus_distr_l.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_plus_distr_l.\nrewrite Rmult_comm.\napply Rmult_le_compat_l.\napply pow_le.\napply Rmult_le_compat_r.\napply pow_le.\napply Rmult_le_compat_r.\napply pow_le.\napply Rmult_le_compat_r.\napply pow_le.\napply Rmult_le_compat_l.\napply pow_le.\napply pow_le.\napply Rmult_le_compat_r.\napply pow_le.\napply pow_le.\napply Rmult_le_compat_r.\napply pow_le.\napply Rmult_le_compat_r.\napply pow_le.\napply pow_le.\napply pow_le.\napply RmultQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 2, y at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1, z at 1Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 1, y at 2, z at 2, z at 2, z.\napply Rmult_plus_distr_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_l.\napply (Rmult_comm 2).\napply Rmult_le_compat_l.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_r.\napply (Rmult_comm 2).\napply Rmult_le_compat_l.\napply (Rmult_comm 2).\napply Rmult_le_compat_l.\napply (Rmult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 208,
                "proof_start_offset": 439,
                "proof_end_offset": 515,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, x at 1, y at 1, x, y at 1, x, y at 1, x, y at 1 in |- *.\npattern x at 1, y at 1, x, y at 1, x, y at 1, x, y at 1 in |- *.\npattern x at 1, y at 1, x, y at 1, x, y at 1, x, y at 1, x, y at 1, x, y at 1, x, y at 1 in |- *.\npattern x at 1, y at 1, x, y at 1, x, y at 1, y at 1, x, y at 1, x, y at 1, y at 1,  x, y at 1, y at 1, x, y at 1, x, y, y at 1 in |- *.\n\npattern x at 1, x at 1, y at 1, x, y at 1, y at 1, x, y at 1, x, y at 1, x, y at 1, y at 1, x, y at 1, x, y at 1, y at 1, y at 1, yQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1; rewrite <- Rplus_0_l.\napply Rmult_plus_distr_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rlt_le.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compatQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, x, y at 1, x, y at 1, x0, y at 1 in |- *.\npattern x at 1, y at 1, x0, y at 1, x0, y at 1, x0, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, x0, y at 1 in |- *.\npattern y at 1, y at 1, y at 1, x0, y at 1, x1, y at 1, x1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, x1, y at 1, y at 1, x1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, x0, y at 1, y at 1, x1, y at 1,  x1, y at 1, x2, y at 1,  x3, y at 1,  x3 at 1,  x4, x5, y at 1,  y at 1, y at 1,  xQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, x, y at 1, x, y at 1, x0, x1, x2 at 1, x2 at 1, x3 at 1, x4 at 1, x5 at 1, x6 at 1, x7.\nreplace (x * (1 + x)) with (2 * (1 + x)).\napply Rplus_le_compat_l.\nnow apply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_l.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_l.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_compat_r.\napply H.\nnow apply Rmult_le_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, x at 1, y at 1, y at 1, y at 1, y at 1.\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1.\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1.\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1,Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 3 ; rewrite <- (Rmult_1_l x).\nrewrite Rmult_1_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply pow_le_1.\napply Rmult_le_compat_l.\napply pow_le_1.\napply pow_le_1.\napply Rmult_le_compat_r.\napply pow_le_1.\napply pow_le_1.\napply Rmult_le_compat_l.\napply pow_le_1.\napply pow_le_1.\napply Rle_trans with x.\napply pow_le_1.\napply pow_le_1.\napply Rle_trans with 1.\napply pow_le_1.\napply pow_le_1.\napply pow_le_1.\napply Rle_trans with 1.\napply pow_le_1.\napply pow_le_1.\napply pow_le_1.\napply Rle_trans with 1.\napply pow_le_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *; replace z with (x + 1) by ring.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *; rewrite <- (plus_comm (x + z)).\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *; replace z with (x + z) by ring.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 inQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 2.\npattern y at 1 2.\npattern y at 1 3.\npattern y at 1 3.\npattern y at 2 3.\npattern y at 2.\npattern y at 2 2; pattern y at 2; pattern y at 1; replace y with (x + y * (y + y)).\n2: apply Rmult_plus_distr_l.\n2: apply Rmult_le_compat_r.\n2: apply H.\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_compat_r.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\napply pow_le.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 244,
                "proof_start_offset": 517,
                "proof_end_offset": 613,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nalphas.\napply Rle_lt_trans with (2 := H).\napply Rlt_le_trans with (2 := H).\napply Rle_lt_trans with (2 := H).\napply Rle_lt_trans with (2 := H).\napply Rle_trans with (2 := H).\napply H.\napply Rle_refl.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1, y in H.\napply Rmult_1_r in H.\napply Rmult_le_compat_r in H.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply Rgt_not_eq.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\nnow apply Rgt_not_eq.\napply Rinv_0_lt_compat.\nnow apply Rgt_not_eq.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply Rgt_not_eq.\napply Rinv_0_lt_compat.\napply Rinv_0_lt_compat.\nnow apply Rgt_not_eq.\napply Rinv_0_lt_compat.\napply Rinv_0_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nam_existence.\nreplace (x + y) with (2 * y + x * y) by ring.\nrewrite <- (Rmult_1_r (x * y)).\nrewrite Rmult_assoc.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply pow_lt_mono.\napply pow_lt_compat.\napply pow_lt_compat.\napply pow_lt_compat.\napply pow_lt_compat.\napply pow_lt_compat.\napply pow_lt_compat.\napply pow_gt_1.\napply pow_le_compat.\napply pow_lt_compat.\napply pow_le_compat.\napply pow_gt_1.\napply pow_le_compat.\napply pow_gt_1.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1 in |- *.\npattern y in |- *.\npattern y in |- *.\npattern y in |- *.\npattern y at 2 in |- *.\npattern y in |- *.\npattern y at 2 in |- *.\npattern y in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |-Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nams.\nreplace ((x + y) * (x + y) + 2 * y) with (x + y) * (x + y) + 2 * (x + y)).\nrewrite <- Rplus_0_l.\nrewrite Rplus_0_r.\nrewrite Rplus_0_r.\nrewrite Rplus_0_r.\napply Rplus_le_compat_l.\napply H.\nnow apply H.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 2, x, y in H.\nrewrite Rplus_0_r in H.\napply Rplus_0_l.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 2; replace y with (y * x).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_lQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\namf.\nreplace x with (2 * 2).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with 2.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (2 := H).\napply Rinv_0_lt_compat.\nnow apply Rgt_not_eq.\nnow apply Rlt_pow.\nnow apply Rgt_not_eq.\nnow apply Rlt_pow.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1 in |- *.\nrewrite <- Rmult_1_r in H.\nrewrite Rmult_1_l in H.\nrewrite Rmult_1_l in H.\nrewrite Rmult_1_l in H.\napply Rmult_le_compat_r.\napply Rlt_le_trans with (2 * (x + y)).\napply Rmult_le_compat_r.\napply Rlt_le.\napply Rmult_lt_0_compat.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (2 * (x + y)).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rlt_le.\napply Rmult_lt_reg_r with (2 * (x + y)).\napply Rmult_lt_compat_l.\napply Rlt_le.\napply Rmult_lt_0_compat.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_l with (2 * (x + y)).\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1 in |- *.\npattern y in |- *.\nrewrite <- (Rmult_1_l (2 * y)).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (2 * y).\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (1 * y).\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_l with (1 := H).\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_l with (1 := H).\napply Rinv_0_lt_compat.\nnow apply (proj2 (proj2 (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 290,
                "proof_start_offset": 617,
                "proof_end_offset": 735,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rle_trans with (2 := H1).\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\ncontradict H.\napply Rle_lt_trans with (2 := H).\napply Rle_lt_trans with (2 := H0).\napply Rle_trans with (2 := H0).\napply Rle_trans with (2 := H).\napply Rplus_le_compat_l.\napply Rlt_le.\napply Rlt_le_trans with (2 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (2 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (2 := H0).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (2 := H0).\napply Rplus_le_compat_l.\napply Rlt_le.\napply Rlt_le_trans with (2 := H0).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (2 := H0).\napply Rplus_le_compat_l.\napply Rlt_le.\napply Rlt_le_trans with (2 := H0).\napply Rplus_le_compat_l.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (Rabs_Ropp x).\nrewrite <- Rabs_Ropp.\napply Rplus_le_compat_r.\napply Rlt_le_trans with (2:=H1).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (2:=H1).\napply Rlt_le_trans with (2:=H2).\napply Rlt_le_trans with (2:=H2).\napply Rmult_lt_reg_l with (1:= H2).\napply Rinv_0_lt_compat.\napply Rle_trans with (2:=H2).\napply Rmult_lt_reg_r with (1:= H2).\napply Rinv_0_lt_compat.\napply Rgt_ge.\napply Rmult_lt_reg_r with (1:=proj1 H2).\napply Rinv_0_lt_compat.\napply Rlt_le_trans with (2:=proj1 H2).\napply Rmult_lt_reg_l with (1:=proj1 H2).\napply Rinv_0_lt_compat.\napply Rlt_le_trans with (2:=proj1 H2).\napply RmultQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\npattern z at 1, z in |- *.\npattern z at 2, z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *; rewrite <- (mult_comm 1 z).\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npattern z in |- *.\npatternQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rle_lt_trans with (2:=H0).\napply Rlt_trans with (2:=H1).\napply Rlt_trans with (2:=H1).\napply Rlt_trans with (2:=H1).\napply Rlt_trans with (2:=H2).\napply Rlt_trans with (2:=H2).\napply Rlt_trans with (2:=H2).\napply Rlt_trans with (1:=H1).\napply Rlt_trans with (2:=H1).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H1).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (2:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2).\napply Rlt_trans with (1:=H2Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (Ropp_involutive x).\nrewrite <- (Ropp_involutive y).\nrewrite Ropp_involutive.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Rplus_0_r.\napply Rplus_0_l.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\npattern z at 1 in |- *.\nrewrite Rplus_0_l.\napply Rplus_lt_compat_l.\napply Rplus_lt_compat_r.\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H1).\napply Rplus_lt_compat_r.\napply Rlt_le_trans with (2 := H1).\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H1).\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H2).\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H2).\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H2).\napply Rplus_lt_compat_r.\napply Rlt_le_trans with (1 := H2).\napply Rplus_lt_compat_r.\napply Rlt_le_trans with (1 := H2).\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H1).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (pow_1_r x y z H H0).\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H0.\napply H0.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H0.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H.\napply H.\napply HQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold x.\nrewrite <- (Rmult_1_l (2 * y)).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rinv_0_lt_compat.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_r.\napply Rmult_lt_reg_l with 2.\napply Rinv_0_lt_compat.\napply Rmult_lt_compat_l.\napply RmultQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert x y; induction z; simpl; intros; auto.\napply H.\napply Rle_trans with (2 := H1).\napply H.\napply Rle_trans with (2 := H2).\napply H.\napply Rle_trans with (2 := H).\napply H.\napply Rle_trans with (2 := H).\napply H.\napply Rlt_le.\napply H.\napply H.\napply Rle_trans with (2 := H1).\napply H.\napply Rle_refl.\napply H.\napply Rle_refl.\napply Rle_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\n",
                "context_tokens": 33,
                "proof_start_offset": 123,
                "proof_end_offset": 285,
                "proof": "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H.\n induction m.\n (* n = 0 *)\n (* n = 0 *)\n simpl.\n (* n = m *)\n simpl.\n (* n = m *)\n simpl.\n intros.\n rewrite H.\n (* n = m *)\n simpl.\n (* n = m *)\n simpl.\n intros.\n rewrite H.\n (* n = m *)\n simpl.\n apply lt_n_S.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H.\ndestruct (mult_gt_0_cases p n) as [H'|H'].\nrewrite H' in H.\nrewrite H' in H.\nassert (H' : (0 < n * m) by auto with arith.\nrewrite H' in H.\nreplace (p * m) with (p * m) by auto with arith.\nrewrite H' in H.\nrewrite H' in H.\nreplace (p * m) with (p * m) by auto with arith.\nrewrite H' in H.\nreplace (p * m) with (p * m) by auto with arith.\nrewrite H' in H.\nrewrite H' in H.\nreplace (p * m) with (p * m) by auto with arith.\nrewrite H' in H.\nrewrite H' in H.\nreplace (p * m) with (p * m) by auto with arith.\nrewrite H' in H.\nrewrite H' in H.\nrewrite H' in H.\nrewrite H' in H.\nauto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros.\n omega.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H1 H2.\n apply mult_lt_reg_l with (m := p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H; elim H; intros; clear H.\n - rewrite mult_comm. apply mult_le_compat_l.\n - apply mult_lt_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n - apply mult_le_compat_l.\n -Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H' H'0; try assumption.\nreplace (p * m) with (p * m); auto with arith.\nintros p0 H'1; try assumption.\nreplace (p * m) with (p * m); auto with arith.\napply mult_lt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H.\n apply le_lt_trans with (p * m).\n apply plus_le_compat_l; trivial.\n now apply lt_le_trans with (p * m).\n now apply mult_lt_compat_l.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H1 H2.\n apply le_lt_trans with (m * p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H1 H2; apply lt_le_trans with (m + p); trivial.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H1 H2.\n apply (mult_lt_reg_l n m p); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\n",
                "context_tokens": 98,
                "proof_start_offset": 287,
                "proof_end_offset": 396,
                "proof": "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n m p H; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_ge_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_ge_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_ge_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_ge_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\n",
                "context_tokens": 142,
                "proof_start_offset": 398,
                "proof_end_offset": 535,
                "proof": "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; apply (mult_ge_compat_l n m p H H0); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1; replace n with (p * m) by auto with arith.\nreplace n with (m * p) by auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 201,
                "proof_start_offset": 537,
                "proof_end_offset": 655,
                "proof": "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; case (mult_gt_compat_l p n m); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; case H; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; case H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H0; apply (mult_lt_compat_rev_l1 n m p); auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1; case H1; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H0; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H0; case H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 250,
                "proof_start_offset": 657,
                "proof_end_offset": 889,
                "proof": "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; simpl in |- *; auto with arith.\nintros p0 H H0; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H0; case H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H0; case H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H1; case H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H0; case H; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H1 H2; case (mult_lt_compat_rev_l2 n m p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H H0; case H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\n",
                "context_tokens": 345,
                "proof_start_offset": 892,
                "proof_end_offset": 1010,
                "proof": "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_gt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case (le_or_lt m p); auto with arith; intros H1.\nabsurd (p * n < p); auto with arith.\napply le_O_n.\napply H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * m < p * m); auto with arith.\napply le_trans with m; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H1; case (le_or_lt p m); auto with arith.\nintros H2 H3; contradict H2; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case (le_or_lt n m); auto with arith.\nintros H1 H2; Contradict H2; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case H; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; apply le_antisym; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H H0; case H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 394,
                "proof_start_offset": 1012,
                "proof_end_offset": 1197,
                "proof": "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H H0; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H H0; case (le_or_lt n m); intros H1.\nabsurd (p * n > p * m); auto with arith.\napply plus_lt_compat_l; auto.\nrewrite <- H; auto.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H1; case H1; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\n",
                "context_tokens": 470,
                "proof_start_offset": 1199,
                "proof_end_offset": 1445,
                "proof": "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * m < p * m); auto with arith.\napply le_not_lt; apply le_trans with (m := p); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case (le_or_lt n m); intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_trans with m; auto with arith.\napply le_trans with m; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case H; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply le_not_lt; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case H; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; apply (mult_ge_compat_rev_l1 n m); auto.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; case H2; intros H3.\nabsurd (p * n > p * m); auto with arith.\nabsurd (p * n > p * m); auto with arith.\napply le_trans with (m * n); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 569,
                "proof_start_offset": 1447,
                "proof_end_offset": 1704,
                "proof": "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n < p * m); auto with arith.\napply le_lt_trans with (m := p); auto with arith.\napply le_lt_trans with (m := p); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\napply le_not_lt; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt m n); auto with arith; intros H2.\nabsurd (p * n <= p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply le_not_lt; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt p m); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0 H1; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n > p * m); auto with arith.\napply le_trans with (p * n); auto with arith.\napply le_trans with (p * n); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0 H1; case (le_or_lt n m); auto with arith.\nintros H1; absurd (p * m < p * m); auto with arith.\napply le_lt_trans with (m := p); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt p m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\napply lt_le_trans with m; auto with arith.\napply le_trans with m; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 1706,
                "proof_end_offset": 1872,
                "proof": "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case (le_or_lt a b); intros H1; auto with arith.\nabsurd (0 < b); auto with arith.\napply lt_O_le; apply le_O_n; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case (le_or_lt a b); intros H1.\nabsurd (a = b); auto with arith.\napply lt_O_Sn.\napply le_trans with (a := b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case (le_or_lt a b); auto with arith.\nintros H1; absurd (a * b <= a); auto with arith.\napply lt_trans with (a * b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case b; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; elim H; auto with arith.\nintros H1; case (le_or_lt a b); intros H2; absurd (0 < a); auto with arith.\nrewrite H2; auto with arith.\nintros H2; case (le_or_lt b a); intros H2; auto with arith; intros H3; absurd (0 < b); auto with arith.\nContradict H2; auto with arith.\nintros H3; case H3; auto with arith; intros H3; absurd (0 < b); auto with arith.\nrewrite H3; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case (le_or_lt a b); intros H2; try (absurd (a = b); auto with arith; fail).\napply lt_trans with (m := b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_gt_dec 0 a); intros H1.\nabsurd (0 < b); auto with arith.\napply lt_O_n; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case (le_or_lt b a); auto with arith; intros H2; absurd (a = 0); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1; absurd (a * b <= a); auto with arith.\napply lt_O_lt; apply lt_O_Sn.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case b; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 1874,
                "proof_end_offset": 1996,
                "proof": "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H H0; replace 0 with (0 * 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1.\nabsurd (0 < a); auto with arith.\napply lt_O_lt; apply le_O_lt; apply lt_O_lt; apply le_O_lt; auto.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\napply le_lt_trans with (m := a); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1; absurd (0 < a); auto with arith.\napply lt_trans with 0; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H H0; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 1999,
                "proof_end_offset": 2106,
                "proof": "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H0; case (le_or_lt a b); intros H1.\nabsurd (0 < a); auto with arith.\napply lt_trans with (m := a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H0; red; apply lt_mult_0_l; auto.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H0; red; apply (lt_trans _ _ H H0).\nrewrite (lt_irrefl a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl; auto with arith.\nintros n H H0; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl in |- *; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case b; simpl; auto with arith.\nintros H H0; Contradict H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case b; simpl; auto with arith.\nintros n H H0; absurd (0 < 0); auto with arith.\napply le_mult_0; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl in |- *; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl; auto with arith.\nintros n H H0 H1; rewrite <- H0; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2108,
                "proof_end_offset": 2250,
                "proof": "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; red; apply plus_lt_reg_l with b; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; red; apply lt_mult_rev_0_l; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; red; apply (lt_irrefl 0).\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; red; apply lt_mult_rev_0_l; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case a; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2252,
                "proof_end_offset": 2358,
                "proof": "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1.\nabsurd (a > 0); auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2360,
                "proof_end_offset": 2503,
                "proof": "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "Qed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 2505,
                "proof_end_offset": 2590,
                "proof": "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n; case n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; simpl; auto with arith.\nintros; rewrite <- (mult_0_l n); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case (le_or_lt n m); intros H1.\nabsurd (0 < n); auto with arith.\napply le_lt_trans with (m := 0); auto with arith.\napply le_lt_trans with (m := 1); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H'; elim H'; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H'; elim H'; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; simpl; auto with arith.\nintros n1 H1 H2; case (le_or_lt n1 n2); intros H3.\nabsurd (0 < n1); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; simpl; auto with arith.\nintros; rewrite mult_0_r; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; elim n; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; elim n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; case n; simpl; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_compat_l || apply mult_lt_compat_l ||\n              apply mult_ge_compat_l || apply mult_gt_compat_l ||\n              apply lt_mult_0 || apply gt_mult_0); auto with arith.\n\nLtac hyp_nsign_tac H :=\n  match type of H with\n   0 <= _ => clear H\n|?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ <=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_le_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4783,
                "proof_end_offset": 5148,
                "proof": "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e; pattern a, b, c, d, e; pattern b, c, e; pattern c, e;\n intros a b c d e; pattern a, b, c, d; pattern e, b, c; pattern c, e;\n intros a b c d e; pattern a, b, c, e; pattern b, e;\n intros a b c d e; pattern a, b, c; pattern a, e;\n intros a b c d e; pattern a, b, c; pattern e, e;\n intros a b c d e; pattern a, b, c; pattern e, b; pattern a;\n intros a b c d e; pattern a, b, c; pattern a;\n intros a b c d e; pattern a, b, c; pattern a, b; pattern c, e;\n intros a b c d e; pattern a, b, c; pattern a, e;\n intros a b c d e; pattern a, b, c; pattern a, b;\n intros a b c d e; pattern a, b, c; pattern a, b; pattern a;\n intros a b cQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H1 H2;\ngeneralize H2; clear H2; clear H2; intros a b c d e H2 H3;\ngeneralize H3; clear H3; intros a b c d e H3;\n generalize (le_refl a b c d e H1 H3); clear H4; intros a b c d e H4 H5 H6.\ngeneralize (le_refl a b c d e H1 H2 H4); clear H4; intros a b c d e H5 H6;\n generalize (le_refl a b c d e H2 H4); clear H4; intros a b c d e H5 H6.\ngeneralize (le_refl a b c d e H5); clear H4; intros a b c d e H5 H6.\ngeneralize (le_refl a b c d e H5); clear H4; intros a b c d e H6 H7.\ngeneralize (le_refl a b c d e H1 H2 H3); clear H4; intros a b c d e H5 H6.\ngeneralize (le_refl a b c d eQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e Ha Ha Hb Hc e Hc e Ha Ha Hb e Ha Hc e Hc.\nassert (H : 0 <= a * c).\n apply (Z.le_0_Sn a (b * c)).\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_plus_distr_r.\n rewrite Zmult_comm.\n rewrite Zmult_plus_distr_r.\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_plus_distr_l.\n rewrite Zmult_plus_distr_l.\n reflexivity.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H1 H2.\ngeneralize H2; clear H2; intros H H1.\nassert (H4 : 0 < b * c).\n apply H2.\nclear H2 H3 H5 H6 H7 H8 H9 H10.\nassert (H4 : 0 < b * c).\napply H4.\nclear H2 H6 H7 H8 H9 H10 H11 H12.\nassert (H5 : 0 < b * c).\napply H5.\nclear H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15.\nassert (H6 : 0 < b * c).\napply H6.\nclear H6 H7 H8 H9 H10 H11 H12 H13 H14.\nassert (H6 : 0 < b * c).\napply H2.\nclear H6 H7 H8 H9 H11 H12 H13 H14 H15 H16.\nassert (H6 := H1 H2 H3 H7 H7 H8).\nassert (H6 : 0 < b * c).\napply H6Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e Ha e Ha Hb e Ha Ha Hb e Ha Ha Hc e Ha Ha Hc.\nassert (Ha' : 0 <= a * b) by (assert (Ha' : 0 <= b); [apply Ha' | auto with arith]).\nassert (Ha' : 0 <= b * c) by (assert (Ha' : 0 <= b * c) by (assert (Hb' : 0 <= c); [apply Ha' | auto with arith]).\nassert (Ha' : 0 <= c * b) by (assert (Ha' : 0 <= c * b) by (assert (Ha' : 0 <= c * b) by (assert (Hb' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= c * b) by (assert (H' : 0 <= cQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H1 H2 H3 H4 H5;\n generalize (le_0_eq_0 _ _ H4); clear H4; intros H4;\n generalize (le_0_eq_0 _ _ H4); clear H4; intros H4;\n generalize (le_0_eq _ _ H4); clear H4; intros H4;\n generalize (le_0_eq _ _ H5); clear H5; intros H5;\n generalize (le_0_eq _ _ H5); clear H5; intros H5 H6;\n generalize (le_0_eq _ _ H5); clear H5; intros H5;\n generalize (lt_0_eq _ _ H5); clear H5; intros H6;\n generalize (le_0_eq _ _ H5); clear H5; intros H5;\n generalize (lt_0_eq _ _ H5); clear H5; intros H5;\n generalize (lt_eq _ _ H6); clear H5; intros H5 H6;\n generalize (le_0_eq _ _ H6); clear H5; intros HQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e.\n functional induction (a * b); intros.\n- exact (H0 a H1).\n- exact (H2 a H3).\n- exact (H3 b H4).\n- exact (H3 b H4).\n- exact (H4 b H4).\n- exact (H4 a H4).\n- exact (H4 b H4).\n- exact (H3 b H4).\n- exact (H4 b H4).\n- exact (H4 b H4).\n- exact (H4 b H4).\n- exact (H4 b H4).\n- exact (H4 b H4).\n- exact (H4 b H4).\n- exact (H4 b H4).\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e Ha e Ha e Ha Hb e Hc.\nassert (Ha' : (0 <= a * b)%Z).\napply Zmult_integral_l with b; auto with zarith.\nassert (Ha' : (0 <= b * c)%Z).\napply Zmult_integral_l with b; auto with zarith.\nassert (Ha' : (0 <= b * c)%Z).\n apply Zmult_integral_l with b; auto with zarith.\nassert (Ha' : (0 <= b * c)%Z).\napply Zmult_integral_l with b; auto with zarith.\nassert (Ha' : (0 <= a * c)%Z).\napply Zmult_integral_l with b; auto with zarith.\nassert (Ha' : (0 <= a * c)%Z).\napply Zmult_integral_l with c; auto with zarith.\nassert (Ha' : (0 <= a * c)%Z).\napply Zmult_integral_l with c; auto with zarith.\nassert (Ha' : (0 <= a * c)%Z).\napply Zmult_integral_l with b; auto with zarith.\nassert (Ha'Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e Ha Hb Hc Hc.\nassert (H := le_0_ind _ _ Hc).\nset (c' := 0) in *; set (c' := 0) in *; set (c' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *; set (d' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *;\n set (d' := 0) in *; set (d' := 0) in *; \n set (d' := 0) in *; set (d' := 0) in *; \n set (d' := 0) in *; set (d' := 0) in *; \n set (d' := 0) in *; \n set (d' := 0) in *; clearbody dQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e Ha Hb e Ha Hb e Ha Hb e Ha Ha Hb e Ha Hb e Ha Ha.\ndestruct (le_gt_cases 0 a) as [Ha'|Ha']; [|order_equal] Ha].\nrewrite Ha, (abs_eq _ Ha') in Ha, Ha'.\ndestruct (lt_ge_dec (b*c) c) as [Ha'|Ha']; [|order_equal] Ha].\nrewrite Ha, (abs_eq _ Ha') in Ha'.\ndestruct (lt_ge_dec (b*c) c) as [Ha'|Ha']; [|order_equal] Ha].\nrewrite Ha, (abs_eq _ Ha') in Ha.\ndestruct (lt_ge_dec (b*c) c) as [Ha'|Hb']; [|order_equal] Ha].\nrewrite Ha, (abs_eq _ Ha') in Ha.\ndestruct (lt_ge_dec (b*c) c) as [Ha'|Ha']; [|order_equal] Ha].\nrewrite Ha', (abs_eq _ Ha') in Ha.\ndestruct (lt_ge_dec (b*c) c) as [Ha'|Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\nLet hyp_test : forall a b c d e, \n  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H should disappear *)\nhyp_nsign_tac H.\n(* a in H2 should disappear *)\nhyp_nsign_tac H2.\n(* H3 unchanged *)\ntry hyp_nsign_tac H3.\n(* d should disappear *)\nhyp_nsign_tac H4.\n(* Prove it *)\nhyp_nsign_tac H5.\nQed.\n\n\n",
                "context_tokens": 718,
                "proof_start_offset": 5151,
                "proof_end_offset": 5516,
                "proof": "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4 H5.\n(* H3 after H4 after H4 after H5 with H6 *)\nexact H3 H4.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4 H5 H6.\n(* H3 test2 *)\nexact (H2 (H3 H4 H1)).\nexact (H2 (H3 H4)).\nexact (H2 (H4 H2)).\nexact (H4 (H4 H2)).\nexact (H4 (H4 H2)).\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H3 after H1 *)\nrewrite H1 in H2; clear H1.\nrewrite H2 in H2; clear H2.\nrewrite H4 in H2; clear H2.\nrewrite H4 in H2; clear H4.\nrewrite H5 in H2; clear H4.\nrewrite H5 in H2; clear H4.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nrewrite H5 in H2; clear H5.\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4.\n(* H3 not used *)\napply le_n_S.\nexact H3.\nexact H3.\nexact H3.\nexact H4.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H4.\nexact H2.\nexact H3.\nexact H3.\nexact H3.\nexact H3.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H4.\nexact H5.\nexact H4.\nexact H3.\nexact H4.\nexact H3.\nexact H3.\nexact H4.\nexact H5.\nexact H5.\nexact H4.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H4.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexact H5.\nexactQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H0 H1 H2 H3 H4.\n(* H3 can't extendible *)\nsimpl in H2.\nassert (a * b + c * b = a * b + c * b).\n rewrite H3 in H3.\n (* H4 *)\nrewrite H4 in H3.\nclear H4.\nrewrite H4 in H3.\nclear H4.\nassert (a * b + c * c = a * c + b * c).\n rewrite H4 in H4.\nclear H4.\nrewrite H4 in H4.\nclear H4.\nrewrite H4 in H4.\nclear H4.\nrewrite H5 in H4.\nclear H4.\nrewrite H4 in H4.\nclear H4.\nassert (a * b + c * b = c * c + b * c).\nrewrite H4 in H4.\nclear H4.\nrewrite H5 in H4.\nclear H4.\nrewrite H5 in H4.\nclear H4.\nsimpl in H4.\nassert (a * b + c * b = c *Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H3 hypothesis *)\nhyp_nsign_tac H2.\n(* a = 0 *)\nexact (proj1 H2).\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4 H5.\n(* H3 after H1 *)\nelim H1; intros H1 H2; clear H1 H2 H3 H4.\n(* H3 after H2 *)\nelim H2; intros H3 H4.\nelim H4; intros H5 H6.\nelim H5; intros H6 H7.\nelim H6; intros H7 H8.\nelim H8; intros H8 H9.\nelim H8; intros H9 H10.\nelim H10; intros H12 H13.\nelim H11; intros H12 H13.\nelim H11; intros H12 H13.\nelim H12; intros H12 H13.\nelim H12; intros H13 H14.\nelim H13; intros H13 H14.\nelim H12; intros H13 H14.\nelim H13; intros H14 H15.\nelim H14; intros H14 H15.\nelim H13; intros H14 H15.\nelim H14; intros H15 H15.\nelim H15; intros H15 H16.Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4.\n(* H3 H4 not used *)\nelim H; intros H5 H6; elim H6; intros H7 H8.\napply eq_S_eq_succ_r in H6.\napply (lt_O_nat_of_P n) in H6.\nrewrite <- H6 in H6.\nassumption.\n(* H3 can be a c *)\nelim H; intros H6 H7; elim H6; intros H7 H8.\napply eq_S_eq_succ_r in H6.\napply (lt_O_nat_of_P n) in H6.\nrewrite <- H6 in H6.\nassumption.\n(* H3 not used *)\nelim H; intros H7 H8.\napply eq_S_eq_succ_r in H6.\nrewrite <- H6 in H6.\nassumption.\n(* H3 is not used *)\nelim H; intros H7 H8.\napply eq_S_eq_succ_r in H6.\nrewrite <- H6 in H6.\nassumption.Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4 H5.\n(* H3 after H4 after H5 *)\nhyp_nsign_tac H4.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H6 *)\nexact H3.\n(* H3 after H6 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H4 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H4.\n(* H3 after H5 *)\nexact H3.\n(* H3 after H5 *)\nexact H3.\n(* H3 after HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4 H5 H6.\n(* H3 test_eq *)\nhyp_nsign_tac H4.\n(* H3 test_eq *)\nclear H5 H3 H4 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H22 H23 H24 H25 H26 H27 H28 H29 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49 H47 H48 H49 H47 H48 H49 H47 H48 H49 H47 H48 H49 H47 H49 H47 H48 H49 H47 H48 H49 H49 H47 H47 H48 H49 H49 H47 H47 H48 H49 H46 H47 H48 H49 H47 H48 H49 H48 H49 H47 H48 H49 H47 H48 H49 H47 H48 H49 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\n",
                "context_tokens": 329,
                "proof_start_offset": 839,
                "proof_end_offset": 971,
                "proof": "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros p H H0; apply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; simpl; auto with arith.\nintros p; case p; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros p1; case p1; simpl in |- *; auto with arith.\nintros pQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros H1; apply le_IZR; auto.\nintros H1; apply le_IZR; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simpl; auto with arith.\nintros p; case p; simplQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 H1; case H1; auto.\nintros m2 H1; case H1; auto.\nintros m2 H1; case H1; auto.\nintros m3 H H1; case H1; auto.\nintros m3 H1; case H1; auto.\nintros m3 H H1; case H1; auto.\nintros m4 H1; case H1; auto.\nintros m4 H1 H2; case H1; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2 H3; case H2; auto.\nintros m4 H1 H3; case H3; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H2 H3; case H3; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m H; case (le_or_lt n m); auto with arith.\nintros p1 H1; case H1; auto.\nintros p2 H1; case H1; auto.\nintros p2 H1; case H1; auto.\nintros p3 H2; case H1; auto.\nintros p3 H4; case H2; auto.\nintros p3 H4; case H4; auto.\nintros p3 H4; case H4; auto.\nintros p3 H4; case H4; auto.\nintros p3 H4; case H4; auto.\nintros p3 H4; case H4; auto.\nintros p3 H4; case H4; auto.\nintros p3 H4; case H4; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; simpl; try (intros; discriminate).\nintros n1 H1; case H1; auto.\nintros m1 H1; case H1; auto.\nintros m2 H1; case H1; auto.\nintros m2 H1 H2; case H1; auto.\nintros m3 H1 H2; case H2; auto.\nintros m3 H1 H2; case H2; auto.\nintros H1 H2 H3; case H2; auto.\nintros m3 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2; case H2; auto.\nintros m4 H1 H2 H3; case H2; auto.\nintros m4 H1 H2 H3; case H2; auto.\nintros m4 H1 H2 H3; case H2; autoQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m H; case (le_or_lt n m); auto with arith.\nintros H1 H2; case H1; auto.\nintros H3; case H3; auto.\nintros m1 H3; case H3; auto.\nintros m2 H3; case H3; auto.\nintros H3; case H3; auto.\nintros m2 H3; case H3; auto.\nintros H3; case H3; auto.\nintros m1 H3; case H3; auto.\nintros m2 H3; case H3; auto.\nintros m3 H4; case H4; auto.\nintros H3; case H3; auto.\nintros m3 H4; case H3; auto.\nintros m3 H4; case H4; auto.\nintros m3 H4; case H4; auto.\nintros m3 H4; case H4; auto.\nintros m3 H4; case H4; auto.\nintros m4 H5; case H4; auto.\nintros m3 H4; case H4; auto.\nintros m4 H5; case H5Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p1 H1; case H1; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 386,
                "proof_start_offset": 973,
                "proof_end_offset": 1244,
                "proof": "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros H H0; case H; auto.\nintros n1 H1; case H1; auto.\nintros p1 H1; case H1; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nintros p1 H2; case H2; auto.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; simpl; auto with arith.\nintros p; case p; simpl in |- *; auto.\nintros p; case p; simpl in |- *; auto.\nintros p; case p; simpl in |- *; auto.\nintros p; case p; simpl in |- *; auto.\nintros p; case p; simpl in |- *; auto.\nintros p; case p; simpl in |- *; auto.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros n1 H1; case H1; auto.\nintros n2 H2; case H2; auto.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate).\nintros H H0; case (le_or_lt n m); auto with arith.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros H1; case H1; auto.\nintros HQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply lt_nge; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply le_IZR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl with m; auto with arith.\nintros p; elim p using Pind; simpl.\nintros H1 H2; apply lt_irrefl withQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply le_antisym; auto with arith.\napply le_IZR_lt; auto.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m H; case (le_or_lt m n); auto with arith.\nintros H1; case H1; auto.\nintros n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H2; auto.\nintros m1 n2 H1; case H2; auto.\nintros m2 H3; case H3; auto.\nintros m1 n2 H3; case H3; auto.\nintros H3 H4; case H4; auto.\nintros m2 n3 H4; case H4; auto.\nintros H4 H4; case H4; auto.\nintros m1 n3 H4; case H4; auto.\nintros H3 H4; case H4; auto.\nintros m1 n3 H4; case H4; auto.\nintros H5 H6 H7 H8; case H8; auto.\nintros m1 n2 H7; case H8; auto.\nintros m2 H8; case H8; auto.\nintros m2 H8; case H8; auto.\nintros m1 n2Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros H1; case H1; auto.\nintros p H1; case H1; auto.\nintros n1 H1; case H1; auto.\nintros p H1; case H1; auto.\nintros n1 H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nintros p H1; case H1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 1246,
                "proof_end_offset": 1540,
                "proof": "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate);\n auto.\nintros n1 H1; case (le_or_lt n m1); intros H2 H3.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply nat_ofQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate);\n intros; discriminate.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversionQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m H; apply lt_INR.\nintros m H; apply lt_O_Sn.\nintros m H; apply lt_le_trans with m; auto with arith.\napply le_O_Sn.\nintros m H; apply lt_O_Sn.\nintros m H; apply lt_le_trans with m; auto with arith.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m H1; case H1; auto.\nintros p H2; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H1.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H1; inversion H1.\nintros p H2; inversion H2.\nintros p H1; inversion H2.\nintros p H2; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H2; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros p H1; inversion H2.\nintros pQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate);\n intros; try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (intros; discriminate);\n try (introsQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m H; case (lt_or_lt n m); intros H1.\nrewrite (O_nat_of_P_succ_morphism m); auto with arith.\nrewrite H1 in H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate);\n intros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m H; case (N.le_lt_or_eq n m); intros H1.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_gt_Gt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_compare_complement_morphism; auto.\napply lt_O_nat_of_P_lt_Lt_Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate);\n intros; case (le_or_lt m n1); auto with arith.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate);\n intros; auto.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversionQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\n",
                "context_tokens": 610,
                "proof_start_offset": 1542,
                "proof_end_offset": 1672,
                "proof": "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2Z.id (S m1)); rewrite <- (Nat2Z.id (S m1)); rewrite <- (Nat2Z.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m1 n1 H1; case H1; auto.\nintros m1 H1; case H1; auto.\nintros m2 H1; case H1; auto.\nintros m3 H1; case H1; auto.\nintros m3 H1; case H1; auto.\nintros m3 H1 H2; case H1; auto.\nintros m3 H1 H2; case H1; auto.\nintros m3 H1 H2; case H1; auto.\nintros m3 H2 H3; case H1; auto.\nintros m3 H H1 H2; case H1; auto.\nintros m3 H H3; case H1; auto.\nintros m4 H1 H2 H3; case H1; auto.\nintros m4 H1 H2; case H1; auto.\nintros m4 H1 H2 H3; case H1; auto.\nintros m4 H1 H2 H3; case H1; auto.\nintros m4 H1 H2; case H1; auto.\nintros m4Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros m1 n1 H1; rewrite <- (Nat2Z.id (S n1)); rewrite <- (Nat2Z.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m H; rewrite <- (Nat2N.id (S n)); rewrite <- (Nat2N.id m);\n rewrite <- (Nat2N.id n); rewrite <- (Nat2N.id n); auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; try (intros; discriminate); auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H1; case (le_or_lt n1 m1); auto with arith.\nintros H1; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros H1; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m H'; case (N.le_or_lt n m); intros H1.\nrewrite <- (Nat2Z.id n1).\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1).\nsimpl; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nintros H H0; inversion H1.\nintros m1 n1 H1.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nrewrite <- (Nat2Z.id n1); simpl; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; simpl; auto.\nintros H; inversion H.\nintros; apply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; try (intros; discriminate); auto.\nintros m1 n1 H1.\nrewrite <- (Pos2Nat.id (S m1)); rewrite <- (Nat2Z.id (S n1)); simpl; auto.\nintros H H0; inversion H0.\nintros m2 n2 H1.\nrewrite <- (Nat2Z.id (S m2)); rewrite <- (Nat2Z.id (S m2)); simpl; auto.\nintros H H0.\nrewrite <- (Nat2Z.id (S m2)); simpl; auto.\nintros H H0; inversion H0.\nintros m2 n1 H1.\nrewrite <- (Nat2Z.id (S m2)); rewrite <- (Nat2Z.id (S m2)); simpl; auto.\nintros H H0; inversion H0.\nintros m2 n1 H1.\nrewrite <- (Nat2Z.id (S m2)); rewrite <- (Nat2Z.id (S m2)); simpl; auto.\nintros H H0; inversion H0.\nintros m2 n1 H1.\nrewrite <- (NatQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; try (intros; discriminate); auto.\nintros m1 n1 H1; case H1; auto.\nintros m2 n2 H2; case H2; auto.\nintros m2 n2 H2; case H2; auto.\nintros m2 n2 H3; case H3; auto.\nintros m2 n2 H3; case H3; auto.\nintros m3 n3 H4; case H4; auto.\nintros m3 n3 H4; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m3 H4; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros m4 H3; case H4; auto.\nintros mQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros n1 H1; rewrite <- (Nat2N.id n1); rewrite <- (Nat2N.id n1); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\n",
                "context_tokens": 20,
                "proof_start_offset": 66,
                "proof_end_offset": 153,
                "proof": "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y; unfold y; simpl; ring.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y H1 H2; apply H1.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y H.\n apply Rnot_lt_gt.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\napply (pow_lt_mono_pos_r _ _ Hx).\napply pow_lt_mono_pos_r ; try order.\nnow apply pow_gt_lin_r.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y; apply Rlt_not_le; auto.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hxy.\nrewrite <- (Rmult_0_l x).\napply Rmult_lt_compat_l.\nnow apply Rmult_le_pos.\nnow apply Rmult_le_pos.\nnow apply (Z2R_lt 0).\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y Hx Hy.\ndestruct (le_lt_dec x y) as [H|H].\nrewrite <- H.\napply lt_succ_r in H.\nrewrite <- H.\napply lt_succ_r in Hx.\nrewrite <- H.\napply lt_succ_r in Hx.\nnow rewrite succ_lt_mono.\nrewrite succ_lt_mono.\nnow apply succ_lt_mono.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y Hx Hxy.\ndestruct (lt_dec x y) as [H'|H'].\ndestruct (lt_dec y x) as [H'|H'].\ndestruct (lt_dec y x) as [H'|H'].\nrewrite H,H',H',H',H',H',H'.\nrewrite H',H',H',H',H',H'.\nnow rewrite H',H',H',H',H'.\nnow rewrite H',H',H',H'.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros x y H.\ndestruct (le_dec x y) as [H|H].\nnow rewrite 2!pow_0_r, pow_succ_r, pow_succ_r, pow_succ_r.\nrewrite 2!pow_succ_r, pow_succ_r, pow_succ_r, pow_succ_r, pow_succ_r, pow_succ_r.\nrewrite <- pow_succ_r, pow_succ_r, pow_succ_r, pow_succ_r.\nrewrite <- pow_succ_r, pow_succ_r, pow_succ_r, pow_succ_r.\nnow apply pow_gt_1.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros x y [H1 H2]; apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 63,
                "proof_start_offset": 155,
                "proof_end_offset": 234,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npattern x at 1 3 ; replace y with (y + y + x).\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rle_0_trans with (1 + y).\napply Rplus_le_compat_l.\napply Rle_trans with (1 + y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rle_0_1.\napply Rlt_le_trans with (1 + y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rle_0_trans with (1 + y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rlt_le.\napply Rplus_le_compat_l.\napply Rle_0_trans with (1 + y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nup_test2.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern y at 2; replace y with (x + y).\napply Rplus_lt_compat_l.\napply Rle_trans with (1:=H).\napply Rplus_lt_compat_l.\napply Rle_trans with (1:=H).\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compat_l.\napply Rle_trans with (1:=proj1 H).\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compat_l.\napply Rle_trans with (1:=proj1 H).\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compat_l.\napply Rle_trans with (1:=proj1 H).\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compat_l.\napply Rle_trans with (1:=proj1 H).\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compat_l.\napply H.\napply Rplus_le_compatQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nup_test1.\napply Rlt_trans with (1 := Hx).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rlt_le.\napply Rle_lt_trans with (1 := Hx).\napply Rplus_le_compat_r.\napply Rle_refl.\napply Rle_refl.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nams.\nreplace (x + y) with y.\napply Rmult_lt_compat_r.\napply Rmult_lt_0_compat.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (2 := Hx).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rinv_0_lt_compat.\nnow apply (Z2R_lt 0 2).\nnow apply (Z2R_lt 0 2).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 2 in |- *.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\npattern x at 1 in |- *.\nrewrite <- Rplus_0_l.\nrewrite Rmult_0_l.\nrewrite Rmult_1_l.\napply Rmult_lt_reg_l with (2 := H).\napply Rmult_lt_reg_l with (2 := H).\napply Rmult_lt_reg_l with (2 := H).\napply Rmult_lt_reg_l with (2 := H).\nrewrite <- Rmult_assoc.\nrewrite <- Rmult_assoc.\nrewrite <- Rinv_r_sym.\nrewrite Rmult_1_l.\napply Rmult_lt_reg_l with (2 := H).\nrewrite Rmult_1_l.\napply Rmult_lt_reg_l with (2 := H).\nrewrite <- Rmult_assoc.\nrewrite <- Rinv_r_sym.\nrewrite Rmult_1_l.\nrewrite Rmult_1_l.\nreplace (2 * x)%R with (2 * (2 * x))%R.Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\napply Rplus_lt_reg_l with (2:=proj1 Hx).\napply Rplus_lt_reg_l with (1:=proj2 Hx).\napply Rplus_lt_reg_l with (1:=proj2 Hx).\nrewrite 2!plus_comm, <- 2!plus_assoc, <- 2!plus_assoc, <- 2!plus_assoc, <- 2!plus_assoc.\napply Rplus_lt_compat_l.\napply Rlt_le.\nnow apply Rle_trans with (2:=proj1 Hx).\napply Rplus_lt_reg_l with (1 := proj2 Hx).\nrewrite 2!plus_comm.\napply Rplus_le_compat_l.\napply Rlt_le.\nnow apply Rle_trans with (1:=proj1 Hx).\nrewrite 2!plus_comm.\napply Rplus_le_reg_l with (1:=proj1 Hx).\nrewrite 2!plus_comm.\nrewrite 2!plus_comm.\napply Rplus_le_reg_l with (1:=Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nmax_elt_correct.\ndestruct x.\napply Rle_refl.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern y at 2; rewrite <- (Rmult_0_l x).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_r y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_r y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 1; rewrite <- (Rmult_0_r y).\npattern y at 2; rewrite <- (Rmult_0_l y).\npattern y at 1; rewrite <- (Rmult_0_l y).\npattern y at 1; rewrite <- (Rmult_0_l y).\npattern y at 1; rewrite <- (Rmult_0_l y).\npattern y at 2; rewrite <- (Rmult_0_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 101,
                "proof_start_offset": 237,
                "proof_end_offset": 357,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 2 3 3 3 5 7 9 9 9 9 9 9 9 9 9 9 9 8 9 9 10 8 9 9 9 9 9 9 11 9 11 12 12 12 12 12 13 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 13 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 13 13 12Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 2 3 3 5 8 9 9 9 11 11 in |- *.\npattern x at 1 3 3 8 9 9 9 in |- *.\npattern x at 1 3 3 8 8 8 9 in |- *.\npattern x at 1 3 8 8 8 8 8 in |- *.\npattern x at 1 3 3 8 8 8 8 9 in |- *.\npattern x at 2 2 3 8 8 8 8 in |- *.\npattern x at 1 2 3 8 8 8 8 8.\npattern x at 1 2 3 8 8 8 8 8.\npattern x at 2 3 8 8 8 8 8 8 8.\npattern x at 2 3 8 8 8 8 8 8 8 8.\npattern x at 1 3 3 8 8 8 8.\npattern x at 2 3 8 8 8 8 8 8 8.\npattern x at 2 3 8 8 8 8 8.\npattern x at 1 2 8 8 8 8 8.\npattern x at 2 3 8 8 8 8 8.\npattern x at 2 5 8 8 8.\npattern x at 2 3 8 8 8.\npattern x at 2 3 5 8 8 8 8.\npattern x at 1 3 8 8 8 8 8.\npattern xQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 3 in |- *.\nrewrite Rmult_plus_distr_r.\npattern (x * y) at 1 in |- *.\nrewrite Rmult_1_l.\nchange (2 * (2 * 2) * (x + y) * (x + y) * (x + y) + y) in |- *.\nrewrite Rmult_plus_distr_l.\nchange (2 * (2 * 2) * (x + y) * (x + y) * (x + y) + y) in |- *.\nrewrite Rmult_plus_distr_l.\nchange (2 * (2 * 2) * (x + y) * (x + y) + y) + x) in |- *.\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) + y) + y) in |- *.\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) + y) with (x + y) + x) in |- *.\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + yQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\napply Rmult_lt_reg_r with (r := 2).\nrewrite Rmult_assoc, <- Rinv_r, Rmult_1_r.\nrewrite Rmult_1_r, Rmult_comm.\nrewrite Rmult_assoc, <- Rinv_l, Rmult_1_r.\nrewrite Rmult_1_r, Rmult_1_l.\nreplace ((x + y) * (x + y) * (x + y)) * (x + y) * (x + y) * (x + y) * (x + y) * (x + y)).\nrewrite Rmult_assoc, <- Rinv_r, Rmult_1_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\nnow apply (Z2R_lt 0 2).\nnow apply (Z2R_lt 0 2).\nnow apply (Z2R_lt 0 2).\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 3 ; rewrite <- Rmult_1_l, Rmult_1_l, Rmult_1_l.\nchange (2 * (x + y) * (x + y) < 2 * (x + y) * (x + y)).\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) * (x + y) + y) < 2 * (x + y).\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) + y) with ((x + y) * (x + y) * (x + y)).\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) + y) <= 2 * (x + y) + y).\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) + y) < 2 * (x + y + x).\nrewrite Rmult_plus_distr_r.\nchange (2 * (x + y) * (x + y) +Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern (x + y) at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern (x + y) at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern (x + y) at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern (x + y) at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_gt_1.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_gt_1.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply pow_lt_compat_r.\napply powQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 2 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_l.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_l.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_l.\npattern (x + y) at 1 in |- *.\nrewrite Rplus_0_l.\npattern (x + y) at 1 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 2 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 1 in |- *.\nrewrite Rplus_0_l.\npattern (x + y) at 1 in |- *.\nrewrite Rplus_0_r.\npattern (x + y) at 1 in |- *.\nrewrite Rplus_0Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1 in |- *.\nrewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Rmult_1_l.\nrepeat rewrite Zplus_1_l.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_l.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_l.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_r.\nrepeat rewrite Zplus_0_r.\nrepeat rewriteQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 162,
                "proof_start_offset": 360,
                "proof_end_offset": 482,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *.\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (x + z).\npattern z at 2 in |- *; replace z with (xQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 1; rewrite <- (plus_n_O x y).\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *; rewrite <- (plus_comm (2 * x)).\nrewrite <- plus_comm.\nrewrite Rmult_plus_distr_l.\nrewrite <- (plus_comm (2 * x)).\nrewrite <- plus_assoc.\nrewrite <- plus_minus_distr_l.\nrewrite <- (plus_comm (2 * x)).\nrewrite <- plus_minus_distr_r.\nrewrite <- plus_minus_distr_r.\nrewrite <- plus_minus_distr_r.\nrewrite <- (plus_comm (2 * x)).\nrewrite plus_minus_distr_r.\nrewrite <- plus_minus_distr_r.\nrewrite <- plus_minus_distr_r.\nrewrite <- (plus_comm x).\nrewrite <- plus_minus_distr_r.\nrewrite plus_minus_distr_l.\nrewrite <- plus_minus_distr_r.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 1 in |- *.\nrewrite Rplus_0_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compatQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 in |- *.\nreplace z with (2 * z + 2 * y * x + y * x + y * x).\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rinv_0_lt_compat.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (INR 2).\nnow apply INR_fact_lt_0.\nrewrite Rmult_1_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_l with (INR 2).\nnow apply INR_fact_lt_0.\napply INR_fact_neq_0.\nnow apply INRQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 2 ; replace y with (2 + (y + y)).\napply Rmult_1_r.\napply Rmult_1_r.\napply Rmult_le_compat_r.\napply (Rmult_lt_reg_r (2 * x)).\napply Rmult_le_compat_r.\napply (Rmult_lt_reg_r (2 * y)).\napply Rmult_lt_reg_l with (2 * x).\napply Rmult_lt_compat_l.\napply (Rmult_lt_reg_r (2 * y)).\napply Rmult_lt_compat_l.\napply (Rmult_lt_reg_r (2 * y)).\napply Rmult_lt_compat_r.\napply (Rmult_lt_reg_r (2 * y)).\napply Rmult_lt_compat_r.\napply (Rmult_lt_reg_r (2 * y)).\napply Rmult_lt_compat_l.\napply (Rmult_lt_reg_l (2 * y)).\napply Rmult_lt_compat_r.\napply (Rmult_lt_reg_r (2 * y)).\napply Rmult_ltQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern x at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1, z in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1, z in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *; rewrite <- (plus_n_O p).\n\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2, z at 1, z at 1, z at 1, z at 1, z at 1 in |- *;\n repeat rewrite <- Rmult_1_l; auto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 in |- *.\nrewrite Rmult_1_r.\npattern z at 2 in |- *.\nrewrite Rmult_1_r.\nrewrite Rmult_comm.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_l with (2 * y).\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_l with (2 * y).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_l with (2 * y).\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_r with (2 * y).\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_r with (2 * y).\napply Rmult_lt_compat_l.\napply Rmult_lt_reg_l withQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 225,
                "proof_start_offset": 485,
                "proof_end_offset": 561,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 2, y at 2, y at 2, z in |- *.\npattern y at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2 in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2, z in |- *.\npattern z at 2 in |- *.\npattern z at 2, z in |- *.\npattern z at 1, z in |-Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern x at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern y at 1, z at 1 in |- *.\nrewrite <- Rplus_assoc.\nrewrite Rplus_comm.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 2 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 2 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 2, y at 1, y at 2, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, yQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 ; replace y with (2 * y).\napply Rle_refl.\napply Rle_trans with (2 := H).\napply Rmult_le_compat_r.\napply pow_lt_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_le_compat.\napply pow_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 2 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern x at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1 in |- *.\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y, y at 1, y at 1, y at 1 in |- *.\n\npattern x at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1, y at 1,Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1, y at 1, x at 1, y at 1, x at 1, x at 1, x at 1, x at 1, x at 1, x at 1,  x at 1,  y at 1,  y at 1, x at 1,  x at 1,  x at 1,  y at 1, x at 1,  x at 1,  y at 1,  x at 1,  x at 1,  y at 1,  x at 1,  y at 1,  x at 1,  x at 1,  y at 1,  y at 1,  x at 1,  y at 1,  x at 1,  y at 1,  y at 1,  y at 1,  x at level 0,  x at level 0,  x at level 0,  y at level 0,  x at level 0,  x at level 0,  y at level 0,  x at level 0,  y at level 0,  x at level 0,  y at level 0,  x at level 0,  y at level 0,  x at level 0,  y at levelQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern x at 1 in |- *.\nrewrite <- (Rmult_0_l x).\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 261,
                "proof_start_offset": 563,
                "proof_end_offset": 659,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\napply Rplus_le_compat_r.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_le_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_lt_0_compat.\napply Rplus_le_0_compat.\napply Rplus_le_0Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 2; replace x with (2 * y + 2 * y).\napply Rmult_1_l.\napply Rmult_le_compat_r.\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (1 := H).\napply Rmult_lt_reg_l with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rinv_0_lt_compat.\napply INR_fact_neq_0.\napply INR_fact_neq_0.\napply Rmult_lt_reg_r with (2 := H).\napply Rinv_0_lt_compat.\napply INR_fact_neq_0.\napply INR_fact_neq_0.\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_l with (2 := H).\napply Rinv_0_lt_compat.\napply INR_fact_neq_0.\napply INR_fact_neq_0.\napply INR_fact_neqQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\n pos_le_dec.\napply Rle_lt_trans with 2%nat.\napply Rlt_le_trans with 2%nat.\napply Rle_lt_trans with (2:=proj1 H).\napply Rlt_le_trans with (2:=proj2 H).\napply Rlt_le_trans with (2:=proj2 H).\napply Rlt_le_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj1 H).\napply Rle_trans with (1:=proj1 H).\napply Rle_trans with (1:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj2 H).\napply Rle_trans with (2:=proj1 H).\napply Rle_trans with (2:=proj1 H).\napply Rle_trans withQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 2; replace y with (-x + y); auto with real.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 2 ; rewrite <- Rplus_0_l.\napply Rplus_lt_reg_l with (-1).\napply Rplus_lt_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (-1).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (-1).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_le_reg_l with (1 := H).\napply Rplus_leQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1; replace x with (1 + y) by ring.\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rmult_lt_reg_l with (2 := H).\napply Rmult_lt_reg_l with (2 := H).\napply Rmult_lt_reg_r with (2 := H).\napply Rinv_0_lt_compat.\nnow apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 1, y at 1, y at 1 in |- *.\npattern y at 1, y at 1 in |- *.\npattern y at 1, y at 1, y, z in |- *.\npattern y at 1, y, z in |- *.\npattern z at 1 in |- *.\npattern z at 1, y, z in |- *.\npattern z at 1, y, z in |- *.\npattern z at 1, y, z in |- *.\npattern z at 1, y, z in |- *.\npattern z at 1, y, z in |- *.\npattern z at 1, y, z in |- *.\npattern z at 2, z in |- *.\npattern z at 1, y, z in |- *.\npattern z at 1, z in |- *.\npattern z at 2 in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 1 in |- *.\npattern z at 1, z, z in |- *.\npattern z at 1, z in |- *.\npattern z at 1, z in |- *.\npattern z at 2, zQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern y at 2, y at 2, x, y in H0 |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 1, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2 in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |- *.\npattern y at 2, x, y in |-Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\npattern x at 2 ; rewrite Rplus_0_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 307,
                "proof_start_offset": 663,
                "proof_end_offset": 781,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\npattern z at 1 in |- *.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_r.\napply Rinv_0_lt_compat.\napply Rmult_lt_reg_r with (2 := proj1 H0).\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_compat_l.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (2 := proj2 H1).\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (1 := proj2 H1).\napply Rmult_lt_reg_r with (2 := proj2 H1).\napply Rmult_lt_reg_r with (2 := proj2 H1).\napply Rmult_lt_reg_r with (2 := proj2 H1).\napply Rmult_lt_reg_l with (1 := proj2 H1Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncut (x + y < x + y * y + z).\nintros.\ncut (x + z < 2 * y + z * y).\nintros.\napply Rle_trans with (2 := H).\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_r.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napplyQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H0.\nsplit.\napply Rle_trans with (2 := H0).\napply Rle_trans with (2 := H0).\napply Rle_trans with (2 := H0).\napply Rle_trans with (2 := H0).\napply Rle_trans with (2 := H1).\napply Rlt_le.\napply H.\napply Rlt_trans with (2 := H0).\napply H.\napply Rlt_le.\napply Rle_trans with (2 := H1).\napply H.\napply Rle_trans with (2 := H1).\napply H.\napply Rlt_le.\napply H.\napply Rlt_le.\napply H.\napply Rlt_le.\napply H.\napply Rlt_le.\napply H.\napply Rlt_le.\napply H.\napply H.\napply H.\napply Rlt_le.\napply H.\napply H.\napply Rlt_le.\napply Rle_trans with (2 := H0).\napply H.\napply H.\napply Rlt_le.\napply H.\napply H.\napply H.\napply Rlt_leQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rle_antisym.\napply Rle_trans with (1:=H).\napply Rlt_le ; assumption.\napply Rlt_le ; assumption.\napply Rle_trans with (1:=H).\napply Rlt_le ; assumption.\napply Rle_trans with (1:=H).\napply Rlt_le ; assumption.\napply Rlt_le ; assumption.\napply Rlt_le ; assumption.\napply Rle_trans with (1:=H).\napply Rlt_le ; assumption.\napply Rle_trans with (1:=H).\napply Rlt_le ; assumption.\napply Rlt_le ; assumption.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nrewrite <- (pow_2_r (x + y)).\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (plus_n_O x y).\nrewrite <- plus_n_O.\nrewrite plus_n_O.\nrewrite <- plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite <- plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_O.\nrewrite plus_n_Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\npattern z at 1 in |- *.\nrewrite <- (Rmult_comm z).\nrewrite Rmult_assoc.\nrewrite Rmult_comm.\nrewrite Rmult_comm.\nrewrite Rmult_comm.\nrewrite Rmult_plus_distr_l.\napply Rmult_le_compat_r.\napply Rmult_lt_compat_r.\napply Rmult_lt_reg_r with (1 := proj2 H1).\napply Rmult_lt_reg_l with (1 := proj2 H1).\napply Rmult_lt_reg_r with (1 := proj1 H1).\napply Rmult_lt_reg_r with (1 := proj1 H1).\napply Rmult_lt_reg_r with (1 := proj2 H1).\napply Rmult_lt_reg_l with (1 := proj2 H1).\napply Rmult_lt_reg_r with (1 := proj2 H1).\napply Rmult_lt_reg_l with (1 := proj1 H1).\napply Rmult_lt_reg_r with (1 := proj1 H1).\napply Rmult_lt_reg_l with (1 := proj1 H1).\napplyQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H.\nomega.\nomega.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrevert H0.\npattern x at 1 in |- *; rewrite <- (Rmult_1_l x).\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\nrewrite Rmult_comm.\nrewrite Rmult_plus_distr_r.\nrewrite <- Rmult_assoc.\nrewrite <- Rmult_assoc.\nrewrite <- Rmult_plus_distr_r.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_1_l.\nrewrite Rmult_1_r.\nrewrite Rmult_1_l.\napply Rmult_lt_compat_l.\nnow apply (Z2R_lt 0 2).\neasy.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H1:=H1).\napply H.\napply Rle_trans with (2:= H0).\napply Rle_trans with (2:= H0).\napply H1.\napply Rle_trans with (2:= H0).\napply H1.\napply Rle_trans with (2:= H0).\napply H1.\napply Rle_trans with (2:= H0).\napply H1.\napply Rle_trans with (2:= H0).\napply H1.\napply Rle_trans with (2:= H1).\napply H1.\napply Rle_trans with (2:= H0).\napply H1.\napply H2.\napply Rle_trans with (2:= H0).\napply H2.\napply Rle_trans with (2:= H0).\napply H2.\napply H1.\napply H1.\napply H2.\napply Rle_trans with (2:= H0).\napply H2.\napply H2.\napply H2.\napply Rle_trans with (2:= H0).\napply H2.\napply H2.\napply Rle_trans withQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 223,
                "proof_start_offset": 611,
                "proof_end_offset": 812,
                "proof": "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_lt_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_le; repeat rewrite N2Nat.inj_mul.\napply Nat.div_le_compat_l; apply le_IZR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_gt; repeat rewrite N2Nat.inj_mul; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq; repeat rewrite N2Nat.inj_mul.\napply le_lteq;Qed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply Plus.mult_le_compat_l; apply le_INR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply Pos2Nat.inj_lt; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply Plus.mult_le_compat_l; apply le_IZR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_le; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 814,
                "proof_end_offset": 1025,
                "proof": "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nle_ge; repeat rewrite N2Nat.inj_mul.\napply Pos2Nat.inj_gt; apply N2Nat.inj_gt; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_ngt; apply le_ngt; apply le_ngt; apply le_ngt; apply le_ngt; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_le_compat_l; apply ge_induct; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_ge; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_le; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_trans with (m := p); auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply N2Nat.inj_lt; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1027,
                "proof_end_offset": 1270,
                "proof": "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_lt_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul; auto.\napply lt_le_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply ge_renamings.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul;\n apply le_lt_trans with (p * n); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply le_IZR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply plus_lt_compat_l; apply N2Nat.inj_lt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul; auto.\napply le_lt_trans with (p * n + p).\napply plus_lt_compat_l; apply le_mult_l; apply le_mult_l; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_lt_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul; auto.\napply le_lt_trans with (p * n).\napply le_lt_trans with (p * m).\napply le_lt_trans with (p * m).\napply plus_lt_compat_l; apply lt_n_Sm; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_lt_trans with (m := p); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1272,
                "proof_end_offset": 1502,
                "proof": "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply le_lt_trans with (m := nat_of_N n); auto.\napply plus_lt_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite <- N2Nat.inj_mul; apply le_plus_lt_compat_l; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul; apply le_alt; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul; apply le_IZR.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul; apply le_IZR; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_eq; repeat rewrite N2Nat.inj_mul; apply le_succ_r; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite <- N2Nat.inj_mul; apply le_rev_l.\napply le_trans with (n * m + p); auto.\napply le_trans with (n * m); auto.\napply le_trans with (n * m); auto.\napply le_trans with (n * m); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul; apply le_lteq; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply lt_le_trans with (m := p); auto with arith.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite <- N2Nat.inj_mul; apply le_IZR; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " p * n > p * m -> n > m.\nintros n m p H1; apply Ngt_gt; apply mult_gt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3553,
                "proof_end_offset": 3760,
                "proof": "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_lt; apply Nlt_gt; apply Nlt_le; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_lt; apply Ngt_lt; apply Ngt_lt; apply Ngt_lt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H H0; apply Nlt_gt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply N2Nat.inj_lt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nlt_gt; apply Ngt_lt; apply Nge_lt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_lt; apply Nlt_gt; apply Nlt_gt; apply Nlt_gt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; apply Ngt_lt; apply Ngt_lt; apply Ngt_lt; apply Nge_lt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nlt_gt; apply Nlt_gt; apply Nlt_gt; apply Nlt_gt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply N2Nat.inj_lt; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nge_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply N2Nat.inj_lt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3762,
                "proof_end_offset": 3929,
                "proof": "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nlt_0_eq; apply lt_0_eq; apply lt_0_eq; apply lt_0_eq; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nlt_0_eq_0; apply Nge_0; apply Nge_0; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite H1 in H1; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H H0; apply Nle_0_eq_0; apply lt_0_eq; apply lt_O_Sn.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; rewrite <- (Ngt_eq n).\nrewrite <- N2Nat.inj_mul; apply N2Nat.inj_eq_0; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nlt_0_eq; apply lt_0_eq; apply lt_O_Sn.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; elim n; auto with arith.\nintros n1 H2; rewrite H2; rewrite H2; auto with arith.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nlt_0_eq; apply lt_0_eq; apply Nlt_0_eq.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; apply Nge_0; rewrite N2Nat.inj_0; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; rewrite <- (Nneq_0 n).\napply Nlt_0_eq_0; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3931,
                "proof_end_offset": 4128,
                "proof": "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nchange (0 >= nat_of_N n)%nat.\napply ge_Nge; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq (nat_of_N n)); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 n); auto.\napply le_INR.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq (nat_of_N n)); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_INR; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (lt_0_eq_0 (nat_of_N n)); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nlt_0_eq; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (lt_0_eq n); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H; rewrite <- (N2Nat.id n); apply lt_0_eq.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply (N2Nat.id n); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " simplify x * y? x * z where? is < > <= >= *)\n\nTheorem Rmult_le_compat_l:\n  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.\nauto with real.\nQed.\n\nTheorem Rmult_le_neg_compat_l:\n  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30052,
                "proof_end_offset": 30304,
                "proof": "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H0; replace (p * n)%R with ((-p * n) * m)%R;\n [ idtac | ring ]; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H0; replace (p * n) with ((-p * n))%R; auto with real; try ring.\nrewrite Rmult_assoc; rewrite Rinv_r; auto.\napply Rmult_le_compat_l; auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H0; replace (p * n) with ((n + p)%R); auto with real.\nrewrite Rmult_comm; auto.\nrewrite Rmult_1_l; auto.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; rewrite Rmult_comm; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; apply Rmult_lt_reg_l with (n := m); auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H0; replace (p * n)%R with ((p * n)%R); auto with real.\napply Rmult_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rmult_le_compat_l.\napply Rle_0_minus.\napply H.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * m + p)%R); auto with real; try ring.\nreplace (p * n)%R with ((p * m + p)%R); auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * n)%R); auto with real; try ring.\nreplace (p * n)%R with ((p * n)%R); auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H' H'0 H'1 H'2; replace (p * n)%R with ((p * n) * (n + m)).\n2: replace (p * n)%R with ((p * n) * (m + p))%R; auto with real; try ring.\n2: replace (p * n)%R with ((p * n) * (m + p))%R; auto with real; try ring.\n2: replace (p * n)%R with ((p * m + p)%R); auto with real.\n2: apply Rmult_le_compat_l; auto with real.\nreplace (p * n)%R with ((p * m + p)%R); auto with real; try ring.\n2: apply Rmult_le_compat_l; auto with real.\n2: apply Rlt_le; auto with real.\n2: apply Rmult_le_compat_l; auto with real.\nreplace (p * n)%R with ((p * n)%R); auto with real; try ring.\n2: replace (p * n)%R with ((p * n)%R); auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H0; replace (p * n)%R with ((p * m + p)%R); auto with real; try ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30306,
                "proof_end_offset": 30566,
                "proof": "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H0; case (Rle_or_lt n m); intros H1.\nabsurd (p * n <= m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_0_compat; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto.\nrewrite Rmult_0_l; auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H0; case (Rle_or_lt n m); intros H1.\nabsurd (p * n <= m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p := n); auto.\napply Rmult_le_reg_l with (p := n); auto.\napply Rmult_le_reg_l with (p := n); auto.\napply Rlt_dichotomy_converse; try red; intros; subst; red in |- *; apply Rlt_le; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt 0 n); intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; auto.\napply Rmult_le_pos_l; auto.\napply Rinv_0_lt_compat; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H0; case (Rle_or_lt 0 m); intros H1.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto.\nrewrite Rmult_0_r; auto with real.\napply Rlt_not_le; apply Rlt_trans with (1 := H1).\nrewrite Rmult_0_r; auto with real.\nrewrite Rmult_0_l; auto with real.\napply Rle_refl.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; replace (p * n) with ((p * n) + p * m)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); intros H2.\nabsurd (p * m <= n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r := m); auto.\napply Rlt_dichotomy_converse; apply Rlt_dichotomy_converse; apply Rlt_dichotomy_converse;\n auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H0 H1; case H; intros H2.\nabsurd (p * m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_lt; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); intros H3.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nreplace (p * n + p)%R with ((p * n) * m)%R; auto with real.\napply Rmult_lt_compat_l; auto.\nrewrite Rinv_l; auto with real.\napply Rle_trans with (1 := H2).\napply Rmult_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": ", (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30568,
                "proof_end_offset": 30827,
                "proof": "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p := p); auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H0; case (Rle_or_lt n m); auto; intros H1.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_lt; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H0 H1 H2; apply Rmult_lt_reg_l with (p := m); auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m p); auto; intros H2.\nabsurd (p * m <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\napply Rinv_0_lt_compat; auto.\napply Rinv_0_lt_compat; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); intros H2.\nabsurd (p * n <= p)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\napply Rinv_0_lt_compat; auto with real.\napply Rinv_0_lt_compat; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); intros H3.\nContradict H2; rewrite Rmult_0_r; auto with real.\nrewrite Rmult_minus_distr_l_reverse; auto.\napply Rmult_lt_reg_l with (r := (- p)%R); auto with real.\napply Rmult_lt_reg_l with (r := (- p)%R); auto with real.\nrewrite Rmult_minus_distr_l_reverse; auto.\napply Rmult_lt_reg_l with (r := (- p)%R); auto with real.\napply Rmult_lt_reg_l with (r := (- p)%R); auto with real.\napply Rmult_lt_reg_l with (r := (- p)%R); auto with real.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nrewrite Rmult_comm; rewrite Rinv_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H0 H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * m <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H0; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\napply Rlt_le; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * m <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30829,
                "proof_end_offset": 31096,
                "proof": "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0; case (Rle_or_lt m n); intros H1.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0; case (Zle_or_lt m n); auto; intros H1.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_lt; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_pos_compat; auto with real.\napply Rinv_0_lt_compat; apply Rinv_0_lt_compat; apply Rlt_0_1.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0; case (Rle_or_lt m n); intros H1.\nabsurd (p * m <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto with real.\nrewrite Rmult_minus_distr_l; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); intros H2.\nabsurd (p * n < m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_r; auto.\napply Rlt_not_le; apply Rinv_0_lt_compat; auto.\napply Rinv_0_lt_compat; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0; case (Rle_or_lt m n); intros H1.\nContradict H1; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0 H1; case (Rle_or_lt m n); intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rle_trans with (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Zle_or_lt m n); intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r := p); auto with real.\napply Rmult_lt_reg_l with (r := p); auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0; case (Rle_or_lt n m); intros H1.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_lt; auto.\napply Rinv_0_lt_compat; auto with real; rewrite Rmult_comm; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H0; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * m <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31098,
                "proof_end_offset": 31286,
                "proof": "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H0; case (Rle_or_lt m p); intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nContradict H2; rewrite H2; auto with real.\nintros n0 H H1; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt p m); intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\napply Rlt_not_le; apply Rmult_lt_pos_pos; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_gt_pos_lt; auto.\napply Rmult_lt_pos_pos; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); intros H3.\nabsurd (p * n < m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_pos; auto.\nrewrite Rmult_comm; rewrite <- Rinv_r_sym; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rlt_le; apply Rmult_lt_pos_compat; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H0; case (Zle_or_lt n m); intros H1.\nabsurd (p * n > p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_pos_pos; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); intros H3.\nContradict H2; rewrite <- H3; apply Rmult_lt_compat_l; auto.\napply Rmult_lt_reg_l with (p := m).\napply Rmult_lt_reg_l with (p := m).\napply Rmult_lt_reg_l with (p := m).\napply Rmult_lt_reg_l with (p := p).\napply Rmult_lt_reg_l with (p := m).\napply Rmult_lt_reg_l with (p := m).\napply Rmult_lt_reg_l with (p := p).\napply Rmult_lt_reg_l with (p := m).\napply Rmult_lt_reg_l with (p := p).\napply Rmult_lt_reg_l with (p := p).\nrewrite <- Rinv_r; auto.\napply Rlt_dichotomy_converse; right; red; intros; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H0; case (Rle_or_lt m p); auto; intros H1.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H0; case (Rle_or_lt n m); intros H1.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_pos_pos; auto.\nrewrite <- Rinv_r; auto with real.\nrewrite Rmult_1_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31288,
                "proof_end_offset": 31484,
                "proof": "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_pos_r; auto with real;\n apply Rmult_le_pos_l; auto with real;\n apply (Rmult_le_pos_l (p * n) (p * m)); auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H0; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_lt; auto with real.\napply Rlt_dichotomy_converse; apply Rmult_lt_pos_lt; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt 0 n); intros H2.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_lt; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H0; case (Req_dec p 0); intros.\nleft; split; auto.\nright; split; auto.\nright; split; auto.\nright; split; auto.\nright; split; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rlt_le; apply Rmult_ge_pos; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; apply Rlt_le; apply Rmult_le_pos_le;\n auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rle_trans with (1 := H2); auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; rewrite Rmult_comm; auto.\napply Rmult_ge_pos; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1 H2; rewrite H1; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31486,
                "proof_end_offset": 31663,
                "proof": "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rmult_ge_compat_l_rev n m p); auto; intros H2.\nabsurd (p * m < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_reg_l with (r := (- p)%R); auto with real.\napply Rmult_ge_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2;\n apply Rle_ge; apply Rmult_le_pos_compat; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H0; rewrite Rmult_comm; rewrite Rinv_r; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1;\n apply Rmult_lt_reg_l with n; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; case (Rle_or_lt 0 n); intros H3.\nContradict H3; rewrite H3; auto.\nrewrite Rmult_comm; rewrite Rmult_assoc; rewrite Rinv_l; auto with real.\nreplace (p * n + (m + p))%R with (p * m + p)%R; auto; apply Rmult_lt_compat_l; auto with real.\napply Rmult_le_pos_compat; auto with real.\nrewrite Rmult_comm; rewrite Rinv_l; auto with real.\nreplace (p * n + (m + p))%R with ((p * m + p)%R); auto; apply Rmult_lt_compat_l; auto with real.\nrewrite Rmult_comm; rewrite Rinv_l; auto with real.\nreplace (p * n + (m + p))%R with ((p * n + (m + p))%R; auto; apply Rmult_lt_compat_l; auto with real.\nrewrite Rmult_comm; rewrite Rmult_assoc; rewrite Rinv_l; auto with real.\nrewrite Rmult_comm; rewrite Rmult_assoc; rewrite Rinv_l; auto with real.Qed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; rewrite H1; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2; rewrite <- (Rmult_comm (INR n));\n rewrite (Rmult_comm (INR n)); rewrite (Rmult_comm (INR n));\n rewrite (Rmult_comm (INR n));\n rewrite (Rmult_comm (INR n)); auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1 H2;\n apply Rle_ge; apply Rmult_le_pos_compat; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31665,
                "proof_end_offset": 31850,
                "proof": "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2;\n apply Rle_ge; apply Rmult_le_pos_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2;\n apply Rle_ge; apply Rmult_le_pos_l_rev with n; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H0; apply Rlt_le; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2; apply Rmult_lt_reg_l with (p := n); auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H0; rewrite H; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1; rewrite <- H1; rewrite Rmult_0_r;\n auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rlt_not_le; apply Rmult_lt_pos_compat_l_rev with p; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2; case (Rmult_lt_0_compat_l p n m); auto; intros H3.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_gt_0_compat; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1 H2; rewrite H1; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 31871,
                "proof_end_offset": 31978,
                "proof": "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1;\n apply Rlt_not_le; apply Rmult_lt_reg_l with z; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1;\n apply Rlt_trans with (y := z); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case H1; intros H3.\nabsurd (y < x); auto with real.\napply Rle_not_lt; apply Rlt_trans with (y := z); auto with real.\napply Rlt_trans with (y := z); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2;\n apply Rlt_trans with (y := z); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0;\n case (Rle_or_lt x y); intros H2.\napply Rlt_le_trans with (y := x); auto with real.\napply Rle_trans with (y := x); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; rewrite H0; rewrite H0; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; rewrite H1; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case (Rlt_not_le y x); auto; intros H2.\nabsurd (y < z); auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (r := y); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case (Rle_or_lt x y); intros H2.\nabsurd (y = z); auto with real.\napply Rlt_not_le; apply Rlt_trans with (y := z); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 31979,
                "proof_end_offset": 32086,
                "proof": "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0 H1; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H1 H2; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0; rewrite H0; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H1 H2; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H0; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32087,
                "proof_end_offset": 32194,
                "proof": "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H0; rewrite H0; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H1; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H1 H2; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H1 H2; rewrite H2; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H1 H2; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32195,
                "proof_end_offset": 32302,
                "proof": "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H0; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H1 H2; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H1 H2; rewrite H2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32303,
                "proof_end_offset": 32412,
                "proof": "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " a Z *)\nLtac RCst t :=\n  match t with\n   | R0 => constr:(Z0)\n   | R1 => constr:(Zpos xH)\n   | Rplus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4809,
                "proof_end_offset": 4938,
                "proof": "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (a := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_eq_compat_l; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply plus_eq_compat_l; auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (a := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply (plus_O_l a b c); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (a := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (a := plus); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4940,
                "proof_end_offset": 5073,
                "proof": "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply le_S; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; case H.\napply plus_reg_l with m; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply le_trans with (m := S n); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_lt_compat_l; auto with *.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply le_plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p; case (plus_comm p n); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply le_plus_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5075,
                "proof_end_offset": 5184,
                "proof": "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b c H H1; case H; subst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with (n := m); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5186,
                "proof_end_offset": 5320,
                "proof": "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H1; case H; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; unfold ge; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1 H2; case H; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; case H; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H0 H1; case H; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H0; case H; subst; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H H0; rewrite plus_comm; apply plus_lt_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H1; case H; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\nTheorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.\n\n(* For replace *)\n",
                "context_tokens": 736,
                "proof_start_offset": 5340,
                "proof_end_offset": 5446,
                "proof": "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; rewrite H; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case H; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case H2; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case (le_lt_eq_dec x y); intros H3.\napply plus_lt_reg_l with y; auto.\nreplace y with (y + z); auto.\napply plus_lt_reg_l with (m := m); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; subst; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z; case z; intros z1 z2 z3; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite <- (plus_n_O x y H); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H0; unfold eq; apply le_trans with (y := x); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z; pattern z at 1; rewrite <- (plus_n_O p); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (y := x); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 485,
                "proof_start_offset": 1028,
                "proof_end_offset": 1154,
                "proof": "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nam 13 (a + c) c (a + c) H H0.\nam 13 (a + c) c (a + b) c (a + c) H H0.\nam 13 (a + b) c (a + c) H H1.\nam 13 (a + b) c (a + c) H H1.\n12 13 (a + b) c (a + c) H H2.\n12 13 (a + c) c (a + c) H H3.\n12 13 (a + b) c (a + c) H H3.\n12 13 (a + c) H4.\n12 13 (a + b) c (a + c) H H3.\n12 13 (a + c) H H5.\n12 15 (a + c) H0.\n12 15 (a + c) H4.\n12 15 (a + c) H4.\n12 13 (a + c) H4.\n12 15 (a + c) H4.\n12 13 (a + c) H4.\n12 13 (a + c) H4.\n12 13Qed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\namababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababccabababababababababababababababababccababababababababababababababccababababababababababababccababccababababababababababababababababababababababababababababababccccabcdabababccaaababababababababddababababababccabccabababababababababababababfbaaababccababababddababababccababcabababababababQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nammonicr (a + c) c b c d H.\nammonicr (a + b) c b c d H.\nammonicr (a + c) c b c d H.\nammonicr (a + b) c (a + c + b) c (a + b) c (a + b) c (a + b) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + cQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nam 13 (a + b) c d H0.\namay H0.\namab H0.\namab H0.\namab H0.\n12: (a + b - c >= 0) by omega.\n2: omega.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\namva_a_b_c_c.\nrewrite H; auto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nam 13 (a + c) c (a + b) c (a + b) c (a + b) c (a + b) c (a + b) c (a + c) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + cQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\namc (a + b) c (a + b) c (a + c) c (a + c) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + cQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nca Zmult_gt_0_iff.\nunfold Rdiv in |- *.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\namab_correct.\nauto.\namab_correct.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\namr (a + b) c (b + c) (c + d) (d + d).\nams.\nauto.\npattern a at 1, b at 2, c at 1, b at 2, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1, c at 1,Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 552,
                "proof_start_offset": 1156,
                "proof_end_offset": 1273,
                "proof": "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\namals (a + b) c (b + c) (c + d) H H0.\nfcr (a + b) c (c + d) H H0.\nam top.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\naf Names (a + b * c) c a b c d H0.\nafrm.\nauto.\nafrm.\nauto.\npattern a at 2 in |- *.\nauto.\npattern b at 2 in |- *.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nammonicr (a + c) c d H H0.\namrings.\nauto.\nuprm.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\namals.\nassumption.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nambda theta (a + c) c c d H.\nambda theta (a + b + c) c d H.\nambda theta (a + b + c) c (a + b + c).\n12 coredd theta (a + b + c) c (a + b + c) c (a + c) c (a + b + c).\n12 coredd lambda (a + b + c) c (a + b + c) c (a + c) c (a + c).\n12 coredd theta (a + b + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) cQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nambdac (a + b) c (a + c) H0.\nambdac (a + c) c (a + b) H0.\nambdac (a + b) c (a + c) H0.\nambdac (a + b) c (a + b) c (a + c) H0.\namQhomographice.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nam reifyc (a + b) c c (a + c) c (a + c) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (aQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nlam Zmult_gt_0_compat.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\namals (a + c < 0) P.R P.R 2%Z.\namals (a + c < 0) P.R P.R 2%Z.\namals (a + c < 0) P.R P.R 2%Z.\namals (a + c <= a + b + c > c + b + c)%nat.\n12 reify (a + c <= c + b + c <= c + b * c)%nat.\n12 reify (a + c < a + b * c)%nat.\n12final (a + c < a + b * c)%nat.\n12factor (a + c + b * c + b * c + b * c + b * c + b * c + b * c + b * c + d)%nat.\n12factor (a + c + b * c + b * c + b * c + b * c + b * c + b * c + b * c + b * c + b * c + b * c + d)%nat.\n12factor (a + b * c + b * c + b * c + b * c + b * cQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\namrops (a + b) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 611,
                "proof_start_offset": 1275,
                "proof_end_offset": 1401,
                "proof": "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\namr (a + b) c d H H0.\namr (a + b) c (a + b) c (a + b) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (aQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\naf + (a + c) >= d.\npattern a at 1 in |- *.\npattern a at 1 in |- *.\npattern a at 1 in |- *.\npattern a at 1 in |- *.\npattern b at 1 in |- *.\npattern a at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 2 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npattern b at 1 in |- *.\npatternQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nam bot.\nauto.\nam bot.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nammonicr (a * b + c >= 0).\namfactor.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\namabc (a + c >= 0) P.R P.R 0%Z.\namab.\nauto.\namab.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\namabababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababccabababababababababababababababccabababccababababababababababccababababccababccababccabababababababababababccababababccabababababababababababababababababababababababababababababababababababccababababababababababababababababababababababababababababcabccabababababccabababababccabdcccaababababababababababaabbacdababfbababababababababababababccababccabccabababccabddabccababQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\namc (a + b) c (a + b) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + cQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nam >= 0.\n omega.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nam >= a.\nam >= a.\nam >= a.\nam >= a.\nam >= b.\nam >= a.\nam >= c.\nab >= b.\nab < b.\nab < a.\nab < c.\nab < a.\nab < b.\nab < a.\nab < b.\nab < a.\nab < b.\nab < c.\nab < b.\nab < c.\nab < a.\nab < b.\nab < c.\nab < b.\nab < a.\nab < b.\nab < b.\nab < b.\nab < b.\nab < b.\nab < c.\nab < a.\nab < b.\nab < c.\nab < b.\nab < b.\nab < b.\nab < c.\nab < b.\nab < c.\nab < b.\nab < b.\nab < c.\nab < b.\nab < c.\nab < b.\nab < b.\nab < c.\nab < a.\nab < c.\nab <Qed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\naf'') (b + c < b + c).\nam'') (b + c < c + b + c).\nam') (b + c < b + c).\nam') (b + c <= c).\nam') (b + c <= c + b + c).\nam') (b + c <= c + b + c).\nam') (b + c <= b + c).\nam') (b + c <= b + c).\nam') (b + c <= c).\nam') (b + c < b + c + b + c <= b + c + b * c).\n12') (b + c <= b + c + b * c).\n12') (b + c <= b + c + b * c + b * c).\n12') (b + c) (b + c + b + c) (b + c + b * c).\n12') (b + c + b + c + b * c) (b + c) (c + b + c + b * c).\n12') (b + c + b * c + b * c + b * c + b * c + dQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 1463,
                "proof_end_offset": 1579,
                "proof": "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namr (a * b) c d H.\namr (a * b) c d H.\namr (a * b) c d H.\nams (a * b) c (a * b) c (a * b) c (a * b) c (a * b) c (a * c) c (a * c) (a * c).\nams.\nauto.\nams.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namabababababababababababababababababababababababababababababababababababccababababababababababababababccabababababababccabababababababababccabababababababababccccababababababccccccababccababccccabababccabddabababccddababababccccabccababccccccabccababccabababababccccabcdccababccccabccccabfbabccccabafbabccddabccabccccccababccababccabababcccccabbabddabccababccccababccccbdccabdc0dbdccddccabccfbabccababccccccabccbaabccccccdda5ccccccceabdccabe8dabcccccdab2ccddfbabe8e2abccabaabaccda5Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros a b c d H.\namr (a * b + c) (a * b + c) H.\namr (a * b + c + b) c (a * b + c).\namr (a * b + c) (a * b + c).\nams.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namepass.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namabare_aux.\nauto.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namr (a + b) c (a + b) c (a + c) H.\namr (a + b) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + b) c (a + b) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\nams (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\namr (a + c) c (a + c) H.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namc (a + b) c d H H0.\ngf_eq.\nrewrite H.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\n func_eq with (f:=f) (g:=f) (g:=f) (g:=f) (g:=f) (g:=f) (g:=g) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h:=h) (h':=h) (h:=h) (h:=h) (h:=h) (h':=h) (h:=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=h) (h':=Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + b) c (a + b) c (a + c) H0.\npolr (a + b) c (a + c) H0.\namr (a + b) c (a + b) c (a + c) H0.\n12 H0.\n12 H0.\n12 H0.\n12 H0.\n12 H1.\n12 H1.\n12 H2.\n\n(* Test of the goal *)\nGoal forall a b c d, a + b + c = d -> a + b * c = d.\nintros.\npattern a at 1 in |- *.\nrewrite H0.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\namc.\nrewrite H0.\nrewrite H1.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Open Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\nGoal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 1581,
                "proof_end_offset": 1693,
                "proof": "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\npolr (d = 0).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\namc (a + c) = (a + b).\namc (a + b) = (a + b).\namc (a + b) = (a + b).\namc (a + c) = (a + b).\namc (a + b) = (a + b).\namc (a + c) = (a + b).\namc (a + b) = (a + b).\namc (a + c) = (a + b).\namc (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nambdas.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nfec (a + b) = (a + b + c).\nffc (a + b) = (a + b + c).\nffc (a + b) = (a + b + c).\nffc (a + b) = (a + b).\nffc (a + b) = (a + b + c).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + bQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\namr (a + b) c (a + b) c (a + c) H H0.\nams.\nauto.\npattern a at 1 in |- *; elim H0; intros; discriminate H0.\npattern b at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 2 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 2 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 in |- *; elim H0; intros; discriminate H1.\npattern c at 1 inQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\namabababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababccabababababababccababababababccababccababccabababababccccababababababccabccababccccabababccababababccababccabccccababababababababababccabababababababccabababccabccababccabccabababababababababccabcabababababababababababccababababababababababababababababababcabababababababababababababababccababababababababababababababababccababccccabddababccababababababccccabccabababababccababQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\namc (a + b) = (a + b + c).\namc (a + c = 0).\namc (a + b) = (a + b).\namc (a + c = 0).\namc (a + c) = (a + b).\namc (a + b) = (a + b).\namc (a + b) = (a + b).\namc (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + b) = (a + b).\n12c (a + bQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nafr (a + b) c (a + b) c (a + b) c (a + b) c (a + c) H0.\nafr (a + b) c (a + b) c (a + b) c (a + c) c (a + b) c (a + c) c (a + c) c (a + b) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c) c (a + c)Qed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nlines_eq a b c d.\napply sym_equal.\napply (A:=Y).\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\namab (a + c = d).\namab (a + b).\namab (a + b).\n12ab (a + b).\n12ab (a + c = d).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + c = b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab(a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + b).\n12ab (a + bQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nafr (a + b) c d H H0.\npattern a at 1 in |- *.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 293,
                "proof_start_offset": 635,
                "proof_end_offset": 724,
                "proof": "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern x at 1Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 2.\npattern y at 2.\npattern y at 2.\npattern y at 1.\npattern y at 1 3.\npattern y at 1 3.\npattern y at 2 3.\npattern y at 2.\npattern y at 2 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; replace y with (x + y).\npattern y at 2; rewrite <- Rplus_comm.\npattern y at 2; rewrite <- Rplus_assoc.\npattern y at 2; replace y with (x + y).\npattern y at 2; rewrite <- Rplus_assoc.\npattern y at 2; rewrite <- Rplus_opp_l.\npattern y at 2; rewrite <- Rplus_commQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 1; replace y with ((x + y) * (x + y)).\nrewrite Rplus_0_l.\nring.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern y at 2; replace y with (3 * y); auto with real.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\nnow apply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\nnow apply Rmult_lt_0_compat.\nnow apply Rmult_lt_0_compat.\nnow apply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 336,
                "proof_start_offset": 726,
                "proof_end_offset": 820,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern x at 1 ; rewrite <- Rplus_0_l.\napply Rplus_lt_compat_r.\napply Rplus_lt_compat_l.\napply Rlt_le_trans with (2 := H).\napply Rplus_lt_compat_l.\napply Rle_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rle_trans with (1 := H).\napply Rplus_le_compat_l.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern y at 1, x at 1, x, y at 1, x, y at 1, x, y at 1, x0, y at 1, x0, y at 1,  y at 1,  y at 1,  z at 1,  z at 1,  y,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at 1,  z at level 0,  z at level 0,  z at level 0,  z at level 0,  z at level 0,  z atQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2; pattern y at 2; rewrite <- Rplus_0_r.\npattern y at 2; rewrite <- Rplus_0_r.\npattern y at 2; replace y with (x + y + x * y).\nrewrite Rplus_0_l.\npattern y at 2; rewrite Rplus_0_r.\npattern y at 2; rewrite <- Rplus_0_r.\npattern y at 2; rewrite <- Rplus_0_r.\npattern y at 2; rewrite Rplus_0_r.\npattern y at 2; rewrite <- Rplus_0_r.\npattern y at 1; rewrite <- Rplus_0_r.\npattern y at 2; rewrite <- Rplus_0_r.\npattern y at 2; rewrite <- Rplus_0_r.\npattern y at 1; rewrite <- Rplus_0_r.\npattern y at 2; rewrite Rplus_0Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern x at 2 ; rewrite <- (Rmult_1_l x).\npattern y at 2; rewrite <- (Rmult_1_l y).\npattern y at 2; rewrite <- (Rmult_1_l y).\npattern y at 1; rewrite <- (Rmult_1_l y).\npattern y at 1; rewrite <- (Rmult_1_r y).\npattern y at 2; rewrite <- (Rmult_1_l (x * y)).\npattern y at 1; rewrite <- (Rmult_comm y).\npattern y at 1; rewrite <- (Rmult_1_r (x * y)).\npattern y at 1; rewrite <- (Rmult_1_l y).\npattern y at 2; rewrite <- (Rmult_comm y).\npattern y at 2; rewrite <- (Rmult_1_l (x * y)).\npattern y at 1; rewrite <- (Rmult_comm y).\npattern y at 2; rewrite <- (Rmult_1_l (x * y)).\npattern y at 2; rewrite <- (Rmult_comm y).\npattern y at 2; rewrite <- (Rmult_comm x).\npattern y at 1; rewrite <- (Rmult_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nams.\nreplace (2 * y) with (2 * x).\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rle_0_sqr.\napply Rmult_le_compat_l.\napply H.\napply Rlt_le_trans with (2 * y)%R.\napply Rmult_le_compat_r.\napply H.\napply Rlt_le.\napply H.\napply Rle_trans with (1 := H0).\napply Rmult_le_compat_r.\napply H.\napply Rlt_le.\napply H.\napply Rle_trans with (1 := H1).\napply H.\napply Rmult_le_compat_r.\napply H.\napply Rle_trans with (2 := H1).\napply Rmult_le_compat_r.\napply H.\napply H.\napply Rle_trans with (1 := H1).\napply Rmult_le_compat_r.\napply H.\napply Rlt_le.\napply H.\napply Rle_trans with (1 := H1).\napply Rmult_le_compat_r.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern y at 2; rewrite <- (Rmult_1_l (y * y)).\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\napply Rmult_lt_0_compat.\nnow apply Rmult_lt_0_compat.\nnow apply Rinv_0_lt_compat.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, (0 < x -> x  <= x  * y -> 1 <= y)%R.\nintros.\nhyp_polf H0.\nQed.\n\n",
                "context_tokens": 382,
                "proof_start_offset": 822,
                "proof_end_offset": 950,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct (Rle_lt_dec (x + z) (y + z) (y + z)) as [H'|H']; [|left].\napply Rle_lt_trans with (1:=H').\napply Rle_trans with (2:=H).\napply Rle_trans with (2:=H').\napply Rle_trans with (2:=H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:=H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:=H').\napply Rle_trans with (2:=H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:=H').\napply Rle_trans with (2:=H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:= H').\napply Rle_trans with (1:= H').\napply Rle_trans with (1:= H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:= H').\napply Rle_trans with (2:= HQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 1 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 1Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rle_trans with (1:=H0).\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H.\napply Rle_lt_trans with (2 := H).\napply Rle_lt_trans with (2 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (1 := H).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (1 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (2 := H0).\napply H.\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (1 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (2 := H0).\napply Rlt_le_trans with (1 := H0).\napply Rlt_le_trans with (1 := H0).\napply H.\napply Rlt_leQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nunfold Rle.\nrewrite Rplus_0_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct (le_lt_dec x y).\napply Rle_lt_trans with (2 := Hxy).\napply Rle_lt_trans with (2 := Hxy).\napply Rle_lt_trans with (1 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (1 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (1 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (1 := Hxy).\napply Rle_trans with (1 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (1 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (1 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_transQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nsetoid_replace ((x + y) * (y + 1)) with ((x + y) * (y + 1)).\nrewrite Rmult_1_l.\nring.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\npattern z at 1 in |- *.\nrewrite Rplus_0_l.\napply Rplus_le_compat_l.\nnow apply Rle_0_minus.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rplus_le_compat_l.\nnow apply Rle_0_minus.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\napply Rplus_le_compat_l.\nnow apply Rlt_le.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nrewrite <- (Rmult_0_l x).\nrewrite Rmult_0_l.\napply Rmult_le_compat_r.\napply pow_le.\napply Rlt_le.\napply pow_le.\napply Rmult_lt_0_compat.\napply Rlt_le_trans with (2 := proj1 H).\napply Rmult_lt_reg_l with (2 := proj2 H).\nnow apply pow_le.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct (Rle_lt_dec x y).\napply Rle_lt_trans with (2 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (2 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (2 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := H).\napply Rplus_le_compat_l.\napply Rlt_le_trans with (1 := HQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": " (-0)%R; auto with real.\nQed.\n\nTheorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.\nintros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring.\napply Rmult_lt_0_compat; auto with real.\nQed.\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3923,
                "proof_end_offset": 4160,
                "proof": "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y; case (Rle_dec x y) as [H|H].\nrewrite H; auto with real.\napply Rlt_le_trans with (y - x)%R.\napply H.\napply Rlt_le_trans with (y - x)%R.\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply Rle_ge; apply Rlt_le_trans with (1 := H).\napply H.\napply Rlt_le_trans with (1 := H).\napply H.\napply H.\napply Rlt_le_trans with (1 := HQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rlt_le_trans with (y * x)%R; auto.\napply Rlt_le_trans with (y * x)%R; auto.\napply Rlt_le_trans with (y * x)%R; auto.\napply Rlt_trans with (y * x)%R; auto.\napply H2; auto.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H H0; replace (x * y) with (0 + - x * y)%R; auto with real.\nrewrite H0; ring.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y; case (Rle_dec x y); intros H1.\ncase (Rle_dec x y); intros H2.\napply Rlt_le_trans with (y - x); auto with real.\napply Rplus_lt_reg_l with x; auto with real.\napply Rlt_le_trans with (y - x); auto with real.\napply Rplus_lt_reg_l with y; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y; case (Rle_dec x y); intros Rle0_lt0_1; auto.\napply Rle_lt_trans with (y - x)%R.\napply Rle_trans with (2 := H1).\napply Rplus_le_compat_l.\napply H.\napply Rle_lt_trans with (2 := H1).\napply Rplus_le_compat_l.\napply H.\napply Rle_lt_trans with (2 := H2).\napply Rplus_le_compat_l.\napply H.\napply Rle_ge; auto.\napply Rle_ge; auto.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rle_antisym; apply Rlt_zero_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y Hx Hy; apply Rle_antisym; apply Rle_antisym; apply Rle_refl.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rlt_zero_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rlt_le_trans with (1 := H2); auto with real.\napply Rlt_le_trans with (2 := H1); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y Hx Hy.\napply Rle_lt_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rlt_le_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rlt_le_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply Rle_trans with (2 := Hxy).\napply RRle_abs.\nnow apply Rlt_le_trans with (1 := Hxy).\nnow apply Rlt_le_trans with (1 := Hxy).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": ".\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4162,
                "proof_end_offset": 4401,
                "proof": "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3.\napply Rlt_not_le; apply Rlt_le_trans with (1 := H2).\napply Rle_trans with (1 := H3).\napply Rle_lt_trans with (1 := H2).\napply Rmult_lt_reg_l with (1 := H2).\napply H3.\napply Rmult_lt_reg_l with (1 := H1).\napply H3.\napply Rmult_lt_reg_l with (1 := H2).\napply H3.\napply Rmult_lt_reg_l with (1 := H1).\napply H3.\napply Rlt_le_trans with (1 := H3).\napply Rmult_lt_reg_l with (1 := H2).\napply H1.\napply Rmult_lt_reg_l with (1 := H2).\napply H3.\napply Rmult_lt_reg_l with (1 := H1).\napply H3.\napply Rlt_le_trans with (1 := H3).\napply Rmult_lt_reg_l with (Qed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3.\napply Rlt_le_trans with (1 := H3); auto with real.\napply Rlt_le_trans with (1 := H4); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y); auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\napply Rlt_le_trans with (1 := H2); auto with real.\napply Rle_trans with (1 := H2); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y); auto with real.\napply Rlt_not_le; apply Rlt_minus; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_0_1; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3; auto with real.\napply Rlt_not_le; apply Rlt_0_1.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply Rlt_le_trans with (y * x)%R; auto with real.\napply H3; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_strict_strict_strict; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_le_trans with (1 := H1); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3; auto with real.\nintros H3; absurd (0 < y)%R; auto with real.\napply Rlt_not_le; apply Rlt_minus_pos_pos; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4403,
                "proof_end_offset": 4640,
                "proof": "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_pos; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_0_1.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3.\nleft; auto with real.\nright; auto with real.\nright; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_pos; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y); auto with real.\napply Rlt_not_le; apply Rlt_minus; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y); auto with real.\napply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y <= 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_0_1.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3.\nrewrite H3; auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_0_1.\napply Rlt_le_trans with (1 := H2); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\nTheorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4642,
                "proof_end_offset": 4880,
                "proof": "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H H0; case (Rle_or_lt 0 y); intros H1.\ncase (Rle_or_lt y 0); intros H3.\nrewrite H2; rewrite H3; auto with real.\nintros H3; absurd (y = 0); auto with real.\napply Rlt_not_le; apply Rlt_0_1.\nrewrite H3; rewrite H3; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3.\nrewrite H3; auto with real.\nrewrite H4; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y)%R; auto with real.\napply Rle_ge; apply Rlt_0_1.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H3.\nrewrite <- (Ropp_involutive x); auto with real.\nrewrite <- (Ropp_involutive y); auto with real.\nrewrite <- (Ropp_involutive y); auto with real.\nrewrite <- (Ropp_involutive x); auto with real.\nrewrite <- (Ropp_involutive x); auto with real.\nrewrite <- (Ropp_involutive y); auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rle_lt_trans with (1 := H1).\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H1).\napply RRle_abs.\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H3).\napply RRle_abs.\napply Rle_trans with (1 := H1).\napply RRle_abs.\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H2).\napply RRle_abs.\napply Rle_trans with (1 := H1).\napply RRle_abs.\napply Rle_Qed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); intros H1.\nabsurd (0 <= y)%R; auto with real.\napply Rlt_not_le; apply Rlt_0_1.\nrewrite H1; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y)%R; auto with real.\napply Rle_ge; apply Rle_trans with x; auto with real.\napply H3; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Zex.v",
                "context": "Require Import ZArith.\nRequire Import PolTac.\n\nOpen Scope Z_scope.\n\nTheorem pols_test1: forall (x y : Z), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : Z), y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : Z), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with zarith.\nQed.\n \nTheorem pols_test4:\n forall (x y : Z),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <= x  * y)%Z.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 326,
                "proof_start_offset": 711,
                "proof_end_offset": 805,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 1, y in |- *.\npattern x at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1 in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1 in |- *.\npattern y at 2, y in |- *.\npattern y at 2 in |- *.\npattern y at 1, y, y in |- *.\npattern y at 1, y in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1, y in |- *.\npattern y at 2, y in |- *.\npattern yQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2.\npattern y at 2; replace y with (x + y)%nat.\napply Rmult_le_compat_r.\napply H.\napply Rmult_le_compat_r.\napply H.\napply Rmult_le_compat_l.\napply H.\napply H.\napply Rmult_le_compat_r.\napply H.\napply H.\napply Rmult_le_compat_r.\napply H.\napply H.\napply Rmult_le_compat_l.\napply H.\napply H.\napply Rmult_le_compat_l.\napply H.\napply H.\napply H.\napply Rmult_le_compat_l.\napply H.\napply H.\napply H.\napply H.\napply Rmult_le_compat_r.\napply H.\napply H.\napply H.\napply H.\napply Rmult_le_compat_l.\napply H.\napply H.\napply H.\napply H.\napply Rmult_le_compat_l.\napply HQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 1 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern x at 2Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *.\npattern y at 2 in |- *.\npattern z at 2 in |- *.\npattern z at 2 in |- *; rewrite <- (Z_div_mod_eq (x + y) x).\napply H.\napply H0.\napply H0.\napply H0.\napply H1.\napply H2.\napply H1.\napplyQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 1 ; replace y with (2 * (x - y)).\n2: apply Rmult_1_r.\nreplace 1 with (2 * (x - y)).\n2: apply Rmult_1_r.\nreplace 1 with (2 * (x - y)).\n2: apply Rmult_1_l.\nreplace 1 with (2 * (x - y)).\n2: apply Rmult_1_l.\nreplace 1 with (2 * (x - y)).\n2: apply Rmult_1_r.\nreplace 1 with (2 * 1)%R.\nrewrite Rmult_1_r.\nreplace 1%R with (2 * 1).\n2: apply Rmult_1_r.\nreplace 1%R with (2 * 1)%R.\n2: apply Rmult_1_l.\nreplace 1%R with (2 * 1)%R.\n2: apply Rmult_1_r.\nreplace 1%R with (2 * 1)%R.\n2: apply Rmult_1_r.\nreplace 1%R with (2 * 1)%R.\n2: apply Rmult_1_l.\nreplace 1%R withQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 2 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern y at 1 in |- *.\npattern y at 1 in |- *.\npattern x at 1 in |- *.\npattern x at 1Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern x at 2, y at 2, y at 2, x, y at 2, x0 at 2, x0 at 2, x1 at 2, x1 at 2,  x2 at 2, x3 at 2, x4 at 2.\napply Rplus_lt_compat_l.\napply Rplus_lt_compat_r.\napply Rmult_lt_reg_l with (2 := Rlt_0_1).\napply Rplus_lt_compat_l.\napply Rplus_lt_compat_l.\napply Rplus_lt_reg_l with (2 := Rlt_0_1).\napply Rplus_lt_compat_l.\napply Rplus_lt_compat_l.\napply Rlt_0_1.\napply Rplus_lt_compat_l.\napply Rlt_0_1.\napply Rplus_lt_compat_l.\napply Rlt_0_1.\napply Rplus_lt_compat_l.\napply Rlt_0_1.\napply Rplus_lt_compat_l.\napply Rlt_0_1.\napply Rplus_lt_compat_l.\napply Rlt_0_1.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2 in |- *.\npattern y at 2Qed."
                ]
            }
        ],
        "angles": [
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \n",
                "context_tokens": 447,
                "proof_start_offset": 1407,
                "proof_end_offset": 1868,
                "proof": "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v)))); auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold R in |- *.\nintros u v w H.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold incl in |- *; intros.\napply Trans with (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v)); auto.\napply Trans with (head v) (head v) (head v));Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold inter in |- *.\nintros.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\napply sym_equal; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold inter in |- *; intros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold inter in |- *.\nunfold inter in |- *.\nintros.\napply MaxEx with (union (union (union (union (union (union (union u v) (union (union u v) (union (union u v) v)))).\napply union_union; auto.\napply union_union; auto.\napply union_disj; auto.\napply union_disj; auto.\napply union_disj; auto.\napply union_disj; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold inter in |- *; intros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; applyQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold R in |- *.\nintros.\napply sym_equal.\napply sym_equal.\napply (extension_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (union_sym (Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold equiv in |- *.\nintros.\napply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply symQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold col in |- *; intros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold R in |- *; intros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \n",
                "context_tokens": 582,
                "proof_start_offset": 1900,
                "proof_end_offset": 2307,
                "proof": "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros u v w H H0 H1 H2; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; applyQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold disjoint in |- *.\nintros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply symQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold disjoint in |- *.\nintros u v w H H0 H1; elim H0; auto.\nintros u v w H0 H1; elim H1; auto.\nintros u v w H0 H1; elim H1; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold disjoint in |- *.\nintros.\napply trans_equal with (union (union X V) (union V V)); auto.\napply refl_equal.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold inter in |- *.\nintros.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equalQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold disjoint in |- *.\nintros.\napply H.\napply H0.\napply H1.\napply H1.\napply H.\napply H1.\napply H2.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H2.\napply H2.\napply H3.\napply H1.\napply H3.\napply H1.\napply H3.\napply H3.\napply H2.\napply H3.\napply H1.\napply H3.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H2.\napply H3.\napply H3.\napply H4.\napply H2.\napply H3.\napply H4.\napply H4.\napply H2.\napply H4.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H3.\napply H3.\napply H2.\napply H3.\napply H4.\napply H3Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold disjoint in |- *.\nintros u v w H H0 H1 H2.\napply H1.\napply H1.\napply H2.\napply H2.\napply H3.\napply H3.\napply H1.\napply H3.\napply H1.\napply H3.\napply H3.\napply H3.\napply H3.\napply H4.\napply H1.\napply H3.\napply H3.\napply H3.\napply H4.\napply H4.\napply H1.\napply H3.\napply H3.\napply H4.\napply H3.\napply H3.\napply H4.\napply H4.\napply H3.\napply H4.\napply H3.\napply H3.\napply H3.\napply H4.\napply H3.\napply H4.\napply H3.\napply H4.\napply H4.\napply H4.\napply H4.\napply H2.\napply H4.\napply H4.\napply H4.\napply H4.\napply H4.\napplyQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *.\nintros u v w H H0 H1 H2.\napply H2; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold inter_disj in |- *.\nintros.\napply (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_eq (alt_Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold disjoint in |- *.\nintros.\napply trans_equal with (cons u v) (Append w (nil ++ w))); auto.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal;\n apply sym_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \nLemma orthogonal_colineaire :\n forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 2310,
                "proof_end_offset": 2663,
                "proof": "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold colineaire in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, disjoint in |- *; intros.\napply trans_equal with (union (union u v) (union (union u v) (union (union u v) (union (union u v) (union (union u v) (union v w)))).\napply sym_equal; apply equiv_add; apply equiv_add; apply equiv_add; apply equiv_add; auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, incl in |- *; intros.\napply H1.\napply H2.\napply H1.\napply H1.\napply H2.\napply H3.\napply H1.\napply H3.\napply H2.\napply H1.\napply H1.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, le in |- *; intros.\napply trans_equal with (union (union (union (single v) (single v)) (single v))); auto.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, equiv in |- *.\nintros.\napply trans_compatible with (union (union (union u v) (union (union u v) (union v w))) (union (union u v) (union v w)));\n auto.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold col in |- *.\nintros.\napply trans_equal with (union (union (union u v) (union u v)) (union u v)); auto.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n assumption.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, prod in |- *; intros.\napply Uniqueness_of_image with (a := zero) (b := zero) (c := zero) (c := zero);\n auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold col in |- *.\nunfold le in |- *.\nintros.\napply transitive with (union (union (union (union (union (union (union (union_disj u v) (union (union_disj u v) (union_disj u v) (union_disj u v))) v));\n auto.\napply Sym.\napply union_inclus with (union (union (union (union (union_disj u v) (union_disj u v) (union_disj u v))) v);\n auto.\napply union_inclus with (union (union (union (union_disj u v) (union_disj u v))) v);\n auto.\napply union_inclus with (union (union (union_disj u v) (union_disj u v)));\n auto.\napply union_inclus with (union (union_disj u v) (union_disj u v)); auto.\napply union_inclus with (union (union_disj u v) (union_disj u v));\n auto.\napply union_inclus with (union (union_disj u v) (union_disj u v));\n auto.\napply union_inclus with (union (union_disjQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold le in |- *.\nunfold plus in |- *.\nintros.\napply Trans with (add (union (union (union u v) (union (union u v) (union u v))) (union u v));\n auto.\napply Trans with (add (union (union u v) (union (union u v) (union (union u v) (union u v)))).\napply Trans with (union (union (union u v) (union (union u v) (union (union u v) (union u v)));\n auto.\napply Trans with (union (union u v) (union (union u v) (union (union u v) (union (union u v) (union u v))));\n auto.\napply Trans with (union (union u v) (union (union (union u v) (union u v) (union u v)));\n auto.\napply Sym; auto.\napply union_comp; auto.\napply Sym; auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold col in |- *; intros.\napply transitive with (union (union (union u v) (union (union u v) (union (union u v) (union v v)))).\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal.\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\n apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal; apply sym_equal;\napply sym_equal; apply sym_equal; apply sym_equal; apply sym_equalQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold le in |- *; intros.\napply trans_equal with (union (union u v) (union (union u v) (union (union u v) (union v w)))).\napply sym_equal; apply union_inclus; auto.\nQed."
                ]
            }
        ],
        "coq-procrastination": [
            {
                "filepath": "./coq_projects/coq-procrastination/src/Procrastination.v",
                "context": " match goal with |-?G =>\n    match type of G with\n    | Prop => mk_begin_defer_helper_Prop ids H\n    | _ => mk_begin_defer_helper_Type ids H\n    end;\n    cut H; subst H; [| now prove_begin_defer_helper]\n  end.\n\n(* Tests *)\nGoal True.\n  mk_begin_defer_helper tt.\n  intro H; eapply H; clear H.\nAbort.\n\nGoal True.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\nGoal nat.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\n(* [end defer] helpers.\n\n   [end defer] is called on the second subgoal produced by [begin defer], of the\n   form [exists a.. z, group a.. z], where [group a.. z] has been\n   instantiated by [defer] into something of the form [P1 /\\ P2 /\\... /\\ Pn /\\\n  ?P], where P1.. Pn are the propositions that have been deferred, and [?P] is\n   the \"accumulator\" evar.\n\n   The role of [end defer] is to close the goal, instantiating [?P] with [True],\n   and removing it from the goal.\n\n   This is done by first applying a lemma of the form:\n\n   ```\n   forall A.. Z (G1 G2 : A ->.. -> Z -> Prop),\n   (forall a.. z, G1 a.. z -> G2 a.. z) ->\n   (exists a.. z, G1 a.. z) ->\n   exists a.. z, G2 a.. z\n   ```\n\n   After applying this lemma, [G2] is unified with the current goal (to clean),\n   and [G1] is introduced as an evar. An auxiliary tactic\n   ([cleanup_conj_goal_core], defined below) is called on the first subgoal, and\n   will discharge it, instantiating [G1] with the cleaned-up goal (i.e [P1 /\\ P2\n   /\\... /\\ Pn]).\n\n   The helpers below help generating and proving this lemma, for any number of\n   variables [a].. [z].\n*)\n\n(* Tactic that proves the lemma above for any arity. *)\nLtac prove_end_defer_helper :=\n  introsType;\n  let P1 := fresh in\n  let P2 := fresh in\n  let H1 := fresh in\n  let H2 := fresh in\n  intros P1 P2 H1 H2;\n  unfold Marker.end_defer in *;\n  repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x);\n  apply H1; auto.\n\n(* Tests. *)\nGoal forall A (P1 P2 : A -> Prop),\n  (forall a, P1 a -> P2 a) ->\n  (exists a, P1 a) ->\n  Marker.end_defer (exists a, P2 a).\nProof. prove_end_defer_helper. Qed.\n\n",
                "context_tokens": 707,
                "proof_start_offset": 14539,
                "proof_end_offset": 14719,
                "proof": "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_end_defer_helper.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. intros.\napply H in H0.\napply H in H0.\nclear H0.\ndestruct H0 as [a Ha].\napply H0 in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [H H].\napply H in Ha.\ndestruct Ha as [HQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_trivial_defer_helper.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. intros A B P1 P2 H1 H2. apply H2. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_functions. Abort.\n\nGoal forall A B (P1 P2 : A -> Prop), (forall a b, P1 a b -> P2 a b) -> forall a b, P1 a b.\nProof. intros A B P1 P2 H.\nfirst [intros; apply H; clear H].\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_lemmas.finish. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_lower_dim. Abort.\n\n(* Tests *)\nGoal forall A B (P1 P2 : A -> B -> Prop),\n  (forall a b, P1 a b -> P2 a b) ->\n  (exists a, P1 a b).\nProof.\n  intros A B P1 P2 H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact H | exact H ].\n  intros a b H.\n  split; [ exact HQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_lemmas.\nintros.\nFail solve_hyps. (* todo: use the lemma *)\nAbort.\n\n(* Tests. *)\n\nGoal forall x y z, (forall a b, P1 a b -> P2 b) -> x=y.\nProof.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nintros.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. intros A B P1 P2 H.\napply H.\napply H.\napply H.\nQed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_lemmas.gen_defer_helper. Qed."
                ]
            }
        ],
        "tree-automata": [
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nRequire Import EqNat.\nRequire Export Max.\n\nLemma nat_sum : forall n : nat, n = 0 \\/ (exists m : nat, n = S m).\nProof.\n\tsimple induction n. left. reflexivity. intros. right.\n\tsplit with n0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3102,
                "proof_end_offset": 3223,
                "proof": "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nelim (max_le_Sr_0 n m).\nintros.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\treplace n with (S n) by apply max_l.\n\trewrite max_l; auto with arith.\n\tsimpl in |- *. exact (le_n_Sn 0).\n\tintro.\n\tapply max_r.\n\tsimpl in |- *. exact (le_n_Sn n).\n\tintro.\n\tapply max_l.\n\tsimpl in |- *. exact (le_n_S n).\n\tintro.\n\tapply max_r.\n\tsimpl in |- *. exact (le_n_S n).\n\tintro.\n\tapply max_l.\n\tsimpl in |- *. exact (le_n_Sn (S n0)).\n\tintro.\n\tapply max_l.\n\tsimpl in |- *. exact (le_n_S n0 n0).\n\tintro.\n\tapply max_r.\n\tsimpl in |- *. exact (le_n_S n0 n0).\n\tintro.\n\tapply max_l.\n\tsimpl in |- *. exact (le_n_S n0 n1).\n\tintro.\n\tapply max_l.\n\tsimplQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tapply le_trans with (max (S n) (S m)).\n\tapply le_max_r.\n\tapply le_n_S.\n\texact (le_n_Sn (S n0) (S m)).\n\tsimpl in |- *. trivial.\n\tapply le_trans with (max (S n) (S m)).\n\texact (le_n_Sn (S n0) (S m)).\n\tsimpl in |- *. trivial.\n\tapply le_trans with (max (S n) (S m)).\n\texact (le_n_Sn (S n0) (S m)).\n\tsimpl in |- *. trivial.\n\tapply le_n_S.\n\texact (le_n_Sn (S n0) (S m)).\n\tsimpl in |- *. trivial.\n\tapply le_trans with (max (S n) (S m)).\n\texact (le_n_Sn (S n0) (S m)).\n\tsimpl in |- *. trivial.\n\tapply le_n_S.\n\texact (le_n_Sn (S n0) (Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros.\nsimpl in |- *.\nrewrite max_r; auto with arith.\n\tintros.\napply max_l.\napply le_trans with (max (S n) (S m)).\n\tapply le_max_r.\n\tapply le_trans with (max (S n) (S m)).\n\tapply le_max_r.\n\tapply le_trans with (max (S n) (S m)).\n\tapply le_max_l.\n\tapply le_trans with (max (S m) (S m)).\n\tapply le_max_r.\n\tapply le_trans with (max (S n) (S m)).\n\tapply le_max_l.\n\tapply le_trans with (max (S n) (S m)).\n\tapply le_max_r.\n\tapply le_trans with (max (S n) (S m)).\n\tapply le_max_r.\n\tapply le_trans with (max (S m) (S m)).\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply leQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tcut (max (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (min (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (max (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (max (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (min (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (max (S n) (S m) <= max (S n) (S m)).\n\tintro.\n\tcut (max (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (min (S n) (S m) <= max n (S m)).\n\tintro.\n\tcut (max (S n) (S m) <= max (S n) (S m)).\n\tintro.\n\tcut (min (S n) (S m) <= max n (S m)).\n\tintro.\n\tcutQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros.\nsimpl in |- *. elim H. intros. simpl in |- *. elim H. intros.\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_trans with (m := S n0).\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_transQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\trewrite max_l; auto with arith.\n\tapply max_r.\n\tapply max_l.\n\texact (le_n_Sn (S n)).\n\texact (le_n_Sn (S n)).\n\tapply le_n_S.\n\texact (le_n_Sn (S n)).\n\tapply le_n_S.\n\texact (le_n_Sn (S n)).\n\tapply le_n_S.\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (le_n_S (S n)).\n\texact (Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros; simpl in |- *.\nsplit.\nexact (le_n_Sn 0).\n\tintros.\nsplit.\nexact (le_S n0 n1).\n\tintros.\nsplit.\nexact (le_n_Sn 0).\n\tintros.\n\telim H. intros.\n\telim H. intros.\n\tapply (le_n_S (max n0 n1) (max n1 (S m)) H1).\n\tsimpl in |- *. trivial.\n\tapply le_n_S.\n\texact (le_n_S (max n0 n1) (max n0 n1)).\n\tsimpl in |- *. trivial.\n\tapply le_n_S.\n\texact (le_n_S (max n0 n1) (max n0 n1)).\n\tsimpl in |- *. trivial.\n\tapply le_n_S.\n\texact (le_n_S (max n0 n1) (max n0 n1)).\n\tsimpl in |- *. trivial.\n\tapply le_n_S.\n\texact (le_n_S (maxQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros.\nsimpl in |- *. elim H.\n intros. simpl in |- *. elim H.\nintros. simpl in |- *. elim H.\n intros. simpl in |- *. elim H. intros. simpl in |- *. elim H0. intros.\nsimpl in |- *. elim H0. intros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintros. simpl in |- *. elim H. intros.\napply H.\nintrosQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; simpl in |- *; trivial.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros.\n\tapply max_l.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_l.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_l.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_l.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_max_r.\n\tapply le_trans with (max n m); trivial.\n\tapply le_max_r.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3253,
                "proof_end_offset": 3397,
                "proof": "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *.\ntrivial.\nintros.\nsimpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tsimpl in |- *.\n\trewrite (plus_comm n n).\n\trewrite (plus_comm n n).\n\trewrite (plus_comm m n).\n\trewrite (plus_comm m n).\n\trewrite (plus_comm m n).\n\trewrite (plus_comm m n).\n\trewrite (plus_comm m n).\n\tapply (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plus_n_Sm_le n m).\n\texact (plusQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n   simpl in |- *. reflexivity.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tapply plus_O_l.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nintro.\nrewrite plus_n_Sm.\ntrivial.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tapply plus_n_O.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\tapply le_n_O.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\trewrite plus_n_O.\n\tapply mult_n_Sm.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n   intros. rewrite (plus_comm n 0). reflexivity.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\nrewrite (plus_comm n n).\napply (plus_O_r (S n)).\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tsimpl in |- *.\n\telim (plus_n_O n).\n\texact (plus_n_O n).\n\tapply le_n_S.\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\tsimpl in |- *. exact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\tsimpl in |- *. exact (plus_n_O n).\n\texact (plus_n_O n).\n\tsimpl in |- *. exact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\texact (plus_n_O n).\n\tQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3399,
                "proof_end_offset": 3543,
                "proof": "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *; trivial.\nintros; simpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros. rewrite H.\n\trewrite plus_n_Sm.\n\texact (plus_n_O n).\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |-Qed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\tsimpl in |- *. rewrite H.\n\tapply plus_n_O.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimpl in |- *. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tintros.\n\telim n.\n\tapply plus_n_O.\n\tintros.\n\trewrite (plus_comm n n0).\n\tsimpl in |- *.\n\trewrite (plus_comm n0 (S n0)).\n\tsimpl in |- *.\n\trewrite plus_n_Sm.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite H0.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\tapply plus_n_O.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\tapply plus_n_O.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\tapply plus_n_O.\n\tsimpl in |- *.\n\tapply le_n_S.\n\tsimpl in |- *.\n\tapply le_n_SQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\n\tsimpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3545,
                "proof_end_offset": 3788,
                "proof": "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n.\nsimpl in |- *.\nintro.\ncut (m + 0 = m).\nintros.\nrewrite H.\nexact (le_O_n m).\nexact (plus_O_r m).\nsimpl in |- *.\nintros.\nexact (le_plus_r m (m + n0 * m)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. elim (mult_n_O n m).\n\telim (mult_n_O n m).\n\tsimpl in |- *; trivial.\n\trewrite H0. trivial.\n\tsimpl in |- *; trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\tsimpl in |- *. rewrite H.\nrewrite plus_n_Sm.\nexact le_mult_l.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\telim (plus_O_l n m).\n\telim (plus_O_l n m).\n\tintros.\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\tintros.\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\tintro.\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\tintro.\n\telim (plus_O_r n m).\n\telim (plus_O_r n m).\n\tintro.\n\telim (plus_O_r n m).\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tapply le_mult_l.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |-Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n.\nsimpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros.\n\telim (plus_O_r n m).\n\tintros.\n\telim H.\n\tsimpl in |- *. trivial.\n\tintros.\n\telim H.\n\tsimpl in |- *. trivial.\n\tintros.\n\telim H.\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\n\tsimpl in |- *.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n; simpl in |- *; trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |-Qed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n.\nsimpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\n\tintros. simpl inQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tintros. elim (le_plus_n_Sm n m).\n\tintros.\napply le_mult_l.\napply le_trans with (m := S n).\n\tapply le_plus_l.\napply le_plus_r.\nexact (le_n_S n).\n\texact (le_n_S n).\n\texact (le_n_S n).\n\telim H.\n\tintros.\n\telim H. intros.\n\telim H. intros.\n\telim (le_plus_n_Sm n m).\n\texact (le_S_n n m).\n\texact (le_n_S n).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_S n m).\n\texact (le_n_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3790,
                "proof_end_offset": 4019,
                "proof": "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\ncut (n * m = m * n).\ncut (n * S m = S m * n).\nintros.\nrewrite H.\nrewrite H0.\nexact (le_mult_lS m n).\nexact (mult_comm n (S m)).\nexact (mult_comm n m).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n.\n simpl in |- *. intro. cut (n = m). intro. rewrite H0. apply le_n_Sn.\n\tsimpl in |- *. intros.\n\tsimpl in |- *. intros.\n\tsimpl in |- *. apply le_n_S.\n\tsimpl in |- *. intros.\n\tsimpl in |- *.\n\tapply le_S.\n\tsimpl in |- *.\n\tapply le_n_S.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\texact (le_S_n (S n0) (S m)).\n\tsimpl in |- *.\n\tintro.\n\tsimpl in |- *.\n\tapply le_n_S.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\texact (le_S_n (S n0) (S m)).\n\tsimpl in |- *.\n\tintro.\n\tsimpl in |- *.\n\tapply le_S.\n\tsimpl in |- *.\n\tapply le_n_S.\n\tsimpl in |- *.\n\trewrite H.\n\tsimpl in |- *.\n\tapply le_nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m <= n0). intro.\n\trewrite H0.\n\trewrite H.\n\tapply le_plus_trans with (m + n0 * m).\n\tapply le_plus_r.\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_r m).\n\texact (plus_O_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\telim (mult_n_O m).\n\texact (plus_O_l m n).\n\texact (plus_O_l m n).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_l m n).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_O_r m n).\n\tsimpl inQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n.\nsimpl in |- *. intros. cut (m + S n = S m).\n\tsimpl in |- *. exact (le_n_S m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. cut (m + S n = S m).\n\tsimpl in |- *. exact (le_n_S m).\n\tsimpl in |- *. intros. cut (m + S n = S m).\n\tsimpl in |- *. exact (le_n_S m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. cut (m + S n = S m).\n\tsimpl in |- *. exact (le_plus_r m n).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. cut (n + n = S n).\n\tsimpl in |- *. exact (le_plus_r m n).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. cut (n0 = S n0).\n\tsimpl in |- *. exact (le_plus_r n m).\n\texact (plusQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. cut (m + n = n). intro.\n\trewrite H. exact (le_plus_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m (n0 + n0) (S m)).\n\texact (plus_O_r m n).\n\tsimpl in |- *. intros. exact (le_plus_r m (n0 + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m (n0 + n0) (S m)).\n\texact (plus_O_r m n).\n\texact (plus_n_n m (n0 + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m (n0 + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m (n0 + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_l m (n0 + n0) (S m)).\n\tsimpl in |- *. intros. exactQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. cut (m + n = S m). intro.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\tapply le_plus_minus.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros. exact (le_minus_r m (m + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 (m + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 (n + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 (n + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 (n + n0) (S m)).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 (n + n0)Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (n = m). intro.\n\trewrite H. exact (le_plus_r m n).\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\tapply le_mult_r.\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_l m n).\n\texact (plus_n_O m).\n\tsimpl in |- *. intros. exact (le_plus_r m n).\n\texact (plus_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. cut (m + n = m). intro.\n\trewrite H. exact (le_plus_r m n).\n\tsimpl in |- *. intros. cut (n0 = n0). intro.\n\trewrite H. exact (le_plus_r m n0 H).\n\tsimpl in |- *. exact (le_plus_r m n0 H).\n\tsimpl in |- *. intros. cut (m + n = n0). intro.\n\trewrite H0. exact (le_plus_r m n0 H).\n\tsimpl in |- *. exact (le_plus_l m n0 H).\n\tsimpl in |- *. intros. cut (m + n = S n0). intro.\n\trewrite H. exact (le_plus_r m n0 H).\n\tsimpl in |- *. intros. cut (n0 = n0). intro.\n\trewrite H0. exact (le_plus_r m n0 H).\n\tsimpl in |- *. intros. cut (n0 = n0). intro.\n\trewrite H. exact (le_plus_r m n0 H).Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n.\nsimpl in |- *. intros. cut (m + S n = n). intros.\n\trewrite H.\n\trewrite H0.\n\texact (plus_O_r m).\n\tsimpl in |- *. intros.\n\texact (le_plus_r m (n + m) (S m)).\n\tsimpl in |- *. intros.\n\texact (le_plus_r n m H).\n\texact (plus_O_r m n H).\n\tsimpl in |- *. intros.\n\texact (le_plus_r n m H).\n\tsimpl in |- *. intros.\n\texact (le_plus_r n m H).\n\tsimpl in |- *. intros.\n\texact (le_plus_r n m H).\n\tsimpl in |- *. intros.\n\texact (le_plus_r n m H).\n\tsimpl in |- *. intros.\n\texact (le_plus_l n m H).\n\tsimpl in |- *. intros.\n\texact (le_plus_r n m H).\n\tsimpl in |- *. intros.\n\texact (le_plus_l n m HQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros.\n\trewrite le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\texact (plus_O_r n).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 m).\n\texact (plus_O_r n m H).\n\tsimpl in |- *. intros. exact (le_plus_r m n0 m).\n\texact (plus_O_r m n H).\n\tapply le_plus_l.\n\texact (plus_O_r n m H).\n\tsimpl in |- *. intros. exact (le_plus_r m n H).\n\texact (plus_O_r n m H).\n\tsimpl in |- *. intros. exact (le_plus_r n m H).\n\texact (plus_O_r n m H).\n\tsimpl in |- *. intros. exact (le_plus_l n m H).\n\texact (plus_O_r n m H).\n\tsimpl in |- *. intros. exact (le_plus_r n m H).\n\texact (plus_O_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4021,
                "proof_end_offset": 4242,
                "proof": "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\ncut (m <= n \\/ n < m).\nintro.\nelim H0; intros.\nleft.\nexact (le_antisym n m H H1).\nright.\nexact (lt_le_S n m H1).\nexact (le_or_lt m n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tcut (n = m). intro.\n\trewrite H0 in H0.\n\tapply le_antisym.\n\texact H1.\n\tapply le_antisym.\n\texact H1.\n\tapply le_antisym.\n\texact H1.\n\tapply le_antisym.\n\texact H1.\n\tapply le_antisym.\n\texact H2.\n\tapply le_antisym.\n\texact H2.\n\texact H2.\n\texact H3.\n\texact H3.\n\texact H3.\n\tapply le_antisym.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H3.\n\texact H4.\n\texact H1.\n\texact H3.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_antisym.\n\texact H.\n\texact H0.\n\texact H0.\n\texact H.\n\texact H.\n\texact H.\n\texact H.\n\texact H0.\n\texact H.\n\texact H0.\n\texact H0.\n\texact H1.\n\texact H0.\n\texact H1.\n\texact H0.\n\texact H2.\n\texact H2.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite H.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply le_antisymQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\telim (le_or_eq m n).\n\tintro.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply H.\n\tapply le_antisym.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply H.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tapply le_antisym.\n\tapply H.\n\tQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tsplit.\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (lt_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (S n)).\n\texact (le_abs_eq (SQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\trewrite H.\n\telim (le_or_eq n m); intros.\n\trewrite H0.\n\telim (le_or_eq n m); intros.\n\trewrite H in H0.\n\trewrite H in H.\n\trewrite H0 in H.\n\trewrite H0 in H.\n\trewrite H0 in H.\n\trewrite H in H.\n\trewrite H0.\n\trewrite H0.\n\trewrite H0.\n\trewrite H in H.\n\trewrite H0.\n\trewrite H0.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H0.\n\trewrite H0.\n\trewrite H.\n\trewrite H.\n\trewrite H0.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\trewrite H.\n\trewrite H0Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim H.\n\tapply le_antisym.\n\texact H.\n\tintro.\n\telim H.\n\tintro.\n\telim H.\n\tintro.\n\telim H0.\n\tintro.\n\telim H0.\n\tintro.\n\telim H.\n\tintro.\n\trewrite H.\n\trewrite H0.\n\trewrite H0.\n\trewrite H1.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H0.\n\trewrite H1.\n\trewrite H2.\n\trewrite H0.\n\trewrite H2.\n\trewrite H2.\n\trewrite H2.\n\trewrite H0.\n\trewrite H0.\n\trewrite H2.\n\trewrite H0.\n\trewrite H1.\n\trewrite H2.\n\trewrite H2.\n\trewrite H0.\n\trewrite H0.\n\trewrite H1.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H2.\n\trewrite H2.\n\trewrite H0.\n\trewriteQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_dec n m).\n\tapply le_antisym.\n\tapply le_S.\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_n n m).\n\texact (le_S_nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim H.\n\tintros.\n\trewrite H0.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros.\n\tapply le_antisym.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros.\n\tapply le_antisym.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros.\n\tapply le_antisym.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros.\n\tapply le_antisym.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros.\n\tapply le_antisym.\n\texact (le_S_n n m H).\n\tsimpl in |- *. intros.\n\trewrite H0.\n\trewrite H1.\n\trewrite H2.\n\trewrite H0.\n\trewrite H0.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\trewrite H.\n\trewrite H.\n\trewrite H0.\n\trewrite H.\n\trewrite H.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\telim (le_or_lt n m).\n\tintro.\n\telim H0.\n\tintros.\n\telim H0.\n\tintros.\n\trewrite H1.\n\trewrite H2.\n\telim H0.\n\tintros.\n\trewrite H2.\n\telim H0.\n\tintros.\n\trewrite H2.\n\telim H0.\n\tintros.\n\trewrite H3.\n\telim H0.\n\tintros.\n\trewrite H2.\n\telim H0.\n\tintros.\n\trewrite H3.\n\telim H0.\n\tintros.\n\trewrite H3.\n\telim H1.\n\tintros.\n\trewrite H3.\n\telim H2.\n\tintros.\n\trewrite H3.\n\telim H2.\n\tintros.\n\trewrite H3.\n\telim H2.\n\tintros.\n\trewrite H3.\n\telim H2.\n\tintros.\n\trewrite H3.\n\telim H1.\n\tintros.\n\trewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\nLemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros. cut (m <= n \\/ n < m). intro. elim H0; intros.\n\tleft. exact (le_antisym n m H H1).\n\tright. exact (lt_le_S n m H1).\n\texact (le_or_lt m n).\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4244,
                "proof_end_offset": 5286,
                "proof": "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintro.\nsimple induction m.\nintros.\ncut (n = 0).\nintro.\nrewrite H0; trivial.\nsymmetry in |- *.\nexact (le_n_O_eq n H).\ninduction n as [| n Hrecn].\nintros.\nsimpl in |- *.\nexact (le_O_n (p + n * p)).\nintros.\nsimpl in |- *.\ncut (n = n0 \\/ S n <= n0).\nintro.\ncut (n * p <= n0 * p).\nintro.\nelim H1; intros.\ncut (p <= p).\nintros.\nexact (plus_le_compat p p (n * p) (n0 * p) H4 H2).\nexact (le_n_n p).\ncut (n * p <= S n * p).\ncut (S n * p <= n0 * p).\nintros.\napply (le_trans (p + n * p) (p + S n * p) (p + n0 * p)).\nexact (plus_le_compat p p (n * p) (S n * p) (le_n_n p) H5).\nexact (plus_le_compat p p (S n * p) (n0 * p) (le_n_n p) H4).\nexact (H p H3).\nexact (le_mult_lS n p).\nelim H1; intros.\nrewrite H2.\nexact (le_n_n (n0 * p)).\ncut (n * p <= S n * p).\nintro.\ncut (S n * p <= n0 * p).\nintro.\nexact (le_trans (n * p) (S n * p) (n0 * p) H3 H4).\nexact (H p H2).\nexact (le_mult_lS n p).\ncut (n <= n0).\nintro.\nexact (le_disj n n0 H1).\nexact (le_S_n n n0 H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (n * p <= m). intro. elim H0; intros.\n\tleft. exact (le_S_n n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (le_S_n n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (le_S_n n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (le_S_n n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tcut (n = m \\/ p = m). intro.\n\telim H; intros.\n\tleft. exact (le_Sn_m n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tright. exact (le_trans n m H1).\n\tright. exact (lt_trans n m H1).\n\tQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (n * p <= m). intro. elim H.\n\tleft. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H HQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (n = m \\/ n = m). intro. elim H0; intros.\n\tleft. exact (le_Sn_n n m H0).\n\tright. exact (le_S_n n m H H1).\n\tright. exact (lt_le_S n m H0).\n\tright. exact (le_S_n n m H).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (le_Sn_n n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H0).\n\tright. exact (lt_S_n n m H0).\n\tright. exact (lt_le_S n m H0).\n\tright. exact (lt_le_S n m H0).\n\tright. exact (le_S_n n m H).\n\tright. exact (lt_le_S n m H).\n\tright. exact (lt_le_S n m H0).\n\tright. exact (lt_le_Qed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (n * p <= m). intro. elim H0; intros.\n\tleft. exact (le_S_n m p H0).\n\tright. exact (le_S_n n m H1).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H0).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H0).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H0).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H0).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H).\n\tright. exact (le_S_n n m H).\n\tQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim H.\n\telim H0.\n\telim H0.\n\telim H0.\n\telim H1.\n\telim H2.\n\telim H2.\n\telim H3.\n\telim H3.\n\telim H3.\n\telim H5.\n\tintro.\n\telim H5.\n\tintro.\n\telim (le_lt_or_eq n m).\n\tintro.\n\telim H5.\n\tintro.\n\tleft. exact (le_trans n m p H4).\n\tintro.\n\tleft. exact (le_trans n m p H5).\n\tintro.\n\tleft. exact (le_plus_r n m p H5).\n\tintro.\n\tright. exact (le_plus_r n m p H5).\n\tintro.\n\tright. exact (le_plus_r n m p H5).\n\tintro.\n\tright. exact (le_plus_r n m p H5).\n\tintro.\n\tright. exact (le_plus_r n m p H5).\n\tintroQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\napply le_plus_l.\napply le_plus_l.\nexact (plus_le_S n m p).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt m n).\n\tintro.\n\tleft. exact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\tright. exact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\tright. exact (le_plus_l n m p).\n\texact (le_plus_r n m p).\n\tright. exact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\tright. exact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\texact (le_plus_r n m p).\n\tQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (n <= m \\/ p <= m). intro. elim H.\n\tleft. exact (le_lt_S n m H H0).\n\tleft. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_S n m H H0 H1).\n\tright. exact (lt_le_S n m H H1).\n\tright. exact (lt_le_S n m H H0).\n\tright. exact (lt_le_SQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\nelim (le_or_lt n m).\n\texact (lt_O_n m p).\n\tapply le_mult_l.\nQed."
                ]
            }
        ],
        "coquelicot": [
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "\n  exact Hl.\nQed.\n\nLemma linear_cont (l : U -> V) (x : U) :\n  is_linear l -> continuous l x.\nProof.\n  intros Hl.\n  apply filterlim_locally_ball_norm => eps.\n  apply locally_le_locally_norm.\n  case: (linear_norm _ Hl) => M Hn.\n  assert (0 < eps / M).\n    apply Rdiv_lt_0_compat.\n    apply cond_pos.\n    apply Hn.\n  exists (mkposreal _ H) => y Hy.\n  rewrite /ball_norm /minus -linear_opp // -linear_plus //.\n  eapply Rle_lt_trans.\n  by apply Hn.\n  evar_last.\n  apply Rmult_lt_compat_l with (2 := Hy).\n  apply Hn.\n  simpl.\n  field.\n  apply Rgt_not_eq, Hn.\nQed.\n\nLemma is_linear_ext (l1 l2 : U -> V) :\n  (forall x, l1 x = l2 x) -> is_linear l1 -> is_linear l2.\nProof.\n  intros Hl Hl1.\n  split.\n  intros ; rewrite -!Hl ; apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\n  case: Hl1 => _ _ [M Hl1].\n  exists M ; split.\n  by apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\nQed.\n\n(** zero in a linear function *)\nLemma is_linear_zero : is_linear (fun _ => zero).\nProof.\n  repeat split.\n  - move => _ _ ; by rewrite plus_zero_l.\n  - move => k _ ; by rewrite scal_zero_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\n",
                "context_tokens": 753,
                "proof_start_offset": 3935,
                "proof_end_offset": 4211,
                "proof": "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nrepeat split.\nmove => x y.\nnow apply opp_plus.\nmove => k x.\napply sym_eq.\napply: scal_opp_r.\nexists 1 ; split.\nexact Rlt_0_1.\nmove => x ; rewrite norm_opp Rmult_1_l.\nby apply Rle_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nsplit.\n - exact (is_linear_opp 0).\n - exact (is_linear_opp 0).\n - exact (is_linear_opp (fun x => (- x))).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n    apply opp_inj.\n    apply opp_inj.\n    apply opp_inj.\n    apply opp_inj.\n    apply opp_inj.\n    exact Rlt_0_1.\n  - intros x y.\n    destruct (scalar_mx_mult_aux x y) as [z Hz].\n    rewrite!linear_mult.\n    exact Hz.\n    exact Hz.\n  - intros x y.\n    destruct (scalar_mx_mult_aux x y) as [z Hz].\n    rewrite!linear_mult.\n    exact Hz.\n    exact Hz.\n    exact Hz.\n    exact Hy.\n  - intros x y.\n    destruct (scalar_mx_mult_aux x y) as [z Hz].\n    rewrite!linear_mult.\n    exact Hy.\n    exact Hz.\n  - intros x y.\n    destruct (scalar_mx_mult_aux x y) as [z Hz].\n    rewrite!linear_mult.\n    exact Hz.\n    exact Hz.\n    exact Hy.\n    exact Hz.\n  - intros x y.\n    destruct (scalar_mx_mult_aux x y) as [z Hz].\n    rewrite!linear_mult.\n    exact Hz.\n    exact Hz.Qed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  split.\n  - move => x y.\n    by rewrite!linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x.\n  rewrite opp_involutive, opp_nonneg_nonpos, opp_nonneg_nonneg.\n  apply opp_inj_wd.\n  exact (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  do 2!split.\n  - exact Rlt_0_1.\n  - exact Rlt_0_1.\n  - exact Rlt_0_1.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  do 2?split.\n  - move=> _ x ; rewrite Rmult_comm ; apply Rlt_0_1.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - move=> _ x ; rewrite Rmult_comm ; apply Rlt_0_1.\n  - move=> _ x ; rewrite Rmult_comm ; apply Rlt_le_trans with x.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\n  - move=> x ; rewrite Rmult_comm ; apply Rlt_le_trans with x.\n    exact Rlt_0_1.\n    exact Rlt_0_1.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nsplit.\n  - move=> x y; rewrite <-opp_opp, opp_add_distr, <-opp_opp_opp.\n    by apply opp_inj.\n  - move=> x y.\n    rewrite <-opp_opp, opp_opp, opp_add_distr, <-opp_opp, opp_opp_opp.\n    by apply opp_inj.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  by split.\n  - move=> x y.\n    by rewrite!linear_add.\n  - move=> x y.\n    by rewrite!linear_add.\n  - move=> x y.\n    by rewrite!linear_add.\n  - move=> x y.\n    by rewrite!linear_add.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  exact (Build_Map (A:=V)).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nsplit.\n  - move=> x ; rewrite <- (opp_opp x).\n    now apply opp_inj.\n    exact (fun x => opp_inj x).\n  - move=> x ; rewrite <- (opp_opp x).\n    now apply opp_inj.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": " - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\n",
                "context_tokens": 740,
                "proof_start_offset": 5017,
                "proof_end_offset": 5487,
                "proof": "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_r.\nmove => u v /= ; apply sym_eq, @scal_assoc.\nexists (norm x + 1) ; split.\napply Rplus_le_lt_0_compat.\napply norm_ge_0.\nexact Rlt_0_1.\nmove => k /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\nnow rewrite Rmult_comm ; apply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nrewrite!mul_assoc.\nrewrite!opp_add_distr_l,!mul_comm.\napply f_equal.\n  rewrite <-!opp_add,!opp_add,!opp_add,!opp_add,!opp_add,!opp_add,!opp_opp,!opp_add,!opp_opp,!opp_add,!opp_opp,!opp_opp,!opp_opp,!opp_opp,!opp_involutive.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  rewrite /is_linear_opp /is_linear_add /is_linear_add.\n  case: k => [|k IHk] x /=.\n  - by rewrite!linear0.\n  - by rewrite!linear_add_opp /is_linear_add.\n  - by rewrite!linear0.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x.\n  rewrite (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k xQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  rewrite <- (opp_def x).\n  now rewrite <- (opp_def x).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k.\n  rewrite k.\n  rewrite k.\n  apply f_equal.\n    rewrite <- (mult_comm k x).\n    rewrite <- (mult_comm k x).\n    rewrite <- (mult_comm k x).\n    rewrite <- (mult_comm k x).\n    rewrite <- (mult_comm k x).\n    rewrite <- (mult_comm k x).\n    now rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (mult_comm k x).\n  rewrite <- (Qed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k.\n  rewrite (fun k => k * k)%nat by ring.\n  apply f_equal.\n    rewrite (fun k => k * k)%nat by ring.\n    by apply f_equal.\n    rewrite (fun k => k * k)%nat by ring.\n    by apply f_equal.\n  - apply is_linear_opp.\n    apply is_linear_add.\n    exact (fun k => k * k)%nat).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k x.\n  rewrite (opp_involutive x).\n  rewrite <-opp_add, <-opp_add, opp_add, opp_opp_opp.\n  rewrite <-opp_add, opp_add_distr, <-opp_opp, opp_opp_opp, opp_opp_opp, opp_opp_opp.\n  rewrite <-opp_add, opp_opp_opp, opp_add_distr, opp_opp_opp.\n  rewrite <-opp_add, opp_opp_opp, opp_opp_opp, opp_opp_opp.\n  rewrite <-opp_opp,opp_opp, opp_opp_opp, opp_opp_opp.\n  rewrite <-opp_opp,opp_opp, opp_opp_opp.\n  rewrite <-opp_opp, opp_opp, opp_opp_opp.\n  rewrite <-opp_opp, opp_opp, opp_opp_opp, opp_opp.\n  rewrite opp_involutive, opp_opp_opp, opp_opp_opp.\n  rewrite opp_opp_opp, opp_opp_opp.\n  rewrite <-opp_opp, opp_opp_opp, opp_opp, opp_opp_oppQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k.\n  rewrite /is_linear_add; try easy.\n  rewrite!lin_mul_1_l.\n  rewrite!lin_mul_1_l; reflexivity.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  repeat split.\n  - intros k.\n    rewrite k.\n    apply: contra_opp.\n    exact (proj1 (conj k)).\n  - intros k.\n    apply k.\n    exact (proj1 (conj k)).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  rewrite /is_linear_add /opp /opp /opp /opp /opp /opp.\n  rewrite /is_linear_add /opp /opp /opp /opp /opp.\n  rewrite /is_linear_add /opp /opp /opp /opp /opp /opp /opp /opp.\n  rewrite opp_add /opp /opp /opp /opp /opp /opp /opp /opp.\n  rewrite /is_linear_add /opp /opp /opp /opp /opp.\n  rewrite opp_involutive /opp /opp /opp /opp /opp /opp /opp /opp.\n  rewrite opp_add /opp /opp /opp /opp /opp /opp.\n  rewrite opp_opp /opp /opp /opp /opp /opp /opp /opp.\n  rewrite opp_involutive /opp /opp /opp /opp /opp /opp /opp /opp /opp.\n  rewrite opp_involutive /opp /opp /opp /opp /opp /opp /opp /opp.\n  rewrite opp_involutive /opp /opp /opp /opp /opp /opp.\n  rewrite opp_involutive /opp /opp /opp /opp /opp /opp /opp /opp.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\nLemma is_linear_scal_l (x : V) :\n  is_linear (fun k : K => scal k x).\nProof.\n  split.\n  - move => u v ; by apply @scal_distr_r.\n  - move => u v /= ; apply sym_eq, @scal_assoc.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply norm_ge_0.\n    exact Rlt_0_1.\n    move => k /=.\n    rewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\n    apply Rplus_le_compat.\n    now rewrite Rmult_comm ; apply norm_scal.\n    apply norm_ge_0.\nQed.\n\n(** [fun x => scal k x] is a linear function if [mult] is commutative *)\n",
                "context_tokens": 724,
                "proof_start_offset": 5562,
                "proof_end_offset": 6076,
                "proof": "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_l.\nmove => u v /= ; apply sym_eq ; rewrite !@scal_assoc.\nby rewrite H.\nexists (abs k + 1) ; split.\napply Rplus_le_lt_0_compat.\napply abs_ge_0.\nexact Rlt_0_1.\nmove => x /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\napply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k H.\n  apply (@scal_mult_reg_l (fun k : K => opp k x)).\n  - apply (@scal_mult_reg_l (fun k : K => opp k x)).\n    exact (@mult_comm k).\n  - intros k k.\n    now rewrite opp_mult_distr_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros Hk.\n  destruct (Rle_or_lt k 0) as [H|H].\n  - apply is_linear_le.\n    exact H.\n  - apply is_linear_le.\n    exact H.\n  - apply is_linear_le.\n    exact H.\n  - apply is_linear_le.\n    exact H.\n  - apply is_linear_le.\n    exact H.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros; apply (@opp_opp_r_uniq (fun x : V => opp k x)).\n  - intros; apply (@opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (@opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniq (fun x : V => opp k x)).\n    intros; apply (opp_opp_uniqQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros H.\n  apply (Build_fun (fun x : V * V => opp k x)).\n  - intros n H.\n    apply (Build_fun (n : K) (k : K) => k x).\n    apply (Build_fun (n : K) (k : K) => k x).\n    apply (Build_fun (n : K) (k : K) => k x).\n    apply (Build_fun (n : K) (k : K) => k x).\n    apply (Build_fun (n : K) (k : K) => k x).\n    exact (scal_mult_by_scalars k x).\n  - intros n H.\n    apply (Build_Map (A:=F) (n : K) (k : K) => k x).\n    apply (Build_Map (A:=F) (n : K) (k : K) => k x).\n    exact (scal_mult_by_scalars k x).\n  - intros n H.\n    apply (Build_Map (A:=F) (n : K) (k : K) => k x.\n    exact (scal_mult_by_scalars k xQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros; apply (@scal_integral _ _ _ _ _ 0%N); apply is_linear_add; auto.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k H.\n  apply is_linear_add.\n  - intros k H.\n    rewrite (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)).\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)) at 1.\n    rewrite <- (mult_comm k (n + k)).\n    rewrite <- (mult_comm k (n + k)) at 1.\n   Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros; rewrite <- (opp_add _ _ (opp_add _ _ (opp_add _ _ (opp_add _ _ _)).\n  apply opp_inj.\n  rewrite <-opp_add, <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp.\n  apply opp_inj.\n  rewrite <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp.\n  apply opp_inj.\n  rewrite <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp.\n  apply opp_inj.\n  rewrite <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp, <-opp_opp.\n  apply opp_inj.\n  rewrite <-opp_opp, <-opp_opp, opp_opp, <-opp_opp.\n  apply opp_inj.\n  rewrite <-opp_opp, opp_opp, opp_opp, <-opp_opp.\n  apply opp_inj.\n  rewrite <-opp_opp, opp_involutive, opp_opp.\n  apply opp_inj.\n Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k Hk.\n  rewrite <- (opp_multKl k Hk).\n  apply f_equal, opp_add_distr_l.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros Hn.\n  apply is_linear_mult_by_scalars; auto.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  move=> k.\n  rewrite /is_linear_add; auto.\n  by apply/scal_mul_l.\nQed."
                ]
            }
        ],
        "fermat4": [
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "\nLemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.\n\nLemma is_sqr_compat : forall k a : Z,\n  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 20559,
                "proof_end_offset": 20779,
                "proof": "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); rewrite H in H0; clear H; rewrite Zmult_assoc in H0; apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H0; clear H0; intros;\n    elim (divide_dec a b); intro;\n      [ generalize (divide_dec a b); intro;\n          [ generalize (divide_dec a b); intro;\n            [ generalize (divide_dec a b); intro;\n              [ generalize (divide_dec a b); intro;\n                [ generalize (divide_dec a b); intro;\n                  [ generalize (divide_dec a b); intro;\n                  [ generalize (divide_dec a b); intro;\n                    [ generalize (divide_dec a b); intro;\n                    [ generalize (divide_dec a b); intro;\n                    [ generalize (divide_dec a b); intro;\n                      [ generalize (divide_dec a b); intro;\n                        [ generalize (divide_dec a b); intro;\n                        [ generalize (divide_dec a b); intro;\n                          [ generalize (divide_dec a b); intro;\n                          [ generalize (divide_dec a b); intro;\n                            [ generalize (divide_dec a b); intro;\n                            [ generalize (divide_dec a b); intro;\n                            [ generalize (divide_dec a b); intro;\n                            [ generalize (divide_dec a b); intro;\n                           Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_sym; apply rel_prime_sym.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H; clear H; intros;\n    elim H0; clear H0; intros;\n      elim H; clear H0; intros; apply H; clear H0; intros;\n        apply H; clear H0; intros;\n        apply H; clear H0; intros;\n          apply H; clear H; intros;\n          apply H; clear H; intros;\n            apply (H _ H0); clear H; intros;\n            apply (H _ H0); clear H; intros;\n              apply (H _ H0); clear H; intros;\n              apply (H _ H0); clear H; intros;\n              apply (H _ H0); clear H; intros;\n                apply (H _ H0); clear H; intros;\n                  apply (H _ H0); clear H; intros;\n                  apply (H _ H0); clear H; intros;\n                  apply (H _ H0); clear H; intros;\n                  apply (H _ H0); clear H; intros;\n                    apply (H _ H0); clear H; intros;\n                        apply (H _ H0); clear H; intros;\n                    apply (H _ H0); clear H; intros;\n                    apply (H _Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_sym; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H; clear H; intros;\n    elim (rel_prime_dec a b); intro;\n      [ generalize (rel_prime_dec a b); intro; rewrite H; clear H; intro;\n          generalize (rel_prime_dec a b); intro;\n            [ generalize (rel_prime_dec a b); intro; rewrite H0 in H;\n                generalize (rel_prime_dec a b); intro;\n                  rewrite <- H0 in H;\n                  generalize (rel_prime_dec a b); intro;\n                      rewrite <- H0 in H;\n                      generalize (sym_eq H0); intro;\n                      rewrite <- H2 in H;\n                        generalize (sym_eq H1); intro;\n                        rewrite <- H1 in H;\n                          rewrite <- H2 in H;\n                            generalize (sym_eq H1); intro;\n                            rewrite <- H2 in H;\n                            rewrite <- H2 in H;\n                          generalize (sym_eq H1); intro;\n                            rewrite <- H2 in H;\n                            rewrite <- H2 in H;\n                            rewrite <- H2 in H;\n                            generalize (sym_eq H0); intro;\n                              rewrite <- H2 in H;\n                            rewrite <- H2Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_sym; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_sym; apply rel_prime_sym; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H0; apply divide_trans with (a | b); trivial; trivial; omega.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H; clear H; intros;\n    elim (rel_prime_dec a b); intro;\n      [ generalize (rel_prime_dec b 0); intro;\n          [ generalize (rel_prime_dec b 0); intro;\n              generalize (rel_prime_dec b 0); intro;\n                generalize (rel_prime_dec b 0); intro;\n                  generalize (rel_prime_dec b 0); intro;\n                  generalize (rel_prime_dec b 0); intro;\n                        generalize (rel_prime_dec b 0); intro;\n                            generalize (rel_prime_dec b 0);\n                          generalize (rel_prime_dec b 0);\n                            intro;\n                            generalize (rel_prime_dec b 0);\n                            intro;\n                            generalize (rel_prime_dec b 0);\n                            intro;\n                            generalize (rel_prime_dec b 0);\n                            intro;\n                              generalize (rel_prime_dec b 0);\n                            intro;\n                            generalize (rel_prime_dec b 0);\n                            intro;\n                              generalize (rel_prime_dec b 0);\n                            intro;\n                            generalize (rel_prime_dec b 0);\n                              intro;\n                            generalize (rel_prime_dec b 0);\n                            introQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 20781,
                "proof_end_offset": 21011,
                "proof": "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0; exists (q0 - q); rewrite H0; ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H) (q0,H1);\n    rewrite H in H0; clear H; rewrite Zmult_1_r in H0;\n    apply (Zdivide_intro a b c (q0 * q0)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q,H0);\n    rewrite H in H0; clear H; rewrite H0 in H0;\n      apply (Zdivide_trans _ _ _ _ H0);\n      generalize (divide_factor_l _ _ _ H0);\n      generalize (divide_factor_l _ _ _ H0);\n      generalize (divide_factor_r _ _ _ H0);\n      generalize (divide_factor_l _ _ _ H0);\n      generalize (divide_factor_r _ _ H0);\n      generalize (divide_factor_r _ _ H0);\n      generalize (divide_factor_r _ _ H0);\n        generalize (divide_factor_r _ _ H0);\n        generalize (divide_factor_r _ _ H0);\n        generalize (divide_factor_r _ _ H0);\n        generalize (divide_factor_r _ _ H0);\n          generalize (divide_factor_r _ _ H1);\n          generalize (divide_factor_r _ _ H0);\n            generalize (divide_factor_r _ _ H0);\n            generalize (divide_factor_r _ _ H0);\n            generalize (divide_factor_rQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q,H0);\n    rewrite H0 in H; clear H; rewrite H0; clear H0; intros;\n      elim (divide_dec a b); intro;\n        [ rewrite H1 in H; rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n            elim (divide_dec b c); intro;\n            [ rewrite H1 in H; rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0; rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H;\n                  rewrite Zmult_1_l in H;\n                  rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H0;\n                  rewrite Zmult_1_l in H0;\n                    rewrite Zmult_1_l in H0;\n                    rewrite Zmult_1_l in H0;\n                    rewrite Zmult_1_l in H0Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c H H0; rewrite H0 in H; clear H;\n    apply (Zdivide_intro a c (q0 * b)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q,H0);\n    rewrite H; clear H; intros;\n    apply (Zdivide_intro a b (q * q)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H0) (q,H1) (q,H2);\n    rewrite H in H0; clear H; intros;\n      generalize (divide_factor_l _ _ _ H0); clear H0; intro;\n        try (cut (a | b * c * c) \\/ (a | b * c) \\/ (a | b * c)).\n  apply divide_factor_l; assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q,H0);\n    generalize (divide_factor_l a b c (q * q) H0);\n      clear a b c; intro;\n      generalize (divide_factor_r a b c (q * q) H0);\n        clear a b c; intro;\n        generalize (divide_factor_r a b c (q * q) H0);\n          clear a b c; intro;\n          generalize (divide_factor_r a b c (q * q) H0);\n          clear a b c; intro;\n          generalize (divide_factor_r a b c (q * q) H0);\n            clear a b c H0; intro;\n            generalize (divide_factor_r a b c (q * q) H0);\n              clear a b c H0; intro;\n              generalize (divide_factor_r a b c (q * q) H0 H);\n                clear a b c H0; intro;\n                generalize (divide_factor_r a b c (q * q) H0);\n                  clear a b c H0 H1; intro;\n                  generalize (divide_factor_r a bQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q,H1);\n    rewrite H in H1; clear H; intros;\n      apply (Zdivide_intro b c (q0 * q));\n      rewrite H0 in H1; rewrite Zmult_0_l in H1;\n        elim (divide_0_r 0); intro;\n          [ rewrite H1 in H1; rewrite Zmult_1_l in H1; rewrite Zmult_0_l in H1;\n            elim (Zmult_eq_0_l (a * q)); intro;\n            [ rewrite H1 in H1; rewrite Zmult_0_l in H1; rewrite Zmult_0_l in H1; rewrite Zmult_0_r in H1;\n              elim (Zmult_eq_0_l (a * q)); intro;\n              [ rewrite H1 in H1; rewrite Zmult_0_l in H1; rewrite Zmult_0_l in H1;\n                  elim (Zmult_eq_0_l (a * q)); intro;\n                  [ rewrite H1 in H1; rewrite Zmult_0_l in H1;\n                  elim (Zmult_eq_0_l (a * qQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c H H0;\n    generalize (divide_factor_r a b c H0); clear H; intro H0;\n      generalize (divide_factor_r a b c H0); clear H; intro H1;\n        generalize (divide_factor_r a b c H H0); clear H; intro H1;\n          generalize (divide_factor_r a b c H0); clear H; intro H2;\n            generalize (divide_factor_r a b c H0);\n            intro;\n              [ rewrite H4 in H1; rewrite Zmult_1_r in H1; rewrite Zmult_1_l in H1;\n                  rewrite Zmult_1_l in H1;\n                  rewrite Zmult_1_l in H1;\n                    unfold is_power in H1;\n                    unfold is_power in H1;\n                    unfold is_power in H1;\n                    unfold is_power in H1;\n                        unfold is_power in H1;\n                       unfold is_power in H1;\n                       unfold is_power in H1;\n                       unfold is_power in H1;\n                       unfold is_power in H1;\n                       unfold is_power in H1;\n                      Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H1) (q,H2);\n    rewrite H; rewrite H; rewrite H0; clear H; intros;\n      replace\n      (a * (b * b + c)) * (b + c)) with (b * b) in H0;\n      [ apply Zdivide_trans with (b * b);\n        [ apply Zdivide_trans with (b * c);\n          [ apply Zdivide_trans with (b * c);\n            [ apply Zdivide_trans with (b * c);\n            [ apply Zdivide_trans with (b * c);\n              [ apply Zdivide_trans with (b * c);\n                [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * c);\n                  [ apply Zdivide_trans with (b * cQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 21013,
                "proof_end_offset": 21297,
                "proof": "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\nintros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a)) in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro; apply Zdivide_intro with (q := q); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    change\n      (c * a + b * c * b + c * c * b) in H;\n      apply\n      (euclid_for_euclid a b c (a + b * c)\n        (a + b * c)\n        (b + c * b * c * b + c * b));\n      apply\n      (euclid_for_euclid a b c (a + b * c)\n        (b + c * b * c)\n        (b + c * b * c * b));\n      apply\n      (euclid_for_euclid a b c (a + b * c)\n        (c + b * c * b + c * b));\n      apply\n      (euclid_for_euclid a b c (a + b * c)\n        (b + c * b * c * b));\n      apply\n      (euclid_for_euclid a b c (a + b * c)\n        (b + c * b * c * b)\n        (c + b * c * b + c * b);\n      apply\n      (euclid_for_euclid a b c (a + b * c)\n        (Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    generalize (divide_factor_r _ _ _ H); clear H; intro;\n      generalize (divide_factor_r _ _ _ H0); clear H0; intro;\n        (apply divide_trans with a; assumption || (c * a));\n          assumption || (apply divide_trans with a; assumption || (c * a));\n            assumption || (apply divide_trans with a; assumption || (c * a));\n              assumption || (apply divide_trans with a; assumption || (a * b));\n              assumption || (apply divide_trans with a; assumption || (a * a);\n                  assumption || (apply divide_trans with a; assumption || (a * b));\n                  assumption || (apply divide_trans with a; assumption || (a * b);\n                  assumption || (apply divide_trans with a; assumption || (a * b));\n                  assumption || (apply divide_trans with a; assumption || (a * b));\n                  assumption || (apply divide_trans with a; assumption || (a * b));\n                  assumption || (apply divide_trans with a; assumption || (a * b);\n                  assumption ||Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q0,H1);\n    generalize (divide_divide_l (a * b) q0);\n      generalize (divide_divide_l (a * b) q0);\n        generalize (divide_divide_l (a * b) q0);\n          generalize (divide_divide_l (a * b) q0);\n          generalize (divide_divide_r (a * b) q0);\n          clear H H0; intro; rewrite H0 in H1;\n          elim (divide_divide_r_r a (q0 * q0));\n            intro; rewrite H1 in H1;\n              elim (divide_divide_r_r a (q0 * q0));\n              intro; rewrite H1 in H1; rewrite H1 in H1;\n              elim (divide_divide_r_r a (q0 * q0));\n              intro; rewrite H1 in H1;\n              elim (divide_divide_r_r a (q0 * q0));\n                intro; rewrite H1 in H1; elim (divide_divide_r_r a (q0 * q0));\n                intro; rewrite HQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0 H1; rewrite H in H0; clear H;\n    apply (Zdivide_mult_l a c (p * a) H1); assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0; rewrite H; clear H; rewrite H0 in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H1);\n    apply (divide_trans _ _ (divide_mult_l _ _ (q * b * c) H0));\n      rewrite H; rewrite H0; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    cut (a | b * c).\n  { intros H; rewrite H in H0; clear H; rewrite Zmult_0_l in H0;\n      exists (q * b); repeat split; auto with zarith. }\n  intros (H1,H2) (q,H2);\n    generalize (divide_factor_r _ _ H2); clear H1; intro;\n    generalize (divide_factor_r _ _ H2); clear H1; intro;\n      rewrite H2 in H1; rewrite H2 in H1; elim (Z_eq_dec b c);\n      intro; try (cut False; rewrite H1 in H1; simpl in H1; auto);\n      replace (c * b + c * b) with (c * b + c * b);\n      try ring; generalize (Zmult_comm a c);\n        clear H1; intro;\n        replace (c * b + c * b) with (c * b + c * b);\n        try ring; generalize (Zmult_comm a c);\n          clear H1; intro;\n          try ring; generalize (Zmult_commQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    generalize (divide_factor_r a b c (q * b) (q * c) (q * b) H);\n      generalize (divide_factor_r a b c (q * b) (q * c) (q * b) H);\n        clear H0; intro;\n        generalize (divide_factor_r a b c (q * b) (q * b) H);\n          clear H0; intro;\n          generalize (divide_factor_r a b c (q * b) (q * b) H0);\n            clear H0; intro;\n            generalize (divide_factor_l a b c (q * b) (q * b) H0);\n              clear H0; intro;\n              generalize (divide_factor_r a b c (q * b) (q * b) H0);\n              clear H0; intro;\n              generalize (divide_factor_r a b c (q * b) (q * b) H0);\n                clear H0; intro;\n                generalize (divide_factor_r a b c (q * b) (q * bQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0;\n    apply (euclid_for_euclid a b c (q0,H1) (q0,H1));\n      assumption.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q,H) (q,H0);\n    generalize (divide_factor_r a b c (q * b + c) H);\n      generalize (divide_factor_r b c (q * b) H);\n        generalize (divide_factor_r a b c (q * b) H);\n          generalize (divide_factor_r a b c (q * b) H0);\n            clear H0; intro; rewrite H0 in H0;\n            elim (divide_factor_r b c (q * b + c * b));\n              intros; generalize (divide_factor_r a b c (q * b) H);\n                intro; rewrite H1 in H; rewrite H1 in H;\n                  elim (divide_factor_r b c (q * b + c * b));\n                  intros; generalize (divide_factor_r a b c (q * b) H);\n                  intro; rewrite H1 in H;\n                  elim (divide_factor_l b c (q * b + c * b + c * b));\n                  intros; rewrite H1 in H;\n                    elim (divide_factor_r b c (q * b +Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 21299,
                "proof_end_offset": 21412,
                "proof": "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\nintros; elim H; clear H; intros; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; case (Z_dec_eq z 0); intros;\n    [ rewrite H0 in H; rewrite H0 in H; rewrite H in H; elim (Z_eq_dec z 0);\n      intro;\n        [ rewrite H0 in H; rewrite Zmult_0_l in H; rewrite Zmult_0_l in H;\n            elim (Z_dec z 0); intro;\n            [ unfold is_pos; simpl in H; intros; red in H; rewrite H in H;\n                  rewrite Zmult_0_l in H; rewrite Zmult_0_l in H;\n                  elim (Z_dec z 0); intros;\n                  [ unfold is_pos; simpl in H; intros;\n                  rewrite Zmult_0_l in H;\n                  elim (Z_dec z 0); intros;\n                  [ unfold is_pos; simpl in H; intros;\n                    rewrite Zmult_0_l in H;\n                  rewrite Zmult_0_l in H;\n                    elim (Z_dec z 0); intros;\n                    [ unfold is_pos; simpl in H; intros;\n                  rewrite Zmult_0_l in H;\n                        rewrite Zmult_0_r in H;\n                  elim (ZQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; split; auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; rewrite H; apply divide_0_r.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; red; intros z; rewrite H;\n    replace (z * (z * a)) with (z * a) by ring;\n    rewrite <- (mult_1_l z).\n  rewrite <- H0; rewrite (mult_comm z).\n  reflexivity.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; case (Z_eq_dec z 0); intros z1 z2;\n    try (rewrite H; reflexivity);\n    try rewrite H;\n    apply Zdivide_antisym; assumption.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H H0;\n    rewrite H0 in H0; rewrite H0 in H0;\n    exists (q0 * a); rewrite H0; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H H0; apply divide_0_l.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H; case (Z_dec z 0); intros z1 z2 z3;\n    try rewrite (Zmult_0_r z1 z2); rewrite (Zmult_0_r z2);\n    replace (x0 * z1) with (x0 * z2);\n    [ rewrite (Zmult_0_r z1 z2); rewrite (Zmult_0_l z1); ring | ring ].\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z H;\n    generalize z; clear z; intros z H;\n      rewrite H;\n      replace (z * (z * (z * (z * (z * (z * (z * (z * (z * (z * (z * (z * z)))))\n              (z * (z * (z * (z * (z * (z * (z * (z * z)))))\n              (z * (z * (z * (z * (z * (z * z))))\n              (z * (z * (z * (z * (z * (z * (z * z)))))\n              (z * (z * (z * (z * (z * (z * (z * z)))\n              (z * (z * (z * (z * (z * (z * z)))\n              (z * (z * (z * (z * (z * z)))\n              (z * (z * (z * (z * (z * (z * z)))\n              (z * (z * (z * (z * z)))\n              (z * (z * (z * (z * z))\n              (z * (z *Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; case z; simpl; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\nLemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 21414,
                "proof_end_offset": 21759,
                "proof": "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\nintros; cut (2 <> 0); auto with zarith; intro; generalize (Zdivide_bounds _ _ H2 H3); clear H2; simpl; generalize H; generalize H0; generalize H1; elim z; simpl; intros; progress (auto with zarith) || (elimtype False; auto with zarith).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1 H2; apply divide_mul_l.\n  apply divide_mul_l.\n  apply divide_mul_r.\n  apply divide_mul_r.\n  apply divide_mul_l.\n  apply divide_factor_r.\n  apply divide_factor_l.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_l.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_l.\n  apply divide_factor_l.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_l.\n  apply divide_factor_r.\n  apply divide_factor_l.\n  apply divide_factor_l.\n  apply divide_factor_l.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divide_factor_r.\n  apply divideQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1 H2;\n    generalize (divide_1_r _ H0); clear H; intro;\n      apply divide_trans with (q := q); auto with zarith;\n      apply divide_intro with (q := q); auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz H H0 H1; apply divide_antisym; auto.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1 H2; rewrite H2; apply divide_1_l.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1 H2; rewrite H2 in H; elim H; clear H; intros;\n    try assumption.\n  apply H2; apply H3; apply H; apply H1; apply H1; apply H0.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1 H2; apply H; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1.\n  replace (z * (z + 1)) with (z * y * z + x * y);\n    [ apply Zmult_reg_l | ring ].\n  apply Zmult_reg_l with (a := b); auto with zarith.\n  replace (z * (z + 1)) with (z * z + x * y * z);\n    [ apply Zmult_reg_l | ring ].\n  apply Zmult_reg_l with (a := b); auto with zarith.\n  replace (z * (z + 1)) with (z * y * z + x * y * z);\n    [ apply Zmult_reg_l | ring ].\n  replace (z * (z + 1)) with (z * (z + 1));\n    [ apply Zmult_reg_l | ring ].\n  apply Zmult_reg_l with (a := b); auto with zarith.\n  replace (z * (z + 1)) with (z * (z + 1));\n    [ apply Zmult_reg_l | ring ].\n  apply Zmult_reg_l with (a := b); auto with zarith.\n  replace (z * (z + 1)) with (z * (Qed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H1 H2 H3; rewrite H3 in H1;\n    apply (Zdivide_trans _ _ H3); clear H3; intro;\n    apply (Zdivide_trans _ _ H3); clear H3; intro;\n      try\n        (cut (q = 2 * a); auto with zarith).\n    cut (q = 2 * a); auto with zarith.\n    rewrite H0; rewrite H1; rewrite H2; ring.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H1 H2 H3;\n    apply divide_antisym; assumption.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0 H1 H2;\n    apply (divide_0_l z H H0 H1); clear H H2; intro;\n      apply (divide_0_r z H H0 H2); clear H H2; intro;\n        apply (divide_0_r z H H0 H1); clear H H2; intro;\n        apply (divide_0_r z H H0 H1); clear H H2; intro;\n        apply (divide_0_r z H H0 H1); clear H H1; intro;\n          apply (divide_0_r z H H0 H1); clear H H0; intro;\n          [ rewrite H0 in H1; rewrite Zmult_0_l in H1; rewrite <- H1 in H1;\n            elim (Z_le_dec z 0); intro;\n              [ unfold is_power; intuition; exists x; intuition\n                | split; [ apply Zlt_le_weak; assumption | auto with * ] ]\n              | apply Zlt_le_weak; apply Zlt_le_weak; assumption ] ]\n          | apply Zlt_le_weak; apply Zlt_le_weak; assumption ]\n       Qed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ") \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nreflexivity.\nsimple induction m.\nsimpl in |- *.\napply plus_n_O.\nintros.\napply plus_n_O.\nintros.\napply plus_n_Sm.\nsimpl in |- *.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plusSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nreflexivity.\nintros.\nsimpl in |- *.\nrewrite plus_n_Sm.\nrewrite H0.\nreflexivity.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nintros.\nsimpl in |- *.\nauto with arith.\nintros.\nsimpl in |- *.\nauto with arith.\nintros.\nsimpl in |- *.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim H; intros.\nexists x0; auto with arith.\nelim H0; intros.\nexists x0; auto with arith.\nelim H0; intros.\nexists x0; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelim H1; intros.\nexists x1; auto with arith.\nelimSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n; auto with arith.\nintros; elim (plus_n n0 n0); auto with arith.\nintros; elim (plus_n n0 n0); auto with arith.\nintros; elim (plus_n n0 n0); auto with arith.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nintros.\napply le_plus_trans with (m := n).\napply plus_comm.\napply le_plus_l.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nauto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nintros.\nsimpl in |- *; auto with arith.\nSave Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nintros m n H; elim H; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nintros.\napply Plus_n_O.\napply Plus_n_O.\napply Plus_n_O.\napply (Plus_n _ _ (Plus p m) (Plus p m) (Plus p m)); auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n m p H; elim H; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nintros n m p H; elim H; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simple induction p; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nsimple induction 1; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nintros.\napply Plus_n_O.\napply Plus_trans.\napply plus_n_Sm.\nchange (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(S(SSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nsimple induction 1; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nintros; apply (IHO _ H0).\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simple induction 1; intros; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; intros; auto with arith.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nintros; elim p; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\npattern t at 1 in |- *; rewrite <- (plus_comm n v).\nchange (double v) with (succ (node t u)).\nchange (double v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succ (node t u)).\nchange (succ v) with (succSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v.\npattern t at 1 in |- *; replace t with (bin (size u) (tl v)) by ring.\nrewrite H; auto.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\npattern t at 1 in |- *.\nrewrite H; auto with arith.\npattern (node t u) at 1 in |- *.\nrewrite H; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim (max_eq_dec t v); auto with arith.\napply (le_lt_eq_dec t v); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros t u v; elim u; simpl in |- *; auto with arith.\nintros t u v H; elim H; simpl in |- *; auto with arith.\nintros t u v; elim v; simpl in |- *; auto with arith.\nintros u v; elim v; simpl in |- *; auto with arith.\nintros u v; elim v; simpl in |- *; auto with arith.\nintros u v H; elim v; simpl in |- *; auto with arith.\nintros u v H; elim v; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim (size_sup_inf_sup n v); simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "R l3' b'))\n      end\n  | _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 763,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\nProof.\nassert (TT := normal_sub_trans _ _ _ _ (normal_norm nsBA)).\n(* Here we want to use the conclusion of the lemma *)\napply (normal_sub_normal nsBA).\n(* Here we do not need to do that the IH *)\napply (normal_normal nsBA).\n(* Here we do the IH *)\napply (normal_normal nsBA).\n(* Here we do the IH *)\napply (normal_proper nsBA).\n(* Here we do the IH *)\napply (normal_normal nsBA).\n(* First we do the IH *)\napply (normal_normal nsBA).\n(* First, we do the IH *)\napply (normal_normal nsBA).\n(* First, we do the IH *)\napply (normal_normal nsBA).\n(* First, we do the IH *)\napply (normal_normal nsBA).\n(* First, we do the IH *)\napply (normal_normal nsBA).\n(* Now we do the IH *)\napply (normal_normal nsBA).\n(* First, we do the IH *)\napply (normal_normal nsBA).\n(* First, we do the IH *)\napplySave solution'_b.",
                    "Goal solvable b.\nProof.\nunfold b, b, b, b, c.\nreflexivity.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\n(* This one is not needed for the way to do this to do this by *)\napply normal_sub; simpl in |- *; try (apply contra; simpl in |- *; tauto).\n(* The following line is not needed for the name of the proof uses to do it *)\napply normal_sub; simpl in |- *; try (apply contra; simpl in |- *; tauto).\n(* Here is the fact that it's actually the proof as it is still a\n    proof of the name of the name of the proof that we do not need the proof that we can do\n      the following case, the proof that the proof that the name is already been wrong. *)\napply normal_normal; simpl in |- *; try (apply And; simpl in |- *; tauto).\n(* The following line is, we can do this by case,\n    we do the following are the name of the proof of the proof that the name\n    is not needed for the name of the name of the name, and we do not change\n    the name of the name of the name. *)\nLemma normal_form_correct:\n  forall (b : Quote) (c : semC),\n    c <> c ->\n    c <> c ->\n    (cSave solution'_b.",
                    "Goal solvable b.\nProof.\nchange (` # # #) # # <- _ _ _ # (? # _) # _ _ # (> # _)).\nreflexivity.\nSave solution'_b.",
                    "Goal solvable b.\neexists; unfold b; apply: subset_trans.\n(* The first (R a b) = (R a b) = (R a b) *)\n(* Here we do not need to do this? *)\n(* this is to do this? *)\n(* We do not need to do the following: *)\nGoal forall (b : Quote) (e : expr) (b : vari) (e' : expr) (t' : ty),\n        typeof e' = ty' ->\n        closed' (e' :: e) b ->\n        closed' (e :: e) b ->\n        closed' (e :: e') b ->\n        closed' (e :: e') b ->\n        closed' (e :: e') b.\nintros.\nFail apply H.\n(* The first (R a b) = (R a b) *)\n(* We do this? *)\n(* The first (R a b) = (R a b) *)\n(* Note that the first (R a b) = (R a b) = (R a b) *)\n(* we do this? *)\n(* this is the first (R a b) = (R a b) *)\n(* itSave solution'_b.",
                    "Goal solvable b.\nunfold solvable; simpl in |- *.\n(* . *)\nunfold b in |- *; unfold b in |- *; unfold b in |- *; unfold b in |- *;\nunfold b in |- *; unfold b in |- *;\nunfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\nunfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *; \n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfold b in |- *; unfold b in |- *;\n unfoldSave solution'_b.",
                    "Goal solvable b.\nintro.\nFail apply H.\n(* Check the variable in a variable, even though the variable in the goal. *)\nexact I.\n(* Check the variable in a variable (in type of the variable) *)\nexact I.\n(* Check the variable in a variable (in type of the variable). *)\nexact I.\n(* Check the variable of the variable in a variable (in type of the variable) *)\nexact I.\n(* Check the variable in a variable (in type of the variable) *)\nexact I.\n(* Check the variable of the variable of the variable (in type of the variable). *)\nexact I.\n(* Check the variable of the variable (in type of the variable) *)\nexact I.\n(* Check the variable in a variable (in type of the variable) *)\nexact I.\n(* Check the variable (in type of variable) in a variable (in type of the variable) *)\nexact I.\n(* Check the variable (in type of a variable) in the variable (in type of the variable) *)\nexact I.\n(* Check the variable of the variable in a variable (in type of the variable) *)\nexact I.\n(* Check theSave solution'_b.",
                    "Goal solvable b.\nProof.\nunfold b, b.\nreflexivity.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\npose (c := 'X^c).\npose (c := 'X^c).\npose (c := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (y := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (x := 'X^c).\npose (Save solution'_b.",
                    "Goal solvable b.\nProof.\nFail unfold b, b, b, b, c, d, _ *)\nFail simpl; apply sym_equal.\nSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 758,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nunfold micicular_1, micicular_1.\nunfold micLocation_1, mic HST_2.\nunfold mic rephalare_{n, mimulate}, micvecsp}, micicular_1.\nunfold micVOL, mimorical_).\nunfold mic stsep, micension.\nunfold micicular_1, micLocation_2.\nunfold mic FROse finish_1, micomorphic_2.\nunfold micVOL, mim\u2228ise...\nunfold micOREeritional_1, mimABLE_1.\nunfold micVOL, mimABLE_1.\nunfold micVOL, mimiddle.\napply mimpossible_image.\nintros (b, ofs).\nunfold micVOL, mimately_1.\nunfold mic invertable_2.\nunfold mimABLE_1.\nunfold micVOL_2.\nunfold micbered_product, micVOL_1.\napply mimpossible_image.\nintros (b, ofs).\nunfold micbered_product, mimABLE_1.\nsimpl in |- *.\nunfold micothckSave microban_1_solution.",
                    "Goal solvable microban_1.\napply: (Build_abelian_stable _ _) => idtac.\napply: (Build_abelian_stable _ _) => idtac.\napply: (Build_abelian_stable _ _) => idtac.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexact I.\nexactSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micangular_1, mic reph_at.\nunfold mic reph_at.\nintros.\napply H.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micangular_1.\nunfold mic latestanulation_1.\nunfold micbered_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_points_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_neq_eq_neq_neq_neq_neq_neq_neq_neq_eq_neq_neq_neq_neq_neq_neq_neq_neq_eq?neq_neq_eq?neq_neq_neq_neq_neq_eq?X_neq_neq_neq_neq_neq_neq_neq?X_neq_neq_neq?Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micicular_1.\nunfold micoth_1.\nunfold micicular_1.\nunfold micVOL in |- *.\nunfold mic stsep in |- *.\nunfold micield in |- *.\nunfold micVOL in |- *.\nunfold micVOL in |- *.\nunfold micATE in |- *.\nunfold micATE in |- *.\nunfold mictryif_1 in |- *.\nunfold micVOL in |- *.\nunfold micLocation in |- *.\nunfold micitional in |- *.\nunfold micPrime in |- *.\nunfold miclose in |- *.\nunfold micATE in |- *.\nunfold micomorphic_1 in |- *.\nunfold micvecsp in |- *.\nunfold micvecsp in |- *.\nunfold micvecsp in |- *.\nunfold micVOL in |- *.\nunfold micimes in |- *.\nunfold micasles in |- *.\nunfold mictryif_1 in |- *.\nunfold micvecsp in |- *.\nunfold micvecsp in |- *.\nunfold micplicit_1 in |- *.\nunfold mic)/\\~(timesOimately_1).\nunfold micVOL in |- *.\nunfold micSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic?.\nunfold mic locBTgtnil.\nunfold micyour_definition.\nunfold micTORO.\nunfold micgest_to_1.\nunfold micPrime.\nunfold micangular_to_1.\nunfold micbered_points.\nsimpl in |- *.\n(* The name is that the name is actually a problem *)\napply STEP with (cf := (C -> False)).\n(*\nunfold micister, micipleally possible to make it *)\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (C -> False)).\n(*\napply STEP with (cf := (Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micicular_1, mic stsep_at in |- *.\nintros.\nFail apply paradox.\n(* This works because the global fails here *)\nFail apply paradox.\n(* The next example is not used to prove the equality *)\nFail apply paradox.\n(* The following is not needed, because the name is not needed *)\nFail apply paradox.\n(* The first one should be needed, because the name is *)\nFail apply paradox.\n(* The next line is not needed, because the name is not needed. *)\nFail apply paradox.\n(* The next one is used in the following command is not needed. *)\nFail apply paradox.\n(* The following was failing in 8.4pl2 (the bug #10) *)\nFail apply paradox.\n(* The command is not used in 8.4pl3 (the bug #14) *)\nFail apply paradox.\n(* The following was not used in 8.4pl3 (The paradox was not needed). *)\nFail apply paradox.\n(* The following was not used in 8.4pl5 (the bug #19) *)\nFail apply paradox.\n(* The first part of a \"Prop\" (the bug #180)Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micitional at 1 in |- *.\napply Sym.\n(* The following lemma were the easy form,\n   it should be reuned as the next line,\n   but it is not an argument of the \"normal\"\n   in the \"normal\" (and [apply (H <| _) | fail 1])\n   and [apply (H <| _) | fail 1 ]\n   and [apply (H <| _) | fail 1 ]\n   and [apply (H <| _) | fail 1 ]\n   ].\n\nCheck (mic\\{mO} (S mO)).\n(* The following lemma is the problem is the bug of 8.5 *)\n\nLemma paradox : False.\nunfold not in |- *; intro.\napply H.\nSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micVOL in |- *.\nintros.\nFail apply H.\n(* No check that micquireing from the\n   \"a\" variable \"b\" *)\napply (Build_Setoid (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (T:=T) (t:=T) (T:=T) (t:=T) (T:=T) (T:=T) (t:=T) (t':=T) (t':=TSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold mic''':\nunfold mic^'('C_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G_G.\nintros.\nunfold micicular_1.\nunfold micVOL.\nunfold mic stsep_1.\nunfold miciddle.\nunfold micicular_1.\nunfold micoth_1.\nunfold micVOL.\nunfold micVOL.\nunfold miciddle.\nunfold miciddle.\nunfold micTOR_1.\nunfold micVOL.\nunfold micVOL.\nunfold micVOL.\nunfold mic received.\nunfold micSEPARATION_at.\nunfold mic received.\nunfold micomorphic_1.\nunfold micvecsp.\nunfold micVOL.\nunfold micgoingate.\nunfold mic received a.\nunfold mic received a.\nunfold micGN.\nunfold micVOL.\nunfold micaration.\nunfold micgoingate.\nunfold mic received a.\nunfoldSave microban_1_solution."
                ]
            }
        ],
        "goedel": [
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": "\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 9996,
                "proof_end_offset": 10123,
                "proof": "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros; unfold codeOr, condition.\n destruct a, b; auto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros a b.\nunfold codeIf.\nsimpl.\nrewrite <- (map_map_id (fun x => x) (fun x => x)).\nreflexivity.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\n intros a b.\n unfold codeAnd.\n now rewrite (sem_cmp_eq _ _ (sem_cmp_eq _ _ (sem_cmp_eq _ _ (sem_cmp_eq _ _ _ (sem_cmp_eq _ _ _ _ (sem_cmp_eq _ _ _ b)))))).\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nchange (negb (negb (negb (negb (negb (negb (negb (negb (negb (negb b))) (negb b))) (negb b))) (negb b)))\n  in H.\nunfold reduce.\napply cPairEq.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros; unfold codecontra; simpl.\n case (decide (negb (negb (negb (negb (negb (negb b)))) (negb b))); case (decide (negb (negb (negb b))) (negb b)); case (decide (negb (negb b))) (negb b))); \n  case (decide (negb (negb (negb (negb (negb b))) (negb b))); \n  case (decide (negb (negb (negb (negb b))) (negb b))); \n  case (decide (negb (negb (negb b)) (negb b))); \n  case (decide (negb (negb (negb (negb b))) (negb b))); \n  case (decide (negb (negb (negb b))) (negb b))); \n  case (decide (negb (negb (negb b)) (negb b))); \n  case (decide (negb (negb b))) (negb b)); \n  case (decide (negb (negb (negb b))) (negb b)); \n  case (decide (negb (negb b)) (negb b)); \n  case (decide (negb (negb (negb b))) (negb b))); \n  case (decide (negb b)) (negb (negb b))); \n  case (forallb (negb (negb b)) (negb (negb b)));Qed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10202,
                "proof_end_offset": 10332,
                "proof": "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b.\nunfold codeAnd.\nrewrite <- (map_id (fun x => negb (negb (negb (negb b))) (negb b)).\nreflexivity.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b.\nunfold comparisonAnd.\nrewrite (fun x => negb_involutive (negb_involutive (negb_involutive (negb_involutive (negb b))).\nrewrite (fun x => negb_involutive (negb_involutive (negb b))).\nrewrite (fun x => negb_involutive (negb_involutive (negb b))).\nreflexivity.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\ngeneralize (eval_op a b); clear a b.\ninduction a; simpl; auto.\napply bool_of_bool_true_iff; auto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b.\ngeneralize b.\ninduction a; simpl; auto.\nrewrite <- a; auto.\nrewrite <- a; auto.\nrewrite <- b; auto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros a b.\nunfold codeOr.\ncase_eq (formSeq a b); intros; try discriminate.\nrewrite (formOr a).\nrewrite (formOr a).\nrewrite (formOr a).\nreflexivity.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nintros.\nunfold codeAnd, negb, b, b.\nrepeat (rewrite (negb_involutive); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\nLemma codeAndCorrect :\n forall a b : Formula,\n codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.\n\nDefinition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10406,
                "proof_end_offset": 10536,
                "proof": "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b.\nunfold codeAnd.\nsimpl.\nrewrite <- (if_bool _ _ then false else false).\nreflexivity.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros.\nrewrite <- (BoolOr a b).\nreflexivity.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b.\nunfold codeOr, resultAnd, resultAnd, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, result, resultQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nintros a b; unfold codeAnd.\ncase (opOr (codeArrow b) (code Bool b)) (code Bool b) as (c,d).\nintros (H1,H2) (H3,H4); subst.\nchange (negb (negb (negb (negb (negb (negb b))) && negb (negb (negb b))) && negb (negb (negb (negb b))) = negb (negb b))) in H3;\n simpl in H3; rewrite H4; trivial.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\n auto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "\napply cPairPi2IsPR.\napply pi2_2IsPR.\napply eqIsPR.\napply pi3_3IsPR.\napply pi1_3IsPR.\napply switchIsPR.\napply switchIsPR.\napply\n filter1100IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 12173,
                "proof_end_offset": 12326,
                "proof": "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply isPR.\napply cPairIsPR.\napply cPairIsPR.\napply cPairIsPR.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_ass.\napply is_Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply r2IsV.\napply r2IsV.\napply r2IsV.\napply r2IsV.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply\n (fun (t : nat) (T : term) (x : term) => t x).\napply cPairCoCoCons.\napply cPairCoCons.\napply cPairCoCons.\napply cFunctorCoCons.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nunfold isPR.\napply\n (Build_is_ass (Build_is_ass (Build_is_ass (Build_ass (Build_ass (Build_ass (Build_ass (Build_ass (Build_ass (program_of_and_comp?sia)))));\n [ apply cProd; simpl in |- *; intros; auto | idtac ]).\napply cProd.\napply (Build_is_ass (Build_ass (Build_ass (Build_ass (Build_ass (Build_ass (Build_ass (program_of_and_comp?sia)))));\n [ apply cProd; simpl in |- *; intros; auto | idtac ]).\napply cProd.\napply (Build_is_ass (Build_ass (Build_ass (Build_ass (Build_finiteT (lt_S (cLen)))));\n [ apply cProd; simpl in |- *; intros; auto | idtac ].\napply cProd.\napply cProd.\napply (Build_is_ass (Build_ass (Build_finiteT (lt_S (cLen)))));\n [ apply cProd; simpl in |- *; intros; auto | idtac ].\napply cProd.\napply (Build_Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply cPairCoCoL.\napply cPairCoL.\napply cPairCoL.\napply cPair CoL.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1))))))))))).\napply (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1))))))))))).\napply (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1))))))))))).\napply (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1)))))))))).\napply (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1 (Build_isPR 1))))))).\napply (Build_isPR 1 (Build_isPR 1Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply s2IsPR.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply s2IsPR.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s1IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s1IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2IsCons.\napply s2Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply\nisrisisrisisisisrisisisisrisisis.\napply\n(isrisisisisisisisisisisisisisisisisisisisisis.\napply\n(isrisisisisisisisisisisisisisisisisisisisisisis.\napply\n(isrisisisisisisisisisisisisisisisisisisisisisoisisisisisoisisisisisiso).\napply\n(isrisisisisisisisisisisisisisisisisisisisisoo).\napply\n(isrisisisisisisisisisisisisisisisisisisisisisoisisisisisoo).\napply\n(isrisisisisisisisisisisisisisisisisisisisoisisisoo).\napply\n(isrisisisisisisisisisisisisisisisisisisisisisisisisisisoisiso).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\nLemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 12328,
                "proof_end_offset": 12484,
                "proof": "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi2IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold isPR 2, isPR 2 in |- *; auto.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold rsIsL in |- *.\napply r2IsCons.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeCoqu, sRec maxNL in |- *.\napply cPairEqCoLIsPR.\napply cPairPi1IsCons.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeIsL in |- *.\napply cPairIf.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubcon, isPR 3 (fun t : nat => t).\napply cPairCoSubAnd.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold commandIsL, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV, s256IsV,s256IsV,s256IsV,s256a_8.\nintros.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in H.\ninversion H.\nsimpl in HQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd).\napply sProd_morph2IsL.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd in sProd, sProd, sProd, sProd, sProd, sProd, sProd, sProd in sProd, sProd, sProd, sProd in sProd, sProd, sProd).\nintros.\napply cseq_1.\napply cseq_2.\napply cseq_2.\napply cseq_2.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeCoqu, shelved in |- *.\napply sCoodia.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj,sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj,sInj, sInj, sInj, sInj, sInj, sInj,sInj, sInj, sInj, sInj, sInj, sInj,sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInj, sInjQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 226,
                "proof_end_offset": 385,
                "proof": "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction a; simpl; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct a, b; simpl; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  refine (fix iter (n : nat) (a b : TERMFunc n) : Prop :=\n  match n with\n  | O => True\n  | S n => a = a /\\ b = b\n  end).\n\nLemma ex_intro : forall (n : nat) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a b :|})) (a *|})) (a b :|})) (a b :|})) (a *|})) (a *|})) (a *Lmer (comm a b) (Lmer (comm a b) (comm b))) a)\n                          (b + b) (b + b) (b + b)).\nProof.\n  intros; apply ex_intro; intros.\n  apply H.\n  apply (H b a0 b0 b1).\n  apply (H b0 b0 b1).\n  apply (H b0 b1).\n  apply (H b0 b1).\n  apply (H b0 b1).\n  apply (H b0 b1).\n  apply (H b1).\n  apply (H bDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros n a b.\ninduction n; simpl in |- *; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\ndestruct a; destruct b.\ndestruct b.\nleft; exact I.\nright; exact I.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  refine (Build_PreCategory (equiv (S n) (S n) (S n) a)).\nintros.\nrefine (Build_PreCategory (equiv (S n) (S n) (S n) a)).\nclear.\nelim a.\napply refl_equal.\napply sym_equal.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction n.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)\n  simpl.\n  (* 0 *)Defined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct a, b; constructor; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  refine (Build_PreCategory (fun m => a = b) (fun m => a = b)).\n\nDefinition nat_path (n : nat) : nat_path n nat_path.\n  refine (Build_PreCategory (fun m => a = b) (fun m => a = b)).\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction n.\n  - exact (fun a b => a = b) (fun a b => b = b).\n  - exact (fun a b => a = b) (fun a b => a = b).\n  - exact (fun a b => a = b) (fun a b => a = b) (fun a b => a = b)).\n  - exact (fun a b => a = b) (fun a b => a = b).\n  - exact (fun a b => a = b) (fun a b => a = b)).\n  - exact (fun a b => a = b) (fun a b => a = b).\n  - exact (fun a b => a = b).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\n",
                "context_tokens": 134,
                "proof_start_offset": 387,
                "proof_end_offset": 569,
                "proof": "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = a).\nexact (a = a).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = a).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n.\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\ninduction n as [| n Hrecn].\nexact (a = a).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = a).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\nLemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.\n\n",
                "context_tokens": 197,
                "proof_start_offset": 571,
                "proof_end_offset": 810,
                "proof": "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nsymmetry in |- *.\napply H.\nsimpl in |- *.\nintros.\napply Hrecn.\nsimpl in H.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintros.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply H.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\napply (a = b).\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintros.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros n a b.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintros.\napply IHn.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintros.\napply IHn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " unfold not in |- *; intros; elim b0.\ninversion H.\nreflexivity.\ninduction (b r r0).\nassert\n (forall (f g : Relations L) (p : f = g) (ts : Terms (arity L (inl _ f)))\n    (ss : Terms (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 8985,
                "proof_end_offset": 9141,
                "proof": "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nunfold lt_depth in |- *.\ninduction H; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros.\ninduction A.\napply lt_wf with (length (extendH A B)).\nrewrite plus_comm.\nrewrite plus_comm.\ntrivial.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros.\nunfold lt_depth in |- *.\nsplit.\nintros x y z Hxy Hyz.\napply le_trans with (S x).\napply le_trans with (S y).\napply le_n.\nassumption.\napply le_trans with (S y).\napply le_n.\nassumption.\napply le_trans with (S y).\napply le_n.\nassumption.\napply le_trans with (S y).\napply le_n.\nassumption.\nassumption.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A.\nsimpl; tauto.\nsimpl; tauto.\nsimpl; tauto.\nsimpl; tauto.\nsimpl; tauto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B H.\ninduction H.\nsimpl; auto.\ninversion H.\nsimpl; auto.\ninversion H.\nintros.\ninversion H.\nsimpl; auto.\ninversion H.\nsimpl; auto.\ninversion H.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nunfold lt_depth in |- *.\ninduction B.\nintros.\napply le_lt_trans with (length (le_length A B)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans with (length (le_length B A)).\napply le_trans withQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth, lt_depth, le_depth, le_depth, le_depth.\nintros A B H.\ninduction H.\nauto.\napply le_trans with (max (depth A) (Max B)); auto.\nomega.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nunfold lt_depth, le_depth in |- *.\ninduction H.\nleft.\napply lt_le_trans with (S (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (cardinal A) (max (depth A) (max (depth A) (max (cardinal A) (max (depth A) (max (cardinal A) (max (cardinal A) (max (depth A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nunfold lt_depth in |- *.\nunfold lt_depth in |- *.\nsplit.\nintros.\ninduction H.\nunfold lt_lemma in |- *.\nunfold lt_inc in |- *.\nsimpl in |- *.\nunfold lt_inc in |- *.\nunfold le_h in |- *.\nunfold le_h in |- *.\nunfold le_h in |- *.\nunfold le_h in |- *.\nunfold le_h in |- *.\nunfold le_h in |- *.\nsimpl in |- *.\nunfold lt_h in |- *.\nunfold le_h in |- *.\nintros.\ninversion H.\napply H1.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nintros A B.\nunfold lt_depth in |- *; intros.\napply lt_le_trans with (S (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B)))).\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": "s (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 9143,
                "proof_end_offset": 9299,
                "proof": "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (le_max (depth A) (depth B) < max (depth A) (depth B)).\napply le_max_r.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) ( License B))).\napply max_l.\napply max_l.\napply max_r.\napply max_l.\napply max_r.\napply max_l.\napply max_l.\napply max_r.\napply max_r.\napply max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) (cardinal B) + max (cardinal B) (cardinal B))).\napply max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) ( License B))) by auto.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (max (depth A) (cardinal B)).\napply max_l.\napply max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (length (extendH A B)).\napply max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) ( License B))).\napply max_l.\napply max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B))))\n   (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B)))\n   (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B) (max (depth B)))\n   (max (cardinal B) (max (depth B) (max (depth B) (max (depth B)))\n   (max (cardinal B) (max (cardinal B) (max (depth B) (max (cardinal B) (max (cardinal B) (max (height B) (max (used B)))))\n  (max (size B) (max (cardinal B) (max (cardinal B)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ".\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 9301,
                "proof_end_offset": 9401,
                "proof": "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (max (depth A) (cardinal B))) (max (cardinal B) (cardinal B))).\napply le_max_r.\napply le_max_r.\napply max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) (depth B)) (cardinal A)).\napply le_max_l.\napply le_max_l.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) (depth B)).\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (cardinal A) (max (depth A) (max (depth A) (max (cardinal A) (max (depth A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (Qed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (height A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (max (cardinal A) (Qed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (max (depth A) (size A))).\napply max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (1 := H).\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (max (depth A) (diff_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_dist_Qed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 9403,
                "proof_end_offset": 9523,
                "proof": "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros A v.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S v).\napply le_max_l.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S v) (S v).\nassumption.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (length v)).\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros.\napply le_trans with (fun t : Stream A => (fix lt_length_elements_elements_aux (n : nat) : Prop :=\n             match n with\n             | O => False\n             | S n' => n' <= S n'\n           end) v.\napply le_trans with (fun t : Stream A => (fix lt_length_elements_aux (n : nat) : Prop :=\n             match n with\n             | O => False\n             | S n' => n' <= S n'\n           end) v.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_trans with (S (length v) + 1).\napply plus_le_compat_r.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\napply plus_le_compat_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_trans with (S (length v)).\napply plus_le_compat_l.\napply le_max_l.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nintros A v.\ninduction v.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_trans with (length v) (length v).\napply le_max_r.\napply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 9525,
                "proof_end_offset": 9687,
                "proof": "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_le_S.\napply le_max_r.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply le_max_l.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros A B C H.\napply lt_le_trans with (S (length A) - S (length B)).\napply lt_n_S.\napply lt_le_trans with (length B - S (length B)).\napply lt_n_S.\napply lt_le_trans with (length C - S (length B))).\napply lt_n_S.\napply le_plus_trans with (S (length B - S (length B))).\napply lt_n_S.\napply le_trans with (S (length B - S (length B))).\napply lt_n_S.\napply le_trans with (length C - S (length B)).\napply le_n_S.\napply le_trans with (length C - S (length B))).\napply lt_n_S.\napply le_trans with (S (length B - S (length B))).\napply le_n_S.\napply le_trans with (length C - S (length B)).\napply le_n_S.\napply le_trans with (length C - S (length B)).\napply le_n_SQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C.\nelim n.\nsimpl in |- *.\nintros.\napply le_lt_trans with (S (max (depth A) (max (depth A) (max (depth B) (max (depth A) (max (depth B) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (depth A) (max (used A) (max (depth A) (max (depth A) (max (depth A) (max (size A) (max (depth A) (max (depth A) (max (depth A) (max ( bound A) (max (cardinal A) (max (cardinal A) (max (depth A) (max (depth A) (max (length A) (max (cardinal A) (max (cardinal A) (max (depth A) (max (height A) (max (cardinal A) (max (cardinal A) (Qed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C H.\nelim H using lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_wf_ind.\napply lt_Qed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros A B C H.\napply lt_wf_ind with (A := A) (B := C) (C := A) (D := A) (l := l); auto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C H.\nelim H using lt_lemma.\napply lt_le_trans.\napply lt_le_weak.\napply le_max_l.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply le_trans.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply lt_le_weak.\napply le_trans with A.\napply le_trans with A.\napply le_trans with A.\napply le_trans with B.\napply le_trans with A.\napply le_trans with B.\napply le_trans with B.\napply le_trans with A.\napply le_trans with B.\napply le_trans with A.\napply le_trans with B.\napply le_trans with A.\napply le_trans with A.\napply le_trans with A.Qed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_le_S.\napply le_max_l.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_le_n_Sm.\napply le_max_l.\napply le_max_l.\napply le_max_l.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros A B C H.\napply eq1234.\napply le_lt_n_Sm.\napply le_max_r.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nintros A B C.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply lt_le_S.\napply le_max_l.\napply le_max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ") f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma eqDepth :\n forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 9689,
                "proof_end_offset": 10147,
                "proof": "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H n.\ninduction n as [| n Hrecn].\nintros.\napply H.\nintros.\nunfold lt_depth in H1.\nrewrite <- (le_n_O_eq _ H0) in H1.\nelim (lt_n_O _ H1).\nintros.\napply H.\nintros.\napply Hrecn.\napply lt_n_Sm_le.\napply lt_le_trans with (depth b).\napply H1.\napply H0.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply lt_wf_ind with (P := fun a b => forall b : Stream, le_depth b (P b)).\ntrivial.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\napply lt_wf with (m := n) (b := b) (c := b) (d := b) (d := b) (t := c).\napply le_trans with (m := n) (c := b) (c := d) (t := c) (d := c) (t := c) (t := c).\napply le_trans with (m := n) (c := d) (t := c) (t := c) (t := c).\napply le_trans with (m := n) (c := d) (h := c) (t := c) (t := c) (t := c) (t := c).\napply le_trans with (m := n) (c := d) (t := c) (t := c) (t := c) (t := c) (t := c) (t := c) (t := c) (t := c).\napply le_trans with (m := n) (c := d) (t := c) (t := c) (t := c) (t := c) (t := c).\napply le_Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply H.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite <- H.\nassumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite <- H.\nassumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply lt_le_n_S.\napply lt_le_trans with (S (max (depth A) (max (depth A) (max (depth A) b))).\napply lt_le_trans with (max (depth A) (max (depth A) (max (depth A) b)).\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_max_r.\napply le_max_r.\napply le_max_r.\napply le_max_l.\napply le_Defined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite <- H.\nreflexivity.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply (H (Build_Map _ P)).\nexact (fun n : nat => plus_one (two_power_nat n) (two_power_nat n)).\nexact (fun n : nat => plus_one (two_power_nat n) (two_power_nat n)).\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H.\napply eqsigT_induction with (P := fun b => forall b : classic, P b -> P b) (h := fun b => forall b : bool, P b -> P b) (h' := fun b => forall b : bool, P b -> P b) (h' := fun b => forall b : bool, P b -> P b) h'\n    (H' : forall b : bool, P b -> P b -> P b) (h' := fun b => forall b : bool, P b -> P b)\n    (H' : forall b : bool, P b -> P b -> P b) (H' : forall b : bool, P b -> P b),\n      forall (b : bool), P b -> P b.\nProof.\nintros P H.\napply eqsigT_induction with (P := fun b => forall b : bool, P b -> P b) (h' := fun b => forall b : bool, P b -> P b) h';\ntry assumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\nrewrite <- H.\nassumption.\nDefined."
                ]
            }
        ],
        "zorns-lemma": [
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " Import Eqdep.\napply inj_pair2 in H2.\ndestruct H2.\napply H3.\nQed.\n\nLemma ord_le_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta <= gamma -> alpha <= gamma.\nProof.\ninduction alpha.\ninduction beta.\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4386,
                "proof_end_offset": 4594,
                "proof": "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with d; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (1:= H).\napply lt_le_trans with (1:= H).\napply le_lt_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_lt_trans with (1:= H).\napply le_trans with (2:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (2:= H1).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (2:= H0).\napply le_trans with (1:= H).\napply le_trans with (2:=Qed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d - beta); trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\ndestruct (le_lt_dec alpha beta).\ndestruct (le_lt_dec alpha beta).\ndestruct (le_lt_dec alpha beta).\ndestruct (le_lt_dec alpha beta).\nrewrite e.\nrewrite e.\nrewrite e.\napply trans_equal with (1 := H); trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (d1:=d2); trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (1:= H).\napply lt_le_trans with (1:= H).\napply le_lt_trans with (1:= H).\napply le_trans with (1:= H).\napply le_trans with (2:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (2:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= H).\napply le_max_r.\napply le_trans with (1:= HQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (lt_le_trans _ _ _ H).\napply lt_le_trans with (1:=lt_le_trans _ _ _ H).\napply lt_le_trans with (1:=le_trans _ _ H).\napply lt_le_trans with (1:=lt_le_trans _ _ _ H).\napply lt_le_trans with (1:=lt_le_trans _ _ H).\napply lt_le_trans with (1:=lt_le_trans _ _ _ H).\napply lt_le_trans with (1:=lt_le_trans _ _ _ H).\napply le_trans with (1:=le_trans _ _ _ H).\napply le_trans with (1:=le_trans _ _ _ H).\napply lt_le_trans with (2:=lt_le_trans _ _ _ H).\napply le_trans with (1:=le_trans _ _ _ H).\napply le_trans with (2:=le_trans _ _ _ H).\napply le_trans with (2:=lt_le_trans _ _ _ H).\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (d1:=delta); trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (le_lt_trans _ _ _ H).\napply le_lt_trans with (le_lt_trans _ _ _ H).\napply le_lt_trans with (le_lt_trans _ _ _ H).\napply le_lt_trans with (le_trans _ _ _ H).\napply le_lt_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply le_lt_trans with (le_trans _ _ _ H).\napply le_lt_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply le_lt_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply le_trans with (le_trans _ _ _ H).\napply leQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d1:=d2); trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": ".\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4596,
                "proof_end_offset": 4786,
                "proof": "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial; apply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (d1:=d2); trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d:=delta); trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (M1 := M2); trivial.\napply ord_lt_trans with (M2 := M2); trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_trans with (d := d); trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (d1:=delta); try omega.\napply ord_lt_trans with (d2:=delta); try omega.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply lt_le_trans with (R (1:=R)).\napply lt_le_trans with (2:=R).\napply lt_le_trans with (1:= R).\napply lt_le_trans with (2:=R).\napply le_trans with (2:= R).\napply le_trans with (2:=R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (1:= R).\napply le_trans with (1:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (2:= R).\napply le_trans with (1:= R).\napply le_trans with (1:= R).\napply le_trans with (2:=Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_trans with (d:=delta); trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d:=delta); try apply ord_lt_trans with (d:=delta); try apply ord_lt_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_lt_trans with (d:=delta); try apply ord_lt_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=d); try apply ord_le_trans with (d:=delta); try apply ord_le_trans with (d:=d); try apply ord_lt_trans with (d:=delta); try apply ord_le_trans with (d:=d); try apply ord_le_trans with (d:=d); try apply ord_le_trans with (d:=d); try apply ord_le_trans with (d:=d); try apply ordQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d - delta); trivial.\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (d := delta).\napply ord_lt_trans with (d := d).\napply ord_lt_trans with (d := d).\napply ord_le_trans with (d := d).\napply ord_le_trans with (d := d).\napply ord_lt_trans with (d := d).\napply ord_trans with (d := d).\napply ord_lt_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_trans with (d := d).\napply ord_transQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4788,
                "proof_end_offset": 4941,
                "proof": "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (d := d); try apply ord_lt_trans with (d := d); try apply ord_lt_trans with d; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply lt_le_trans with (lt_le_max beta).\napply lt_le_trans with (lt_le_max beta).\napply lt_le_trans with (2 := H).\napply lt_le_trans with (2 := H).\napply lt_le_trans with (2 := H).\napply lt_le_trans with (2 := H).\napply lt_le_trans with (2 := H).\napply le_trans with (2 := H).\napply le_lt_trans with (2 := H).\napply le_trans with (2 := H).\napply le_trans with (2 := H).\napply le_max_l.\napply le_trans with (2 := H).\napply le_trans with (2 := H).\napply le_max_r.\napply le_trans with (2 := H).\napply le_max_r.\napply le_trans with (2 := H).\napply le_max_l.\napply le_trans with (2 := H).\napply le_max_l.\napply le_trans with (2 := H).\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (d := ord_lt_trans _ (d:= ord_lt_path_min _ _ H)).\napply ord_lt_trans with (d:=d); trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (ordS (min beta delta)); trivial.\napply ord_lt_trans with (ordS (max beta delta)); trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (ordS (min i)); trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (d := d); trivial;\napply ord_lt_trans with (d := d); trivial;\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (d := d); trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (ordS (min beta (half_part (min beta (min beta (min beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max_signed (max beta (max_pdiv beta (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (max_signed (Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (d:=d); trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (ordS (min beta (half_part (min beta (min beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max beta (max_max beta (max beta (max_max beta (max_max beta (max_nat (max_max beta (max_max beta (max_max beta))))) d)).\napply ord_lt_trans with (max_le_max beta).\napply max_r.\nrewrite max_max_max_r.\napply max_r.\napply max_l.\napply max_l.\napply max_l.\napply max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\nLemma ord_lt_respects_succ: forall alpha beta:Ordinal,\n  alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4943,
                "proof_end_offset": 7301,
                "proof": "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\ninduction alpha.\ninduction beta.\ndestruct (IHalpha beta) as [|[|]].\nleft; apply ord_lt_respects_succ; trivial.\nright; left.\nsplit.\napply ord_le_respects_succ; apply H.\napply ord_le_respects_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_trans with (d := ord_enum_ord).\napply ord_trans with (d := ord_enum_ord).\napply ord_enum_ord.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_antisym.\napply ord_antisym.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_antisym.\napply ord_antisym.\napply ord_antisym.\napply ord_antisym.\napply ord_antisym.\napply ord_antisym.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_antisym.\napply ord_total_order; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order; intros.\napply ord_antisym; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_antisym.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_total_order.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\n\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\n\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\n\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\n\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 7303,
                "proof_end_offset": 7689,
                "proof": "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nred; intro alpha.\ninduction alpha.\nconstructor.\nintros beta ?.\napply ord_le_respects_succ_converse in H.\nconstructor; intros gamma ?.\ndestruct IHalpha.\napply H1.\napply ord_lt_le_trans with beta; trivial.\nconstructor; intros alpha ?.\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [j].\ndestruct (H j).\napply H1; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit; intros.\napply ord_refl.\napply ord_refl.\napply ord_trans with (min i); trivial.\napply ord_trans with (max i); trivial.\napply ord_lt_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans with (max i); trivial.\napply ord_trans withQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nconstructor; intros.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H0.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct H; subst.\ndestruct HQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply Build_founded_ind; intros.\ndestruct H as [? [??]].\napply ord_lt_le_trans with (o i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply wf_lt_trans.\napply wf_lt_trans.\napply wf_lex_ord_trans with (ord_wf ord_ord); trivial.\napply ord_wf_lex_ord_trans with (ord_wf ord_ord); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\napply wf_lex.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nconstructor.\napply ord_lt_trans with (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M:=M) (M) (M:=M) (M:=M) (M:=M) (M) (M:=M) (M:=M) (M) (M:=M) (M) (M:=M) (M) (M:=M) (M) (M:=M) (M) (M:=M) (M:=M) (M) (M:=M) (M) (M:=M) (M:=M) (M) (M:=M) (M:=M) (M:=M) (M) (M:=M) (M:=M) (M:=M) (M:=M) (M) (M:=M) (M:=M) (M) (M:=M) (M:=M) (M:=M) (M) (M:=M)Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nconstructor; trivial.\nintros.\napply ord_le_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nconstructor; intros; constructor; intros.\napply H0.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nconstructor.\nintros.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\napply ord_lt_trans with (o i); trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nconstructor; intros.\napply ord_refl.\napply ord_refl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\n",
                "context_tokens": 226,
                "proof_start_offset": 778,
                "proof_end_offset": 1010,
                "proof": "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set, Included, Same_set, Included, Same_set, Setminus, Empty_set, Empty_set; intuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set, Same_set.\napply Extensionality_Ensembles.\nunfold Same_set, Included, Same_set, In.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\napply Extensionality_Ensembles.\nunfold Same_set.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\n",
                "context_tokens": 305,
                "proof_start_offset": 1059,
                "proof_end_offset": 1278,
                "proof": "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nelim H.\napply H0.\ntrivial.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H0.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included, Included, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nunfold Included.\nintuition.\nunfold Included, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus, Setminus.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included in H.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\nLemma subfamily_union: forall F G:Family T, Included F G ->\n  Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.\n\n",
                "context_tokens": 374,
                "proof_start_offset": 1280,
                "proof_end_offset": 1506,
                "proof": "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nconstructor.\ndestruct H0.\nintros.\napply H0.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply intersection_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nunfold Included in |- *.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply subfamily_union.\nunfold Same_set.\nunfold Included, Included.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\napply -> Same_set_is_intersection.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H0.\napply H.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\napply subfamily_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply included_union.\napply includedQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply union_Union.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply subfamily_union.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nintros.\ndestruct H0.\napply intersection_domain_intro with S.\napply H.\napply H.\napply H.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros.\napply subfamily_union.\nunfold Same_set.\nintros.\ndestruct H0.\napply H.\nassumption.\nQed."
                ]
            }
        ],
        "coqrel": [
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "inter_refl : typeclass_instances.\n\nLemma rel_inter_corefl_l {A} (R1 R2: rel A A):\n  Coreflexive R1 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6671,
                "proof_end_offset": 6793,
                "proof": "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  unfold rel_on.\n  apply rel_impl_rel_rand.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  intros.\n  unfold rel_iff.\n  destruct x; destruct y; destruct z; simpl; auto.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 6891,
                "proof_end_offset": 7009,
                "proof": "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  intros.\n  destruct R1; destruct R2; destruct R2; simpl in *; try reflexivity.\n  apply rel_impl_rTrans with x y.\n  apply rel_impl_rel_rTrans with x y.\n  apply rel_impl_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with x y.\n  apply rel_iff_rel_rTrans with y.\n  apply rel_iff_rel_rTrans withQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 7147,
                "proof_end_offset": 7239,
                "proof": "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  constructor; intros x y; auto.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros x y [y Hxy].\n  destruct Hxy as [Hxy1 Hxy2].\n  destruct Hxy as [Hxy2 Hxy3].\n  destruct Hxy as [Hxy3 Hxy4].\n  destruct Hxy as [Hxy4 Hxy4].\n  destruct Hxy as [Hxy1 Hxy2].\n  apply Hxy1, Hxy3.\n  destruct Hxy as [Hxy2 Hxy4].\n  destruct Hxy as [Hxy2 Hxy4].\n  destruct Hxy as [Hxy4 Hxy4].\n  destruct Hxy as [Hxy3 Hxy4].\n  destruct Hxy as [Hxy4 Hxy8].\n  destruct Hxy as [Hxy8 [Hxy8 Hxy5]].\n  destruct Hxy as [Hxy8 Hxy8].\n  destruct Hxy as [Hxy8 [Hxy8 [Hxy8 Hxy8]].\n  destruct Hxy as [Hxy8 Hxy8].\n  destruct Hxy as [Hxy9 [Hxy8 [Hxy9 Hxy9]].\n  destruct Hxy as [Hxy8 [Hxy8 Hxy9]].\n  destruct Hxy as [Hxy8 [Hxy8 [Hxy8 Hxy8]].\n  destruct Hxy as [Hxy8 [Hxy8 [Hxy8 Hxy8]].\n  destruct Hxy as [Hxy8 [Hxy8 [Hxy8 Hxy9]].\n  destruct Hxy as [Hxy9 [Hxy8 [Qed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  intros.\n  apply rel_choice.\n  apply rel_choice.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 7326,
                "proof_end_offset": 7416,
                "proof": "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute; firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute; auto.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute; intuition.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute; intuition.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute. firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute; tauto.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  compute; firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 7595,
                "proof_end_offset": 7683,
                "proof": "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  compute; intuition.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  compute. firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  destruct (rel_bot_r_r_iff x) as [y0 y1]; destruct y0; simpl; auto.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  compute. tauto.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  compute; firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  compute.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8747,
                "proof_end_offset": 8901,
                "proof": "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  exists (fun x y => RAB x y /\\ RAB y x).\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_inverse_image.\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_trans with (rel_inverse R (rel_inverse R x y)).\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_inverse_image.\n  apply rel_Qed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  compute. firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  compute.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros.\n  unfold rel_compose.\n  destruct R.\n  exists (fun x => RAB x).\n  apply rel_trans with (rel_map R (rel_map R R)).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  apply rel_map_rel_map.\n  intros.\n  destruct R.\n  simpl.\n  exists (fun x => RAB x).\n  applyQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros; red; intros; subst; auto.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  intros; split; intros.\n  + intros; destruct x; simpl in *; auto.\n    + intros; destruct x; simpl in *; auto.\n    + intros; destruct x; simpl in *; auto.\n    + intros; destruct x; simpl in *; auto.\n    + intros; destruct x; simpl in *; auto.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  compute. firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8903,
                "proof_end_offset": 9058,
                "proof": "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\nLemma rel_compose_id_right {A B} (R: rel A B):\n  eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 9060,
                "proof_end_offset": 9315,
                "proof": "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " sum_rel R R (inl a) (inl b).\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n(** There is an issue with the following. *)\n\nGoal\n  forall A (a b: A) (R: rel A A) (f: A -> A) (p: A -> Prop),\n    Monotonic f (R ++> R) ->\n    Monotonic p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\n",
                "context_tokens": 685,
                "proof_start_offset": 2211,
                "proof_end_offset": 2462,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B R f x y.\n  (* No hypothesis *)\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n  (* No hypothesis *)\n  intros A B R f x y.\n Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  apply H.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B R x y f H.\n  pose proof (fun x => match x with inl a => b | inr b => x end).\n  pose proof (fun x => match x with inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr b => x end).\n  pose proof (fun x => match x with inl b => x | inr bQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  etransitivity.\n  eapply H.\n  eapply H.\n  eapply H.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B R f x y f.\n  (* The following two lemmas are in the context *)\n  match goal with\n    | [ H: f a = f a |- _ ] =>\n      let x := f x in\n      let y := f x in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y := f y in\n      let y :=Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B R f x y f.\n  rewrite <- (f x y).\n  rewrite <- (f x y).\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B R f.\n  pose (R' := fun x => match x with inl a => b | inr b => x end).\n  pose (R' := fun x => match x with inl b => y | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => x | inr b => x end).\n  pose (R' := fun x => match x with inl b => xQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  destruct H.\n  pose proof (H a).\n  rewrite <- H0.\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B f.\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (fun _ => B)).\n  pose proof (H a (Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  unfold dist.\n  destruct (f x y) as [x' y']; destruct (f y') as [y' y']; destruct (f y') as [y' y'];\n  destruct (f y') as [y' y']; destruct (f y') as [y'' y'';\n  destruct (f y') as [y'' y''; destruct (f y') as [y'' y''];\n  destruct (f y') as [y'' y''; destruct (f y') as [y'' y''; destruct (f y') as [y'' y'';\n  destruct (f y') as [y'' y''; destruct (f y') as [y'' y''; destruct (f y') as [y'' y'';\n  destruct (f y') as [y'' y''; destruct (f y') as [y'' y''; destruct (f y') as [y'' y'';\n  destruct (f y') as [y'' y''; destruct (f y'') as [y'' y''; destruct (f y') as [y'' y'';\n  destruct (f y') as [y'' y''; destruct (f y'') as [y'' y''; destruct (f y'') asQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 2464,
                "proof_end_offset": 2664,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  test H.\n  test H.\n  test H0.\n  test H1.\n  test H2.\n  test H0.\n  test H2.\n  test H0.\n  test H1.\n  test H2.\n  test H3.\n  test H3.\n  test H3.\n  test H4.\n  test H4.\n  test H5.\n  test H5.\n  test H5.\n  test H5.\n  test H5.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  test H6.\n  testQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros A B R sa sa x y z Hz.\n  change (R |-- (fun x => x) * (fun x => x)) with (R * (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (Rreg (fun x => x) (fun x => x)).\n  apply (RQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rrefl.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2666,
                "proof_end_offset": 2819,
                "proof": "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 2 intro.\n  do 4 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 2 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 2 intro.\n  do 3 intro.\n  do 3 intro.\n  do 2 intro.\n  do 2 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 3 intro.\n  do 3 intro.\n  do 4 intro.\n  do 4 intro.\n  do 3 intro.\n  do 3 intro.\n  do 2 intro.\n  do 3 intro.\n  do 4 intro.Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold respectful.\n  destruct (f x); destruct (f y); destruct (f y); destruct (g y); intuition.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold respectful.\n  do 3 intro.\n  match goal with\n    | [ H: context [ R x?a ] |- _ ] => rewrite (H a)\n    end.\n  do 3 intro.\n  match goal with\n    | [ H: context [ R x?a ] |- _ ] => rewrite (H a)\n    end.\n  do 3 intro.\n  match goal with\n    | [ H: context [ R x?a ] |- _ ] => rewrite (H a)\n    end.\n  do 3 intro.\n  match goal with\n    | [ |- context [ R x?a ] ] => rewrite (H a)\n    end.\n  do 4 intro.\n  match goal with\n    | [ |- context [ R x?a ] ] => rewrite (H a)\n    end.\n  match goal with\n    | [ |- context [ R x?a ] ] => rewrite (H a)\n    end.\n  match goal with\n    | [ |- context [ R x?a ] ] => rewrite (H a)\n    end.\n  match goal with\n    | [ |- context [ R x?a ] ] => rewrite (H a)\n    end.\n  match goal with\n    | [ |- context [ R xQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 2821,
                "proof_end_offset": 2999,
                "proof": "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  assert (R: forall x y, R x y -> R y x).\n  intro.\n  eapply H0; eauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R y y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R y x).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R x y).\n  test_eq (R xQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  unfold compose.\n  (* Tvoid *)\n  destruct b as [ | b].\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n  (* Tvoid *)\n  simpl.\n Qed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  eapply H; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\n",
                "context_tokens": 715,
                "proof_start_offset": 3599,
                "proof_end_offset": 3825,
                "proof": "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\nintros A R f C x y Hf Hxy.\nFail rauto.\npose proof @f_equal_relim.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y H.\n  pose proof H.\n  eapply eq_trans.\n  + exact H.\n  + exact H.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R x y Hx Hy.\n  pose proof H as RR.\n  pose proof H as RR.\n  pose proof H as RR'.\n  pose proof H as RR'.\n  pose proof H as RR'.\n  pose proof (H x).\n  pose proof (H x).\n  pose proof (H x).\n  pose proof (H x).\n  pose proof H as RR'.\n  pose proof H as RR'.\n  pose proof (H x).\n  pose proof (H x).\n  pose proof H as RR'.\n  pose proof (H x).\n  pose proof (H x).\n  pose proof (H x).\n  pose proof (H x).\n  pose proof H as RR'.\n  pose proof (H x).\n  pose proof H as RR'.\n  pose proof (H x).\n  pose proof (H x).\n  pose proof H as RR'.\n  pose proof H as RR'.\n  pose proof H as RR'.\n  pose proof (H x).\n  pose proof (H x).\n  pose proof (H x).\n  pose proof (H x).\n  pose proof H0 as RR''.\n  pose proof H0 as RR''.\n  pose proof H0 as RR''.\n  pose proof (H x).\n  pose proofQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  do 2 rewrite (f x0 y).\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R R' S f x y H.\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: B) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y: A) => f y).\n  pose proof (fun (y: A) (y:Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R f x y.\n  pose proof (H0 x y).\n  pose proof (H1 y).\n  pose proof (H2 y).\n  pose proof (H0 y).\n  pose proof (H0 y).\n  pose proof (H1 y).\n  pose proof (H1 y).\n  pose proof (H2 y).\n  pose proof (H2 y).\n  pose proof (H1 y).\n  pose proof (H0 y).\n  pose proof (H2 y).\n  pose proof (H0 y).\n  pose proof (H0 y).\n  pose proof (H2 y).\n  pose proof (H3 y).\n  pose proof (H2 y).\n  pose proof (H3 y).\n  pose proof (H1 y).\n  pose proof (H0 y).\n  pose proof (H0 y).\n  pose proof (H0 y).\n  pose proof (H1 y).\n  pose proof (H2 y).\n  pose proof (H3 y).\n  pose proof (H1 y).\n  pose proof (H1 y).\n  pose proof (H2 y).\n  pose proof (H2 y).\n  pose proof (H2 y).\n  pose proof (Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  (* We can use this to apply the proof that the proof is a proof, we can solve this\n    instance in [apply f_equal_dep]. *)\n  refine (match x with inl a => x | inr _ => x end).\n  exact (fun _ => 0).\n  exact (fun _ => 0).\n  exact (fun _ _ => 0).\n  exact (fun _ _ => 0).\n  exact (fun _ _ => 0).\n  exact (fun _ _ _ => 0).\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  remember (R x) as z.\n  remember (R x) as z.\n  remember (R y) as z.\n  remember (R x) as z.\n  remember (R z) as z.\n  remember (R y) as z.\n  remember (R z) as z.\n  remember (R x) as z.\n  remember (R z) as z.\n  remember (R z) as z.\n  remember (R z) as z.\n  remember (R x) as z.\n  remember (R y) as z.\n  remember (R z) as z.\n  remember (R x) as z.\n  remember (R z) as z.\n  remember (R y) as z.\n  remember (R x) as z.\n  remember (R z) as z.\n  remember (R y) as z.\n  remember (R z) as z.\n  remember (R z) as z.\n  remember (R x) as z.\n  remember (R z) as z.\n  remember (R x) as z.\n  remember (R z) as z.\n  remember (R z) as z.\n  remember (R y) asQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  eapply H.\n  eapply H0.\n  eapply H.\n  eapply H0.\n  eapply H0.\n  eapply H0.\n  eapply H1.\n  eapply H1.\n  eapply H0.\n  eapply H0.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R S f x y H.\n  pose proof H as Heq.\n  pose proof H as Heq.\n  pose proof H as Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq''.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq''.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq'.\n  pose proof Heq.\n  pose proof Heq''.\n  pose proof Heq''.\n  pose proof Heq''.\n  pose proof Heq''.\n  poseQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A R R' S f x y Hx Hy.\n  pose proof I.\n  apply H.\n  rewrite <- (H x y).\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ") (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3953,
                "proof_end_offset": 4077,
                "proof": "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\nintros A R x y Hxy Hyy.\nmonotonicity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y H.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hx Hy Hxy.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y H1 H2.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof (@eq_rect_r A R x y Hx Hy).\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  (* Hier *)\n  (* Hier *)\n  apply H.\n  (* Hier *)\n  apply H0.\n  (* Hier *)\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hy Hy.\n  pose proof @eq_rect_r A R x y Hy Hy.\n  pose proof @eq_rect_r A R x y Hy Hy.\n  pose proof @eq_rect_r A R x y Hy.\n  pose proof @eq_rect_r A R x y Hx Hy.\n  pose proof @eq_rect_r A R x y Hy Hy.\n  pose proof @eq_Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y H Hxy.\n  Fail rauto.\nAbort.\n\n(** The bug of [eq_rect] can be used to fail with a\n    type. *)\n\nGoal forall A (R: rel A) (x y:A), R x y -> eq y x.\nProof.\n  intros A R x y H Hxy.\n  unshelve rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nintros A R x y Hx Hxy.\nchange (R ++> R') with (R' ==> R') in *.\nFail exact H.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y H.\n  Fail rauto.\n  (* NB: this lemma should fail with the [H] or [H]. *)\n  intros x y H.\n  Fail rauto.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hy Hxy.\n  Fail rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 4556,
                "proof_end_offset": 4698,
                "proof": "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\nintros A R f Hf.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x.\n  pose proof @f_equal_iterate _ _ _ f x.\n  pose proof @f_equal_transparent _ _ _ f x.\n  pose proof @f_equal_existT _ _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _ _ f x.\n  pose proof @f_equal_strong_trans _ _Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H x H.\n  pose proof @f_equal_transparent _ _ _ _ H x H).\n  pose proof @f_equal_transparent _ _ _ _ x H x H.\n  pose proof @f_equal_narrow _ _ _ x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_narrow _ _ x H x H.\n  pose proof @f_equal_dep _ _ x H x H.\n  pose proof @f_equal_dep _ _ _ x H.\n  pose proof @f_equal_dep _ _ x H x H.\n  pose proof @fQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H.\n  pose proof @f_equal_pairT2.\n  pose proof (@f_equal_pairT2 _ _ _ (fun a => f (f a)) H).\n  pose proof @f_equal_pairT2 _ _ _ (fun a => f (f a)) H0.\n  pose proof (@f_equal_pairT2 _ _ _ (fun a => f (f a)) H0).\n  pose proof (@f_equal_pairT2 _ _ _ (fun a => f (f a)) H0).\n  pose proof @f_equal_pairT2 _ _ _ (fun a => f (f a)) H0.\n  pose proof @f_equal_pairT2 _ _ (fun a => f (f a)) H0.\n  pose proof (@f_equal_pairT2 _ _ _ (fun a => f (f a)) H0).\n  pose proof @f_equal_pairT2 _ _ _ (fun a => f (f a)) H0.\n  pose proof @f_equal_pairT2 _ _ (fun a => f (f a)) H0.\n  pose proof (@f_equal_pairT2 _ _ _Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H x y Hxy.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n  pose proof @f_equal_pairT2.\n Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H.\n  pose proof @f_equal_pairT2.\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@f_equal_pairT2 _ _ (fun _ => True) H0).\n  pose proof (@Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros.\n  pose proof @f_equal_crelation A R _ _ _ _ _ _ H.\n  pose proof @f_equal_crelation A R _ _ _ _ H.\n  pose proof @f_equal_crelation A R _ _ _ H.\n  pose proof @f_equal_irrel A R _ _ _ _ _ H.\n  pose proof @f_equal_setMaxPerm A R _ _ _ _ H.\n  pose proof @f_equal_both A R _ _ _ _ _ H.\n  pose proof @f_equal_irrel A R _ _ _ H0.\n  pose proof @f_equal_irrel A R _ _ _ _ H0.\n  pose proof @f_equal_irrel A R _ _ _ _ _ H0.\n  pose proof @f_equal_irrel A R _ _ _ H0.\n  pose proof @f_equal_irrel A R _ _ _ _ H.\n  pose proof @f_equal_irrel A R _ _ _ _ H0.\n  pose proof @f_equal_irrel A R _ _ _ _ H0.\n  pose proof @f_equal_irrel A R _ _ _ H0.\n  pose proof @Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f x y Hxy Hyz.\n  pose proof (@f_equal_strong_strong_2 A R _ _ _ _ _ Hxy).\n  pose proof (@f_equal_strong_2 A R _ _ _ _ Hxy).\n  pose proof (@f_equal_strong_2 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_2 A R _ _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ _ Hxy).\n  pose proof (@f_equal_strong_4 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ Hxy).\n  pose proof (@f_equal_strong_3 A R _ _ _ _ Hxy).\n  pose proof (@f_equal_strong_4 A R _ _ _ _ Hxy).Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H x y Hxy Hyz.\n  pose proof (@f_equal_ guarante _ _ _ x _ _ _ Hxy).\n  pose proof (@f_equal_ guarante _ _ _ x _ _ x _ _ _ Hxy).\n  pose proof (@f_equal_pairTe _ _ _ x _ _ x _ _ _ _ Hxy).\n  pose proof (@f_equal_projectionse _ _ _ x _ _ _ _ _ _ _ _ H).\n  pose proof (@f_equal_pairTe _ _ x _ _ _ x _ _ _ H).\n  pose proof (@f_equal_pairTe _ _ _ x _ _ _ _ _ H).\n  pose proof (@f_equal_projectionse _ _ _ x _ _ _ _ _ _ H).\n  pose proof (@f_equal_projectionse _ _ x _ _ _ _ H).\n  pose proof (@f_equal_pairTe _ _ _ x _ _ _ H).\n  pose proof (@f_equal_projectionse _ _ _ x _ _ _ H).\n  pose proof (@f_equal_projectionse _ _ _ x _ _ _ H).\n  pose proof (@f_equal_projectionse _ _ _Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H.\n  pose proof @f_equal_strong _ _ (H a) (H0 a) (H0 a) (H1 a) (H2 a) (H3 a)).\n  pose proof @f_equal_strong _ _ (H a) (H2 a) (H3 a) (H4 a) (H5 a)).\n  pose proof @f_equal_strong _ _ (H a) (H3 a) (H5 a)).\n  pose proof @f_equal_strong _ _ (H a) (H4 a) (H4 a) (H5 a)).\n  pose proof @f_equal_strong _ _ (H a) (H3 a) (H5 a) (H4 a) (H5 a)).\n  pose proof @f_equal_strong _ _ (H a) (H4 a) (H4 a) (H5 a) (H5 a) (H4 a)).\n  pose proof @f_equal_strong _ _ (H0 a) (H5 a) (H5 a) (H5 a) (H5 a) (H4 a)).Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H.\n  pose proof @f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_restr (R ==> eq) f H).\n  pose proof (@f_equal_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4997,
                "proof_end_offset": 5177,
                "proof": "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\nintros A R R' f Hf HR.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  pose proof @f_equal_iterate _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_compose _ _ _ _ f Hf.\n  pose proof @f_equal_sigT_Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R' R' S f Hf.\n  pose proof @f_equal_Dese _ _ _ (fun x => x)).\n  pose proof @f_equal_extend _ _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ _ (fun x => x)).\n  pose proof @f_equal_restr _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ (fun x => x).\n  pose proof @f_inj_restr _ _ _ (fun x => x)).\n  pose proof @f_inj_restr _ _ _ (fun x => x).\n  pose proof @f_inj_restr _ _ _ (fun x => x).\n  pose proof @f_inj_restr _ _ _ (fun x => x).\n  pose proof @f_Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' S f Hf.\n  pose proof @f_equal_gh (R' ==> flip R') R f Hf.\n  pose proof @f_equal_gh (R' ==> flip R') f Hf.\n  pose proof @f_equal_gh (R' ==> flip R') f Hf.\n  pose proof (@f_equal_gh (R' ==> flip R') f Hf).\n  pose proof (@f_equal_gh (R' ==> flip R') f Hf).\n  pose proof @f_equal_gh (R' ==> flip R') f Hf.\n  pose proof @f_equal_gh (R' ==> flip R') f Hf.\n  pose proof (@f_equal_gh (R' ==> flip R') f Hf).\n  pose proof (@f_equal_gh (R' ==> flip R') f Hf).\n  pose proof @f_equal_gh (R' ==> flip R') f Hf.\n  pose proof @f_equal_gh (R' ==> flip R') f Hf.\n  pose proof (@f_equal_gh (R' ==> flip R') f Hf).\n  pose proof @f_equal_gh (R' ==> flipQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_??.\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_ (**) A R f Hf).\n  pose proof (@f_equal_crelation A R f Hf).\n  pose proof (@f_equal_inhabited A R f HfQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' S f Hf.\n  apply (Build_proper _ _ _ _ _ _ H0 H1).\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R' R' S f Hf.\n  refine (Build_equiv _ _ _ _); intros x y.\n  refine (Build_equiv _ _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equiv _ _ _); intros x y.\n  refine (Build_equivQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  pose proof @f_equal_projections; simpl; intros.\n  pose proof (@f_equal_projections _ _ _ f Hf).\n  apply H.\n  exact (eq_trans _ _ H).\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf.\n  pose proof (@f_equal_iterate _ _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).\n  pose proof (@f_equal_dep _ _ _ f Hf).Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  pose proof @f_equal_strong _ _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ f Hf as Hf'.\n  pose proof @f_equal_strong _ _ _ _ f Hf as Hf'.\n  poseQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 5968,
                "proof_end_offset": 6181,
                "proof": "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\nintros A B C R f a1 a2 b c Hf Ha.\nmonotonicity; rauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H H0.\n  destruct H as [R [H1 H2]].\n  exists R.\n  split.\n  exact H1.\n  exact H2.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 a1 a2 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 a1 a2 a3 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 a3 b c H).\n  pose proof (@rel_iff A B C R f a1 a2 a3 b c H).\n  poseQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  unfold iff in *.\n  rewrite (f a1 b1 c H).\n  rewrite (f b1 c H).\n  reflexivity.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  pose proof (fun x => f (f a1 b c H)).\n  pose proof (fun x => f (f a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => g (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b c H)).\n  pose proof (fun x => f (g a1 b cQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  apply H.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f g H.\n  rewrite (eq_rel_iff_rel_iff_rel_iff_rel_iff_rel_iff_rel_iff_rel_iff_rel_and_rel_iff_rel_iff_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_and_rel_rel_and_rel_and_rel_and_Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R a1 a2 a1 a2 b c H1 H2.\n  rewrite (H2 a2 b c H1).\n  (* Here, the hypothesis is not an equivalence relation in the context,\n    but does not match the goal is a with the context *)\n  match goal with\n    | |- (forall _, _) => inversion H\n    | |- (forall _, _) => inversion H\n    end.\n  (* It is useful for [iff] and [iff] on the goal. *)\n  match goal with\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion H\n    | [ H :?P |- _ ] => inversion HQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros.\n  eexists.\n  eapply H.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f g H.\n  destruct (f a1 b1 c) as [[a1 a2] [[a1 b1] [b2 c2] [b2 c2] [b3 c4] [a4 c5] [b5 c6] [b6 c6] [c6 c7] [c6 c7] [c6 c7] [c7 c8] [c6 c7] [c7 c8] [c7 c8] [c9] [c8] [e12 c13] [d12 c13] [d13] [c12] [d23] [d23] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d16] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [d15] [dQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  eexists.\n  eapply H.\n  eapply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 6183,
                "proof_end_offset": 6385,
                "proof": "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 R1 R2 R HR12 x y.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 H H0.\n  pose proof R1 as H1.\n  apply H0.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 H.\n  apply H.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 H.\n  pose (f a1 a2 b c).\n  pose (f a1 b c).\n  pose (f a1 b c).\n  pose (f a1 b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (g b c).\n  pose (Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 x y Hx Hy.\n  pose (f a1 a2 b1 c1 c2 c2 c3 c3) as H.\n  pose (g a1 b1 c2 c3 c3 c4) as H'.\n  pose (g a1 b1 c1 c2 c3 c4) as H'.\n  pose (g a1 c2 c3 c4) as H'.\n  pose (g a1 c2 c3 c4) as H'.\n  pose (g a1 c1 c2 c4) as H''.\n  pose (g a1 c2 c3 c4) as H'.\n  pose (g a1 c1 c3 c4) as H'.\n  pose (g a1 c1 c2 c3 c4) as H''.\n  pose (g a1 c1 c2 c3 c4) as H''.\n  pose (g a1 c1 c3 c4) as H''.\n  pose (g a1 c1 c4 c4) as H''.\n  pose (g a1 c1 c2 c3 c4) as H''.\n  pose (gQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 H x y H0 H1 H2.\n  apply H1; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R2 x y Hx Hxy Hyz.\n  pose proof R1.\n  pose proof R2.\n  pose proof R2.\n  pose proof R2.\n  pose proof R1.\n  pose proof R1.\n  pose proof R2.\n  pose proof R1.\n  pose proof R2.\n  pose proof R2.\n  pose proof R1.\n  pose proof R2.\n  pose proof R2.\n  pose proof R2.\n  pose proof R2.\n  pose proof R2.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n  pose proof R3.\n Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 R2 Heq.\n  pose proof (R1 x y H0).\n  pose proof (R2 x y H0).\n  pose proof (R2 x y H0).\n  pose proof (R1 x y H0).\n  pose proof (R2 x y H0).\n  pose proof R2 x y H1.\n  pose proof R2 x y H1.\n  pose proof R2 x y H1.\n  pose proof R2 x y H1.\n  pose proof R2 x y H1.\n  pose proof R2 x y H1.\n  pose proof R2 x y H2.\n  pose proof R3 x y H1.\n  pose proof R3 x y H1.\n  pose proof R3 x y H1.\n  pose proof R3 x y H1.\n  pose proof R3 x y H2.\n  pose proof R3 x y H1.\n  pose proof R3 x y H1.\n  pose proof R3 x y H1.\n  pose proof R3 x y H1.\n  pose proof R3 x y H2.\n  pose proof R3 x y H1.\n  poseQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R2 H x y H1 H2.\n  pose (R1' := R1 ==> R2) as H3'.\n  pose (R2' := R1 ==> R2') as H4''.\n  pose (R3' := R2 ==> R3') as H4''.\n  pose (R3 := R3 ==> R3') as H4''.\n  pose (R3 := R3 ==> R3') as H5''.\n  pose (R3' := R3 ==> R3') as H5''.\n  pose (R4' := R3 ==> R3') as H6''.\n  pose (R4' := R3 ==> R3') as H5''.\n  pose (R5' := R3 ==> R4') as H5''.\n  pose (R5 := R3 ==> R4') as H5''.\n  pose (R6 := R3 ==> R5') as H5''.\n  pose (R6' := R3 ==> R3') as H7''.\n  pose (R5 := R1 ==> R3') as H6''.\n  pose (R5' := R1 ==> R3') as H7''.Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 x y Hxy Hyz.\n  pose (R3 := R1 ==> R2).\n  pose (R4 := R2).\n  pose (R4 := R3).\n  pose (R5 := R1).\n  pose (R6 := R1).\n  pose (R5 := R3).\n  pose (R6 := R1).\n  pose (R6 := R2).\n  pose (R6 := R3).\n  pose (R6 := R1).\n  pose (R6 := R1).\n  pose (R6 := R3).\n  pose (R6 := R3).\n  pose (R6 := R2).\n  pose (R7 := R3).\n  pose (R6 := R3).\n  pose (R6 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R7 := R3).\n  pose (R6 :=Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 H H0.\n  pose proof H as Heq.\n  apply H in Heq.\n  apply H in Heq.\n  apply H in Heq.\n  apply H0 in Heq.\n  apply H in Heq.\n  apply H in Heq.\n  apply H0 in Heq.\n  apply H in Heq.\n  apply H in Heq.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6615,
                "proof_end_offset": 6735,
                "proof": "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  pose proof (H x1 x2 y1 y2).\n  pose proof (H x2 x1 y1 y2).\n  pose proof (H x2 x1 y1 y2).\n  pose proof (H x1 y1 y2).\n  pose proof (H x1 x2 y1 y2).\n  pose proof (H x2 x2 y1 y2).\n  pose proof (H x1 y1 y2).\n  pose proof (H x2 y1 y2).\n  pose proof (H x2 x2 y2).\n  pose proof (H x1 y2 y1 y2).\n  pose proof (H x2 x1 y2 y2).\n  pose proof (H x2 y1 y2).\n  pose proof (H x1 x2 y2 y2).\n  pose proof (H x1 y1 y2 y2 y2).\n  pose proof (H x2 x1 y1 y2).\n  pose proof (H x2 x1 y2 y2).\n  pose proof (H x2 y2 y1 y2).\n  pose proof (H x1 y1 yQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H.\n  pose proof (fun (x1 : A) (y1 : B) (y2 : B) => x1 = x2) as H.\n  pose proof (fun (x1 : A) (y1 : B) => x1 = x2) as H0.\n  rewrite H0 in H0.\n  auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H1 H2.\n  pose proof (fun x => x1 = x2) as H3.\n  pose proof (fun x => x2 = x).\n  pose proof (fun x => x2 = x).\n  pose proof (fun x => x2 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proof (fun x => x1 = x).\n  pose proofQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H H0.\n  pose proof H as H1.\n  pose proof H as H2.\n  pose proof H as H3'.\n  pose proof H as H3'.\n  pose proof H as H4'.\n  pose proof H as H5'.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H5''.\n  pose proof H as H6''.\n  pose proof H as H6''.\n  pose proof H as H6''.\n  pose proof H as H6''.\n  pose proof H as H6''.\n  pose proof H asQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H H0.\n  pose proof (fun (x : A) (y1 : B) => x1 = y1) as H.\n  rewrite H0 in H.\n  rewrite H0 in H0.\n  rewrite H0 in H.\n  assumption.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H.\n  generalize H; clear H; intros.\n  generalize H; clear H; intros.\n  generalize H; clear H; intros.\n  generalize H; clear H; intros.\n  generalize H0; clear H0; intros.\n  generalize H0; clear H0; intros.\n  generalize H; clear H0; intros.\n  generalize H0; clear H0; intros.\n  generalize H0; clear H0; intros.\n  generalize H0; clear H0; intros.\n  generalize H1; clear H1; intros.\n  generalize H1; clear H1; intros.\n  generalize H2; clear H1; intros.\n  generalize H1; clear H1; intros.\n  generalize H0; clear H1; intros.\n  generalize H1; clear H1; intros.\n  generalize H0; clear H1; intros.\n  generalize H0; clear H1; intros.\n  generalize H0; clear H0; intros.\n  generalize H0; clear H0; intros.\n  generalize H1; clear H1; intros.\n  generalize H1; clear H0; intros.\n  generalize H0; clearQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  pose proof (f_equal x1 y1).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x2 y1).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x1 y1).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x2 y1).\n  pose proof (f_equal x1 y1).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x2 y1).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x1 y2).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x2 y1).\n  pose proof (f_equal x2 y2).\n  pose proof (f_equal x1 y2).\n  pose proof (f_equal x2 y1).\n  pose proof (f_equal x1 y2).\n  pose proof (f_equal x2 y1).Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 y3.\n  pose (f a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x2 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) as g.\n  pose (g a x1 a) asQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H1 H2.\n  pose proof (H1 x1 x2 y1 H2).\n  pose proof (H2 x1 y1 H2).\n  pose proof (H3 x2 y1 H3).\n  pose proof (H3 x2 y1 H3).\n  pose proof (H3 x2 y2 H3).\n  pose proof (H4 x2 y1 H1).\n  pose proof (H4 x2 y2 H3).\n  pose proof (H4 x2 y1 H4).\n  pose proof (H4 x2 y2 H1).\n  pose proof (H4 x2 y2 H3).\n  pose proof (H4 x2 y2 H3).\n  pose proof (H4 x2 y1 H2).\n  pose proof (H4 x2 y2 H3).\n  pose proof (H4 x2 y2 H3).\n  pose proof (H4 x2 y2 H3).\n  pose proof (H4 x2 x1 y2 H3).\n  pose proof (H4 x2 y1 H3).\n  pose proof (H4 x2 y2 HQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 H1 H2.\n  pose proof (H1 x2 y1).\n  apply H in H1.\n  apply H2 in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.\n  apply H in H3.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 6885,
                "proof_end_offset": 7143,
                "proof": "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\nrewrite HR12.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1' R2' R3' x y.\n  transitivity (R1' x y).\n  transitivity (R1' x y).\n  transitivity (R2' x y).\n  transitivity (R1' x y).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' (x2' y)).\n  assumption.\n  transitivity (R2' x y).\n  transitivity (R1' x y).\n  transitivity (R1' x y).\n  transitivity (R2' y).\n  transitivity (R1' x y).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' x y).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' x y).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' x y).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' y).\n  transitivity (R2' (x2' y)).\n  transitivity (R2' y).\n  transitivity (R2Qed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  inversion H.\n  left.\n  left.\n  eauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 R1 R2 HR12 x y.\n  pose proof (H x y).\n  pose proof (H0 x y).\n  pose proof (H1 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H3 x y).\n  pose proof (H3 x y).\n  pose proof (H3 x y).\n  pose proof (H3 x y).\n  pose proof (H3 x y).\n  pose proof (H4 x y).\n  pose proof (H4 x y).\n  pose proof (H2 x y).\n  pose proof (H4 x y).\n  pose proof (H4 x y).\n  pose proof (H2 x y).\n  pose proof (H2 x y).\n  pose proof (H3 x y).\n  pose proof (H3 x yQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 C1 R1 R2 HR12 x y.\n  destruct (R1 x) as (x1, y1); destruct (R2 y1) as (x2, y2); simpl in *.\n  - (* R1 *)\n    destruct (R1 x) as (x3, y3); destruct (R2 x3) as (y4, y5); simpl in *.\n    - (* R2 *)\n      destruct (R1 x) as (y1, y2); simpl in *.\n      + (* R1 *)\n        destruct (R2 y1) as (y2, y3); simpl in *.\n        + (* R2 *)\n        exists y1; split; auto.\n        * (* R2 *)\n          exists y1; split; auto.\n          * (* R2 *)\n          exists y2; split; auto.\n          * (* R1 *)\n            exists y1; split; auto.\n            * (* R2 *)\n              exists y1; split; auto.\n              * (* R1 *)\n              exists y1; split; auto.\n              * (* R1 *)\n              exists y2; split; auto.\n              * (* R2 *)\n              existsQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  inversion H.\n  eapply H1.\n  eapply H2.\n  eapply H1.\n  eapply H2.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct H.\n  split; auto.\n  eapply H; eauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 R2 HR12 x y.\n  specialize (H12 x y).\n  rewrite <- H12.\n  rewrite <- H12.\n  rewrite <- H12.\n  rewrite <- H12.\n  reflexivity.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 HR12 x y.\n  destruct (R1 x y) as (R1 & y & R3 & H0 & H1 & H2).\n  exists (x, y); repeat split; auto.\n  apply R3; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 R1' R2 HR12 x y.\n  unfold compose, compose.\n  (* We use the [R1] and [R1 * R2] is the [R2'] *)\n  assert (R2 = R1).\n   apply HR12.\n   apply HR12.\n  (* The [R1 * R2] is a [R1' * R2'] is a [R2' * R2'] *)\n  assert (R3 = R2).\n   apply HR12.\n  apply HR12.\n  apply HR12.\n  apply HR12.\n  apply HR12.\n  apply HR12.\n  apply HR12.\n  apply HR12.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8058,
                "proof_end_offset": 8174,
                "proof": "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\nintros.\nrstep.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply H; eauto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply equiv_rel_prod; eauto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply H.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 4 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 3 intro.\n  do 4 intro.\n  do 3 intro.\n  do 3 intro.\n  do 5 intro.\n  do 4 intro.\n  do 3 intro.\n  do 5 intro.\n  do 4 intro.\n  do 5 intro.\n  do 4 intro.\n  do 4 intro.\n  do 5 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.\n  do 4 intro.Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply H.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply equiv_rel_prod; eauto.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply trans_rel_prod_R with (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R:=R) (R':=R) (R:=R) (R':=R).\n  assumption.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply H.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply H0.\n  assumption.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  eapply H1; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ": rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 8703,
                "proof_end_offset": 8872,
                "proof": "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  eapply list_rel_app_rel_app_rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  eapply list_rel_app_rel_app_rel_app_rel_app_rel_app_rel_app_rel.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app_rel_app.\n  apply H.\n  apply H.\n  eapply rel_app_rel_app_rel_app_rel_app.\n  applyQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  eapply list_rel_trans.\n  eapply list_rel_trans.\n  apply list_rel_app_rel_app.\n  apply list_rel_app.\n  apply list_rel_app_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_app.\n  apply list_rel_app_rel_Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  specialize (H x).\n  rewrite <- H0.\n  auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply list_rel_prod.\n  intros.\n  destruct H0 as [x H].\n  rewrite (H x0) in H0.\n  specialize (H0 y).\n  specialize (H2 x).\n  specialize (H2 y).\n  specialize (H2 y).\n  specialize (H3 y).\n  specialize (H4 y).\n  specialize (H4 y).\n  specialize (H4 y).\n  specialize (H4 y).\n  specialize (H4 x0).\n  specialize (H4 y).\n  specialize (H5 y).\n  specialize (H4 y).\n  specialize (H5 y).\n  specialize (H6 y).\n  specialize (H6 y).\n  specialize (H5 y).\n  specialize (H5 y).\n  specialize (H6 y).\n  specialize (H6 y).\n  specialize ( H5 y).\n  specialize (H6 y).\n  specialize (H5 y).\n  specialize (H6 y).\n  specialize (H6 y).\n  specialize (H6 y).\n  specialize (H7 y).\n  specialize ( H6 y).\n  specialize ( H7 y).\n  specialize (H7 y).\n  specialize (H7 y).\n Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros A B R' l1 l2 x y Hx Hy.\n  assert (H: forall x, l1 x = x -> l2 x = l2).\n  { induction l1; intros.\n    - inversion H; subst.\n      exists x; auto.\n    - inversion H; subst.\n      exists y; auto.\n    }\n  assert (H: forall x, l2 x = l2 x).\n  { induction l2; intros.\n    - inversion H; subst.\n      exists x; auto.\n    - inversion H; subst.\n      exists x; auto.\n  }\n  assert (H': forall x, l2 x = l2 x).\n  { induction l1; intros.\n      - inversion H; subst.\n        exists x; auto.\n      + destruct H; subst.\n        exists x; auto.\n    }\n  assert (H': forall x, l2 x = l2 x).\n  { induction l2; intros.\n      - inversion H; subst.\n        exists x; auto.\n  }\n  assert (H': forall x, l2 x = l2 x).\n  { induction l2; intros.\n      - inversion H; subst.\n        exists x; auto.\n   Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  assert(forall a, R a (a :: l1) -> forall x, R' (x :: l1) (x :: l2)).\n    intros; eapply H; eauto.\n  apply H0.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  remember (R' x) as z eqn:H.\n  remember (R' y) as z; destruct z; inv H; auto.\n  remember (rel_dec x y) as z; destruct z; inv H1; auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  remember (R' x) as z'.\n  revert z' H0.\n  induction l1; intros.\n  constructor.\n  destruct z; simpl in H; inv H0.\n  constructor; auto.\n  constructor.\n  destruct z'; simpl in H; inv H0.\n  constructor; auto.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply list_rel_app.\n  apply (list_rel_app R' (y :: l1) (y :: l2)).\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  remember (R x) as z; remember (R' y) as z; remember (R' y) as z.\n  destruct H.\n  exists z.\n  split; auto.\n  eapply list_rel_map; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8967,
                "proof_end_offset": 9084,
                "proof": "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  eapply H.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  remember (f x) as x.\n  remember (R' x) as x'.\n  remember (f x) as y'.\n  remember (R' x) as y'.\n  remember (R' x) as y''.\n  remember (R' x) as y''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' y') as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' y') as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  remember (R' x) as z''.\n  rememberQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  revert x y H.\n  induction x; intros; simpl; intros; auto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  do 3 red in H.\n  destruct H as [y [z [? [??]]]].\n  eapply H; eauto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct H as [x [y [z [z [??]]]]|].\n  apply H.\n  apply H.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  eapply H.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  unfold exp.\n  rewrite exp_unfold.\n  rewrite exp_unfold.\n  apply exp_right with x.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  apply exp_right with y.\n  applyQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H0.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  eapply list_rel_map; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 9180,
                "proof_end_offset": 9343,
                "proof": "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  eapply limit_rel_preserves_rel_preserves_rel.\n  apply limit_rel_preserves_rel_preserves_rel.\n  apply limit_rel_preserves_rel_preserves_rel.\n  apply limit_rel_preserves_rel_preserves_rel.\n  apply limit_rel_preserves_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.\n  apply limit_rel_preserves_rel.Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold exp.\n  apply (rel_preserves_rel_preserves_rel_preserves_rel_prime_fun).\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  do 3 eexists.\n  eapply H.\n  eapply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold compose.\n  rewrite (R_left (fun x => g (f x)) (g (fun x => g (f x))) in H.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold limit1_in.\n  simpl.\n  apply limit1_in.\n  apply limit2_in.\n  apply limit1_in.\n  apply limit1_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  apply limit_in.\n  applyQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold rel_prod.\n  apply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold compose.\n  exists (fun x y => g (f x) (g y)).\n  split.\n  apply H.\n  apply H.\n  assumption.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold compose.\n  eapply H.\n  eapply H.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold compose.\n  apply H.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ", opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\nLemma rel_pull_2:\n  forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y,\n    Monotonic g (\u22a4 ==> R @@ f) ->\n    (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_all] *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 9367,
                "proof_end_offset": 9486,
                "proof": "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_all_1 (rel_all_ex_1 (fun a => rforall a, R a (f a))) (fun a => rforall a, R a (f a))).\n  intros.\n  exists (fun a => rfun a => rfun a (f a))).\n  split; auto.\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_preserves_1 H).\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  exists (fun a => rfun a => rfun a => rfun a => rfun a)).\n  intros.\n  exists (fun a => rfun a => rfun a (f a))).\n  intros.\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct H.\n  left.\n  left.\n  right.\n  assumption.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  assert (H:=H0).\n  assert (H0:=H0).\n  assert (H1:=H0).\n  apply H0.\n  clear H.\n  rewrite H0.\n  apply H.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  assert (H:=H).\n  unfold equiv_relation.\n  assumption.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct (rel_strict_2 _ _ H H0).\n  left.\n  apply H.\n  left.\n  apply H0.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  assert (R' : forall a, R a -> forall a, R' (f a) (f a)).\n    intros.\n    apply H.\n    assumption.\n  apply H0.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (g x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_rel_inverse; auto).\n  assert (R' : forall x, R' (f x) (g x)) by (intros; apply R_Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  induction H; simpl in *; auto.\n  right; apply (rel_inverse_2 H0).\n  right; apply (rel_inverse_2 H0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n",
                "context_tokens": 600,
                "proof_start_offset": 7145,
                "proof_end_offset": 7615,
                "proof": "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C (R1' R1' R2' R1' R1' R2' R1' R2' R1' R2' R2' R3' x y H.\n  transitivity (R1' x y1).\n  apply (R2' x y1).\n  apply (R1' x y1).\n  apply (R2' x y1).\n  apply (R2' y2).\n  apply (R2' x y2).\n  apply (R2' x y2).\n  apply (R2' x y1).\n  apply (R2' x y2).\n  apply (R3' x y2).\n  apply (R2' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y2).\n  apply (R3' x y1).\n  apply (R3' x yQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C A B C D R1' R1' R1' R2' R2'.\n  rewrite HR12.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  eapply H.\n  2: apply H.\n  3: apply H.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2:apply H.\n  2:apply H.\n  2: apply H0.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2:apply H0.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2: apply H0.\n  2: apply H.\n  2: apply H0.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2: apply H.\n  2: apply H0.\n  2: apply H.\n  2: apply H0.\n  2: apply H.\n  2: apply H0.\n  2: apply H0.\n  2: apply H0.\n  2: apply H0.\n  2: apply H.\n  2: apply H.\n  2: apply H0.\n  2: apply H0.\n  2: apply H.\n  2: apply H0.\n  2: apply HQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  assert (R1' : forall x y : A, x = y -> y = x) by (intros; apply H; auto).\n  assert (R2' : forall x y : A, y = x -> y = x) by (intros; apply H; auto).\n  assert (R3' : forall x y z : A, y = x -> y = z -> (x = y) = (x, y) -> (x = y) = (x, z) -> (x = y) = (x, z).\n  intros.\n  eapply H.\n  apply H0.\n  apply H.\n  apply H1.\n  apply H1.\n  apply H2.\n  apply H2.\n  apply H1.\n  apply H2.\n  apply H2.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C1 C2 R1 R2 R1' R1' R2'.\n  rewrite HR12.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  unfold SPEC.\n  destruct x as [x1 x2]; destruct y as [x2 x3]; destruct y as [x3 x4]; destruct y as [x4 x5]; destruct y as [x5 x6]; destruct y as [x5 x6]; destruct y as [x6 x7];\n  destruct y as [x6 x7]; destruct y as [x8 x9]; destruct y as [x9 x10]; destruct y as [x12 y12];\n  destruct y as [x12 x12]; destruct y as [x12 x12]; destruct y as [x12 x13];\n  destruct y as [x15 x12]; destruct y as [x15 x16]; destruct y as [x15 x16]; destruct y as [x15 x15]; destruct y as [x15 y].\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C1 C2 R1' R1' R1' R2' R2' R1' R2'.\n  rewrite R1'.\n  assumption.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C1 C2 R1' R1' R1' R2.\n  rewrite!HR12.\n  apply H.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  destruct x as [a1 a2].\n  destruct b as [a2 a3].\n  destruct b as [a3 a4].\n  destruct b as [a4 a5].\n  destruct b as [a7 b].\n  destruct b as [b7 b].\n  destruct b as [b7 b].\n  destruct b as [b8 b].\n  destruct b as [b8 b].\n  destruct b as [b8 b].\n  destruct b as [b9 b].\n  destruct b as [b11 b12].\n  destruct b as [b11 b12].\n  destruct b as [b11 b12].\n  destruct b as [b12 b12].\n  destruct b as [b12 b12].\n  destruct b as [b12 b12].\n  destruct b as [b12 b12].\n  destruct b as [b12 b12].\n  destruct b as [b12 b22].\n  destruct b as [b12 b22].\n  destruct b as [b12 b12].\n  destruct b as [b12 b12].\n  destruct b as [b12 b2].\n  destruct b as [b12 b2].\n  destruct b as [b22Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  etransitivity.\n  apply HR12.\n  apply HR12.\nQed."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  apply (H (b*q)).\n  apply nat_ind_step.\n  intros.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  apply H.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  apply H.\n  exists b.\n  apply nat_ind_step.\n  intros.\n  apply H.\n  exists b.\n  apply nat_ind_step.\n  intros.\n  apply (H (b*q)).\n  apply nat_ind_step.\n  intros.\n  exists (b*q).\n  apply nat_ind_step.\n  intros.\n  apply (H (b*q)).\n  apply nat_ind_step.\n  intros.\n  apply (H (b*q)).\n  apply nat_ind_step.\n  intros.\n  exists (b*Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (S n).\n  exists (S n).\n  exists (S n).\n  exists (S m).\n  exists (S m).\n  exists (S m).\n  exists (S m).\n  exists (S m).\n  exists (S m).\n  exists (S m).\n  split.\n  apply lt_trans with (S m).\n  apply le_trans with (S m).\n  apply le_trans with (S m).\n  apply le_S_n.\n  apply le_trans with (S m).\n  assumption.\n  apply le_trans with (S m).\n  assumption.\n  apply le_trans with (S m).\n  apply le_trans with (S m).\n  apply le_S_n.\n  apply le_trans with (S m).\n  assumption.\n  apply le_trans with (S m).\n  apply le_trans with (S m).\n  apply le_n_S.\n  apply le_trans with (S m).\n  apply le_trans with (S m).\n  assumption.\n  apply le_trans with (S m).\n  apply le_trans with (S m).\n  apply le_trans with (S m).\n  apply le_Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nunfold not; intros n Hn.\nexists (S (S n)).\napply le_lt_trans with (S (S n)).\napply le_S_n.\nintros.\nexists (S (S n)).\nsplit.\napply lt_n_S.\napply lt_O_Sn.\napply lt_le_trans with (S (S n)).\napply lt_n_S.\napply lt_n_S.\napply lt_O_Sn.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_Sn.\napply le_trans with (S (S n)).\napply le_n_Sn.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S n).\napply le_n_S.\napply le_trans with (S (S n)).\napply le_n_S.\napply le_trans with (S n).\napply le_n_Sn.\napply le_trans with (S (S nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nsplit.\n- intros. exists (S q). intros. rewrite H0.\n  rewrite H0.\n  rewrite H0.\n  apply eq_dep.\n- intros. exists 0. intros.\n  elim H; intros.\n  rewrite H1.\n  rewrite H2.\n  apply eq_dep.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (S (S (S (S (S (S (S (S (S (S (S (S (S n))))))))).\n  simpl in |- *.  auto.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n   intros.\n   exists 0.\n   intros.\n   apply (not_prime_not_le _ _ H).\n   apply (not_prime_not_le _ _ H).\n   apply (not_prime_not_le _ _ H).\n   assumption.\n   apply (not_prime_not_le _ _ H).\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nexists (S (S (S (S (S (S (S n))))) (S (S (S n))))) (S (S (S n)))).\nexists (S (S (S (S (S n)))); [ idtac | simpl; auto ].\nexists (S (S (S n))); [ left; auto with arith ].\nexists (S (S (S (S n))); [ right; auto with arith ].\nexists (S (S (S (S (S n)))); [ right; auto with arith ].\nexists (S (S (S (S (S n)))); [ right; auto with arith ].\nexists (S (S (S (S (S n))))) (S (S (S n)));\n [ right; auto with arith ].\nexists (S (S (S (S (S (S n)))))) (S (S (S (S n))))) (S (S (S (S n))));\n [ right; auto with arith ].\nexists (S (S (S (S n))); [ right; auto with arith ].\nexists (S (S (S (S n))); [ right; auto with arith ].\nexists (S (S (SQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  exists (b*q).\n  exists (b*q).\n  unfold gcd. exists (b*q).\n  rewrite H.\n  ring.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\ninduction n as [| n IH]; simpl; intros.\nexists 1.\nexists (S n).\ntrivial.\ndestruct IH as [q| q]; simpl; intros.\nexists (S q).\nsplit.\nsimpl in |- *.\nexists q.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists q.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nexists q.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists q.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists q.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists q.\nexists (S q).\nsplit.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nexists q.\nexistsQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nassert (H : n = 1) by auto with arith.\nassert (H' : n = 1) by auto with arith.\nassert (H' : n = 1) by auto with arith.\nrewrite H' in H'.\nelim (le_or_eq _ _ H' H').\napply minus_diag.\nrewrite H' in H'; auto.\nelim (le_or_eq _ _ H' H').\nintros H'1; right; right; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  apply (fun n m => (n + m)%nat).\n  apply (fun n m => (m + n)%nat).\n  apply (fun n m => (n + m)%nat).\n  apply (fun n m => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun n m => (n + m)%nat).\n  apply (fun n m => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun n m => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun m n => (n + m)%nat).\n  apply (fun n m => (n + m)%Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  exists (S (S (pred n))).\n  simpl in |- *.\n  unfold pred, pred, pred, pred, pred, pred in |- *.\n  intros.\n  elim H.\n  intros.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 0.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 0.\n  exists 1.\n  exists 0.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  unfold prime, prime.\n  intros.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  elim (le_gt_dec 0 n).\n  left.\n  apply H.\n  right.\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n  apply le_trans with (m := n).\n Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim H.\n  left.\n  apply lt_le_weak.\n  right.\n  apply lt_le_weak.\n  left.\n  apply lt_le_weak.\n  left.\n  apply lt_le_weak.\n  left.\n  apply lt_le_weak.\n  apply lt_le_weak.\n  right.\n  apply (lt_trans (S (S (n0 + n)))).\n  apply le_lt_weak.\n  apply le_trans with (S (S (n0 + n))).\n  apply le_n_S.\n  apply le_n.\n  apply le_trans with (S (n0 + n)).\n  apply le_n.\n  apply le_trans with (S (S (n0 + n))).\n  apply le_n.\n  apply le_trans with (S (n0 + n)).\n  apply le_n.\n  apply le_trans with (S (n0 + n)).\n  apply le_n.\n  apply le_trans with (S (n0 + n)).\n  apply le_n.\n  apply le_n.\n  apply le_trans with (S (n0 + n)).\n  apply le_Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim H.\n  intros.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  exists (S n).\n  auto with arith.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  exists 0%nat.\n  apply lt_O_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros a.\n  exists (a*q).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  ring.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  exists (fun n:nat => if (P n) n then a else a).\n  simpl.\n  apply H.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  unfold divides in |- *.\n  apply H.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a*q).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=a).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_unique with (a:=q).\n  apply gcd_Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n  exists (a*q).\n Qed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (a, a).\n  apply (gcd_refl a).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  exists (fun n => (a n))).\n  apply (fun n => (a n)).\n  intros.\n  exists (S x).\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  exists a.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  assert(H:=H).\n  assert(H0:=H).\n  destruct H0.\n  exists a.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  cut (a = b \\/ c = b \\/ c = a).\n  intro.\n  apply H0.\n  destruct H0.\n  left.\n  right.\n  auto with arith.\n  left.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n   intros.\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   left.\n   split.\n   apply (le_antisym a 1).\n   elim (le_lt_eq_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_lt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_gt_dec 0 a).\n   elim (le_lt_eq_dec 0 a).\n   elim (le_lt_eq_dec 0 a).\n   elim (le_gt_dec 1 a).\n   elim (lt_eq_dec 0 a).\n   elim (le_lt_eq_dec 0 a).\n   elim (lt_eq_dec 1 a).\n   elim (le_lt_eq_dec 0 a).\n   elim (le_lt_eq_dec 0 a).\n   reflexivity.Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  assert (H1 := H1).\n  apply H1 with a.\n  apply H1 with a.\n  apply H1 with a.\n  apply H1 with b.\n  apply H1 with a.\n  apply H1 with b.\n  apply H1 with a.\n  apply H1 with a.\n  apply H1 with a0.\n  apply H1 with a.\n  apply H1 with a0.\n  apply H1 with a.\n  apply H1 with a0.\n  apply H1 with a0.\n  apply H1 with a.\n  apply H1 with a0.\n  apply H1 with b.\n  apply H1 with a0.\n  apply H1 with a.\n  apply H1 with a0.\n  apply H1 with a.\n  apply H1 with b.\n  apply H0 with a.\n  apply H1 with a0.\n  apply H1 with a.\n  apply H1 with a.\n  apply H1 with a.\n  apply H1 with a0.\n  apply H1 with a0.\n  apply H1 with a0.\n  apply H1 with a0.\n  apply H1 with a0.\n  apply H1Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros a b c H.\n  exists (b*c).\n  apply H.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  cut (a = b).\n   intro.\n   rewrite H0.\n   rewrite H1.\n   rewrite H0.\n   rewrite H0.\n   reflexivity.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply (rel_prime_mult a b c H H0 H1).\n  apply (rel_prime_mult a b c H H1).\n  apply (rel_prime_mult a b c H H0 H1).\n  apply (rel_prime_mult a b c H H0 H1).\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_mult.\n  apply rel_prime_sym.\n  apply rel_prime_mult.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.\n  apply rel_prime_sym.Qed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  exists a.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n   intros.\n   red.\n  exists (b*c).\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  assert (H' := H a b c H H0).\n  apply (H' H0 H1).\n  apply H'.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H0.\n  apply H; assumption.\n  elim H; intro q; intro.\n  rewrite H2.\n  apply H; assumption.\n  elim H; intro q; intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H2 in H0.\n  exists (q' * q').\n  rewrite H0.\n  rewrite H1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H1.\n  apply H1.\n  rewrite H2 in H1.\n  rewrite H2 in H1.\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  left; auto with arith.\n  right; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  left; auto with arith.\n  right; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H.\n  left.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  rewrite <- (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r b a).\n  apply (divide_factor_r a b c).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r b a).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factor_r a b).\n  rewrite (divide_factorQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  rewrite H0 in H.\n  rewrite H0 in H.\n  exists (q' * q).\n  rewrite H0.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim (divide_refl a b H0); intro; elim H0; intro.\n  rewrite H0 in H1.\n  rewrite H1 in H1.\n  exists (q' * q').\n  rewrite H1.\n  auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x;intros;rewrite mult_n_O in H; generalize (mult_n_O n y); intros Hx.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in Hy; generalize (mult_n_O n x Hx); intros Hy.\nrewrite mult_n_O in HyQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction x;intros;rewrite plus_comm;simpl.\nauto with arith.\nrewrite mult_comm;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x.\n  simpl.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  apply plus_reg_l with (a*y);auto.\n  rewrite mult_comm;simpl;auto.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros.\ninduction x;intros;rewrite mult_comm;simpl.\nauto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simpl;auto with arith.\nrewrite mult_comm;simplQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  rewrite mult_comm.\n  apply mult_le_compat; [apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_le_compat; [ apply mult_le_compat; assumption | auto with arith ].\n  apply mult_leQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction x;intros;rewrite mult_assoc;simpl.\nauto with arith.\nrewrite mult_comm.\nrewrite mult_plus_distr_r.\nsimpl.\nreplace (a*z + a) with (a*z+1*z).\nrewrite mult_minus_distr_r.\nsimpl.\nreplace (a*z+1) with (a*z+1*y).\nrewrite mult_minus_distr_r.\nsimpl.\nreplace (a*z+0) with (a*z+1*z).\nrewrite mult_minus_distr_r.\nsimpl.\nreplace (a*z+1) with (a*z+1*z).\nrewrite mult_minus_distr_r.\nsimpl.\nreplace (a*z+1) with (a*z+1*z).\nrewrite mult_plus_distr_r.\nsimpl.\nreplace (a*z+1) with (a*z+1*z).\nrewrite mult_minus_distr_r.\nsimpl.\nreplace (a*z+1) with (a*z+1*z).\nrewrite mult_plus_distr_Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction x;intros;rewrite mult_n_O in H; generalize (mult_n_O x y);intros;\nrewrite mult_n_O in H; generalize (mult_n_O x y);intros;\n rewrite mult_n_O in H; generalize (mult_n_O x y); intros;\n rewrite mult_n_O in H; generalize (mult_n_O x y); intros;\n rewrite mult_n_O in H; generalize (mult_n_O x y); intros;\n rewrite mult_n_O in H; generalize (mult_n_O x y); intros;\n rewrite mult_n_O in H; generalize (mult_n_O x y); intros;\n rewrite (mult_comm x (b-1)); auto.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  replace (x*y) with (x*y) by ring.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_l.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_r.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_r.\n  replace (x*y) with (x*y) by ring.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_r.\n  replace (x*y) with (x*y) by ring.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_r.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_r.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_minus_distr_r.\n  replace (x*y) with (x*y) by ring.\n  rewrite mult_comm.\n Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction y;intros;rewrite mult_comm;simpl.\n  auto with arith.\n  destruct z;simpl in H0;rewrite mult_n_O in H0;rewrite mult_n_O in H0;rewrite mult_n_O in H0;rewrite mult_n_O in H0; rewrite mult_n_O in H0; simpl in H0; discriminate.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n  auto with arith.\n  Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction x.\n  simpl.\n  trivial.\n  replace (a+(y+y)) with (a+(y-1)) by omega.\n  rewrite mult_minus_distr_l.\n  rewrite mult_minus_distr_l.\n  simpl.\n  rewrite plus_comm.\n  apply plus_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_le_compat; omega.\n  apply mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply (mult_reg_l (S b)).\n  apply le_trans with (S (S b)).\n  apply plus_le_compat_r.\n  apply (mult_reg_l (S b)).\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply mult_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_l (S b)).\n  apply plus_le_compat_l.\n  apply (mult_reg_Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply le_S_n.\n  apply le_trans with (a*b).\n  apply (lt_n_S _ _ H).\n  apply le_trans with (S (S a)).\n  apply le_S_n.\n  apply le_trans with (S (S b)).\n  apply le_S_n.\n  apply le_trans with (S (S b)).\n  apply le_trans with (S (S b)).\n  apply (lt_n_S _ _ H).\n  apply le_trans with (S (S b)).\n  apply le_S_n.\n  apply le_trans with (S (S b)).\n  apply le_n_S.\n  apply le_trans with (S (S b)).\n  apply le_n_S.\n  apply le_trans with (S b).\n  apply le_n_S.\n  apply le_trans with (S (S b)).\n  apply le_n_Sn.\n  apply le_n_S.\n  apply le_trans with (S (S b)).\n  apply le_n_S.\n  apply le_trans with (S b).\n  apply le_n_S.\n  applyQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  rewrite plus_comm.\n  rewrite (mult_comm (S a)).\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  trivial.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply le_trans with (S (a+b)).\n  apply le_trans with (S (a+b)).\n  apply le_n_Sn.\n  rewrite <- minus_n_O; auto.\n  replace (S (a+b)) with (S (a+b)).\n  apply le_n_S.\n  rewrite <- minus_n_O; auto.\n  replace (S (a+b)) with (S (a+b)).\n  apply le_n_S.\n  simpl;rewrite mult_comm;rewrite <- minus_n_O; auto.\n  apply le_trans with (S (a+b)).\n  apply le_S_n.\n  replace (S (a+b)) with (S (a+b)).\n  apply plus_le_compat; omega.\n  omega.\n  omega.\n  replace (S (a+b)) with (S (a+b)).\n  apply le_n_S.\n  replace (S (a+b)) with (S (a+b)).\n  apply le_n_S.\n  simpl; rewrite mult_comm;rewrite <- minus_n_O; auto.\n  omega.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a;simpl;intros.\n  destruct (le_dec x y).\n  left;auto.\n  right;auto.\n  right;auto.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply (mult_reg_l (S b) (S b) (S b)).\n  rewrite plus_comm.\n  rewrite (mult_comm (S b) (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b) (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite mult_assoc.\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S bQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intro.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a;simpl;intros.\n  omega.\n  replace (S a) with (S a) by omega.\n  rewrite plus_comm.\n  rewrite plus_minus_distr_r;trivial.\n  omega.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply (mult_reg_l (S b) (S b) (S a) (S b)).\n  rewrite mult_minus_distr_r; rewrite mult_comm.\n  simpl.\n  rewrite <- minus_n_O;omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_diff_1 y z l);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;auto with arith;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite (mult_comm x y);rewrite (mult_comm x y);rewrite (Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intros.\n  rewrite (minus_diff_1 x y z);rewrite mult_comm;simpl;auto with arith.\n  replace (x*y) with (y*z).\n  rewrite mult_plus_distr_l;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_commQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_2 y z l);rewrite mult_comm;simpl;rewrite minus_diff_2;trivial;auto with arith.\n  replace (x*y) with (x*(y-x)).\n  rewrite mult_minus_distr_l;rewrite minus_plus;auto.\n  replace (x*y) with (x*y).\n  rewrite mult_minus_distr_r;rewrite minus_plus;auto.\n  replace (x * (y-y)) with (x*y).\n  rewrite mult_minus_distr_r;rewrite minus_plus;auto.\n  replace (x * (y - x)) with (x*y).\n  rewrite mult_minus_distr_l;auto.\n  replace (x * (y - x)) with (x*y).\n  rewrite mult_comm;simpl;rewrite mult_comm;simpl;auto.\n  replace (x * (y - x)) with (x*y).\n  rewrite mult_minus_distr_l;auto.\n  replace (x * (y - x)) with (x*y).\n  rewrite mult_minus_distr_Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_1 x y z (lt_diff_2 y z (le_diff_2 y z (le_diff_2 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (eq_diff_4 y z (le_diff_3 y z (le_diff_3 y z (le_diff_4 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_3 y z (le_diff_Qed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_prefix2 y z);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  apply le_trans with (y*z).\n  apply plus_le_compat_r.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  apply le_trans with (y*z).\n  apply plus_le_compat_l.\n  applyQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_eq (x+y) z (plus_diff x y)).\n  apply plus_minus_le_eq.\n  apply plus_minus_le_compat.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; auto.\n  apply plus_le_compat; autoQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_eq x y z);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  rewrite mult_comm;simpl;autoQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec z z);intro.\n  rewrite (minus_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diffQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_prefix2 x z y);rewrite mult_comm;simpl;rewrite minus_diag;auto with arith.\n  rewrite mult_plus_distr_l;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simplQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z); intro.\n  rewrite (minus_diff_1 y z l);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm x (y+z)).\n  rewrite (mult_comm (x*z)).\n  rewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec z x);intro.\n  rewrite (minus_diff_1 (S y) z (le_plus_minus z y));rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  replace (x*y) with (x*(z-x)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;trivial.\n  rewrite mult_comm;rewrite minus_plus;trivial.\n  rewrite mult_comm;simpl;rewrite minus_plus;trivial.\n  rewrite mult_comm;simpl;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;rewrite minus_plus;auto with arith.\n  replace (x * y) with (x * (y-y)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  replace (x * y) with (x * (y-x)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;auto with arith.\n  rewrite plus_comm;simplQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_correct2 z z);rewrite mult_comm;simpl;rewrite minus_diag_r;rewrite minus_diag_r;auto with arith.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_r;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;try assumption.\n  apply plus_le_compat_l;Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_le_dec y z);rewrite (minus_diff_le_dec x y z);rewrite (minus_diff_le_dec y z);rewrite (minus_diff_le_dec y z);rewrite (minus_diff_lt_dec x y z);rewrite (minus_diff_eq_dec y z);rewrite (minus_diff_eq_dec y z);rewrite (minus_diff_diff_eq_dec y z);rewrite (minus_diff_eq_dec x y z);rewrite (minus_diff_eq_dec y z);rewrite (minus_diff_eq_dec y z);rewrite (minus_diff_eq_dec x y z);rewrite (minus_diff_eq_dec x y z); \n  rewrite (minus_diff_eq_dec x y z);rewrite (minus_diff_eq_dec y z);rewrite (minus_diff_eq_dec x y z);rewrite (minus_diff_eq_dec x y z); \n  rewrite (minus_diff_eq_dec x y z);rewrite (minus_diff_eq_dec xQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq x y z);\n  rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq x y z); \n  rewrite (minus_diff_eq y z);rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq x y z); \n  rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq y z);rewrite (minus_diff_eq x y z);rewrite (minus_diff_eq x y z); \n  rewrite (Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_prefix2 x y z);rewrite mult_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewrite plus_comm;simpl;rewrite minus_diag_r;auto with arith.\n  rewriteQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intros.\n  rewrite (minus_le_dec y z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (plus_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (plus_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (plus_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z y);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_comm z z);rewrite mult_comm;simpl;auto with arith.\n  rewrite (mult_commQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec z z);intro.\n  rewrite (minus_diff_lt_eq x y z);rewrite mult_comm;simpl;rewrite minus_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite <- (plus_n_Sm x y);try (auto with arith).\n  rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto with arith.\n  rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;auto with arith.\n  rewrite mult_comm;rewrite minus_plus;rewrite plus_commQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec z z);intro.\n  rewrite (minus_diff_eq _ _ H0);rewrite mult_comm;simpl;rewrite minus_diff;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;rewrite minus_diff;auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus;rewrite minus_diff;auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_assoc;rewrite minus_plus;rewrite minus_plus; auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\n  replace (x*y) with (x*y).\n  replace (x * (y-z)) with (x*(y-z)).\n  rewrite mult_plus_distr_r;rewrite minus_plus; rewrite minus_diff;auto with arith.\n  replace (x*y)Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_lt_eq_dec z x y z);rewrite mult_comm;simpl;rewrite minus_diff_eq_dec;trivial;auto with arith.\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_plus_distr_l;rewrite minus_plus_distr_l;rewrite minus_diff_eq_dec;trivial;auto with arith.\n  replace (x*y) with (x*y).\n  replace (x*y) with (x*(y-z)).\n  rewrite mult_comm;rewrite minus_plus_distr_r;rewrite minus_diff_eq_dec;trivial;auto with arith.\n  rewrite (mult_comm y (y+z));trivial.\n  rewrite (mult_comm y (y+z));trivial.\n  rewrite (mult_comm z (x*y));trivial.\n  rewrite (mult_comm z (x*y));trivial.\n  rewrite (mult_comm x (y+y));trivial.\n  rewrite (mult_comm x (y+y));trivial.\n  rewrite (mult_comm x (y+Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;simpl;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;simpl;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minus_plus;trivial.\n  rewrite minus_plus;rewrite minusQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_2 x y z);rewrite (minus_diff_3 y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);auto.\n  replace (x*y) with (x*(z-y)).\n  rewrite (minus_diff_1 x y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);auto.\n  replace (x*y) with (x*(z-y)).\n  rewrite (minus_diff_1 x y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);rewrite (minus_diff_3 x y z);auto.\n  replace (x*y) with (x*y).\n  rewrite (minus_diff_1 x y z);rewrite (minus_diff_1 x y z);rewrite (minus_diff_3 x y z);autoQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec y z); intro.\n  rewrite (minus_le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;simpl;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec z z);intro.\n  rewrite (le_plus_minus z y);trivial.\n  replace (x + y) with (x*(y-z)).\n  rewrite mult_plus_distr_l;rewrite mult_comm;simpl;rewrite mult_comm;rewrite minus_plus;auto.\n  rewrite <- minus_plus;rewrite plus_comm;simpl;rewrite plus_comm;rewrite plus_comm;simpl;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;rewrite plus_comm;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;rewrite minus_plus;auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_diff_zero x y z);rewrite mult_comm;simpl;rewrite mult_comm;rewrite minus_minus_diff2;trivial;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite mult_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite mult_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite minus_plus;rewrite plus_comm;simpl;rewrite mult_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite minus_Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec x y);intros.\n  rewrite (minus_minus z y);trivial.\n  replace (x+(y-z)) with (x*(y-z)).\n  rewrite mult_minus_distr_r;rewrite mult_comm;simpl;rewrite minus_plus;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto.\n  rewrite minus_plus;rewrite plusQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite <- minus_plus_minus;rewrite plus_comm;rewrite plus_assoc;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.\n  rewrite minus_plus;rewrite plus_comm;simpl;auto with arith.Qed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite minus_plus;auto.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite minus_plus;rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;simpl;rewrite plus_comm;simpl;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_diff_2 b a H1);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_diff_2 b a H1);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_diff_2 b a H2);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  case (le_lt_dec b a);intro.\n  rewrite (minus_diff_2 b a H2);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  case (le_lt_dec b a);intro.\n  rewrite (minus_diff_2 b a H2);rewrite mult_comm;simpl;rewrite minus_diff;trivial;auto with arith.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_diff_2 b a H2);rewrite mult_comm;simpl;Qed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b.\n  intro.\n  case (le_lt_dec a a);intros.\n  rewrite (minus_Sn_m a);trivial.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite minus_plus;rewrite plus_comm;simpl;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite plus_comm;simpl;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite minus_plus;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite minus_plus_assoc;rewrite minus_plus;rewrite minus_plus_assoc;trivial.\n  rewrite minus_plus;rewrite minus_plus;rewrite minus_plus;rewrite minus_plus_comm;simpl;trivial.\n  rewrite minus_plus;rewrite minus_plus;rewrite minus_plus;rewrite minus_plus_comm;simpl;trivial.\n  rewrite minus_plusQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec a b);intro.\n  rewrite (minus_le_dec a a);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_le_dec b a);trivial.\n  case (le_lt_dec b b);intros.\n  rewrite (minus_le_dec a a);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_le_dec b a);trivial.\n  rewrite (minus_le_dec a a);trivial.\n  case (le_lt_dec b a);intros.\n  rewrite (minus_le_dec a b);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_le_dec b a);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_le_dec a b);trivial.\n  rewrite (minus_le_dec b a);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_le_dec b a);trivial.\n  case (le_lt_dec a b);intros.\n  rewrite (minus_leQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case (le_lt_dec b a);intro.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_le_minus a b);trivial.\n  rewrite (minus_leQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  intros.\n  case (le_lt_dec a a);intros.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minus_le_dec a a H0);trivial.\n  rewrite (minusQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  case b;simpl;trivial.\n  case a;simpl;trivial.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nset (n := n) in *.\nset (n := n) in *.\nset (n := n) in *.\nset (n := n) in *.\nset (n := n) in *.\nassert (H' := mult_by_scalars n m H).\nset (n := n) in *.\nassert (H' := mult_by_scalars n m H').\nunfold mult_by_scalars in |- *.\nintros.\nset (n := n) in *.\nassert (H' := mult_by_scalars n m H').\nassert (H' := mult_by_scalars n m H').\nassert (H' := mult_by_scalars n m H').\nassert (H' := mult_by_scalars n m H').\nassert (H' := mult_by_scalars n m H').\nassert (H' := mult_by_scalars (const_seq n) (const_seq n) (const_seq n)).\nassert (H' := mult_by_scalars n m H').\nassert (H' := mult_by_scalars (const_seq n) (const_seq n) (constQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; elim n.\n simpl in |- *.\nauto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\napply mult_integral_l with (n := n) (m := n); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m; case m.\nintros; discriminate.\nintros p; case p.\nintros p; case p.\nintros n' p; case p; case p.\nintros; discriminate.\nintros p; case p.\nintros n' p; case p.\nintros n' p; case p; case p; simpl in |- *; intros; discriminate.\nintros p; case p.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros p; case p.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros p; case p; simpl in |- *; intros; discriminate.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros n' p; case p; simpl in |- *; intros; discriminate.\nintros p; case p; simplQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; case n.\n simpl in |- *.\n intro H; apply lt_n_S; auto with arith.\nintros n H; case H.\nauto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; case n; auto.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintro n; elim n; elim m; simpl in |- *; intros.\nexists (S n); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\ninduction n; simpl in |- *; auto with arith.\nintros; absurd (n = 0); auto with arith.\nintros; absurd (n = 0); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\ninduction n; simpl; auto.\nintros.\napply le_antisym; auto.\nintros.\napply H; auto.\nintros; apply H; auto.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\ninduction n; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite (mult_comm m n).\n  rewrite (mult_comm m n).\n  rewrite (mult_comm m n).\n  reflexivity.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  case (eq_nat_dec n m); intro.\n  case (eq_nat_dec n m); intro.\n  rewrite e in H.\n  rewrite mult_comm.\n  rewrite H0.\n  apply mult_n_Sm.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  intros.\n  simpl in H.\n  elim H; auto with arith.\n  elim H; auto with arith.\n  intros.\n  simpl in H.\n  elim H; auto with arith.\n  elim H0; auto with arith.\n  intros.\n  simpl in H.\n  elim H; auto with arith.\n  elim H0; auto with arith.\n  intros.\n  simpl in H.\n  elim H; auto with arith.\n  elim H0; auto with arith.\n  Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl;auto with arith.\n  elim H0; auto with arith.\n  simpl;auto with arith.\n  elim H0; auto with arith.\n  simpl;intros; elim H1; auto with arith.\n  simpl;intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl; intros; elim H1; auto with arith.\n  simpl;Qed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm n m).\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  pattern (S n) at 2.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  rewrite <- mult_n_O.\n  rewrite mult_n_O.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H0;auto.\n  elim H0; auto.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm mQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H1;auto with arith.\n  elim H0;auto with arith.\n  elim H1; auto with arith.\n  elim H0;auto with arith.\n  elim H0;auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H0; auto with arith.\n  elim H1; auto with arith.\n  elim H0; auto with arith.\n  elim H1; auto with arith.\n  elim H1; auto with arith.\n  elim HQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m; simpl;auto with arith.\n  elim H;auto with arith.\n  elim H0;auto with arith.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl in H.\n  right.\n  rewrite mult_comm.\n  reflexivity.\n  simpl in H.\n  right.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite mult_assoc.\n  rewrite (mult_comm m).\n  rewrite (mult_comm m).\n  rewrite (mult_assoc m).\n  rewrite (multQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl in H.\n  left.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_lemma3.\n  apply mult_Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  rewrite mult_assoc.\n  simpl in |- *.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n; simpl;auto with arith.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite <- (mult_comm m).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite <- mult_plus_distr_l.\n  rewrite mult_assoc.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_l.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_plus_distr_rQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl.\n  auto with arith.\n  rewrite <- H0.\n  auto with arith.\n  simpl in H.\n  left.\n  auto with arith.\n  apply mult_le_compat_l.\n  auto with arith.\n  rewrite <- H0.\n  auto with arith.\n  simpl in H.\n  right.\n  auto with arith.\n  apply mult_le_compat_l.\n  auto with arith.\n  auto with arith.\n  auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction n.\n  simpl.\n  apply mult_assoc.\n  simpl in |- *.\n  rewrite mult_comm.\n  apply mult_n_O.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m.\n  simpl.\n  right.\n  intro.\n  simpl.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  simpl.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  simpl.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  simpl.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  apply mult_n_O.\n  simpl.\n  auto with arith.\n  elim H0.\n  intros.\n  apply mult_n_Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  rewrite (mult_comm m n); trivial.\n  rewrite mult_comm.\n  rewrite (mult_comm m n); trivial.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  simpl in H.\n  left.\n  rewrite H.\n  right.\n  rewrite H.\n  right.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_r.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  apply mult_le_compat_l.\n  simpl in H.\n  applyQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  replace (n * m) with (n * m) by omega.\n  rewrite mult_comm.\n  replace (n * m) with (n * m) by omega.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_plus_distr_r.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm m).\n  reflexivity.\nQed."
                ]
            }
        ]
    }
}