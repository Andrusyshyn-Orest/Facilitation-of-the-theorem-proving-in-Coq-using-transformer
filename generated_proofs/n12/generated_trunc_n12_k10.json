{
    "hyperparams": {
        "sequence_length": 1024,
        "max_new_tokens": 256,
        "batch_size": 4,
        "proofs_per_theorem": 10,
        "temperature": 0.6,
        "do_sample": true,
        "top_p": 0.95,
        "model_repo_name": "Andrusyshyn/gpt2-pretrained-for-coq-pt-custom-train",
        "model_commit_hash": "41d3d96b6b3d0a267bb09893b5f851d658234ad7",
        "torch_seed": 7
    },
    "projects": {
        "weak-up-to": [
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    ",
                "context_tokens": 440,
                "proof_start_offset": 1443,
                "proof_end_offset": 1519,
                "proof": "Lemma weak_refl: forall x, Weak T x x.\nProof.\nintro x; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    unfold L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L, LQed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n    \tunfold Inv; intros; apply R_refl.\n  Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      induction x.\n      simpl.\n      apply H.\n      apply H.\n      apply H.\n  Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      intros.\n      unfold Ext.\n      unfold Inv.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply Wf.union2.\n      apply binary.union2.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Ext; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction x.\n      simpl.\n      apply (is_empty_x x).\n      intros.\n      apply (is_empty_x x).\n      apply (is_empty_x x).\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      destruct x; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Ext; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      induction x; simpl; auto.\n    Qed.",
                    "Lemma weak_refl: forall x, Weak T x x.\n    Proof.\n      unfold Ext; simpl.\n      destruct (X x); simpl; auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    ",
                "context_tokens": 473,
                "proof_start_offset": 1555,
                "proof_end_offset": 1835,
                "proof": "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply S_star with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros; inv H; inv H0; inv H1; inv H2; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros; red; intro H.\n    induction H; simpl; auto.\n    apply (valid_trans H); auto.\n    apply (valid_trans H); auto.\n    apply (valid_trans H0); auto.\n  Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros.\n      induction l; simpl; auto.\n      intros.\n      apply (H _ H1).\n      apply (H0 _ H2).\n      apply (H0 _ H3).\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros. inv H; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros; red; destruct x; destruct y; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros; red; destruct (X x); destruct (Y y); simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros; apply H. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intros. destruct l; simpl; auto. Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z; simple induction l.\n      simpl; auto.\n      apply (IHt0 x).\n      intros l r H1 H2 H3.\n      generalize (IHt2 x); simple induction l.\n      simpl; auto.\n      apply (IHt2 x).\n      intros l r H1 H3.\n      generalize (IHt3 x); simple induction l.\n      simpl; auto.\n      simpl; auto.\n    Qed.",
                    "Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. intro y; simpl; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 561,
                "proof_start_offset": 1841,
                "proof_end_offset": 2069,
                "proof": "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply S_star with y; assumption.\nexists x; auto.\nexists y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Ppre YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n  Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z tycast YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HPQ YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW ZW].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HXY Z.\n      apply S_star with y; assumption.\n      destruct Z as [ w YW ZWY].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x zSyY; apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z SZ YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW ZWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z tycast.\n      apply S_plus with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Xz YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n  Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HUV YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HXY Z.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    ",
                "context_tokens": 633,
                "proof_start_offset": 2075,
                "proof_end_offset": 2206,
                "proof": "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\nProof.\nintros l x y H.\napply weak_tau with y; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros y l; destruct l; simpl; intros x y SZ YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x z Hyy YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros.\n      destruct l; simpl; intros x z tycast; simpl; intros y z nN; simpl; intros.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HADT YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l; destruct l; simpl; intros x z tycast; simpl; intros.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Vu YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x l; destruct l; simpl; intros x y z Ny Z.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y. destruct l; simpl; intros x y HXY YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros x l; destruct l; simpl; intros x z xz YZ.\n      apply S_plus with y; assumption.\n      destruct YZ as [ w YWYY].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y; destruct l; simpl; intros x y xz YZ.\n      apply S_star with y; assumption.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": "(** * Labelled Transition Systems (LTS) *)\n\nRequire Export Diagrams.\nSet Implicit Arguments.\n\nLtac cgen H := generalize H; clear H.\n\nSection Reductions.\n\n  Section R.\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    ",
                "context_tokens": 677,
                "proof_start_offset": 2212,
                "proof_end_offset": 2502,
                "proof": "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct YZ as [ w YW WZ ].\nexists w; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply Wf_clos_trans with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x zSy YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_tau with y; auto.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z JK YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply cong_lt with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Ppre YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n  Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n  Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z; destruct l; simpl; intros x z eqx YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z HUV YZ.\n      apply S_plus with y; assumption.\n    Qed.",
                    "Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply partial_step with y; auto.\n    Qed."
                ]
            },
            {
                "filepath": "./coq_projects/weak-up-to/Reductions.v",
                "context": ".\n    Variables A X: Type.\n    Definition reduction := A -> relation X.\n    Definition incl_r: relation reduction := fun R1 R2 => forall a, incl (R1 a) (R2 a).\n    Definition eeq_r: relation reduction := fun R1 R2 => forall a, eeq (R1 a) (R2 a).\n  End R.\n\n  Variable A: Type.\n\n  Section Diagram.\n    Variables X Y: Type.\n    Definition diagram_r(RX: reduction A X) R (RY: reduction A Y) S := forall a, diagram (RX a) R (RY a) S.\n  End Diagram. \n\n  Section Weak.\n  \n    (** A `label' is either the silent action, or a visible one *)  \n    Inductive Lbl: Type := T | L(a: A).\n    Definition reduction_t := reduction Lbl.\n  \n    Variable X: Type.\n    Variable Red: reduction_t X.\n\n    (** Weak transition relation *)  \n    Definition Weak: reduction_t X := fun l => \n      match l with \n\t| T => star (Red T)\n\t| L a => comp (star (Red T)) (comp (Red (L a)) (star (Red T)))\n      end.\n\n    (** Transition relation for expansion *)\n    Definition EWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => Red (L a)\n      end.\n\n    (** Transition relation for relaxed expansion *)\n    Definition REWeak: reduction_t X := fun l => \n      match l with \n\t| T => union2 (eq (A:=X)) (Red T)\n\t| L a => comp (Red (L a)) (star (Red T))\n      end.\n\n    Lemma weak_refl: forall x, Weak T x x.\n    Proof. intro x; simpl; auto. Qed.\n    Hint Immediate weak_refl.\n\n    Lemma tau_weak: forall y l x z, Red T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply S_star with y; assumption.\n    Qed.\n\n    Lemma weak_tau: forall y l x z, Red l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n      exists x; auto.\n      exists y; auto.\n    Qed.\n\n    Lemma red_weak: forall l x y, Red l x y -> Weak l x y.\n    Proof.\n      intros l x y H.\n      apply weak_tau with y; auto.\n    Qed.\n\n    Lemma taus_weak: forall y l x z, Weak T x y -> Weak l y z -> Weak l x z.\n    Proof. \n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply star_trans with y; assumption.\n      destruct YZ as [ w YW WZ ].\n      exists w; auto.\n      apply star_trans with y; assumption.\n    Qed.\n\n    ",
                "context_tokens": 718,
                "proof_start_offset": 2508,
                "proof_end_offset": 2853,
                "proof": "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\nProof.\nintros y l; destruct l; simpl; intros x z XY YZ.\napply star_trans with y; assumption.\ndestruct XY as [ w XW WY ].\ndestruct WY as [ t WT TY ].\nexists w; auto.\nexists t; auto.\napply star_trans with y; assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z XY YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Ny YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Ny Z.\n      apply S_star with y; assumption.\n      destruct Z as [ w YW ZW].\n      exists w; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z tycast YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z xz YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z eqx YZ.\n      apply S_star with y; assumption.\n      destruct Z; auto.\n      apply S_star with y; assumption.\n  Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z tycast; simpl; intros y z ntrue; simpl; intros.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z Vu YZ.\n      apply S_star with y; assumption.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l x z H.\n      apply weak_t with y; auto.\n    Qed.",
                    "Lemma weak_taus: forall y l x z, Weak l x y -> Weak T y z -> Weak l x z.\n    Proof.\n      intros y l; destruct l; simpl; intros x z tycast YZ.\n      apply S_star with y; assumption.\n      destruct YZ as [ w YWZ].\n      exists w; auto.\n      apply S_star with y; assumption.\n  Qed."
                ]
            }
        ],
        "buchberger": [
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\n",
                "context_tokens": 38,
                "proof_start_offset": 167,
                "proof_end_offset": 590,
                "proof": "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0; [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b; elim (H a); auto.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b ys H; elim H; intros.\nsplit; intros.\nelim (H0 (H1 a)); intros.\nelim H0; intros.\nelim (H0 (H1 a); intros.\nelim H1; intros.\nelim H1; intros.\nelim H1; intros.\nsplit; intros.\nelim (H1 a); intros.\nelim H2; intros.\nsplit; intros.\nelim (H2 a); intros.\nelim H3; intros.\nelim (H3 a); intros.\nelim H3; intros.\nelim H3; intros.\nsplit; intros.\nelim H3; intros.\nsplit; intros.\nelim H4; intros.\nelim H5; intros.\nsplit; intros.\nelim (H3 a); intros.\nelim H5; intros.\nelim H5; intros.\nsplit; intros.\nelim H5; intros.\nsplit; intros.\nelim (H3 a0); intros.\nelim H5; intros.\nelim H6; intros.\nsplit; intros.\nelim (H5 a); intros.\nelim H6; introsQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b; red in |- *.\napply map_in.\napply map_in.\napply map_in.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nunfold map in |- *.\nintros A B f b xs H H0; elim H0; intros; auto with arith.\nelim H; intros; auto with arith.\nelim (H1 (H2 a) (H3 a)); auto with arith.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros; red in |- *; unfold map in |- *; apply map_in_dom.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nProof.\n  unfold map in |- *.  intros A B f b.  simpl in |- *.  intros.  elim (le_or_lt_or_eq _ _ H).\n  assumption.  intro y.  elim y.  intros y1 y2.  elim y2.  intros y3 y4.  elim y4.  intros y4.\n  elim y5.  intros y5 y6.  elim y7.  intros y7 y8.  elim y8.  intros y8 y10.\n  elim y10.  intros y10.  elim y10.  intros y11 y12.  elim y10.  intros y11 y12.\n  elim y10.  intros.  elim y12.  intros y12 y13.  elim y11.  intros y13 y14.\n  elim y14.  intros y14 y11.  elim y12.  intros y14 y12.  elim y13.  intros.\n  elim y12.  intros.  elim y14.  intros y15 y10.  elim y11.  intros y13 y15.\n  elim y10.  intros y15 yQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs ys H.\nelim H; intros; auto with arith.\nelim (H0 a); intros; auto with arith.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b; unfold map in |- *; split; [ auto with zfc | idtac ].\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b; elim A; simpl in |- *; intros a b H.\napply map_in_dom; auto with algebra.\nQed.",
                    "Lemma map_in : forall (A B : Set) (f : A -> B) (b : B) (xs : list A), In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b ys; unfold map in |- *; apply map_in_map; auto with algebra.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\n",
                "context_tokens": 214,
                "proof_start_offset": 592,
                "proof_end_offset": 803,
                "proof": "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros H'; elim H'; auto.\nintros H'; elim H'; auto.\nintros a0 E; elim E; intros H'0 H'0; clear H'0; auto.\nexists a0; split; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a0 E; elim E; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed.",
                    "Lemma map_app : forall (A B : Set) (f : A -> B) (l1 l2 : list A), map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1 l2; elim l1; simpl in |- *; auto.\nintros H'; elim H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 805,
                "proof_end_offset": 1093,
                "proof": "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nProof.\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto with datatypes.\nintros a l; rewrite H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l; rewrite <- H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'2 H'3; clear H'0 | intros H'0; clear H' ]; \n auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l; rewrite <- (H a); auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l H' a; rewrite H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l; rewrite <- H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l; rewrite H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l; rewrite <- H'; auto.\nQed.",
                    "Lemma map_rev : forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\n",
                "context_tokens": 414,
                "proof_start_offset": 1095,
                "proof_end_offset": 1340,
                "proof": "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nProof.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nintros a0 l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; rewrite <- H'; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l H'; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H' ]; \n auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l H'; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H' a; elim H'; auto.\nQed.",
                    "Lemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H' a H'0; elim H'0; auto.\nintros a l0 H'0 H'1; elim H'1; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/ListProps.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\nRequire Import List.\n\nLemma map_in :\n forall (A B : Set) (f : A -> B) (b : B) (xs : list A),\n In b (map f xs) -> ex (fun a : A => b = f a /\\ In a xs).\nintros A B f b xs; elim xs; simpl in |- *; auto.\nintros H'; elim H'; auto.\nintros a l H' H'0; elim H'0;\n [ intros H'1; clear H'0 | intros H'1; clear H'0 ]; \n auto.\nexists a; split; auto.\nelim H'; [ intros a0 E; elim E; intros H'2 H'3; clear E H' | clear H' ]; auto.\nexists a0; split; auto.\nQed.\n\nLemma map_app :\n forall (A B : Set) (f : A -> B) (l1 l2 : list A),\n map f (l1 ++ l2) = map f l1 ++ map f l2.\nintros A B f l1; elim l1; simpl in |- *; auto with datatypes.\nintros a l H' l2; rewrite H'; auto.\nQed.\n\nLemma map_rev :\n forall (A B : Set) (f : A -> B) (l : list A), map f (rev l) = rev (map f l).\nintros A B f l; elim l; simpl in |- *; auto.\nintros a l0 H'; rewrite <- H'; simpl in |- *; auto.\napply trans_equal with (y := map f (rev l0) ++ map f (a :: nil)); auto.\napply map_app; auto.\nQed.\n\nLemma rev_in : forall (A : Set) (a : A) (l : list A), In a (rev l) -> In a l.\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H' H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'1; auto.\nelim H'1; auto.\nintros H'2; elim H'2.\nQed.\n\n",
                "context_tokens": 524,
                "proof_start_offset": 1342,
                "proof_end_offset": 1509,
                "proof": "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nProof.\nintros A a l H'.\napply rev_in with (A := A); auto.\nrewrite (rev_involutive l); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a l0 H'0; elim H'0; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0.\ncase (in_app_or _ _ _ H'1); simpl in |- *; intros H'2; auto.\nelim H'1; auto.\nintros a0 l0 H'0; elim H'0; auto.\nintros a0 l0 H'1; elim H'2; auto.\nintros H'2; elim H'2; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'2; auto.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'3; auto.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'4; auto.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'4; auto.\ncase (in_app_or _ _ _ H'4); simpl in |- *; intros H'5; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H'; apply in_rev.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'2; auto.\nexists a0; split; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0; elim H'0; auto.\nintros H'1; elim H'1; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H'; elim H'; simpl in |- *; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l H'0.\ncase (in_app_or _ _ _ H'0); simpl in |- *; intros H'2; auto.\nexists a0; split; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l H' a; case (in_app_or _ _ _ H'0); simpl in |- *;\n intros H'1; elim H'2; auto.\nQed.",
                    "Lemma in_rev : forall (A : Set) (a : A) (l : list A), In a l -> In a (rev l).\nintros A a l; elim l; simpl in |- *; auto.\nintros a0 l0 H'0.\ncase (in_app_or _ _ _ H'0); intros H'2; auto.\ncase (in_app_or _ _ _ H'0); intros H'3; auto.\ncase (in_app_or _ _ _ H'0); intros H'4; auto.\ncase (in_app_or _ _ _ H'0); intros H'4; auto.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_or.\napply in_app_orQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 163,
                "proof_start_offset": 1031,
                "proof_end_offset": 1124,
                "proof": "Definition zeroP : Term -> Prop.\nProof.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition zeroP : Term -> Prop.\nintro.\napply (Build_Setoid (A * mon n)).\nexact (Build_Setoid (A * mon n)).\nDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition zeroP := one P.\nDefinition zeroP := one P.\nDefinition oneP := one P.\nDefinition oneP := one P.\nDefinition zeroP := one P.\nDefinition oneP := one P.\nDefinition zeroP := one P.\nDefinition zeroP := one P.\nDefinition zeroP := one P.\nDefinition zeroP := one P.\nDefinition zeroP := one P.\nDefinition zeroP := one P.\nDefinition zeroP := zeroP.\nDefinition oneP := zeroP.\nDefinition oppP := one P.\nDefinition oppP := one P.\nDefinition addP := zeroP.\nDefinition oppP := zeroP.\nDefinition oppP := zeroP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppP.\nDefinition oppP := oppPDefined.",
                    "Definition zeroP : Term -> Prop.\nAdmitted.\n\nDefinition zeroP := Bool.\nDefinition zeroP := Bool.\nDefinition oneP := Bool.\nDefinition zeroP := Bool.\nDefinition zeroP := Bool.\nDefinition zeroP := Bool.\nDefinition zeroP := Bool.\nDefinition zeroP := Bool.\nDefinition zeroP := Bool.\nDefinition oneP := Bool.\nDefinition zeroP := Bool.\nDefinition oneP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.\nDefinition negP := Bool.Defined.",
                    "Definition zeroP : Term -> Prop.\nAdmitted.\nDefinition zeroP := fun P => zeroP.\n\nDefinition zeroP := fun P => oneP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => oneP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition oneP := fun P => oneP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition zeroP := fun P => zeroP.\nDefinition oneP := fun P => zeroPDefined.",
                    "Definition zeroP : Term -> Prop.\nintro.\napply (Build_Map (fun a b => let (a, b) := a in b).\nDefined.",
                    "Definition zeroP : Term -> Prop.\nAdmitted.\n\nDefinition zeroP := forall x, P x.\n\nDefinition zeroP := forall x, P x.\n\nDefinition zeroP := forall x, P x.\n\nDefinition zeroP := forall x, P x.\n\nDefinition zeroP := forall x, P x.\nDefinition zeroP := zeroP.\n\nDefinition zeroP := oneP.\n\nDefinition zeroP := zeroP.\n\nDefinition zeroP := zeroP.\nDefinition zeroP := zeroP.\n\nDefinition zeroP := zeroP.\n\nDefinition zeroP := oneP.\n\nDefinition oneP := oneP.\n\nDefinition oppP := oneP.\n\nDefinition oppP := zeroP.\n\nDefinition oppP := zeroP.\n\nDefinition oppP := oppP.\n\nDefinition oppP := oppP.\n\nDefinition addP := oppP.\n\nDefinition addP := addP.\n\nDefinition oppP := oppP.\n\nDefinition addP := addP.\n\nDefinition oppP := addP.\n\nDefinition oppP := addP.\n\nDefinition addP := addP.\n\nDefinition addP := addP.\n\nDefinition addP :=Defined.",
                    "Definition zeroP : Term -> Prop.\nmove=> m m; apply: (m == 0).\nDefined.",
                    "Definition zeroP : Term -> Prop.\nProof.\n  intro P.\n  apply (Build_Map (fun m n m => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (fun m n => m = n)).\n  apply (Build_Map (funDefined.",
                    "Definition zeroP : Term -> Prop.\n\nDefinition rule_mon (m n : natural) :=\n  let: Pack _ m := m in\n  forall m, m = n -> m = m.\n\nDefinition rule_mon (m n : natural) :=\n  let: Pack _ m := m in\n  forall m, m = n -> m = m.\n\nDefinition axiom_mon (m n : natural) :=\n  let: Pack _ m := m in\n  forall m, m = n -> m = m.\n\nDefinition axiom_mon (m n : natural) :=\n  let: Pack _ m := m in\n  forall m, m = n -> m = n.\n\nDefinition axiom_mon (m n : natural) :=\n  let: Pack _ m := m in\n  fun m => Pack _ m (m * n).\n\nDefinition class := let: Pack _ m := cT in\n  fun m => Pack _ m ( class_of _ m).\n\nDefinition clone_pre (m n : natural) :=\n  let: Pack _ m := cT in\n  fun m => Pack _ m ( class_of _ m).\n\nDefinition clone_pre_true (m n : natural) :=\n  let: Pack _ m := cTDefined.",
                    "Definition zeroP : Term -> Prop.\nProof.\nmove=> n m; elim: n m => //= m IHm; rewrite?andbF //.\nby apply: anti_order; rewrite // orbT.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \n",
                "context_tokens": 197,
                "proof_start_offset": 1127,
                "proof_end_offset": 1265,
                "proof": "Definition eqTerm : Term -> Term -> Prop.\nProof.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; case H'.\nintros a H'2; case H'1; case H'2; case H'2; case H'3; case H'3; case H'3; case H'4; case H'5; case H'5;\n intros H'6 H'7 H'8; elim H'7; case H'8; case H'7; case H'8;\n intros H'8 H'9 H'10; elim H'9;\n intros H'10 H'11; elim H'10;\n intros H'11 H'12; elim H'12;\n intros H'12 H'13; elim H'12;\n intros H'14 H'14; elim H'14;\n intros H'14 H'15; elim H'14;\n intros H'15 H'16; elim H'16;\n intros H'15 H'15; elim H'15;\n intros H'16 H'16; elim H'16;\n intros H'17 H'19; elim H'19;\n intros H'19 H'20; elim H'Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (Equiv (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans a) (equiv_trans aDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'2; case H'1.\nintros H'2; case H'2.\nintros H'3; case H'3.\nintros H'4 H'5; case H'5.\nintros H'6 H'7; case H'8.\nintros H'7 H'8 H'9.\napply H'9; auto with sets.\nintros H'9 H'10 H'11.\napply H'10; auto with sets.\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; case (H' a); exact (eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; case H'1.\nintros a H'2; case H'2.\nintros a H'3; case H'3.\nintros a H'4 H'5; apply H'5; auto.\nintros a H'6; case H'6.\nintros a H'7; case H'7.\nintros a H'8; case H'8.\nintros a H'9; case H'8.\nintros a H'9; case H'9.\nintros a H'9; case H'9.\nintros a H'9; case H'9.\nintros a H'10; case H'9.\nintros a H'9; case H'9.\nintros H'9 H'10; case H'10.\nintros a H'10; case H'10.\nintros H'11 H'11 H'11 H'12; case H'10.\nintros H'12 H'12 H'14; case H'11.\nintros H'13 H'13 H'14; case H'14.\nintros a H'14; caseDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqDec a).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; apply (eqA a A0); case H'.\nintros a H'2; case H'1; case H'2; case H'1; case H'2; case H'3;\n intros H'3 H'4 H'5; apply (eqA a A0); case H'4;\n intros H'5 H'6; apply (eqA a A0); case H'5; case H'6;\n intros H'7 H'8 H'8; apply (eqA a A0); case H'7;\n intros H'9 H'10; apply (eqA a A0); case H'9;\n intros H'11 H'12; apply (eqA a A0); case H'10;\n intros H'12 H'12; apply (eqA a A0); case H'11;\n intros H'14 H'14; apply (eqA a A0); case H'11;\n intros H'14 H'14; apply (eqA a A0); case H'14;\n intros H'14 H'14; apply (eqA a A0); case H'14;Defined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact ( eqA a A0).\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a H'1 H'2; case H'1; case H'2; case H'2; case H'3; case H'3; case H'3; case H'4; case H'5;\n intros H'5 H'6; case H'6; case H'7; case H'7; case H'7;\n intros H'7 H'7 H'8; case H'8; case H'8; case H'8; case H'9;\n intros H'8 H'9 H'10; apply H'9; apply H'10; apply H'10; apply H'10;\n auto with sets.\nDefined.",
                    "Definition eqTerm : Term -> Term -> Prop.\nintro H'; case H'.\nintros a H'1; case H'1.\nintros a H'2; case H'2.\nintros H'3 H'4; case H'4.\nintros H'5 H'6; apply H'6; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 259,
                "proof_start_offset": 1315,
                "proof_end_offset": 1416,
                "proof": "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; red in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; simpl in |- *; auto with algebra.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nsplit; [ idtac | exact (eqA a A0).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\nsplit; [ exact (equivity_sym_sym_1 (M1:=M2)).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nProof.\n  constructor; red; intros; exact (Equiv (Equiv (Equiv (Equiv A0) (Equiv A0) (Equiv A0) (Equiv A0))).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; intros a H'; case H'.\nintros a H'1; case H'1; case H'2.\nintros a H'2; case H'1; case H'2.\nintros H'3 H'4; red in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nintros a a' H'; case H'.\nintros b b'; exact (eqA a b).\nQed.",
                    "Theorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *; red in |- *; red in |- *; intros.\napply H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 293,
                "proof_start_offset": 1419,
                "proof_end_offset": 1578,
                "proof": "Theorem eqTerm_sym : symmetric Term eqTerm.\nProof.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; auto with *.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; red in |- *; intros x; case x.\nintros a H'; apply H'; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; red in |- *; red in |- *; red in |- *; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *; red in |- *; red in |- *; intros x y z H'; inversion H';\n auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 350,
                "proof_start_offset": 1581,
                "proof_end_offset": 1788,
                "proof": "Theorem eqTerm_trans : transitive Term eqTerm.\nProof.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nintros y z; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *; red in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nsplit.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 435,
                "proof_start_offset": 1838,
                "proof_end_offset": 1917,
                "proof": "Definition T2M : Term -> mon n.\nProof.\nintros t; case t; intros a m; exact m.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition T2M : Term -> mon n.\nintros H'; case H'; case H'; case H'; case H'; case H'.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintro H'; case H'.\nintros a H'; case H'; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintro H'; case H'.\nintros x y; case y; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nred in |- *.\nintros x y z; case z; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'; case H'; case H'.\nintros a H'0; case H'0; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'; case H'; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\napply\n (Build_Setoid (A:=A) (B:=A) (B:=A) (C:=fun x : T2A => C x)).\nred in |- *.\nintros x y z; case x; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros x y z; case y; simpl in |- *; auto.\nDefined.",
                    "Definition T2M : Term -> mon n.\nintros H'; case H'.\nintros a b H'0; case H'0.\nintros a' H'1; case H'0.\nintros a' H'2; case H'1.\nintros a' H'3; case H'1.\nintros a'' H'4; case H'4; auto.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 522,
                "proof_start_offset": 2133,
                "proof_end_offset": 2190,
                "proof": "Lemma eqT_refl : reflexive _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nsplit; red in |- *; intros x y z; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y z; case x; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *; red in |- *; intros x y z.\napply T2M.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros a b; case b; case b; simpl in |- *; auto.\nQed.",
                    "Lemma eqT_refl : reflexive _ eqT.\nred in |- *.\nintros a b; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 543,
                "proof_start_offset": 2193,
                "proof_end_offset": 2249,
                "proof": "Lemma eqT_sym : symmetric _ eqT.\nProof.\nred in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "(* This code is copyrighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \n",
                "context_tokens": 564,
                "proof_start_offset": 2252,
                "proof_end_offset": 2364,
                "proof": "Lemma eqT_trans : transitive _ eqT.\nProof.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed.",
                    "Lemma eqT_trans : transitive _ eqT.\nred in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "ighted by its authors; it is distributed under  *)\n(* the terms of the LGPL license (see LICENSE and description files) *)\n\n(****************************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \n",
                "context_tokens": 601,
                "proof_start_offset": 2367,
                "proof_end_offset": 2492,
                "proof": "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; red in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nunfold eqT in |- *; unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfold Equal in |- *;\n unfold Equal in |- *; unfold Equal in |- *; unfoldQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nunfold eqTerm in |- *; intros a b; case b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; case a; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nProof.\n  unfold eqic in |- *.\n  intros x y z H' H'0; rewrite H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; case H'; case H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; case H'; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nunfold eqTerm in |- *; auto.\nQed.",
                    "Theorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b H'; case H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "**********************************************************************\n                                                                           \n          Buchberger : Terms                           \n                                                                           \n          Laurent Thery April 01                          \n                                                                           \n  ****************************************************************************)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \n",
                "context_tokens": 618,
                "proof_start_offset": 2495,
                "proof_end_offset": 2864,
                "proof": "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nProof.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed.",
                    "Theorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *; intuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "****)\nRequire Import Relation_Definitions.\nRequire Import CoefStructure.\nRequire Import moreCoefStructure.\nRequire Import OrderStructure.\nRequire Import Monomials.\nSection Term.\nLoad \"hCoefStructure\".\nLoad \"mCoefStructure\".\nLoad \"hOrderStructure\".\nLoad \"mOrderStructure\".\n \nDefinition M1 := zero_mon n.\n \nDefinition Term := (A * mon n)%type.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \n",
                "context_tokens": 735,
                "proof_start_offset": 2867,
                "proof_end_offset": 3131,
                "proof": "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *.\nintros a b c; case a; case b; simpl in |- *; auto.\nintros a b c; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b H' H'0; elim H'; intros H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case a; case b; simpl in |- *.\nintros a b c3.\ncase (eqmon_dec a b); intros eqAZ; auto.\ncase (eqmon_dec a b); intros eqAZ; auto.\ncase (eqmon_dec a b); intros eqAZ; auto.\ncase (eqmon_dec a b); intros eqAZ; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case a; case b; simpl in |- *; auto.\nintros a b H'1; case (eqmon_dec a b); intros eqAZ; auto.\nleft; red in |- *; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; case b; simpl in |- *; auto.\nintros a b c0 b c0 b0 c1 c2 d2 d3.\ncase (eqmon_dec n c1 d2); intros eqAZ; auto.\ncase (eqmon_dec n c1 d2); intros eqAZ; auto.\ncase (eqmon_dec n c1 d3); intros eqAZ; auto.\ncase (eqmon_dec n c1 d2); intros eqAZ; auto.\ncase (eqmon_dec n c2 d3); intros eqAZ; auto.\ncase (eqmon_dec n c3 d4); intros eqAZ; auto.\ncase (eqmon_dec n c1 d2); intros.\ncase (eqmon_dec n c2 d4); intros eqAZ; auto.\nright; red in |- *; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b H'; case a; case b; simpl in |- *; auto.\nintros a' b; case (eqmon_dec a' b'); intros eqAZ; auto.\nleft; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; case b; simpl in |- *.\nintros a b; case b; case b; simpl in |- *.\nintros a b c3 b4 c5; case (eqmon_dec a b4); intros eqAZ; auto.\ncase (eqmon_dec a b4); intros eqAZ; auto.\nright; red in |- *; intros H'; elim H'; intros H'1 H'2; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b c H'0; elim H'; intros H'1; clear H'; auto.\nQed.",
                    "Theorem eqT_zerop_is_eqTerm : forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition zeroP : Term -> Prop.\nintros H'; case H'.\nintros a H'1; exact (eqA a A0).\nDefined.\n \nDefinition eqTerm : Term -> Term -> Prop.\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 745,
                "proof_start_offset": 3134,
                "proof_end_offset": 3267,
                "proof": "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nProof.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros a b H' a b H'0; case (eqmon_dec n c1); intros eqAZ1; auto.\nright; red in |- *; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *; auto.\nintros a b c3 c4.\ncase (eqmon_dec n c4); intros eqAZ1; auto.\ncase (eqmon_dec n c4); intros eqAZ2; auto.\ncase (eqmon_dec n c4); intros eqAZ2; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros b2 c3; case (eqmon_dec n c3); intros eqAZ; auto.\nleft; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros a b c3 c4; case (eqmon_dec n c3 c4); intros eqAZ; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros a b c3; case (leb_dec a b); case (leb_dec a b); intros eqAZ; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; case x; simpl in |- *.\nintros a b2 c3; case (eqmon_dec n c3 c3); intros eqAZ; auto.\ncase (eqmon_dec n c3 c3); intros eqAZ; auto.\ncase (eqmon_dec n c3 c3); intros eqAZ; auto.\ncase (eqmon_dec n c3 c4); intros eqAZ; auto.\ncase (eqmon_dec n c3 c4); intros eqAZ; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros a0 b c1 c2.\ncase (eqmon_dec n c1 c2); intros eqAZ; auto.\nleft; red in |- *; intros H'; elim H'; intros H'1 H'2; clear H'; auto.\nQed.",
                    "Theorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; case b; simpl in |- *.\nintros a b; caseQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nintros H'; case H'.\nintros a a' H'2; case H'2.\nintros b b'; exact (eqA a b /\\ a' = b').\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem eqTerm_refl : reflexive Term eqTerm.\nred in |- *.\nintros x; case x; simpl in |- *; auto.\nQed.\n \nTheorem eqTerm_sym : symmetric Term eqTerm.\nred in |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \n",
                "context_tokens": 740,
                "proof_start_offset": 3270,
                "proof_end_offset": 3522,
                "proof": "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto; apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; elim H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b H' H'0; elim H'; intros H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros b H'.\napply (eqA_comp_below a b); auto.\napply (eqA_comp_below a b); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *.\nintros b H'.\napply eqTerm_eq; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b H' H'0; rewrite H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *.\nintros b H' H'0; case (eqmon_dec n c1); intros eqAZ1; auto.\ncase (eqmon_dec n c1); intros eqAZ1; auto.\nleft; red in |- *; intros H'0 H'1; clear H' H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H').\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n b); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n b); auto.\nintros a b; case (eqmon_dec n a); auto.\nintros a b; case (eqmon_dec n a); auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros b H'.\ncase (eqmon_dec n c); intros eqAZ; auto.\nright; red in |- *; intros H'0 H'1; elim H'; intros H'2 H'3; clear H'; auto.\nright; red in |- *; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'1 H'1; clear H'; auto.\nQed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b H'; case a; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *.\nintros b H'.\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _ _ _ _ _ _ _ _ _ _ H'1).\napply (cmp_trans _Qed.",
                    "Theorem zeroP_comp_eqTerm : forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b H' H'0; case H'; intros H'0 H'1; clear H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " |- *.\nintros x y; case x; case y; simpl in |- *; intuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem eqTerm_trans : transitive Term eqTerm.\nred in |- *.\nintros x y z; case x; case y; case z; simpl in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3524,
                "proof_end_offset": 3738,
                "proof": "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nProof.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros b H'.\napply (lt_zeroP _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a0 b; case a; case b; simpl in |- *; auto.\nintros a b; case a; case a; simpl in |- *; auto.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a0 b; case a; case a; simpl in |- *; autoQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *.\nintros a b H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros b H'.\napply (eqA_dec a b); auto.\napply (eqA_dec a b); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem nzeroP_comp_eqTerm : forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b H' H'0; case a; case b; simpl in |- *; auto.\nintros a b H' H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case b; simpl in |- *; auto.\nintros a b H'0; case a; case a; simplQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " in |- *; intuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a0); auto.\nrewrite H2; auto.\nQed.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition T2M : Term -> mon n.\nintros t; case t; intros a m; exact m.\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \n",
                "context_tokens": 757,
                "proof_start_offset": 3790,
                "proof_end_offset": 3932,
                "proof": "Definition plusTerm : Term -> Term -> Term.\nProof.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3; exact (plusA b2 b3, c2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition plusTerm : Term -> Term -> Term.\n  refine (fun x y => plusDec x y) _).\n\nTheorem plus_zeroP_comp_powers :\n forall a b : Term,\n ~ emptyP a ->\n (forall x : Term, ~ emptyP x -> ~ emptyP x) -> forall x : Term,\n (forall x : Term, ~ emptyP x -> ~ emptyP x) -> P x.\nintros a b H'; red in |- *; intros H'1.\napply H'.\napply H'.\napply (exp_zeroP _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1 H'2).\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros; red in |- *; intros a b H'.\napply (O.eq_comp_powers a b H'0).\napply (O.eq_comp_powers a b H'0).\nred in |- *; intros a b H'.\napply H'0.\napply H0.\napply (O.eq_comp_powers a b H'0).\nred in |- *; intros a b H'.\napply H'0.\napply (O.eq_comp_powers a b H'0).\nred in |- *; intros a' H'.\napply H'0.\napply (O.eq_comp_powers a b H'0).\nred in |- *; intros a' H'.\napply H'0.\napply (O.eq_comp_powers a' b H'0).\nred in |- *; intros a' H'.\napply H'0.\napply (O.eq_comp_powers a' b H'0).\nred in |- *; intros a' H'.\napply H'0.\napply (O.eq_comp_powers a' b H'0).\nred in |- *; intros a' H'.\napplyDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n \nDefinition addTerm : Term -> Term -> Term -> Term :=\n  fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => fun f => funDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros.\napply H.\napply H0.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H'; red in |- *; intros H'1.\napply H'.\napply (Oeq_comp_imply _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H').\nred in |- *; intros H'1.\napply H'.\napply (Oeq_comp_imply _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H').\nred in |- *; intros H'1.\napply H'.\napply (Oeq_comp_imply _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H').\nred in |- *; intros H'1.\napply H'.\napply (Oeq_comp_imply _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H').\nred in |- *; intros H'1.\napply H'.\napply (Oeq_comp_imply _ _ _ _ _ _Defined.",
                    "Definition plusTerm : Term -> Term -> Term.\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; apply (Build_Map (monoid * Term) (monoid * Term)).\n  intros; applyDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros; apply (Build_Eqolution); auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n  intros.\n  case (eqDec_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_dec (O.eq_decDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\nintros a b H'; elim H'; auto.\nDefined.",
                    "Definition plusTerm : Term -> Term -> Term.\n  refine (Build_Eq (fun x y => x -> y) (fun y => x -> y)).\n  unfold multChar in |- *.\n  apply comp_refl.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nUnset Implicit Arguments.\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition eqT (a b : Term) : Prop := T2M a = T2M b.\nHint Unfold eqT.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nLemma eqT_refl : reflexive _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_sym : symmetric _ eqT.\nred in |- *; auto.\nQed.\n \nLemma eqT_trans : transitive _ eqT.\nred in |- *; unfold eqT in |- *.\nintros x y z H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 3982,
                "proof_end_offset": 4281,
                "proof": "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b H'; red in |- *; intros H'1; elim H'; intros H'2; clear H'; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1.\napply (H'1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H' H'0; red in |- *; intros H'1; apply H'.\napply (nzeroP_plus Termr (plus Term a b)); auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b H'; red in |- *; intros H'; elim H';\n [ intro H'1; elim H'1; clear H'1 | intro H'1; clear H'1 ];\n auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem zeroP_plusTermr : forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " H' H'0; rewrite H'; auto.\nQed.\n \nTheorem eqTerm_imp_eqT : forall a b : Term, eqTerm a b -> eqT a b.\nintros a b; case a; case b; simpl in |- *; intuition.\nQed.\n \nTheorem eqTerm_dec : forall x y : Term, {eqTerm x y} + {~ eqTerm x y}.\nintros x y; case x; case y; simpl in |- *.\nintros b2 c2 b3 c3.\ncase (eqA_dec b3 b2); intros eqAZ; auto.\ncase (eqmon_dec n c3 c2); intros eqAZ1; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 736,
                "proof_start_offset": 4284,
                "proof_end_offset": 4653,
                "proof": "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1); auto.\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem zeroP_plusTerml : forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "'0 H'1; clear H'; auto.\nright; red in |- *; intros H'; elim H'; intros H'0 H'1; clear H'; auto.\nQed.\n \nTheorem eqT_zerop_is_eqTerm :\n forall a b : Term, eqT a b -> zeroP a -> zeroP b -> eqTerm a b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4656,
                "proof_end_offset": 4853,
                "proof": "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply (coeq_comp_r _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0); auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case c; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply H'.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H' H'0; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'0).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H' H'; split; auto.\napply (equiv_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1).\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1; elim H'; auto.\nQed.",
                    "Theorem plusTerm_comp_l : forall a b c : Term, eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c H'; red in |- *; intros H'1.\napply (co_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 725,
                "proof_start_offset": 4856,
                "proof_end_offset": 5053,
                "proof": "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (co_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case c; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_comp_r : forall a b c : Term, eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " _ _ cs); auto.\nQed.\n \nTheorem zeroP_dec : forall x : Term, {zeroP x} + {~ zeroP x}.\nintros x; case x; simpl in |- *.\nintros b H'.\napply eqA_dec; auto.\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \n",
                "context_tokens": 737,
                "proof_start_offset": 5056,
                "proof_end_offset": 5201,
                "proof": "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; red in |- *; intros H'1.\napply (multDec_mult _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H'1); auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros a b c; case a; case b; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nintros a b c; case c; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y; case x; case y; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; red in |- *; intros H'; apply H'.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; red in |- *; intros H'1.\napply (multerererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererererereranterererererererererererereranterererererererererererererererererererererererererQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; red in |- *; intros H'; elim H'; auto.\nQed.",
                    "Theorem plusTerm_com : forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros x y H'; split; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ".\nQed.\n \nTheorem zeroP_comp_eqTerm :\n forall a b : Term, zeroP a -> eqTerm a b -> zeroP b.\nintros a b; case a; case b; simpl in |- *; auto.\nintuition.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5204,
                "proof_end_offset": 5341,
                "proof": "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m1; simpl in |- *; auto.\nintros a1 m2; case m1; case m2; simpl in |- *; auto.\nintros a2 m3; case m3; simpl in |- *; auto.\nintros a3 m4; case m4; simpl in |- *; auto.\nintros a1 m4; case m4; simpl in |- *; auto.\nintros a1 m4; case m4; simpl in |- *; auto.\nintros a1 m4; case m4; simpl in |- *; auto.\nintros a3 m4; case m4; simpl in |- *; auto.\nintros a1 m4; case m4; simpl in |- *; auto.\nintros a2 m4; case m4; simpl in |- *; auto.\nintros a3 m4; case m4; simpl in |- *; auto.\nintros a3 m4; case m4; simpl in |- *; auto.\nintros a1 m4; case m4; simpl in |- *; auto.\nintros a1 m4; case m4; simpl in |- *; auto.\nintros a2 m4Qed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m1; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; red in |- *; intros H'1.\napply (multDec_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nintros a1 m1 m2 H1 H2; split; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2; case m1; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; split; auto.\nQed.",
                    "Theorem plusTerm_eqT1 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros m1 m2 H; split; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": " (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := a1); auto;\n apply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n\nTheorem nzeroP_comp_eqTerm :\n forall a b : Term, ~ zeroP a -> eqTerm a b -> ~ zeroP b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 734,
                "proof_start_offset": 5344,
                "proof_end_offset": 5481,
                "proof": "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m1; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_eqT2 : forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros m1 m2; case m1; case m2; case m2; case m3; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": "P b.\nintros a b H' H'0; red in |- *; intros H'1.\napply H'.\napply zeroP_comp_eqTerm with (a := b); auto.\napply eqTerm_sym; auto.\nQed.\n\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n \nDefinition plusTerm : Term -> Term -> Term.\nintros x; case x; intros b2 c2; intros y; case y; intros b3 c3;\n exact (plusA b2 b3, c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 714,
                "proof_start_offset": 5484,
                "proof_end_offset": 5775,
                "proof": "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nProof.\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2 H H0; split; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a; case a0; simpl in |- *; auto.\nintros a1 a2; case a1; case a2; simpl in |- *; auto.\nintros a3 a4; case a4; simpl in |- *; auto.\nintros a5 a5 a6; case a5; simpl in |- *; auto.\nintros a5 a6; case a5; simpl in |- *; auto.\nintros a5 a6; case a6; simpl in |- *; auto.\nintros a6; case a6; simpl in |- *; auto.\nintros a6; case a6; simpl in |- *; auto.\nintros a6; case a6; simpl in |- *; auto.\nintros a6; case a6; simpl in |- *; auto.\nintros a6; case a6; simpl in |- *; auto.\nintros a6; case a6; simpl in |- *; auto.\nintros a7; case a6; simpl in |- *; auto.\nintros a7; case a7; simpl in |- *; auto.\nintros a6; case a7; simpl in |- *; auto.\nintros a6; case a7;Qed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a a0 A1; case a; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2; case a; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2 H H0; split; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2 H H0; split; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2 A3 A4 A5 B1 B2 C3 C4 C5.\napply (A1 (plusAp (plusIndexless A1 a0) (plusColess A2 a0)) (plusIndexless A1 (plusIndexless A1 a0)) (plusIndexless A1 (plusIndexless A1 a0)) (plusIndexless A2 a0)) (plusIndexless A1 (plusIndexless A1 a0)) (plusIndexless A2 a0))).\napply (A2 (plusAp (plusIndexless A1 a0) (plusIndexless A1 (plusIndexless A1 a0)) (plusIndexless A1 a0)) (plusIndexless A1 (plusIndexless A1 a0)) (plusIndexless A1 a0))).\napply (A2 (plusAp (plusIndexless A1 a0) (plusIndexless A1 a0)) (plusIndexless A1 (plusIndexless A1 a0)) (plusIndexless A2 a0))).\napply (A3 (plusAp (plusIndexless A1 a0) (plusIndexless A1 (plusIndexlessQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1; case a; case a0; simpl in |- *; auto.\nQed.",
                    "Theorem plusTerm_assoc : forall a a0 A1 : Term, eqT A1 a0 -> eqT a a0 -> eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a0 A1 A2 H'; split; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/buchberger/Term.v",
                "context": ", c2).\nDefined.\nSet Strict Implicit.\nUnset Implicit Arguments.\n \nTheorem zeroP_plusTermr :\n forall a b : Term, eqT a b -> zeroP b -> eqTerm a (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a2 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem zeroP_plusTerml :\n forall a b : Term, eqT a b -> zeroP a -> eqTerm b (plusTerm a b).\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 m1 a2 m2 H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA A0 a1); auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ cs) with (y := plusA a1 A0); auto.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs); auto.\nQed.\n \nTheorem plusTerm_comp_l :\n forall a b c : Term,\n eqT a c -> eqT b c -> eqTerm a b -> eqTerm (plusTerm a c) (plusTerm b c).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_comp_r :\n forall a b c : Term,\n eqT c a -> eqT c b -> eqTerm a b -> eqTerm (plusTerm c a) (plusTerm c b).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\nQed.\n \nTheorem plusTerm_com :\n forall x y : Term, eqT x y -> eqTerm (plusTerm x y) (plusTerm y x).\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT1 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m1.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_eqT2 :\n forall m1 m2 : Term, eqT m1 m2 -> eqT (plusTerm m1 m2) m2.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.\n \nTheorem plusTerm_assoc :\n forall a a0 A1 : Term,\n eqT A1 a0 ->\n eqT a a0 ->\n eqTerm (plusTerm (plusTerm A1 a0) a) (plusTerm A1 (plusTerm a0 a)).\nintros a b c; case a; case b; case c; simpl in |- *; auto.\nintuition.\napply (eqA_sym _ _ _ _ _ _ _ _ _ cs).\napply plusA_assoc with (1 := cs).\nQed.\n \n",
                "context_tokens": 718,
                "proof_start_offset": 5778,
                "proof_end_offset": 6007,
                "proof": "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nProof.\nintros a b c d; case a; case b; case c; case d; simpl in |- *; auto.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; split; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; split; auto.\napply (eqDec_inv _ _ _ _ _ _ _ _ _ (eqDec_inv _ _ _ _ _ _ _ _ H0)).\napply (eqDec_inv _ _ _ _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ _ H0).\napply (eqDec_inv _ _ _ _ _ _ _ H0).\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0 H1; split; auto.\napply (co_plus Term_plusexplicit_comp (plus Expr (plusExpr a b c) (pluset b c))).\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; case a; case c; simpl in |- *; auto.\nintros a0 A1 A2 H H1 H2; split; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d; case a; case b; case c; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H1 H2; split; intros H3; elim H3; clear H3.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H3 H4).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H4).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H2 H4).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H4).\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ H1 H2 H3 H4).\napply (eqA_Qed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0; elim H0; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H H0 H1 H2.\ncase a; case b; case c; simpl in |- *; auto.\napply (eqA_trans _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1); auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem eqTerm_plusTerm_comp : forall a b c d : Term, eqT a c -> eqT b d -> eqTerm a b -> eqTerm c d -> eqTerm (plusTerm a c) (plusTerm b d).\nintros a b c d H; split; auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napply (eqDec_pluser (pluset a c) (pluset b c)); auto.\napplyQed."
                ]
            }
        ],
        "dblib": [
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\n",
                "context_tokens": 535,
                "proof_start_offset": 2012,
                "proof_end_offset": 2137,
                "proof": "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\nintros.\nsimpl_lift_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction v;\n    simpl;\n    try reflexivity;\n    try (\n      try (\n      match goal with\n      | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n        match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      end);\n      try (\n      match goal with\n        | [ |- context[ vector] ] => destruct (FVar x)\n      endQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction w as [| [i w].\n  simpl.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_rec.\n  rewrite subst_Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction w; simpl.\n  - reflexivity.\n  - destruct (eq_nat_dec k 0).\n    + subst.\n      simpl.\n      f_equal.\n      f_equal.\n      f_equal.\n      rewrite <- subst_rec.\n      f_equal.\n      rewrite <- subst_rec.\n      reflexivity.\n  - induction w; simpl.\n    - simpl.\n      f_equal.\n      rewrite <- subst_rec.\n      reflexivity.\n    - destruct (eq_nat_dec k 0).\n      + subst.\n        simpl.\n        f_equal.\n        rewrite <- subst_rec.\n        reflexivity.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction w; simpl; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply functional_extensionality.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction w; simpl in *; f_equal; auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  induction w.\n  reflexivity.\n  simpl.\n  f_equal.\n  auto.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply (Var_eq _ _ _).\n  rewrite (eq_refl _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n  rewrite (eq_sym _ _ H).\n Qed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  unfold lift.\n  apply prop_ext; split; intros.\n  + apply (H (lift w k x)).\n    + apply H.\n    + apply (H (lift w k x)).\n    + apply H.\n    + apply H.\nQed.",
                    "Lemma lift_TVar: forall w k x, lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros.\n  apply (subst_rec_eq _ _ _ _ _ _ _ _ _ _ _ H).\n  (* Now we can use the equality of [subst] and [subst] *)\n  apply (subst_rec_eq _ _ _ _ _ _ _ _ _ _ _ _ H).\n  (* Now we use [subst] to prove [subst] to prove [subst] to prove [subst] *)\n  apply (subst_rec_eq _ _ _ _ _ _ _ _ _ H).\n  (* Now we use [subst] to prove [subst] to prove [subst] *)\n  apply (subst_rec_eq _ _ _ _ _ _ _ _ _ _ _ H).\n  (* Now we use [subst] to prove [subst] *)\n  apply (subst_rec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\n  (* Second, use [subst] to prove [subst] *)\n  apply (subst_rec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\n  (* Now we use [subst] to prove [subst] to prove [subst] *)\n  apply (subst_rec_eq _ _Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "Set Implicit Arguments.\nRequire Export Coq.Program.Equality.\nFrom Dblib Require Import DblibTactics DeBruijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 583,
                "proof_start_offset": 2139,
                "proof_end_offset": 2442,
                "proof": "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TApp: forall w k t1 t2, lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "uijn Environments.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The syntax of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 659,
                "proof_start_offset": 2444,
                "proof_end_offset": 2565,
                "proof": "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\neauto with simpl_lift_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros.\n  unfold lift.\n  apply (lift_TApp (lift w k t)).\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma lift_TAbs: forall w k t, lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " of untyped lambda-terms. *)\n\nInductive term :=\n  | TVar: nat -> term\n  | TAbs: term -> term\n  | TApp: term -> term -> term.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\n",
                "context_tokens": 695,
                "proof_start_offset": 2567,
                "proof_end_offset": 2693,
                "proof": "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\nintros.\nsimpl_subst_goal.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_F. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_wrt_exp.\n  rewrite subst_body_open_Qed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_F. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.",
                    "Lemma subst_TVar: forall v k x, subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl.\n  f_equal.\n  f_equal.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\n  apply subst_TVar.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "------------------------------------------------- *)\n\n(* The following definitions allow us to use the [DeBruijn] library. In\n   particular, [traverse_term] defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\n",
                "context_tokens": 702,
                "proof_start_offset": 2695,
                "proof_end_offset": 2838,
                "proof": "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_K. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_subst v k t1.\n  reflexivity.\nQed.",
                    "Lemma subst_TApp: forall v k t1 t2, subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " defines the binding structure of terms. *)\n\nInstance Var_term : Var term := {\n  var := TVar (* avoid eta-expansion *)\n}.\n\nFixpoint traverse_term (f : nat -> nat -> term) l t :=\n  match t with\n  | TVar x =>\n      f l x\n  | TAbs t =>\n      TAbs (traverse_term f (1 + l) t)\n  | TApp t1 t2 =>\n      TApp (traverse_term f l t1) (traverse_term f l t2)\n  end.\n\nInstance Traverse_term : Traverse term term := {\n  traverse := traverse_term\n}.\n\nInstance TraverseVarInjective_term : @TraverseVarInjective term _ term _.\nProof.\n  constructor. prove_traverse_var_injective.\nQed.\n\nInstance TraverseFunctorial_term : @TraverseFunctorial term _ term _.\nProof.\n  constructor. prove_traverse_functorial.\nQed.\n\nInstance TraverseRelative_term : @TraverseRelative term term _.\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n",
                "context_tokens": 731,
                "proof_start_offset": 2840,
                "proof_end_offset": 2975,
                "proof": "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\neauto with simpl_subst_goal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_T. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_T. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.",
                    "Lemma subst_TAbs: forall v k t, subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  intros. simpl_subst. reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "\nProof.\n  constructor. prove_traverse_relative.\nQed.\n\nInstance TraverseIdentifiesVar_term : @TraverseIdentifiesVar term _ _.\nProof.\n  constructor. prove_traverse_identifies_var.\nQed.\n\nInstance TraverseVarIsIdentity_term : @TraverseVarIsIdentity term _ term _.\nProof.\n  constructor. prove_traverse_var_is_identity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 3574,
                "proof_end_offset": 3768,
                "proof": "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lift_subst.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  unfold subst.\n  apply H.\n  apply H0.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  induction t1; simpl; intros; auto.\n  destruct (X.eq_dec x x0).\n  left; auto.\n  right; auto.\n  right; auto.\n  destruct (X.eq_dec x x0).\n  left; auto.\n  right; auto.\n  right; auto.\n  left; auto.\n  right; auto.\n  right; auto.\n  destruct (X.eq_dec x x0).\n  left; auto.\n  left; auto.\n  right; auto.\n  right; auto.\n  right; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; simpl; auto.\n  eapply lc_expr_mutind; eauto.\n  eapply lc_expr_mutind; eauto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros. inversion H; subst; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  apply subst_typ.\n  auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; auto.\n  destruct H0 as [x1?].\n  destruct (x === x1).\n  left; auto.\n  right; auto.\n  left; auto.\n  right; auto.\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H.\n  simpl in H. inversion H.\n  destruct (IHtyp t2).\n  apply IHa.\n  simpl.\n  rewrite subst_typ_subst.\n  apply IHa.\n  simpl.\n  apply (IHtyp t2).\n  apply (IHtyp t2).\n  apply (IHtyp t2).\n  apply (IHtyp t2).\n  apply (IHtyp t2).\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; simpl; auto.\n  apply (IHtyp t1 t2).\nQed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction t1; simpl; auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (eq_nat_dec x x0); auto.\n  destruct (Qed.",
                    "Lemma red_weakening: forall t1 t2, red t1 t2 -> forall x, red (shift x t1) (shift x t2).\nProof.\n  intros.\n  induction H; simpl; auto.\n  destruct (eq_nat_dec x x).\n  + subst.\n    rewrite e.\n    rewrite (subst_fresh_eq x).\n    rewrite subst_fresh_eq.\n    auto.\n  + rewrite (subst_fresh_eq x).\n    rewrite subst_fresh_eq.\n    auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "(* The following lemmas characterize [lift] and [subst]. In principle, the\n   user does not need to explicitly state these lemmas, and that is fortunate.\n   Here, we prove these lemmas only in order to illustrate how the tactics\n   [simpl_lift] and [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4003,
                "proof_end_offset": 4153,
                "proof": "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\nintros.\ninversion_closed.\neauto using closed_var.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  induction H; subst; simpl_lift_goal;\n  repeat (rewrite subst_env_subst_env_subst_env; eauto with subst).\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros. induction H; auto.\n  simpl_subst_hyp; auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction k; intros.\n  auto.\n  auto.\n  intros.\n  rewrite subst_exp_subst_exp_fresh_eq in H.\n  destruct (k x); auto.\n  auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  destruct (le_gt_dec k x); auto.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros. induction H; eauto with subst.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; simpl_lift_hyp;\n  econstructor; eauto with closed.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; simpl_lift_hyp;\n    eauto with lc.\nQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  destruct (H k x H0).\n  destruct (H0 k x H).\n  destruct (H0 k x H0).\n  destruct (H0 k x H0).\n  destruct (H0 k x H0).\n  destruct (H1 k x H0).\n  destruct (H1 k x H0).\n  destruct (H2 k x H0).\n  destruct (H2 k x H0).\n  destruct (H3 k x H0).\n  destruct (H3 k x H0).\n  destruct (H2 k x H0).\n  destruct (H3 k x H0).\n  destruct (H3 k x H0).\n  destruct (H4 k x H0).\n  destruct (H3 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destruct (H4 k x H0).\n  destructQed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  induction 1; intros; simpl_lift_goal;\n    econstructor; eauto with lift_subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_open_subst; eauto with subst;\n    try rewrite subst_env_Qed.",
                    "Lemma inversion_closed_TVar: forall k x, x >= k -> closed k (TVar x) -> False.\nProof.\n  intros.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " [simpl_subst] can simplify applications of [lift] and\n   [subst]. *)\n\nLemma lift_TVar:\n  forall w k x,\n  lift w k (TVar x) = TVar (lift w k x).\nProof.\n  intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4155,
                "proof_end_offset": 4297,
                "proof": "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros.\n  inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros.\n  inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros.\n  inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_1: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t1.\nProof.\n  intros. inversion H. eauto using closed_var.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " intros. simpl_lift_goal. reflexivity.\nQed.\n\nLemma lift_TApp:\n  forall w k t1 t2,\n  lift w k (TApp t1 t2) = TApp (lift w k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4299,
                "proof_end_offset": 4441,
                "proof": "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. auto.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. auto.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma inversion_closed_TApp_2: forall t1 t2 k, closed k (TApp t1 t2) -> closed k t2.\nProof.\n  intros. inversion_closed. auto using closed_var.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": " k t1) (lift w k t2).\nProof.\n  (* [simpl_lift_goal] can also be used as a hint for [eauto].\n     This is useful when this equality goal occurs as a leaf\n     within a larger automated proof. *)\n  eauto with simpl_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4443,
                "proof_end_offset": 4580,
                "proof": "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\nintros.\ninversion_closed.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. auto.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma inversion_closed_TAbs: forall t k, closed k (TAbs t) -> closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "_lift_goal.\nQed.\n\nLemma lift_TAbs:\n  forall w k t,\n  lift w k (TAbs t) = TAbs (lift w (1 + k) t).\nProof.\n  eauto with simpl_lift_goal.\nQed.\n\nLemma subst_TVar:\n  forall v k x,\n  subst v k (TVar x) = subst_idx v k x.\nProof.\n  intros. simpl_subst_goal. reflexivity.\nQed.\n\nLemma subst_TApp:\n  forall v k t1 t2,\n  subst v k (TApp t1 t2) = TApp (subst v k t1) (subst v k t2).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\nLemma subst_TAbs:\n  forall v k t,\n  subst v k (TAbs t) = TAbs (subst (shift 0 v) (1 + k) t).\nProof.\n  eauto with simpl_subst_goal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Reduction semantics. *)\n\nInductive red : term -> term -> Prop :=\n  | RedBeta:\n      forall t1 t2 t,\n      subst t2 0 t1 = t ->\n      red (TApp (TAbs t1) t2) t\n  | RedContextTAbs:\n      forall t1 t2,\n      red t1 t2 ->\n      red (TAbs t1) (TAbs t2)\n  | RedContextTAppLeft:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t1 t) (TApp t2 t)\n  | RedContextTAppRight:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 4621,
                "proof_end_offset": 4884,
                "proof": "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\ninduction 1; intros; subst; inversion_closed; try construction_closed.\neauto using @subst_preserves_closed with typeclass_instances.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion H; subst; simpl_lift_goal;\n  econstructor; eauto withlift.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros.\n  induction H0; inversion_closed. eauto using closed_var.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  induction 1; intros; subst; simpl_lift_hyp; eauto with closed.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. auto.\nQed.",
                    "Lemma red_closed: forall t1 t2, red t1 t2 -> forall k, closed k t1 -> closed k t2.\nProof.\n  intros. inversion_closed. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "ht:\n      forall t1 t2 t,\n      red t1 t2 ->\n      red (TApp t t1) (TApp t t2).\n\n(* The reduction judgement is compatible with weakening. *)\n\nLemma red_weakening:\n  forall t1 t2,\n  red t1 t2 ->\n  forall x,\n  red (shift x t1) (shift x t2).\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lift_subst.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\n",
                "context_tokens": 702,
                "proof_start_offset": 5750,
                "proof_end_offset": 5972,
                "proof": "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\ninduction 1; intros; subst; simpl_lift_goal; econstructor; eauto with lookup_insert insert_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  destruct t; simpl_lift_goal; auto.\n  (* Case beta *)\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n  Case beta.\n Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; auto with ty.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_hyp; auto.\n  (* Case wsind *)\n  Case \"j ~>\".\n    destruct t; simpl_lift_hyp; auto.\n  Case \"j ~>\".\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    apply (IHj H1); auto.\n  (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; auto.\n    (* Case wsind *)\n    destruct t; simpl_lift_hyp; autoQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction t; intros; simpl_lift_goal;\n  econstructor; eauto using subst_weaken_nil.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; inversion_closed; try copy_lookup.\n  - (* E_Abs *)\n    eauto using subst_wrt_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_wrt_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub with typeclass_instances.\n  - (* E_Abs *)\n    eauto using subst_preserves_sub withQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction E; intros; simpl_lift_goal;\n    try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; eauto with ctx_subst; try subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_subst; eauto with ctx_subst; try congruence);\n  try (apply IHi; eauto with ctx_Qed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros E t T H.\n  induction H; intros; subst; simpl_lift_goal;\n  try (progress inversion H; subst; eauto with subst) ||\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  try (progress inversion H; subst);\n  tryQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros.\n  induction H; eauto with ty.\n  (* Case \"j\" *)\n  Case \"j'\" := (j j (S j)) (t1 ++ t2) (typ_arrow T1 T2)\n  | JApp:\n      forall E t1 t2,\n      j (swap 1 t1 t2) (swap 1 t2)\n  | Jcons:\n      forall t1 t2 T1 T2,\n      j (swap 1 t1 t2) (swap 1 t1 t2)\n  | Jcons:\n      forall t1 t2 T1 T2,\n      j (swap 1 t1 t2) (swap 1 t1 t2)\n  | Jcons:\n      forall t1 t2 T1 T2,\n      j (swap 1 t1 t2) (swap 1 t1 t2)\n  | Jcons:\n      forall t1 t2 T1 T2,\n      j (swap 1 t1 t2) (swap 1 t1 t2)\n  | Jcons:\n      forall t1 t2 T1 T2,\n      j (swap 1 t1 t2) (swap 1 t1 t2)\n  | Jcons:\n      forallQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion H. subst. auto.\nQed.",
                    "Lemma weakening: forall E t T, j E t T -> forall x U E', insert x U E = E' -> j E' (shift x t) T.\nProof.\n  intros. inversion H; subst; eauto using subst_to_typ.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "---------------------------------------------------- *)\n\n(* Working with closedness. *)\n\n(* Again, we prove the following lemmas only in order to illustrate\n   the use of the tactic [inversion_closed]. *)\n\nLemma inversion_closed_TVar:\n  forall k x,\n  x >= k ->\n  closed k (TVar x) ->\n  False.\nProof.\n  intros. inversion_closed. eauto using closed_var.\nQed.\n\nLemma inversion_closed_TApp_1:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t1.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TApp_2:\n  forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 6096,
                "proof_end_offset": 6487,
                "proof": "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\ndo 5 intro; intro h; dependent induction h; intros; simpl_subst_goal; try solve [ econstructor; eauto using weakening with insert_insert ].\nunfold subst_idx.\ndblib_by_cases; lookup_insert_all; eauto with j.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert_insert.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma substitution: forall E x t2 T1 T2, j (insert x T1 E) t2 T2 -> forall t1, j E t1 T1 -> j E (subst t1 x t2) T2.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup_lookup_lookup.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/DemoLambda.v",
                "context": "forall t1 t2 k,\n  closed k (TApp t1 t2) ->\n  closed k t2.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\nLemma inversion_closed_TAbs:\n  forall t k,\n  closed k (TAbs t) ->\n  closed (1 + k) t.\nProof.\n  intros. inversion_closed. assumption.\nQed.\n\n(* Reduction preserves closedness. *)\n\nLemma red_closed:\n  forall t1 t2,\n  red t1 t2 ->\n  forall k,\n  closed k t1 ->\n  closed k t2.\nProof.\n  induction 1; intros; subst; inversion_closed; try construction_closed.\n  (* Case RedBeta. *)\n  eauto using @subst_preserves_closed with typeclass_instances.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Simple types. *)\n\n(* These types do not contain any variables. They have no binding structure. *)\n\nInductive ty :=\n  | TyIota: ty\n  | TyArrow: ty -> ty -> ty.\n\n(* The typing judgement of the simply-typed lambda-calculus. *)\n\nInductive j : env ty -> term -> ty -> Prop :=\n  | JVar:\n      forall E x T,\n      lookup x E = Some T ->\n      j E (TVar x) T\n  | JAbs:\n      forall E t T1 T2,\n      j (insert 0 T1 E) t T2 ->\n      j E (TAbs t) (TyArrow T1 T2)\n  | JApp:\n      forall E t1 t2 T1 T2,\n      j E t1 (TyArrow T1 T2) ->\n      j E t2 T1 ->\n      j E (TApp t1 t2) T2.\n\nHint Constructors j : j.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The typing judgement is compatible with weakening, i.e., inserting a new\n   term variable. *)\n\nLemma weakening:\n  forall E t T,\n  j E t T ->\n  forall x U E',\n  insert x U E = E' ->\n  j E' (shift x t) T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_insert insert_insert.\nQed.\n\n(* The typing judgement is compatible with substitution, i.e., substituting a\n   well-typed term for a term variable. *)\n\nLemma substitution:\n  forall E x t2 T1 T2,\n  j (insert x T1 E) t2 T2 ->\n  forall t1,\n  j E t1 T1 ->\n  j E (subst t1 x t2) T2.\nProof.\n  do 5 intro; intro h; dependent induction h; intros; simpl_subst_goal;\n  (* General rule. *)\n  try solve [ econstructor; eauto using weakening with insert_insert ].\n  (* Case TVar. *)\n  unfold subst_idx. dblib_by_cases; lookup_insert_all; eauto with j.\nQed.\n\n(* The typing judgement is preserved by reduction. Note that this is\n   proved for an arbitrary environment [E]: we do not restrict our\n   attention to closed terms. *)\n\n",
                "context_tokens": 699,
                "proof_start_offset": 6659,
                "proof_end_offset": 6974,
                "proof": "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\ninduction 1; intros ? ? h; subst; dependent destruction h; eauto with j.\nmatch goal with h: j _ (TAbs _) _ |- _ => inversion h; clear h; subst end.\neauto using substitution.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  intros. induction t1; intros; simpl_lift_goal;\n  (* this lemma is used to show that [j] is well-typed. *)\n  eauto using (well_founded_induction_wf_induction_wf).\n  Case \"well_founded_induction_wf\".\n  Case \"well_founded_induction_wf\".\n  Case \"well_founded_induction_wf\".\n  Case \"well_founded_induction_wf\".\n  Case \"well_induction_wf\".\n  Case \"well_induction_wf\".\n    (* We don't need to use induction. *)\n    apply (well_founded_induction_wf_induction_wf).\n    (* We can show that [t] is well-typed. *)\n    apply (well_founded_induction_wf_induction_wf).\n    (* We can prove that [t] is well-typed. *)\n    apply (well_founded_induction_wf_induction_wf).\n    (* We can use [t] is well-typed. *)\n    apply (well_founded_induction_wf_induction_wf).\n    (* We can use [t] is well-typed. *)\n    apply (well_founded_induction_wf_induction_Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; simpl_subst_hyp;\n  try solve [inversion H; inversion H; inversion H0; subst; auto].\n  + (* [j] is the same as [j] and [j] and [j] and [j] and [j] and [j] *)\n    inversion H; subst; eauto using fresh_with_closed.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; simpl_subst_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction t1; intros; simpl_lift_goal;\n  (* this lemma is used to remove the induction hypothesis, but it's\n   case where it's induction hypothesis. *)\n  destruct (H _ _ _ H1 H0) as [T1 [T2 [T3 [T4 [T5 T6]]]].\n  destruct (H0 _ _ _ H1 H) as [T2 [T3 [T4 [T5 T6]]]].\n  destruct (H0 _ _ _ H1 H) as [T3 [T4 [T5 T6]]]].\n  destruct (H0 _ _ _ H1 H) as [T4 [T5 [T6 T7]].\n  destruct (H0 _ _ _ H1 H2) as [T4 [T6 [T7 T8]].\n  destruct (H0 _ _ _ H1 H2) as [T4 [T6 [T7 T8]].\n  destruct (H0 _ _ _ H1 H2) as [T4 [T6 [T8 T9]].\n  destruct (H0 _ _ _ H1 H2) as [T4 [T5 [T8 T9]].\n  destruct (Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; simpl_lift_goal;\n  (* this line has a \"value\" value, with the\n   value of the value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the value of the\n   value of the value of the value of the\n   value of the value of the value of the valueQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; simpl_lift_goal;\n  econstructor; eauto using (wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf_wf).\n  (* this lemma is used to show that the\n   typing derivation of the typing derivation of the typing derivation\n   of the typing derivation. *)\n  destruct (IHtyping2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; subst; simpl_lift_goal;\n  econstructor; eauto with lookup_lookup.\nQed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction t1; intros; simpl_lift_goal;\n  econstructor; eauto using (closed_wf H);\n  try solve [ econstructor; eauto using (closed_wf H);\n  try solve [econstructor; eauto using (closed_wf H)].\n  (* Case lvalue *)\n  simpl in H.\n  inversion H; subst.\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_wf H0).\n  apply (closed_Qed.",
                    "Lemma type_preservation: forall t1 t2, red t1 t2 -> forall E T, j E t1 T -> j E t2 T.\nProof.\n  induction 1; intros; simpl_lift_goal;\n  (* We need to do it, the same as [E,\n   destruct X as [X0 X0]. *)\n  destruct X0 as [X1 X2].\n  destruct X1 as [X2 X3].\n  destruct X2 as [X3 X4].\n  destruct X3 as [X4 X5].\n  destruct X4 as [X5 X6].\n  destruct X6 as [X6 X7].\n  destruct X7 as [X10 X10].\n  destruct X10 as [X10 X11].\n  destruct X10 as [X11 X12].\n  destruct X10 as [X12 X12].\n  destruct X12 as [X13 X12].\n  destruct X13 as [X13 X13].\n  destruct X14 as [X13 X14].\n  destruct X14 as [X13 X14].\n  destruct X14 as [X14 X14].\n  destruct X14 as [X15 X15].\n  destruct X15 as [X14 X15].\n  destruct X15 as [X15 X15].\n  destruct X15 as [X15 X15].\n  destruct X15 as [XQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bounded version of this\n   notion. Perhaps by chance, the basic laws that relate [lookup], [insert],\n   and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\n",
                "context_tokens": 639,
                "proof_start_offset": 3688,
                "proof_end_offset": 3780,
                "proof": "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros x. induction x; simpl; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  simpl.\n  rewrite (app_ass (1 + 2)).\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_assoc.\n  rewrite <- app_Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  destruct (x + 1).\n  simpl.\n  rewrite <- plus_n_O.\n  rewrite <- plus_n_O.\n  apply plus_n_O.\n  apply plus_n_O.\n  rewrite plus_comm.\n  apply plus_n_O.\n  apply plus_comm.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  simpl.\n  destruct (x + 1).\n  simpl.\n  destruct (x + 1).\n  simpl.\n  omega.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros. destruct x; auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros. apply (is_reachable_plus_one_left x).\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof. auto. Qed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl.\n  auto.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  induction x; simpl.\n  intros. omega.\n  destruct a. omega.\n  destruct a. omega.\n  destruct (1 + x). omega.\nQed.",
                    "Lemma one_plus_x_minus_one_left: forall x, (1 + x) - 1 = x.\nProof.\n  intros.\n  apply same_add_x_minus_one_left.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "  and [map] are valid with respect to Leibniz equality, so we do not define\n   extensional equality. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Operations on environments. *)\n\n(* The empty environment is undefined everywhere. *)\n\nDefinition empty A : env A :=\n  nil.\n\n(* Environment lookup. *)\n\nFixpoint lookup A (x : nat) (e : env A) : option A :=\n  match e, x with\n  | nil, _ =>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 656,
                "proof_start_offset": 3782,
                "proof_end_offset": 3886,
                "proof": "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.",
                    "Lemma one_plus_x_minus_one_right: forall x, x > 0 -> 1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "=>\n      None\n  | entry :: _, 0 =>\n      entry\n  | _ :: e, S x =>\n      lookup x e\n  end.\n\n(* [insert x a e] inserts a new variable [x], associated with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 4202,
                "proof_end_offset": 4306,
                "proof": "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  induction e; simpl.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  induction e; simpl; auto.\n  destruct o; simpl; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  induction e; simpl; f_equal; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  apply functional_extensionality.\n  intros.\n  simpl.\n  destruct (x =? 0).\n  auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  rewrite <- List.fold_left_rev.\n  apply List.in_map.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. induction e; simpl; intros. auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. reflexivity.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.\n  intros. apply functional_extensionality.\n  simpl.Qed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros. unfold raw_insert.\n  destruct o; simpl; auto.\nQed.",
                    "Lemma raw_insert_zero: forall A o (e : env A), raw_insert 0 o e = o :: e.\nProof.\n  intros.\n  destruct o; simpl.\n  reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " with data [a], in the\n   environment [e]. The pre-existing environment entries at index [x] and\n   above are shifted up. Thus, [insert x] is closely analogous to [shift x]\n   for terms. *)\n\n(* [insert] inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 4308,
                "proof_end_offset": 4484,
                "proof": "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\nintros.\ndestruct e; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  destruct o.\n  destruct o.\n  simpl.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_ext.\n  apply pred_extQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. unfold raw_insert.\n  simpl.\n  rewrite <- List.app_nil_r.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction e; simpl.\n  + reflexivity.\n  + reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction e; simpl; auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. induction e; simpl; intros.\n  rewrite <- (IHis_insert_conj_cons _ _ _ H); auto.\n  rewrite IHm1; simpl.\n  rewrite <- (IHis_insert_conj_cons _ _ _ H); auto.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. induction e; simpl.\n  rewrite <- app_nil_r. simpl. reflexivity.\n  destruct o; simpl. reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction e.\n  simpl.\n  rewrite <- app_nil_r.\n  simpl.\n  rewrite <- app_nil_r.\n  reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction e; simpl; auto.\n  rewrite IHs. rewrite IHs. rewrite IHs. reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. induction e; simpl.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\n  destruct o; reflexivity.\nQed.",
                    "Lemma raw_insert_successor: forall A x o (e : env A), raw_insert (S x) o e = lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros.\n  induction e; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "inserts a non-null entry in the environment. We define it in terms\n   of [raw_insert], which can also be used to insert a null entry. [raw_insert]\n   is useful because it allows generating every environment (thus, it can be\n   used in the formulation of an induction principle). *)\n\nFixpoint raw_insert A (x : nat) (o : option A) (e : env A) : env A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\n",
                "context_tokens": 696,
                "proof_start_offset": 4545,
                "proof_end_offset": 4773,
                "proof": "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\nunfold empty; intros; destruct x.\nrewrite raw_insert_zero in *.\ncongruence.\nrewrite raw_insert_successor in *.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; simpl.\n  apply (same_eq_insert _ _ _ _ H).\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct (eq_dec x x).\n  apply empty_eq_insert.\n  rewrite (same_eq_insert _ _ _ H).\n  rewrite (same_eq_insert _ _ _ H).\n  apply (same_eq_insert _ _ _ H).\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros.\n  destruct e; simpl in *; try congruence.\n  destruct (X.eq_dec x x0); subst; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl; trivial.\n  destruct o; simpl; trivial.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\n  destruct o; simpl in H.\n  contradiction.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl; auto.\nQed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n  destruct o; simpl in *; try contradiction.\n Qed.",
                    "Lemma empty_eq_insert: forall A x o (e : env A), empty _ = insert x o e -> False.\nProof.\n  intros. destruct e; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " A :=\n  match x, e with\n  | 0, _ =>\n      o :: e\n  | S x, entry :: e =>\n      entry :: raw_insert x o e\n  | S x, nil =>\n      None :: raw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 4908,
                "proof_end_offset": 5022,
                "proof": "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\ndestruct x; simpl; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  unfold empty; intros.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite empty_eq_insert.\n  rewrite <- insert_app_x_prev.\n  rewrite <- insert_app_x_prev.\n  rewrite insert_app_prev.\n  rewrite <- insert_app_prev.\n  rewrite <- insert_app_prev.\n  rewrite <- insert_app_prev.\n  rewrite <- insert_app_prev.\n  rewrite <- insert_app_prev.\n  rewrite <- app_ass.\n  rewrite <- insert_app_prev.\n  rewrite <- app_ass.\n  rewrite <- app_ass.\n  rewrite <- app_assQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite empty_eq_insert.\n  destruct (T.get x (empty A)).\n  rewrite empty_eq_insert; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold empty; auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros.\n  rewrite (empty_eq_empty x); auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold empty; reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. apply empty_eq_insert. auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold lookup; simpl. rewrite H. reflexivity.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold lookup, nil.\n  apply PTree.gempty.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold lookup. rewrite PTree.gempty. auto.\nQed.",
                    "Lemma lookup_empty_None: forall A x, lookup x (@empty A) = None.\nProof.\n  intros. unfold lookup; rewrite make_empty.\n  apply get_empty_unit_left.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "aw_insert x o e\n  end.\n\nNotation insert x a e :=\n  (raw_insert x (Some a) e).\n\n(* [map f e] is the environment obtained by applying [f] to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\n",
                "context_tokens": 686,
                "proof_start_offset": 5024,
                "proof_end_offset": 5158,
                "proof": "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\ndestruct x; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; intros.\n  rewrite H. rewrite H. auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; intros.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct a; simpl; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  intros. destruct x; simpl; reflexivity.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; intros; congruence.\nQed.",
                    "Lemma lookup_empty_Some: forall A x (a : A), lookup x (@empty _) = Some a -> False.\nProof.\n  destruct x; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "to every datum\n   in the environment [e]. *)\n\nFixpoint map A B (f : A -> B) (e : env A) :=\n  match e with\n  | nil =>\n      nil\n  | None :: e =>\n      None :: map f e\n  | Some a :: e =>\n      Some (f a) :: map f e\n  end.\n\n(* [fold f e accu] performs an iteration over all entries in the environment.\n   Older entries are visited first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\n",
                "context_tokens": 685,
                "proof_start_offset": 5160,
                "proof_end_offset": 5335,
                "proof": "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\ndestruct e.\ndo 2 rewrite lookup_empty_None.\nreflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct x; simpl; congruence.\nQed.",
                    "Lemma lookup_successor: forall A x (e : env A), lookup (S x) e = lookup x (tail e).\nProof.\n  intros. destruct x; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " first: in other words, the initial accumulator\n   should make sense at the toplevel, outside of the environment, and is\n   pushed successively into every binding, so as to yield a final accumulator\n   that makes sense inside this environment. *)\n\nFixpoint fold A B (f : option A -> B -> B) (e : env A) (accu : B) : B :=\n  match e with\n  | nil =>\n      accu\n  | o :: e =>\n      f o (fold f e accu)\n  end.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Basic arithmetic simplifications. *)\n\nLemma one_plus_x_minus_one_left:\n  forall x,\n  (1 + x) - 1 = x.\nProof.\n  intros. omega.\nQed.\n\nLemma one_plus_x_minus_one_right:\n  forall x,\n  x > 0 ->\n  1 + (x - 1) = x.\nProof.\n  intros. omega.\nQed.\n\nLtac one_plus_x_minus_one :=\n  repeat rewrite one_plus_x_minus_one_left in *;\n  repeat rewrite one_plus_x_minus_one_right in * by omega.\n  (* I tried [autorewrite with... using omega]; it does not work. *)\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Trivial facts. *)\n\nLemma raw_insert_zero:\n  forall A o (e : env A),\n  raw_insert 0 o e = o :: e.\nProof.\n  reflexivity.\nQed.\n\nLemma raw_insert_successor:\n  forall A x o (e : env A),\n  raw_insert (S x) o e =\n  lookup 0 e :: raw_insert x o (tail e).\nProof.\n  intros. destruct e; reflexivity. (*! *)\nQed. (* Maybe this should be the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\n",
                "context_tokens": 661,
                "proof_start_offset": 5471,
                "proof_end_offset": 5755,
                "proof": "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\ninduction x; intros; destruct y; destruct e; simpl; try solve [ elimtype False; omega | eauto with omega ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct (o x); reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros.\n  destruct o.\n  rewrite (insert_insert_bingo x y).\n  rewrite (insert_insert_bingo x y).\n  rewrite (insert_insert_bingo x y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo x y).\n  rewrite (insert_insert_bingo y x).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y x).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y x).\n  rewrite (insert_insert_bingo y y).\n  rewrite (insert_insert_bingo y xQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct o; simpl; intros.\n  rewrite (H a); reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct e.\n  rewrite H. reflexivity.\n  rewrite <- insert_insert_bingo. reflexivity.\n  rewrite <- insert_insert_bingo. reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. unfold lookup.\n  destruct o.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookup_insert_bingo.\n  rewrite lookupQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. unfold lookup.\n  destruct o.\n  rewrite make_insert_error.\n  rewrite lookup_insert_bingo.\n  destruct o.\n  rewrite make_insert_error.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite make_insert_bingo.\n  destruct o.\n  rewrite makeQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct x; simpl; intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  destruct e; simpl; auto.\n  rewrite <- (insert_insert_bingo e); auto.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. destruct o; reflexivity.\nQed.",
                    "Lemma lookup_insert_bingo: forall A x y (o : option A) e, x = y -> lookup x (raw_insert y o e) = o.\nProof.\n  intros. induction o; simpl; auto.\n  destruct o; simpl; auto.\n  destruct o; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "e the definition of [raw_insert]. *)\n\nLemma empty_eq_insert:\n  forall A x o (e : env A),\n  empty _ = insert x o e ->\n  False.\nProof.\n  unfold empty; intros; destruct x.\n  rewrite raw_insert_zero in *. congruence.\n  rewrite raw_insert_successor in *. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [empty]. *)\n\nLemma lookup_empty_None:\n  forall A x,\n  lookup x (@empty A) = None.\nProof.\n  destruct x; simpl; reflexivity.\nQed.\n\nLemma lookup_empty_Some:\n  forall A x (a : A),\n  lookup x (@empty _) = Some a ->\n  False.\nProof.\n  destruct x; simpl; congruence.\nQed.\n\nLemma lookup_successor:\n  forall A x (e : env A),\n  lookup (S x) e = lookup x (tail e).\nProof.\n  destruct e.\n  do 2 rewrite lookup_empty_None. reflexivity.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [insert]. *)\n\nLemma lookup_insert_bingo:\n  forall A x y (o : option A) e,\n  x = y ->\n  lookup x (raw_insert y o e) = o.\n(* Hence, [lookup x (insert y a e) = Some a]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 6812,
                "proof_end_offset": 7137,
                "proof": "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\nintros.\ndestruct_lift_idx.\nrewrite lookup_insert_old by omega.\nf_equal.\nomega.\nrewrite lookup_insert_recent by omega.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Proof. *)\n  intros.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega | auto ].\n  (* It is not true *)\n  rewrite lookup_empty_None.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <- insert_involutive.\n  rewrite <-Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  unfold lookup.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega\n    | auto ].\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  destruct x; simpl; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  rewrite lookup_insert_swap.\n  destruct (lookup x (insert y a e)); simpl.\n  destruct (lookup x (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert y a e)); simpl.\n  destruct (lookup y (insert yQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  unfold lookup.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega | change (S x - 1) with x; auto ].\n  simpl lookup at 1; rewrite <- insert_insert_bingo; auto.\nQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  unfold lookup.\n  destruct x; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega |\n    apply lookup_insert_bingo with (y:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o) (z:=o)Qed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\nProof.\n  intros.\n  unfold lookup, lookup.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega |\n    destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destruct o; simpl; try solve [\n    elimtype False; omega | destructQed.",
                    "Lemma lookup_shift_insert: forall A x y (o : option A) e, lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Proof.\n  intros.\n  unfold lookup.\n  destruct x; destruct y; simpl; try solve [\n    elimtype False; omega | destruct e; auto].\n  destruct y; destruct e; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "Proof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\nQed.\n\nLemma lookup_insert_recent:\n  forall A x y (o : option A) e,\n  x < y ->\n  lookup x (raw_insert y o e) = lookup x e.\n(* Hence, [lookup x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 7969,
                "proof_end_offset": 8070,
                "proof": "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros.\n  unfold map.\n  destruct (map f) as [A | B]; [reflexivity | ]; reflexivity.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof.\n  intros. apply map_empty_left.\nQed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. induction f; auto. Qed.",
                    "Lemma map_empty: forall A B (f : A -> B), map f (@empty _) = @empty _.\nProof. reflexivity. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "p x (insert y a e) = lookup x e]. *)\nProof.\n  induction x; intros; destruct y; destruct e; simpl; try solve [\n    elimtype False; omega\n  | eauto with omega\n  ].\n  (* One troublesome case. *)\n  erewrite <- lookup_empty_None. eauto with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\n",
                "context_tokens": 682,
                "proof_start_offset": 8203,
                "proof_end_offset": 8423,
                "proof": "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; solve [ eauto | congruence ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  rewrite map_empty.\n  rewrite map_app.\n  apply map_empty.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. induction f; simpl; auto.\n  destruct e; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct x; simpl.\n  - rewrite <- map_empty_o. reflexivity.\n  - rewrite <- map_empty_o. reflexivity.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  f_equal.\n  apply lookup_lookup_insert_drop.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  destruct (f x); destruct (f x); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  destruct (f x); reflexivity.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  destruct (x x); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  destruct (f x); destruct (f x); auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros.\n  unfold lookup.\n  destruct (f x) eqn:?; try discriminate.\n  destruct (f x); simpl; auto.\n  destruct (f x); simpl; auto.\nQed.",
                    "Lemma lookup_map_none: forall A B x e (f : A -> B), lookup x e = None -> lookup x (map f e) = None.\nProof.\n  intros. unfold lookup.\n  destruct (map_nth x e) eqn:E; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nLemma lookup_insert_old:\n  forall A x y (o : option A) e,\n  x > y ->\n  lookup x (raw_insert y o e) = lookup (x - 1) e.\n(* Hence, [lookup x (insert y a e) = lookup (x - 1) e]. *)\nProof.\n  (* Induction over [x], which is non-zero. *)\n  induction x; intros; [ elimtype False; omega | replace (S x - 1) with x by omega ].\n  (* Case analysis. *)\n  destruct y; destruct e; simpl; try solve [ eauto ].\n  (* One troublesome case. *)\n  rewrite lookup_empty_None. erewrite <- lookup_empty_None. eauto with omega.\n  (* Another troublesome case. *)\n  destruct x; intros; [ elimtype False; omega | replace (S x - 1) with x in * by omega ].\n  simpl lookup at 2.\n  eauto with omega.\nQed.\n\nLemma lookup_shift_insert:\n  forall A x y (o : option A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 8425,
                "proof_end_offset": 8665,
                "proof": "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\ninduction x; intros; destruct e as [ | [ | ] ? ]; simpl in *; subst; try solve [ congruence | eauto ].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros. destruct a; simpl in *; subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? | ]; simpl in *; subst;\n  solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  unfold lookup.\n  destruct (f x); simpl in *; subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  unfold lookup.\n  destruct (f x); simpl in *; subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]?]; simpl in *; subst;\n  solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]?]; simpl in *; subst;\n  solve [ eauto | congruence].\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; simpl in *; subst; auto.\nQed.",
                    "Lemma lookup_map_some: forall A B x a e (f : A -> B), lookup x e = Some a -> lookup x (map f e) = Some (f a).\nProof.\n  intros.\n  destruct a; simpl in *; subst; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "A) e,\n  lookup (shift y x) (raw_insert y o e) = lookup x e.\n(* Hence, [lookup (shift y x) (insert y a e) = lookup x e]. *)\nProof.\n  intros. destruct_lift_idx.\n  rewrite lookup_insert_old by omega. f_equal. omega.\n  rewrite lookup_insert_recent by omega. reflexivity.\nQed.\n\nLtac lookup_insert :=\n  first [\n    rewrite lookup_insert_bingo by omega\n  | rewrite lookup_insert_old by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent by omega\n  | rewrite lookup_shift_insert\n  ].\n\nLtac lookup_insert_all :=\n  first [\n    rewrite lookup_insert_bingo in * by omega;\n    try match goal with h: Some _ = Some _ |- _ => injection h; intro; subst; clear h end\n  | rewrite lookup_insert_old in * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\n",
                "context_tokens": 663,
                "proof_start_offset": 9140,
                "proof_end_offset": 9636,
                "proof": "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\nintros ? k s.\ngeneralize s k; clear s k.\ninduction s; intros.\ndestruct k; [ | elimtype False; omega ].\nreflexivity.\ndestruct k.\nreflexivity.\ndestruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction a; intros; simpl.\n  - rewrite insert_insert_drop; auto.\n  - rewrite insert_insert_drop; auto.\n  - rewrite insert_insert_drop; auto.\n  - rewrite insert_insert_drop; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction a; intros; destruct e as [ | [a b]? ].\n  simpl.\n  rewrite insert_ins_merge; auto.\n  rewrite insert_ins_merge.\n  rewrite insert_ins_merge; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  assert (forall a b c d e, exists e, join a b c d /\\ join a c d e = d).\n  { induction 1; intros.\n    - simpl in H.\n      destruct H as [e [H1 H2]].\n      destruct H as [e [H1 H2]].\n      exists e; split; [split|]; auto.\n    - simpl in *.\n      destruct H as [e [H1 H2]].\n      destruct H1 as [e [H1 H2]].\n      exists e; split; [split|]; auto.\n    - simpl in *.\n      destruct H as [e [H1 H2].\n      exists e; split; [split|]; auto.\n    - simpl in *.\n      destruct H as [e [H1 H2]].\n      exists e; split; [split|]; auto.\n    - simpl in *.\n      destruct H as [e [H1 H2]].\n      exists e; split; [split|]; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction a; intros; simpl in *;\n  solve [\n  try solve [\n    destruct a; simpl in *; subst; auto;\n    try solve [rewrite (IHi s); simpl; auto];\n    try solve [\n    destruct (a::b); simpl in *; subst; auto;\n    try solve [\n    destruct (a::b); simpl in *; subst; auto;\n      rewrite (IHi s); simpl; auto].\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  destruct a; simpl in *; subst; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction s; intros; simpl.\n  + rewrite insert_ins_node; auto.\n  + rewrite insert_ins_node; auto.\n  + rewrite insert_ins_node; auto.\n  + rewrite insert_ins_node; auto.\n  + rewrite insert_ins_node; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros.\n  induction a; simpl; auto.\n  destruct a; simpl; auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction a; intros; simpl.\n  - auto.\n  - destruct a.\n    + destruct s; simpl in *.\n      + destruct (ins_error _ _ H).\n        subst; simpl in *.\n        auto.\n      + destruct (ins_error _ _ H).\n        subst; simpl. auto.\n      + destruct (ins_error _ _ H).\n        subst; simpl. auto.\n      + destruct (ins_error _ _ H).\n        subst; simpl. auto.\n      + destruct (ins_error _ _ H).\n        subst; simpl. auto.\n  - destruct a.\n    + destruct (ins_error _ _ H).\n      subst; simpl. auto.\n  - destruct (ins_error _ _ H).\n    subst; simpl. auto.\nQed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction a; intros; destruct e as [ | [a b]?]; simpl in *; subst; try solve [\n    congruence];\n    try match goal with\n    | |- Some _ = Some _ => destruct a eqn:?\n    end;\n    first [destruct b as [a b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b] b'\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b b]?\n      | destruct b as [b' b]?\n      | destruct b as [b' b']?\n      | destruct b as [b' b']Qed.",
                    "Lemma insert_insert: forall A k s (a b : option A) e, k <= s -> raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  induction a; intros; destruct e as [ | [ | ]? ];\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct e as [ | [ | ]? ];\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct e as [ | [ | ]?];\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct e as [ | [ | ]?];\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct e as [ | [ | ]?];\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct e as [ | [ | ]?];\n  destruct (a =? b); try solve [destruct e; simpl in *; auto | auto].\n  destruct e as [ | [ | ]?];\n  destruct (a =? b); try solve [destructQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " * by omega; one_plus_x_minus_one\n  | rewrite lookup_insert_recent in * by omega\n  | rewrite lookup_shift_insert in *\n  ].\n\nHint Extern 1 (lookup _ (raw_insert _ _ _) = _) =>\n  lookup_insert\n: lookup_insert.\n\nHint Extern 1 (lookup _ _ = _) =>\n  lookup_insert_all\n: lookup_insert.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [empty]. *)\n\nLemma map_empty:\n  forall A B (f : A -> B),\n  map f (@empty _) = @empty _.\nProof.\n  reflexivity.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [lookup] and [map]. *)\n\nLemma lookup_map_none:\n  forall A B x e (f : A -> B),\n  lookup x e = None ->\n  lookup x (map f e) = None.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst;\n  solve [ eauto | congruence ].\nQed.\n\nLemma lookup_map_some:\n  forall A B x a e (f : A -> B),\n  lookup x e = Some a ->\n  lookup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\n",
                "context_tokens": 669,
                "proof_start_offset": 9794,
                "proof_end_offset": 10236,
                "proof": "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\nintros.\ndestruct (le_gt_dec k s).\nrewrite lift_idx_old by assumption.\neauto using insert_insert.\nrewrite lift_idx_recent by assumption.\nreplace k with (1 + (k - 1)) in * by omega.\nrewrite <- insert_insert by omega.\ndo 2 f_equal.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  unfold merge.\n  apply lookup_map_none.\n  (* Case [s <> 0]. *)\n  destruct e; [ | destruct e as [ | [ | ]? | ]? | ]; simpl; auto;\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHs; auto);\n    try (rewrite IHsQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  unfold merge.\n  rewrite insert_insert_left by auto.\n  apply lookup_map_none.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction e; intros; simpl.\n  destruct a; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n  rewrite insert_ins; auto.\n  destruct b; simpl.\n Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. unfold merge.\n  apply lookup_map_none.\n  rewrite <- (app_nil_r _ _ _ _ _ H).\n  rewrite app_nil_r. reflexivity.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. unfold insert.\n  rewrite (insert_insert _ _ _ H).\n  rewrite insert_ins; auto.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k.\n  (* Case [s = 0]. *)\n  destruct (k1 - 1) eqn: s; simpl in *; subst; try solve [\n    congruence].\n  (* Case [s = 0]. *)\n  destruct (k2 - 1) eqn: s; simpl in *.\n  - (* Case [s = 0]. *)\n    destruct (k1 - 1) eqn: s; simpl in *.\n    + (* Case [s = 0]. *)\n      destruct (k2 - 1) eqn: s; simpl in *.\n      * (* Case [s = 0]. *)\n        rewrite e. rewrite e. rewrite <- e. rewrite <- e. rewrite <- e. rewrite <- e. rewrite <- e. auto.\n      * (* Case [s <> 0]. *)\n        rewrite e. rewrite e. rewrite <- e. rewrite <- e. rewrite <- e. auto.\n      * (* Case [s <> 0] *)\n        rewrite e. rewrite e. rewrite <- e. rewrite <- e. rewrite <- e. auto.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction a; simpl; intros.\n  (* Case [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0], [s = 0]. *)\n  simpl. rewrite H. rewrite H. reflexivity.\nQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  induction s; simpl.\n  (* Case [s = 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  destruct k.\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  destruct e.\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  destruct e.\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  simpl in H.\n  destruct (lt_eq_dec _ _ H) as [H1|H1].\n  (* Case [s <> 0] *)\n  reflexivity.\n  (* Case [s <> 0] *)\n  destruct (lt_eq_dec _ _ H) as [H1|H1].\n  (* Case [s <> 0] *)\n  destruct (lt_eq_dec _ _ H) as [H1|H1].\n  (* Case [s <> 0] *)\n  destruct (lt_eq_decQed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  induction a; simpl; intros.\n  (* Case [k = 0] *)\n  destruct k.\n  (* Case [k = 0] *)\n  simpl. rewrite <- app_nil_end.\n  rewrite <- app_nil_end.\n  simpl. rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <- app_nil_end.\n  simpl.\n  rewrite <-Qed.",
                    "Lemma insert_insert_always: forall A k s (a b : option A) e, raw_insert k a (raw_insert s b e) = raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (eq_dec a b).\n  + (* Case [s = 0] *)\n    rewrite merge_insert_uniq.\n    assert (forall i k e (b : option A),\n        i < k ->\n        exists a, i < k /\\ ~(i < k)%nat) by (destruct le_gt_dec; auto).\n    assert (forall i k e (b : option A), i < k ->\n            exists a, i < k /\\ ~(i < k)%nat) by (destruct le_gt_dec; auto).\n    assert (forall i k e (b : option A), i < k ->\n               (i < k)%nat ->\n               (i < k)%nat ->\n               exists a, i < k /\\ ~ (i < k)%nat).\n    {\n      clear - H0.\n      revert i k.\n      induction s; intros.\n      - inv H0.\n        * destruct H0.\n          * destruct (le_gt_dec k0).\n            * destruct (le_gt_dec k0).\n              * destruct (lt_gt_dec k0).\n              * destruct (lt_gt_dec k).\n              * destruct (zlt (k - 1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "kup x (map f e) = Some (f a).\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\nQed.\n\nLemma lookup_map_some_reverse:\n  forall A B x b e (f : A -> B),\n  lookup x (map f e) = Some b ->\n  exists a,\n  lookup x e = Some a /\\ b = f a.\nProof.\n  induction x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 10854,
                "proof_end_offset": 10989,
                "proof": "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct x; destruct e; simpl; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  rewrite insert_insert.\n  auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (eq_dec x a).\n  + subst.\n    apply insert_insert.\n    apply insert_insert.\n    auto.\n    apply insert_insert.\n  + intros.\n    destruct (eq_dec x a).\n    + subst.\n      apply insert_insert.\n    + simpl.\n      apply insert_insert.\n    + simpl.\n      apply insert_insert.\n    + simpl.\n      apply insert_insert.\n    + simpl.\n      apply insert_insert.\n    + simpl.\n      apply insert_insert.\n    + simpl.\n      apply insert_insert.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (insert_insert _ _ _ _ _ _ _ _ H) as [? [??]].\n  apply insert_insert_sorted.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (insert_insert _ _ _ _ _ H) as [H1 H2].\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insert in H1.\n  rewrite insert_insertQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction e; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  induction x; simpl; intros.\n  auto.\n  destruct (x0 a); simpl in *; subst; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct e as [ | [ | ]? H]; try discriminate.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ninduction a; simpl; auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\n  intros.\n  destruct (insert_insert _ _ _ _ _ H) as [x [a [H1 H2]].\n  rewrite app_nil_r in H1.\n  auto.\nQed.",
                    "Lemma insert_nil: forall A x a (e : env A), insert x a e = nil -> False.\nProof.\ndestruct a; simpl; intros; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x; intros; destruct e as [ | [ | ]? ]; simpl in *; subst; try solve [\n    congruence\n  | eauto\n  ].\n  eexists. split. reflexivity. congruence.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [insert] commutes with itself, just like [lift] commutes with itself. *)\n\nLemma insert_insert:\n  forall A k s (a b : option A) e,\n  k <= s ->\n  raw_insert k a (raw_insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\n",
                "context_tokens": 697,
                "proof_start_offset": 11139,
                "proof_end_offset": 11446,
                "proof": "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\nintros.\nassert (lookup x (insert x a1 e1) = Some a1).\neauto using lookup_insert_bingo.\nassert (lookup x (insert x a2 e2) = Some a2).\neauto using lookup_insert_bingo.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  assert (a1 = a2).\n  apply insert_eq_insert_1 in H.\n  rewrite <- insert_insert_eq_insert_1 by assumption.\n  subst a1.\n  rewrite insert_insert_2 by assumption.\n  subst a2.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insert_2 by assumption.\n  simpl.\n  rewrite insert_insert_3 by assumption.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insert_2 by assumption.\n  simpl.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insert_1 by assumption.\n  simpl.\n  rewrite insert_insert_2 by assumption.\n  rewrite insert_insert_3 by assumption.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insert_3 by assumption.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insert_3 by assumption.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insert_2 by assumption.\n  rewrite insert_insert_2 by assumption.\n  rewrite insert_insert_2 by assumption.\n  rewrite insert_insert_1 by assumption.\n  rewrite insert_insertQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct (eq_dec x x).\n  - subst. simpl.\n    rewrite insert_insert. auto.\n  - rewrite insert_insert. auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros. destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros. apply functional_extensionality. intros [x1 x2].\n  destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros. apply insert_eq_insert_1 with (a2 := e1); auto.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros. destruct x; destruct e1; simpl; congruence.\nQed.",
                    "Lemma insert_eq_insert_1: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> a1 = a2.\nProof.\n  intros.\n  destruct x; destruct e1; simpl; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert s b e) = raw_insert (1 + s) b (raw_insert k a e).\nProof.\n  intros? k s. generalize s k; clear s k. induction s; intros.\n  (* Case [s = 0]. *)\n  destruct k; [ | elimtype False; omega ]. reflexivity.\n  (* Case [s > 0]. *)\n  destruct k.\n  (* Sub-case [k = 0]. *)\n  reflexivity.\n  (* Sub-case [k > 0]. *)\n  destruct e; replace (1 + S s) with (S (1 + s)) by omega; simpl; f_equal; eauto with omega.\nQed.\n\n(* Even when it is not known which of [k] and [s] is greater, [insert] commutes\n   with itself. The formula is slightly horrid, but can be very useful. *)\n\nLemma insert_insert_always:\n  forall A k s (a b : option A) e,\n  raw_insert k a (raw_insert s b e) =\n  raw_insert (shift k s) b (raw_insert (if le_gt_dec k s then k else k - 1) a e).\nProof.\n  intros.\n  destruct (le_gt_dec k s).\n  rewrite lift_idx_old by assumption. eauto using insert_insert.\n  rewrite lift_idx_recent by assumption.\n  replace k with (1 + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 11448,
                "proof_end_offset": 11778,
                "proof": "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\ninduction x; simpl; intros.\ncongruence.\ndestruct e1; destruct e2; match goal with h: _ = _ |- _ => injection h; clear h; intros end; f_equal; try congruence; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = None). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a2). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using insert_insert_bingo.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using insert_insert_bingo.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e2) = Some a2). eauto using insert_insert_bingo.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_2: forall A x a1 a2 (e1 e2 : env A), insert x a1 e1 = insert x a2 e2 -> forall b, insert x b e1 = insert x b e2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some b). eauto using insert_insert_bingo.\n  congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " + (k - 1)) in * by omega. rewrite <- insert_insert by omega.\n  do 2 f_equal. omega.\nQed.\n\n(* Attempting to rewrite in both directions may seem redundant, because of the\n   symmetry of the law [insert_insert]. It is not: because [omega] fails in\n   the presence of meta-variables, rewriting in one direction may be possible\n   while the other direction fails. *)\n\nLtac insert_insert :=\n  first [\n    rewrite    insert_insert; [ reflexivity | omega ]\n  | rewrite <- insert_insert; [ reflexivity | omega ]\n  ].\n\nHint Extern 1 (raw_insert _ _ _ = _) =>\n  insert_insert\n: insert_insert.\n\nHint Extern 1 (_ = raw_insert _ _ _) =>\n  insert_insert\n: insert_insert.\n\n(* The result of an insertion cannot be nil. *)\n\nLemma insert_nil:\n  forall A x a (e : env A),\n  insert x a e = nil ->\n  False.\nProof.\n  destruct x; destruct e; simpl; congruence.\nQed.\n\n(* Two lemmas about equations of the form [insert x a1 e1 = insert x a2 e2].\n   Note that we have [a1 = a2], but not [e1 = e2], due to padding. *)\n\nLemma insert_eq_insert_1:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  a1 = a2.\nProof.\n  intros.\n  assert (lookup x (insert x a1 e1) = Some a1). eauto using lookup_insert_bingo.\n  assert (lookup x (insert x a2 e2) = Some a2). eauto using lookup_insert_bingo.\n  congruence.\nQed.\n\nLemma insert_eq_insert_2:\n  forall A x a1 a2 (e1 e2 : env A),\n  insert x a1 e1 = insert x a2 e2 ->\n  forall b,\n  insert x b e1 = insert x b e2.\nProof.\n  induction x; simpl; intros.\n  congruence.\n  destruct e1; destruct e2;\n  match goal with h: _ = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\n",
                "context_tokens": 658,
                "proof_start_offset": 12207,
                "proof_end_offset": 13770,
                "proof": "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\ninduction x1; intros.\ndestruct x2; [ omega | ].\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e2; [ congruence | ].\nsubst.\nsimpl.\nexists e2.\nexists x2.\nexists 0.\neauto.\ndestruct x2.\nrewrite raw_insert_zero in *.\nrewrite raw_insert_successor in *.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros end.\ndestruct e1; [ congruence | ].\nsubst.\nexists e1.\nexists 0.\nexists x1.\nsplit.\neauto.\nsplit.\neauto.\nsplit.\neauto.\ndblib_by_cases.\nomega.\ndo 2 rewrite raw_insert_successor in *.\nassert (xx: x1 <> x2).\nomega.\nmatch goal with h: _ = _ |- _ => injection h; clear h; intros h ?; generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [ ? [ ? [ ? ? ]]]]]] end.\ndestruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\ndestruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\nexists (o :: e).\nexists (S y1).\nexists (S y2).\nsplit.\nsimpl.\ncongruence.\nsplit.\nsimpl.\ncongruence.\nsplit.\neapply translate_lift with (k := 1).\neauto.\ndblib_by_cases; omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a1 e1) = Some a1). eauto using merge_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a1 e1) = Some a1). eauto using insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a1 e1) = Some a1). eauto using insert_In_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e1; [exists e1 | exists e2];\n  destruct e2; [exists e1 | exists e2];\n  destruct e2; [exists e2 | exists e3];\n  destruct e2; [exists e3];\n  destruct e3; [exists e3];\n  destruct e3; [exists e3];\n  destruct e4; [exists e3];\n  destruct e4; [exists e4];\n  destruct e4; [exists e4];\n  destruct e5; [exists e4];\n  destruct e5; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e6; [exists e4];\n  destruct e7; [exists e4];\n  destruct e6; [exists e4];\n  destruct e7; [exists e4];\n  destruct e7; [exists eQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x1 a1 e1) = Some a1). eauto using insert_eq_insert_3.\n  assert (lookup x1 (insert x1 a2 e2) = Some a2). eauto using insert_eq_insert_3.\n  assert (lookup x2 (insert x1 a2 e2)). eauto using insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  destruct e1; destruct e2;\n  match goal with H: (if le_gt_dec x1 x2 then _ else _ |- _ => inversion H; clear H; subst end.\n  all: intros.\n  assert (lt_gt_dec x1 x2).\n  {\n    destruct (lt_gt_dec x2 x1).\n    + subst x1.\n      rewrite insert_eq_insert_1.\n      destruct (eq_dec x1 x2).\n      + subst x2.\n        rewrite insert_eq_insert_2.\n        destruct (eq_dec x2 x1).\n        * subst x1.\n          rewrite insert_eq_insert_3.\n          destruct (eq_dec x1 x2).\n          * subst x2.\n            rewrite insert_eq_insert_1.\n            destruct (eq_dec x1 x2).\n            * subst x1.\n            rewrite insert_eq_insert_2.\n            destruct (eq_dec x1 x2).\n            * subst x2.\n            rewrite insert_eq_insert_1.\n            destruct (eq_dec x1 x2).\n            * subst x1.\n            rewrite insert_eq_insertQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a2 e1) = Some a1). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a2). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a1 e2) = Some a2). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a2). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a1). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a2). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a1). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a2). eauto using nth_eq_lookup_3.\n  assert (lookup x (insert x1 a2 e2) = Some a2Qed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x (insert x1 a1 e1) = Some a2). eauto using insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x1 a1 e1) = Some a1). eauto using insert_eq_insert_3.\n  congruence.\nQed.",
                    "Lemma insert_eq_insert_3: forall A x1 x2 a1 a2 (e1 e2 : env A), insert x1 a1 e1 = insert x2 a2 e2 -> x1 <> x2 -> exists e y1 y2, e1 = insert y1 a2 e /\\ e2 = insert y2 a1 e /\\ shift x1 y1 = x2 /\\ y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  intros.\n  assert (lookup x1 (insert x1 a2 e1) = Some a1). eauto using lookup_insert_3.\n  congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " = _ |- _ => injection h; clear h; intros end;\n  f_equal; try congruence; eauto.\nQed.\n\n(* This is a really crazy diamond lemma that says, roughly, if the equation\n    [insert x1 a1 e1 = insert x2 a2 e2] holds, then [e1] and [e2] can be\n    constructed out of a common environment [e]. We would like to conclude\n    [e1 = insert x2 a2 e /\\ e2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 13903,
                "proof_end_offset": 14163,
                "proof": "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  induction e; simpl; auto.\n  destruct a. simpl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite <- IHl.\n  auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. unfold map. rewrite map_insert. apply map_insert.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; simpl; auto.\n  destruct (f a); auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. unfold map. f_equal.\n  apply functional_extensionality; intros.\n  rewrite <- map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  rewrite map_insert.\n  reflexivity.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. induction e; simpl. auto.\n  simpl. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. induction a.\n  simpl. auto.\n  simpl. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. induction e; simpl; auto.\n  destruct e; simpl. auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction e; simpl; auto.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros.\n  apply map_insert_eq_insert_3.\n  intros.\n  unfold insert.\n  simpl.\n  rewrite map_insert_nil.\n  reflexivity.\nQed.",
                    "Lemma map_insert: forall A B (f : A -> B) x a e, map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  intros. unfold map.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_extensionality.\n  simpl.\n  apply functional_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2 = insert x1 a1 e], but this is false, because\n    one of the indices is off-by-one in one way or the other. We need to\n    adjust, and the arithmetic is a bit painful. *)\n\nLemma insert_eq_insert_3:\n  forall A x1 x2 a1 a2 (e1 e2 : env A),\n  insert x1 a1 e1 = insert x2 a2 e2 ->\n  x1 <> x2 ->\n  exists e y1 y2,\n  e1 = insert y1 a2 e /\\\n  e2 = insert y2 a1 e /\\\n  shift x1 y1 = x2 /\\\n  y2 = (if le_gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 14224,
                "proof_end_offset": 14387,
                "proof": "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\nintros; subst.\neapply map_insert.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  intros. unfold map.\n  rewrite insert_eq_insert_eq.\n  rewrite insert_eq_insert_eq.\n  destruct (map_insert_inv _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ _ H).\n  rewrite map_insert_eq.\n  destruct (map_insert_inv _ _ _ _ H).\n  rewrite map_insert_eq.\n Qed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  destruct a; simpl; auto.\n  destruct b; simpl; auto.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct b; simpl; eauto.\n  rewrite IHx. reflexivity.\nQed.",
                    "Lemma map_insert_eq: forall A B (f : A -> B) x a b e, f a = b -> map f (insert x a e) = insert x b (map f e).\nProof.\n  induction x; intros; destruct b; simpl; eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "gt_dec x1 y1 then x1 else x1 - 1).\nProof.\n  induction x1; intros.\n  (* Case [x1 = 0]. *)\n  destruct x2; [ omega | ].\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e2; [ congruence | ]. subst. simpl.\n  exists e2. exists x2. exists 0. eauto.\n  (* Case [x1 > 0]. *)\n  destruct x2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 14681,
                "proof_end_offset": 14953,
                "proof": "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\ninduction x; intros; destruct e; simpl; eauto.\nrewrite IHx.\nreflexivity.\nmatch goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; destruct e; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros; rewrite map_insert; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; destruct e; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  induction x; simpl.\n  - auto.\n  - auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; auto.\n  rewrite IHx. reflexivity.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma map_raw_insert: forall A B (f : A -> B) x e, map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  intros.\n  induction x; simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "2.\n  (* Sub-case [x2 = 0]. *)\n  rewrite raw_insert_zero in *. rewrite raw_insert_successor in *.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros\n  end.\n  destruct e1; [ congruence | ]. subst.\n  exists e1. exists 0. exists x1.\n  split. eauto.\n  split. eauto.\n  split. eauto.\n  dblib_by_cases. omega.\n  (* Sub-case [x2 > 0]. *)\n  do 2 rewrite raw_insert_successor in *.\n  assert (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 15074,
                "proof_end_offset": 15327,
                "proof": "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  auto.\n  rewrite <- map_f_equiv.\n  rewrite map_app.\n  rewrite map_app.\n  auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  rewrite map_map.\n  rewrite map_map.\n  rewrite map_map.\n  auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  rewrite <- map_map_f; auto.\n  rewrite <- map_map_f; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  destruct g.\n  simpl. rewrite <- map_map. auto.\n  rewrite <- map_concat.\n  simpl.\n  rewrite map_map.\n  rewrite map_map.\n  auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; intros; simpl.\n  rewrite map_map_f; auto.\n  rewrite map_map_f.\n  rewrite map_map_f; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros. induction H; simpl.\n  auto.\n  rewrite IHx. reflexivity.\n  induction e; simpl; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  intros.\n  induction e; simpl; auto.\n  rewrite IHx.\n  rewrite IHx.\n  auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; intros.\n  rewrite in_map_f.\n  rewrite map_map.\n  apply map_filter_map_f.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; auto.\nQed.",
                    "Lemma map_map_fuse: forall A B C (f : B -> C) (g : A -> B) h e, (forall (d : A), f (g d) = h d) -> map f (map g e) = map h e.\nProof.\n  induction h; simpl; auto.\n  rewrite IHl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (xx: x1 <> x2). omega.\n  match goal with h: _ = _ |- _ =>\n    injection h; clear h; intros h?;\n    generalize (IHx1 _ _ _ _ _ h xx); intros [ e [ y1 [ y2 [? [? [?? ]]]]]]\n  end.\n  (* [e1] and [e2] must be non-nil. *)\n  destruct e1; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  destruct e2; simpl tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 679,
                "proof_start_offset": 15329,
                "proof_end_offset": 15636,
                "proof": "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros. apply map_parameters_map_flem.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto.\n  destruct a; simpl in *; auto.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewrite IHx0.\n  rewriteQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto with map_f.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto with f_equal.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  intros.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_Qed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros; simpl; eauto with map_map.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o as [|x o]; simpl; eauto with f_equal; eauto with f_equal; auto end.\nQed.",
                    "Lemma map_map_exchange: forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e, (forall (d : A), f1 (f2 d) = g1 (g2 d)) -> map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  destruct e; simpl; eauto with f_equal.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " tl in *; [ elimtype False; eauto using insert_nil | ].\n  exists (o :: e). exists (S y1). exists (S y2).\n  split. simpl. congruence.\n  split. simpl. congruence.\n  split. eapply translate_lift with (k := 1). eauto.\n  dblib_by_cases; omega.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Interaction between [map] and [insert]. *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 15638,
                "proof_end_offset": 15887,
                "proof": "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\neauto using map_map_exchange, @lift_lift.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros;\n  try match goal with |-?a =?b => destruct a as [o e]; simpl; eauto with f_equal; auto end.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl; eauto.\n  rewrite IHx. rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_map.\n  rewrite <- map_lift_Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  auto.\n  rewrite IHs.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  rewrite IHs.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  simpl.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equal.\n  rewrite IHs.\n  f_equalQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite IHs. rewrite IHs. rewrite IHs. simpl. rewrite IHs.\n  rewrite IHs. rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs. simpl. rewrite IHs.\n  rewrite IHs. rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  rewrite IHs. simpl. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs. simpl. rewrite IHs.\n  simpl. rewrite IHs.Qed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction s; simpl; eauto with map.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite IHs. rewrite IHs. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs. rewrite IHs.\n  simpl. rewrite IHs. rewrite IHs. auto.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite IHs. rewrite IHs. rewrite IHs. reflexivity.\n  rewrite IHs. rewrite IHs. rewrite IHs. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite IHl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  rewrite IHs.\n  rewrite IHs.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHs.\n  simpl.\n  rewrite IHsQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite IHs. reflexivity.\n  rewrite IHs. reflexivity.\n  rewrite IHs. reflexivity.\nQed.",
                    "Lemma map_lift_map_lift: forall T k s wk ws (e : env T), forall `{Lift T}, @LiftLift T _ -> k <= s -> map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  induction e; intros; simpl.\n  rewrite IHs. reflexivity.\n  destruct (map_lift s nil); auto.\n  destruct (map_lift s nil); auto.\n  destruct (map_lift s nil); auto.\n  destruct (map_lift s nil); auto.\n  destruct (map_lift s nil); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " *)\n\nLemma map_insert:\n  forall A B (f : A -> B) x a e,\n  map f (insert x a e) = insert x (f a) (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 15889,
                "proof_end_offset": 16144,
                "proof": "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\nintros.\nrewrite map_insert.\nf_equal.\neapply map_map_exchange.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHx. rewrite <- IHp.\n  rewrite <- IHp.\n  rewrite <- IHp.\n  rewrite <- IHp.\n  rewrite <- IHp.\n  rewrite <- IHp.\n  rewrite <- IHp.\n  auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction h; intros; simpl.\n  rewrite IHl; auto.\n  rewrite IHl; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction h; simpl; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; eauto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl.\n  rewrite IHs1. rewrite IHs2. rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs1.\n  rewrite IHs2.\n  rewrite IHs2.\n  rewrite IHs2.\n  rewrite IHm1.\n  rewrite IHs1.\n  rewriteQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl.\n  rewrite IHl. rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; simpl; eauto with map_node.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  intros. rewrite map_insert.\n  rewrite map_map_fuse.\n  rewrite map_insert.\n  rewrite map_map_fuse.\n  rewrite map_map_fuse.\n  rewrite map_map_fuse.\n  rewrite map_map_fuse.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_map_flem.\n  rewrite map_mapQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction e; intros; simpl; auto.\nQed.",
                    "Lemma map_insert_map: forall A (f g h : A -> A) x (a : A) e, (forall a, f (g a) = g (h a)) -> map f (insert x a (map g e)) = insert x (f a) (map g (map h e)).\nProof.\n  induction f; intros; simpl; eauto with f_equal.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n(* The following variant is easier to use for [eauto]. *)\n\nLemma map_insert_eq:\n  forall A B (f : A -> B) x a b e,\n  f a = b ->\n  map f (insert x a e) = insert x b (map f e).\nProof.\n  intros; subst. eapply map_insert.\nQed.\n\nLtac map_insert :=\n  first [\n    rewrite map_insert; reflexivity\n  | rewrite <- map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\n",
                "context_tokens": 712,
                "proof_start_offset": 16146,
                "proof_end_offset": 16393,
                "proof": "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\ninduction e; intros; try match goal with o: option _ |- _ => destruct o end; simpl; eauto with f_equal.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_map_map_f.\n  apply map_map_node.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  induction e; intros; simpl; eauto with f_equal.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_proj.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_proj.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_proj.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_flem.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_proj.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_node_agreeore.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  rewrite map_map_map.\n  eapply map_map_flem.\n  eauto.\nQed.",
                    "Lemma map_map_vanish: forall A B (f : B -> A) (g : A -> B) (e : env A), (forall x, f (g x) = x) -> map f (map g e) = e.\nProof.\n  intros.\n  rewrite map_insert.\n  f_equal.\n  eapply map_map_proj.\n  eauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " map_insert; reflexivity\n  ].\n\nHint Extern 1 (map _ (insert _ _ _) = insert _ _ (map _ _)) =>\n  map_insert\n: map_insert.\n\nHint Extern 1 (insert _ _ (map _ _) = map _ (insert _ _ _)) =>\n  map_insert\n: map_insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 16555,
                "proof_end_offset": 16676,
                "proof": "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite fold_empty. rewrite fold_empty.\n  destruct (f a); auto.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold.\n  rewrite fold_empty.\n  rewrite fold_left_elements.\n  rewrite fold_right_elements.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite mapQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite map_app. apply fold_empty.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite map_fold.\n  f_equal.\n  rewrite map_fold.\n  rewrite map_fold.\n  rewrite map_add.\n  rewrite map_fold.\n  rewrite map_fold.\n  rewrite map_map_fold.\n  rewrite map_fold.\n  rewrite map_map_fold.\n  rewrite map_map_fold.\n  rewrite map_fold.\n  rewrite map_map_comp.\n  rewrite map_fold.\n  rewrite map_map_app.\n  rewrite map_fold.\n  rewrite map_map_map.\n  rewrite map_map_fold.\n  rewrite map_map_app.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_map_map.\n  rewrite map_map.\n  rewrite map_mapQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite map_empty_r. rewrite map_empty_r.\n  rewrite map_map_base.\n  rewrite map_empty_r.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_map_base.\n  rewrite map_mapQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold.\n  rewrite map_fold.\n  rewrite map_fold.\n  rewrite map_map_f.\n  rewrite map_map.\n  rewrite map_comp.\n  rewrite map_map_f.\n  rewrite map_fold.\n  rewrite map_map_f.\n  rewrite map_comp.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_map_f.\n  rewrite map_map_f.\n  rewrite map_map_fQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof. auto. Qed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros. unfold fold. rewrite map_empty. rewrite map_empty.\n  rewrite map_empty. apply map_empty.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\n  intros.\n  rewrite fold_empty. rewrite fold_empty.\n  rewrite fold_empty.\n  apply List.elements_correct.\nQed.",
                    "Lemma fold_empty: forall A B (f : option A -> B -> B) accu, fold f (@empty _) accu = accu.\nProof.\nintros.\nextensionality s.\napply fold_empty_left.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "insert.\n\nLemma map_raw_insert:\n  forall A B (f : A -> B) x e,\n  map f (raw_insert x None e) = raw_insert x None (map f e).\nProof.\n  induction x; intros; destruct e; simpl; eauto.\n  rewrite IHx. reflexivity.\n  match goal with o: option _ |- _ => destruct o end; f_equal; eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [map] composes with itself. *)\n\nLemma map_map_fuse:\n  forall A B C (f : B -> C) (g : A -> B) h e,\n  (forall (d : A), f (g d) = h d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\n",
                "context_tokens": 725,
                "proof_start_offset": 16726,
                "proof_end_offset": 16875,
                "proof": "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros; simpl.\n  rewrite IHx. rewrite IHs. reflexivity.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. unfold fold.\n  rewrite fold_right_elements.\n  set (l := list (fun x => if x then Some x else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None).\n  set (l' := list (fun x => if x then None else None)).\n  set (l' := list (fun x => if x then None else None)).\n  set (l'Qed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. induction f; simpl. auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction o; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  induction e; intros; simpl; auto.\nQed.",
                    "Lemma fold_insert: forall A B (f : option A -> B -> B) o e accu, fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  intros. unfold fold.\n  rewrite fold_empty.\n  rewrite fold_left_rev.\n  rewrite fold_left_rev.\n  rewrite fold_left_rev.\n  apply fold_right_rev.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " d) ->\n  map f (map g e) = map h e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_map_exchange:\n  forall A F G B (f1 : F -> B) (f2 : A -> F) (g1 : G -> B) (g2 : A -> G) e,\n  (forall (d : A), f1 (f2 d) = g1 (g2 d)) ->\n  map f1 (map f2 e) = map g1 (map g2 e).\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\n",
                "context_tokens": 704,
                "proof_start_offset": 17224,
                "proof_end_offset": 17518,
                "proof": "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\nintros ? ? ? ? ? init step.\ninduction e; simpl.\neapply init.\neapply step.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros; simpl.\n  auto.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_node.\n  apply fold_empty.\n  apply fold_node.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_empty.\n  apply fold_node.\n  apply fold_node_not_1.\n  apply fold_node_not_2.\n  apply fold_node_not_2.\n  apply fold_node_not_2.\n  apply fold_node_not_2.\n  apply fold_node_not_2.\n  applyQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; simpl; intros; auto.\n  apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\n  simpl. apply IHcs.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; intros; simpl.\n  auto.\n  destruct (H a); auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros; simpl.\n  auto.\n  destruct (H1 e); auto.\n  destruct (H2 e); auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; simpl; intros.\n  apply fold_empty.\n  intros. rewrite (H a). apply in_app. auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction e; simpl; intros.\n  auto.\n  destruct (H0 e). auto.\n  destruct H0; auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction f; simpl; intros.\n  auto.\n  simpl. apply IHenv. auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; simpl; auto.\n  intros. destruct e; simpl; auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros; simpl. auto.\n  destruct a; simpl.\n  case (f x); simpl; auto.\n  case (f x); simpl; auto.\n  case (f x); simpl; auto.\n  case (f x); simpl; auto.\n  case (f x); simpl; auto.\nQed.",
                    "Lemma fold_invariant: forall A B (P : env A -> B -> Prop) f accu, P (@empty _) accu -> (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) -> forall e, P e (fold f e accu).\nProof.\n  induction 1; intros; simpl.\n  apply fold_empty.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ion e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\nLemma map_lift_map_lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\n",
                "context_tokens": 723,
                "proof_start_offset": 17848,
                "proof_end_offset": 17982,
                "proof": "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl.\n  eapply IHlength.\n  eapply IHl; eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros.\n  apply H.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply IHl.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  induction e; simpl.\n  auto.\n  destruct (H a); auto.\n  destruct (H0 a); auto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros.\n  assert (k1 <= length e)%nat by omega.\n  assert (length (k1 + length e) < length e)%nat by omega.\n  assert (k2 < length e)%nat by omega.\n  assert (length (k2 + length e) < length e)%nat by omega.\n  apply nth_error_monotonic.\n  apply nth_error_monotonic.\n  omega.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros.\n  auto.\n  eapply IHl; eauto.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl.\n  intros.\n  apply IHk.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\n  apply H.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros.\n  auto.\n  destruct (H0 k1).\n  apply e0.\n  simpl; apply IHl.\n  apply IHl.\n  apply IHl.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  induction e; simpl; intros.\n  eapply H; eauto.\n  apply IHl.\n  apply H. omega.\nQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A B e k1 k2 H.\n  induction H.\n  apply H.\n  simpl.\n  eapply IHl.\n  eapply IHl.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H2.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H2.\n  eapply map_length_monotonic.\n  eapply H2.\n  eapply H2.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H2.\n  eapply H2.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H2.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_length_monotonic.\n  eapply H2.\n  eapply map_length_monotonic.\n  eapply H1.\n  eapply map_lengthQed.",
                    "Lemma length_monotonic: forall A (e : env A) k1 k2, length e <= k1 -> k1 <= k2 -> length e <= k2.\nProof.\n  intros A e k1 k2 H.\n  induction H.\n  simpl; auto.\n  eapply H.\n  eapply IHl.\n  eapply IHl.\n  eapply H.\n  eapply H.\n  eapply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "lift:\n  forall T k s wk ws (e : env T),\n  forall `{Lift T},\n  @LiftLift T _ ->\n  k <= s ->\n  map (lift wk k) (map (lift ws s) e) = map (lift ws (wk + s)) (map (lift wk k) e).\nProof.\n  eauto using map_map_exchange, @lift_lift.\nQed.\n\nLemma map_insert_map:\n  forall A (f g h : A -> A) x (a : A) e,\n  (forall a, f (g a) = g (h a)) ->\n  map f (insert x a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 17984,
                "proof_end_offset": 18200,
                "proof": "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\ninduction e; simpl; intros.\neapply lookup_empty_None.\ndestruct x; [ omega | ].\nsimpl.\neapply IHe.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  apply (well_founded_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_Qed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  destruct (eq_dec x x).\n  subst; auto.\n  apply IHl.\n  destruct (eq_dec x x).\n  subst; auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  destruct e.\n  + reflexivity.\n  + destruct e.\n    simpl in H. apply H.\n  + destruct e.\n    simpl.\n    destruct (eq_dec x k).\n    + subst.\n      apply H0.\n    + apply H.\n    + apply H.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. induction e; simpl.\n  apply a.\n  apply IHa. auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  apply (well_founded_induction_wf wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_ind wf_indQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  apply list_length_conv.\n  applyQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros. omega.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  rewrite <- (nth_error_length _ _ _ _ H).\n  rewrite <- (nth_error_length _ _ _ _ H).\n  apply nth_error_left; auto.\nQed.",
                    "Lemma lookup_beyond_length: forall A (e : env A) x, length e <= x -> lookup x e = None.\nProof.\n  intros.\n  assert (H: forall x, length e <= length e -> In x (nth x e nil)).\n    intros.\n    rewrite H0 in H.\n    apply H0 in H.\n    destruct (nth x e) eqn:E; auto.\n    apply IHl in H.\n    apply IHl in H.\n    apply IHl in H.\n    apply IHl in H.\n    apply IHl in H.\n    apply IHl in H.\n    apply H.\n    apply H0 in H.\n    apply IHl in H.\n    apply H.\n    apply IHl in H.\n    apply H0.\n    apply IHl in H.\n    apply H.\n    apply IHl in H.\n    apply H.\n    apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a (map g e)) =\n  insert x (f a) (map g (map h e)).\nProof.\n  intros.\n  rewrite map_insert. f_equal.\n  eapply map_map_exchange.\n  eauto.\nQed.\n\nLemma map_map_vanish:\n  forall A B (f : B -> A) (g : A -> B) (e : env A),\n  (forall x, f (g x) = x) ->\n  map f (map g e) = e.\nProof.\n  induction e; intros;\n  try match goal with o: option _ |- _ => destruct o end;\n  simpl; eauto with f_equal.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Properties of [fold]. *)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\n",
                "context_tokens": 688,
                "proof_start_offset": 18306,
                "proof_end_offset": 18753,
                "proof": "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\nintros.\ncase (le_gt_dec k x); intro; try tauto.\nassert (lookup x e = None).\neapply lookup_beyond_length.\nomega.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros.\n  assert (x < k) by omega.\n  assert (k < length (a :: nil)).\n  { eapply H. omega. }\n  destruct (H k).\n  rewrite <- (IHlength a), <- (IHlength a), <- (IHlength a), <- (IHlength a).\n  rewrite <- (IHlength a), <- (IHlength a), <- (IHlength a).\n  simpl; omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  contradiction.\n  destruct a. destruct H.\n  subst. destruct H.\n  subst. auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  contradiction.\n  destruct H1. destruct H2.\n  subst x. eapply IHa. eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  apply e. omega.\n  simpl. eapply IHlength. omega.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  auto.\n  destruct (H x).\n  inv H.\n  simpl. auto.\n  simpl. eapply IHk; eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  contradiction.\n  destruct a; simpl in *.\n  destruct (x == k).\n  inv H.\n  eapply IHl. eapply H. eauto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. destruct e; simpl in *; try omega.\n  destruct (x0 x); auto.\n  destruct (x0 x); auto.\n  destruct (k0 x); auto.\n  destruct (k1 x); auto.\n  destruct (k2 x); auto.\n  destruct (k2 x); auto.\n  destruct (k2 x); auto.\n  destruct (k3 x); auto.\n  destruct (k3 x); auto.\n  destruct (k3 x); auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  intros. destruct (eq_dec x k).\n  subst k.\n  apply pred_ext; auto.\n  destruct (eq_dec x k).\n  subst. omega.\n  auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  apply H.\n  destruct H1. omega.\n  destruct (x0 x). simpl in H. subst. auto.\nQed.",
                    "Lemma defined_implies_below_length: forall A (e : env A) x k a, length e <= k -> lookup x e = Some a -> x < k.\nProof.\n  induction e; simpl; intros.\n  rewrite <- (nth_error_nil _ H).\n  destruct a.\n  destruct (nth x e); auto.\n  destruct (nth x e); auto.\n  destruct (nth x e); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "*)\n\n(* Interaction between [fold] and [empty]. *)\n\nLemma fold_empty:\n  forall A B (f : option A -> B -> B) accu,\n  fold f (@empty _) accu = accu.\nProof.\n  reflexivity.\nQed.\n\n(* Interaction between [fold] and [insert]. *)\n\nLemma fold_insert:\n  forall A B (f : option A -> B -> B) o e accu,\n  fold f (raw_insert 0 o e) accu = f o (fold f e accu).\nProof.\n  reflexivity.\nQed.\n\n(* An induction principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\n",
                "context_tokens": 698,
                "proof_start_offset": 18862,
                "proof_end_offset": 18957,
                "proof": "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\nsimpl.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. unfold list_nth.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.in_map.\n  apply List.inQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  rewrite <- (Nat2Z.id (A:=A)).\n  apply Nat2Z.inj.\n  rewrite <- (Nat2Z.id (A:=A)).\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.inj.\n  apply Nat2Z.Qed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. rewrite Zlength_correct. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros. unfold empty. apply elements_wf.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction A; simpl; intros.\n  apply IHl.\n  apply IHl.\n  apply IHl.\n  apply (H k).\n  apply IHl.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  auto.\n  destruct (le_gt_dec k x).\n  rewrite <- (H (k, a)).\n  auto.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  intros.\n  case (le_gt_dec k 0); intros.\n  apply Nat.le_lt_trans with (k - 0).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (k - 1).\n  apply Nat.le_lt_trans with (kQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction A; simpl; intros. omega.\nQed.",
                    "Lemma length_empty: forall A k, length (@empty A) <= k.\nProof.\n  induction k; simpl; intros.\n  contradiction.\n  destruct a; simpl in *.\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k k).\n  contradiction.\n  destruct (zeq k kQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "tion principle. In order to prove that a property [P] holds of\n   [fold f e accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 19259,
                "proof_end_offset": 19333,
                "proof": "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec j i).\n  + (* the next case, we don't prove that [j < k] *)\n    destruct (lt_gt_dec j i).\n    + (* the next case, we can prove that [j < k] *)\n      destruct (lt_gt_dec j j).\n      + (* the next case, we can prove that [j < k] *)\n        destruct (lt_gt_dec j j).\n        + (* the next case, the next case, we can prove that [j < k] *)\n          destruct (lt_gt_dec j j).\n            * (* the next case, the next case, we don't prove that [j < k] *)\n            apply IH; omega.\n          * (* the next case, the next case, the next case, the next case, after the next case,\n         but the next case, it's enough, it's not the next case,\n         only one is more convenient, since [j < k] *)\n          destruct (lt_gt_dec j k).\n            * (* the next case, the next case, the next case, but the next case,\n         but theQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  unfold mymax.\n  destruct (le_gt_dec m n).\n  apply min_l.\n  omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_gt_dec j j).\n  apply min_l.\n  apply min_l.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct le_gt_dec.\n  apply Nat2Z.inj_le. omega.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax, default_min.\n  rewrite <- (nth_default_l 0 i).\n  apply nth_default_l.\n  apply nth_default_l.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_error_nth_default.\n  rewrite nth_errorQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  unfold mymax, lt_lt.\n  intros.\n  apply Nat.le_trans with (j := 0); auto.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\nunfold mymax, regmax.\ndestruct (lt_gt_dec j j); auto.\nQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  rewrite <- (Nat2Z.inj_le i j).\n  (* TODO: why we must be done, but it's not the proof of [i]\n   and [j <= j] or [j <= j] or [j < j] *)\n  unfold mymax.\n  destruct (lt_le_dec i j).\n  (* this is the proof of [j < j] or [j < j] or [j < j] or [j < j] *)\n  unfold mymax.\n  destruct (lt_le_dec j j).\n  (* this is the proof of [j < j] or [j < j] or [j < j] *)\n  unfold mymax.\n  destruct (lt_le_dec j j).\n  (* this is the proof of [j < j] or [j <= j] *)\n  unfold mymax.\n  destruct (lt_le_dec j j).\n  (* this is the proof of [j < j] or [j <= j] or [j < j] *)\n  unfold mymax.\n  destruct (lt_le_dec j j).\n  (* this is the proof of [j < jQed.",
                    "Lemma mymax_l: forall i j, mymax i j >= i.\nProof.\n  intros.\n  unfold mymax.\n  destruct (le_lt_dec j i).\n  apply min_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "accu], it suffices to hold that it holds of the initial\n   accumulator and that it is preserved by one iteration. The statement is\n   expressed in terms of [empty] and [raw_insert], so the fact that\n   environments are implemented as lists is not exposed. *)\n\nLemma fold_invariant:\n  forall A B (P : env A -> B -> Prop) f accu,\n  P (@empty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 19335,
                "proof_end_offset": 19409,
                "proof": "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\nintros.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. apply mymax_r.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. unfold mymax.\n  rewrite Nat2Z.inj_succ.\n  auto.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. unfold mymax.\n  rewrite Nat2Z.inj_succ. omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. unfold mymax.\n  rewrite Nat2Z.inj_succ.\n  omega.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. mymax.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. unfold mymax.\n  rewrite Nat2Z.inj_succ.\n  reflexivity.\nQed.",
                    "Lemma mymax_r: forall i j, mymax i j >= j.\nProof.\n  intros. unfold mymax.\n  destruct (lt_ge_dec j i).\n  - (* this case, it's not very easy. *)\n    auto.\n  - (* this case, it's not easy. *)\n    auto.\n  - (* This case, it's not easy. *)\n    auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ty _) accu ->\n  (forall o e accu, P e accu -> P (raw_insert 0 o e) (f o accu)) ->\n  forall e,\n  P e (fold f e accu).\nProof.\n  intros????? init step.\n  induction e; simpl.\n  eapply init.\n  eapply step. eauto.\nQed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* [length e] should be viewed as an upper bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\n",
                "context_tokens": 705,
                "proof_start_offset": 19590,
                "proof_end_offset": 19888,
                "proof": "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\ninduction x; simpl; intros; subst.\nmymax.\ndestruct e; simpl.\nmymax.\nerewrite IHx by reflexivity.\nsimpl.\nmymax.\nerewrite IHx by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  pose proof (Nat.min_max_l x (1 + k)).\n  pose proof (Nat.min_max_r x (1 + k)).\n  omega.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. induction e.\n  - apply Zlength_nil_end.\n  - rewrite Zlength_cons.\n    reflexivity.\n  - rewrite Zlength_cons.\n    reflexivity.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  destruct (le_gt_dec x k) as [H|H].\n  + (* case *)\n    rewrite H.\n    rewrite H.\n    rewrite H.\n    reflexivity.\n  + (* case *)\n    rewrite H.\n    rewrite H.\n    reflexivity.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  rewrite Zlength_correct, Nat2Z.inj_succ.\n  rewrite Nat2Z.inj_add.\n  rewrite Nat2Z.inj_add.\n  apply Nat2Z.inj_le.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold elements.\n  set (k := (k - 1) + k - 1) in *.\n  set (l := (k - 1) + k - 1) in *.\n  assert (0 + k = length l).\n    rewrite <- (Nat2Z.inj_add k 1) in H.\n    rewrite <- (Nat2Z.inj_add k 1) in H.\n    rewrite (Nat2Z.inj_add k 1) in H.\n    omega.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  apply Nat2Z.inj_lt.\n  apply Nat2Z.inj_lt.\n  rewrite Nat2Z.inj_succ, Nat2Z.inj_succ.\n  omega.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  assert (forall k, length e <= k -> length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall k, length e <= k) by (clear; intro H; auto).\n  assert (forall kQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  unfold midmax.\n  destruct (le_gt_dec x 0).\n  + subst. apply (H 0).\n    reflexivity.\n  + subst. apply (H 0).\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros. unfold elements.\n  destruct (eq_dec x o).\n  subst x.\n  rewrite H.\n  simpl.\n  auto.\nQed.",
                    "Lemma length_insert_general: forall A x k o (e : env A), length e = k -> length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  intros.\n  assert (forall x, length (raw_insert x o e) = length (raw_insert x o e)).\n    intros.\n    assert (forall x, length (raw_insert x o e) = length (raw_insert x o e)).\n      intros.\n      apply raw_elements_compat with (x := e) (1 := x) (2 := x) (3 := x) (k := x) (k := x) (l := l) (d := l) (l := l) (l := l) (r := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (r := l) (r := l) (l := l) (r := l) (l := l) (l := l) (r := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (l := l) (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " bound on the true length of the\n   environment [e], since there may be useless [None] entries at the end.\n   We are careful to always work with hypotheses and goals of the form\n   [length e <= k]. *)\n\nLemma length_monotonic:\n  forall A (e : env A) k1 k2,\n  length e <= k1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 19928,
                "proof_end_offset": 20142,
                "proof": "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\nintros.\nerewrite length_insert_general by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  subst. destruct o; simpl.\n  apply H.\n  destruct o; simpl.\n  apply H0.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  pose proof (nth_error_In _ _ _ _ H).\n  destruct (zlt x 0).\n  destruct (zlt x 0).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 1).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 0).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 1).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 1).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 0).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 0).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x 1).\n  simpl in H.\n  assert (x < n + 1) by omega. clear H.\n  destruct (zlt x n).\n  simpl in H.Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  apply (IHcs _ _ _ _ H); auto.\n  destruct e; simpl; auto.\n  apply (IHcs _ _ _ _ H); auto.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros.\n  assert (H: length (raw_insert x o e) <= length (raw_insert x o e)).\n    apply H.\n    apply H.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    apply in_or_app.\n    applyQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k TMP1 o k Pk1 o.\n  remember (linear_insert x o e) as m.\n  generalize dependent m.\n  induction m; simpl; intros.\n  apply (H _ _ H).\n  rewrite app_nil_end.\n  rewrite IHl. simpl. apply IH, H0.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k T H.\n  assert (H: forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_insert x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_partition x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_partition x o e) <= 1) by omega.\n  assert (H': forall k, length (raw_partition x oQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros A x k.\n  apply Zlength_insert_general.\n  intros. apply lt_le_trans with x; auto. apply lt_le_trans with k; auto.\n  omega.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  auto.\n  destruct e; simpl.\n  destruct (in_app_or _ _ _ H); auto.\n  apply IHl.\nQed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  intros. induction x; simpl; intros.\n  - destruct e; simpl in *.\n    - destruct (lt_gt_dec x 1) eqn:H1; try discriminate.\n      destruct H1.\n      * destruct (lt_gt_dec x 1); [omega | ].\n        destruct (lt_gt_dec x 1); [omega | ].\n        destruct (lt_gt_dec x 2); [omega | ].\n        destruct (lt_gt_dec x 1); [omega | ].\n        destruct (lt_gt_dec x 1); [omega | ].\n        destruct (lt_gt_dec x 2); [omega | ].\n        destruct (lt_gt_dec x 3); [omega | ].\n        destruct (lt_gt_dec x 3); [omega | ].\n        destruct (lt_gt_dec x 3); [omega | ].\n        destruct (lt_gt_dec x 2); [omega | ].\n        destruct (lt_gt_dec x 3); [omega | ].\n        destruct (lt_gt_dec x 3); [omega | ].\n        destruct (lt_gt_dec x 5); [omega | ].\n        destruct (lt_gt_dec x 3); [omega |Qed.",
                    "Lemma length_insert: forall A x k km1 o (e : env A), length e <= km1 -> km1 <= k - 1 -> x < k -> length (raw_insert x o e) <= k.\nProof.\n  induction x; simpl; intros.\n  rewrite <- (IHcs).\n  omega.\n  destruct o.\n  simpl.\n  apply IHcs. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "1 ->\n  k1 <= k2 ->\n  length e <= k2.\nProof.\n  intros. omega.\nQed.\n\nLemma lookup_beyond_length:\n  forall A (e : env A) x,\n  length e <= x ->\n  lookup x e = None.\nProof.\n  induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 20163,
                "proof_end_offset": 20345,
                "proof": "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  destruct (lt_dec k x).\n  auto.\n  simpl.\n  destruct (lt_dec k x).\n  auto.\n  auto.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. induction H.\n  simpl. auto.\n  apply H0.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  destruct (le_gt_dec x a).\n  apply nth_error_nil.\n  apply nth_error_nil.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  induction e; simpl; intros.\n  inv H.\n  destruct a.\n  remember (a::k) as d.\n  assert (length (a::l)) by omega.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (a::l)); try contradiction.\n  destruct (in_dec eq_dec (aQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. rewrite app_length. apply app_nil_end.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  rewrite <- app_length.\n  rewrite <- app_length.\n  apply list_length_app.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros.\n  pose proof (length_insert_length _ _ H).\n  destruct (nth_error _ _ H).\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_iff in H.\n  destruct H as [? [??]].\n  apply in_map_Qed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. unfold insert.\n  rewrite <- app_length.\n  apply H.\nQed.",
                    "Lemma length_insert_reverse_1: forall A (e : env A) k x a, length (insert x a e) <= k -> x < k.\nProof.\n  intros. induction e; simpl; intros.\n  contradiction.\n  destruct (lt_gt_dec k x); simpl in *.\n  apply IH, (in_app_or _ _ H).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " induction e; simpl; intros.\n  eapply lookup_empty_None.\n  destruct x; [ omega | ]. simpl. eapply IHe. omega.\nQed.\n\n(* Every variable that is defined in the environment is less than the\n   length of the environment. *)\n\nLemma defined_implies_below_length:\n  forall A (e : env A) x k a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 20347,
                "proof_end_offset": 20541,
                "proof": "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction x; intros.\n  rewrite app_nil_r. omega.\n  destruct a; simpl.\n  rewrite app_nil_r.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite length_insert_num.\n  destruct (lt_gt_dec k 0).\n  rewrite app_length in *.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite Zlength_insert_flatten in * by omega.\n  destruct (le_lt_dec k 0).\n  + subst. apply H. omega.\n  + rewrite Zlength_insert_flatten by omega.\n    rewrite <- Nat2Z.inj_add by omega.\n    apply Nat2Z.inj_le. omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  rewrite length_insert_app.\n  destruct (lt_dec x 0).\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  assert (length (a - 1) > 0) by omega.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite length_insert_num.\n  destruct (in_dec (a::nil) x).\n  2: elimtype False; omega.\n  destruct (in_dec (a::nil) x); inv H.\n  subst.\n  rewrite rev_length in *.\n  rewrite rev_length in *.\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. induction e.\n  + simpl. rewrite IHl. simpl. apply H.\n  + simpl. apply H.\n  + simpl. apply H.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite length_insert_flatten in * by auto.\n  apply in_or_app_or_app_or in H. apply in_or_app_or in H. apply in_or_app_or in H.\n  destruct H.\n  destruct H. subst.\n  destruct H.\n  simpl.\n  apply in_or_app_or in H. apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_or_app_or in H.\n  apply in_orQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros.\n  rewrite length_insert_flatten in * by omega.\n  destruct (le_gt_dec k 0).\n  apply Nat.le_gt_cases. omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  induction x; simpl; intros.\n  destruct a.\n  destruct (le_lt_dec k x).\n  simpl.\n  destruct (le_lt_dec x x).\n  destruct (le_lt_dec x x); [omega|].\n  omega.\n  simpl. destruct (le_lt_dec x x); [omega|].\n  omega.\nQed.",
                    "Lemma length_insert_reverse_2: forall A (e : env A) k x a, length (insert x a e) <= k + 1 -> length e <= k.\nProof.\n  intros. rewrite Zlength_insert_real.\n  apply length_insert_flatten_1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a,\n  length e <= k ->\n  lookup x e = Some a ->\n  x < k.\nProof.\n  intros.\n  (* If [x < k] holds, the result is immediate. Consider the other case,\n     [k <= x]. *)\n  case (le_gt_dec k x); intro; try tauto.\n  (* By definition of [length], [lookup x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n",
                "context_tokens": 718,
                "proof_start_offset": 20543,
                "proof_end_offset": 20777,
                "proof": "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\nintros.\nerewrite length_insert_general in * by reflexivity.\nmymax.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite Zlength_insert_lower by (rewrite <- H by auto).\n  destruct (lt_dec x y); [subst y|].\n  rewrite Zlength_insert_alt by omega.\n  omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  assert (length (msubst_insert x a (e :: nil))).\n  assert (length (msubst_insert x a (e :: nil))).\n  apply H.\n  destruct (in_dec H0) as [H1|H1].\n  apply in_app.\n  apply in_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_app.\n  apply in_or_app.\n  apply inQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_real_1 by reflexivity.\n  assert (length (treeify_nth k a e)) by (rewrite H1 by auto).\n  apply H.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  destruct H.\n  apply in_or_app.\n  destruct H.\n  apply in_or_app.\n  apply in_or_app.\n  destruct H.\n  rewrite <- H0.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  destruct H.\n  rewrite <- H0.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_app.\n  apply in_or_Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_count in * by reflexivity.\n  rewrite <- app_length.\n  omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. induction H.\n  + simpl.\n    rewrite app_nil_r.\n    destruct e.\n    + simpl.\n      rewrite app_nil_r.\n      rewrite app_nil_r.\n      apply H.\n  + simpl.\n    rewrite app_nil_r.\n    destruct (le_gt_dec k 0).\n    + simpl.\n      rewrite app_nil_r.\n      destruct (le_gt_dec k 0).\n      * subst.\n          rewrite app_nil_r.\n          rewrite app_nil_r.\n          omega.\n      * apply H.\n  + simpl.\n    rewrite app_nil_r.\n    destruct (le_gt_dec k 0).\n    + subst.\n        rewrite app_nil_r.\n        destruct (le_gt_dec k 0).\n        * subst.\n          rewrite app_nil_r.\n            rewrite app_nil_r.\n            rewrite app_nil_r.\n            rewrite app_nil_r.\n            omega.\n      * apply H.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  apply in_app_iff in H.\n  destruct H.\n  subst.\n  destruct e.\n  destruct (le_gt_dec x0 x).\n  auto.\n  omega.\n  destruct (lt_gt_dec x0 y).\n  omega.\n  destruct (le_gt_dec x0 y).\n  omega.\n  destruct (lt_gt_dec y x).\n  omega.\n  destruct (le_gt_dec x0 y).\n  omega.\n  destruct (le_gt_dec y x).\n  omega.\n  destruct (le_gt_dec y x).\n  omega.\n  destruct (le_gt_dec y x).\n  omega.\nQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros.\n  erewrite length_insert_over by (rewrite <- (H x).\n  rewrite <- (H y).\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.\n  rewrite <- (H (S k)).\n  simpl.Qed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  induction e; intros.\n  simpl in H. omega.\n  destruct H.\n  destruct (H _ H).\n  apply in_app_or in H. destruct H.\n  rewrite in_app_or in H.\n  apply in_app_or in H. destruct H.\n  destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_or in H. destruct H.\n  apply in_app_orQed.",
                    "Lemma length_insert_independent: forall A (e : env A) k x a, length (insert x a e) <= k -> forall y o, y < k -> length (raw_insert y o e) <= k.\nProof.\n  intros. rewrite length_insert_commute in * by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n  destruct (le_gt_dec k x).\n  rewrite IHl by omega.\n Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " x e] is [None]. *)\n  assert (lookup x e = None). eapply lookup_beyond_length. omega.\n  (* We obtain a contradiction. *)\n  congruence.\nQed.\n\nHint Resolve defined_implies_below_length : lift_idx_hints.\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\n",
                "context_tokens": 734,
                "proof_start_offset": 20858,
                "proof_end_offset": 21019,
                "proof": "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\ninduction e as [| [|] ]; simpl; intros; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; simpl; intros; auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; simpl; intros; auto.\n  destruct (f a); simpl; auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; simpl; intros.\n  auto.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  apply map_length.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; simpl.\n  destruct e; simpl.\n  rewrite IHx by auto.\n  rewrite IHx by auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros.\n  induction e; simpl; intros.\n  rewrite IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite <- IHl.\n  rewrite IHl.\n  f_equal.\n  apply IHl.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; simpl; intros.\n  rewrite <- IHl.\n  apply IHl.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; intros.\n  auto.\n  rewrite IHl. rewrite <- IHl.\n  simpl.\n  rewrite IHl.\n  rewrite IHl.\n  auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. induction e; simpl; auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  intros. induction e; simpl; auto.\nQed.",
                    "Lemma length_map_general: forall A B (f : A -> B) (e : env A), length (map f e) = length e.\nProof.\n  induction e; intros; simpl; auto.\n  rewrite IHl. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* The empty environment has zero length. *)\n\nLemma length_empty:\n  forall A k,\n  length (@empty A) <= k.\nProof.\n  simpl. intros. omega.\nQed.\n\n(* This definition of [max] is much more pleasant to work with than the\n   one found in Coq's standard library. It can be easily unfolded, and\n   then [omega] takes control. *)\n\nDefinition mymax m n :=\n  if le_gt_dec m n then n else m.\n\nLtac mymax :=\n  unfold mymax in *; dblib_by_cases; try omega.\n\nLemma mymax_l:\n  forall i j, mymax i j >= i.\nProof. \n  intros. mymax.\nQed.\n\nLemma mymax_r:\n  forall i j, mymax i j >= j.\nProof. \n  intros. mymax.\nQed.\n\nHint Resolve mymax_l mymax_r : mymax.\n\n(* Extending an environment increments its length by one, in the usual case.\n   It can be extended by more than one if [x] is far away. *)\n\nLemma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 21021,
                "proof_end_offset": 21185,
                "proof": "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\nintros.\nrewrite length_map_general.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| | [] [ | ] [| k] ]; intros; simpl.\n  - apply IHl.\n  - apply IHl.\n  - simpl. apply IHl.\n  - apply IHl.\n  - simpl. apply IHl.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| [ | e' IH]; simpl; intros.\n  apply IH. rewrite <- IH. apply IH.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|y]; simpl; intros.\n  auto.\n  destruct e; simpl.\n  destruct e; auto.\n  destruct (IHy x0); auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k IHk]; simpl; intros.\n  apply length_nil. apply H.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| k] l; simpl; intros.\n  rewrite IHl; simpl.\n  replace (S k) with (S k) by omega.\n  rewrite IHl. rewrite IHl. auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k1 o1 IH]; simpl.\n  intros. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|k]; intros.\n  rewrite map_length in *.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite IHl.\n  simpl.\n  rewrite IHl.\n  rewrite IHl.\n  rewrite map_length.\n  rewrite IHl.\n  clear IHl.\n  induction (map f e); simpl; intros.\n  rewrite map_length.\n  simpl.\n  rewrite IHl.\n  rewrite map_length.\n  rewrite IHl.\n  auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [| k Hreck].\n  simpl.\n  rewrite Zlength_map.\n  rewrite IHl. simpl. apply IHl.\n  intros. rewrite Zlength_map. auto.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|x tl]; simpl; intros.\n  apply elements_nil.\nQed.",
                    "Lemma length_map: forall A B (f : A -> B) (e : env A) k, length e <= k -> length (map f e) <= k.\nProof.\n  induction e as [|x a]; simpl; intros.\n  inv H.\n  apply IHl.\n  apply IHl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "ma length_insert_general:\n  forall A x k o (e : env A),\n  length e = k ->\n  length (raw_insert x o e) = mymax (1 + k) (1 + x).\nProof.\n  induction x; simpl; intros; subst.\n  mymax.\n  destruct e; simpl.\n  mymax. erewrite IHx by reflexivity. simpl. mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\n",
                "context_tokens": 690,
                "proof_start_offset": 21885,
                "proof_end_offset": 22104,
                "proof": "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\ndo 6 intro.\nintros hlookup ? ?.\nrewrite <- hlookup.\nsymmetry.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  destruct (H0 x).\n  auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. destruct (x == k) eqn:E.\n  - destruct (k == k) eqn:E.\n    + subst k. auto.\n    + destruct (k == k) eqn:E.\n      rewrite E in E. rewrite E in E. rewrite E in E. discriminate.\n  - destruct (k == k) eqn:E.\n      rewrite E in E. rewrite E in E. discriminate.\n  - destruct (k == k) eqn:E.\n      + subst k. rewrite E in E. rewrite E in E. discriminate.\n  - destruct (k == k) eqn:E.\n      rewrite E in E. rewrite E in E. rewrite E. discriminate.\n  - destruct (k == k) eqn:E.\n      rewrite E in E. rewrite E in E. rewrite E. discriminate.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree.\n  destruct (a == a0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\n  destruct (a == x0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\n  destruct (a == x0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\n  destruct (a == x0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\n  destruct (a0 == x0) eqn:E; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree.\n  destruct (x?= k) eqn:E; [inversion E | inversion E | inversion E | auto ];\n  try (destruct a; inversion E).\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  unfold agree.\n  destruct (find_lookup x e1) eqn:E1.\n  - destruct (find_lookup x e2) eqn:E2.\n    + destruct (find_lookup x e2) eqn:E2.\n      + destruct (find_lookup x e1) eqn:E2.\n        { destruct (find_lookup x e2) eqn:E1; try discriminate.\n          destruct (find_lookup x e2) eqn:E1.\n          { destruct (find_lookup x e2) eqn:E2.\n            { destruct (find_lookup x e2) eqn:E1; try discriminate.\n              destruct (find_lookup x e2) eqn:E2.\n              { destruct (find_lookup x e1) eqn:E1.\n              { destruct (find_lookup x e2) eqn:E2.\n                { destruct (find_lookup x e2) eqn:E2.\n                  { destruct (find_lookup x e1) eqn:E1.\n                    { destruct (find_lookup x e2) eqn:E2.\n                      { destruct (find_lookup x e2) eqn:E1.\n                      { destructQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (find_leaf_same _ _ H). rewrite H1.\n  destruct (x == k).\n  - auto.\n  - rewrite <- (find_leaf_same _ _ H).\n    destruct (k == k).\n    + subst. auto.\n    + rewrite <- (find_leaf_same _ _ H).\n      auto.\n    + rewrite <- (find_leaf_same _ _ H).\n      auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros.\n  assert (k = 0 -> exists k, e1 = Some a /\\ x = Some a).\n  {\n    intros.\n    destruct H0 as [k [Hk]].\n    exists k; auto.\n    apply (H k). }\n  destruct (H k) as [Hk].\n  exists k; auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros A e1 e2 k x a k H.\n  pose proof (H _ _ _ _ _ H).\n  destruct (H0 _ _ H0).\n  destruct (H0 _ _ H1).\n  destruct (H1 _ _ H2).\n  destruct (H2 _ _ H0).\n  destruct (H1 _ _ H2).\n  destruct (H1 _ _ H3).\n  destruct (H2 _ _ H3).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  destruct (H2 _ _ H4).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  simpl in H1.\n  destruct (H1 _ _ H2).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  simpl in H1.\n  destruct (H1 _ _ H2).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  simpl in H1.\n  destruct (H1 _ _ H1).\n  simpl in HQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. rewrite <- (open_assoc H0 k) by auto. auto.\nQed.",
                    "Lemma agree_below: forall A (e1 e2 : env A) x a k, lookup x e1 = Some a -> x < k -> agree e1 e2 k -> lookup x e2 = Some a.\nProof.\n  intros. unfold agree.\n  destruct (find_error e1) eqn:E; try discriminate.\n  destruct (find_error e2) eqn:E1; try discriminate.\n  - destruct (find_error e2) eqn:E2; try discriminate.\n    subst. rewrite find_error_find; auto.\n    destruct (find_error e3) eqn:E1; try discriminate.\n    rewrite find_error_find; auto.\n  - destruct (find_error e3) eqn:E2; try discriminate.\n    subst. rewrite find_error_find; auto.\n  - destruct (find_error e2) eqn:E1; try discriminate.\n    subst. rewrite find_error_find; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ". mymax.\n  erewrite IHx by reflexivity. mymax.\nQed.\n\n(* This should be the usual case. *)\n\nLemma length_insert:\n  forall A x k km1 o (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\n",
                "context_tokens": 708,
                "proof_start_offset": 22183,
                "proof_end_offset": 22313,
                "proof": "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. unfold agree.\n  destruct e.\n  reflexivity.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. unfold agree.\n  apply identity_unit_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  destruct e; simpl; auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. unfold agree.\n  unfold unit_lookup, get.\n  destruct (eq_dec x 0).\n  + subst.\n    rewrite get_set_same.\n    destruct (eq_dec x 0).\n    + subst.\n      destruct (eq_dec x 0).\n      * subst. rewrite get_set_same.\n        simpl. rewrite get_set_same.\n        simpl. rewrite get_set_same. auto.\n        auto.\n    + destruct (eq_dec x 0).\n      * subst. rewrite get_set_same. auto.\n        auto.\n        auto.\n  + destruct (eq_dec x 0).\n    + subst. rewrite get_set_same. auto.\n    + destruct (eq_dec x 0).\n      * subst. rewrite get_set_same. auto.\n      * rewrite get_set_same. auto.\n      * rewrite get_set_same. auto.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  unfold identity, get, set.\n  apply f_equal.\n  apply proof_irr.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros.\n  apply identity_unit.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. rewrite identity_unit_left. apply identity_unit_left.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. apply identity_unit_right.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. apply identity_unit.\nQed.",
                    "Lemma agree_empty_left: forall A (e : env A), agree (@empty _) e 0.\nProof.\n  intros. unfold agree.\n  rewrite <- (same_empty_right (id, e)).\n  apply identity_unit.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " (e : env A),\n  length e <= km1 ->\n  km1 <= k - 1 ->\n  x < k ->\n  length (raw_insert x o e) <= k.\nProof.\n  intros. erewrite length_insert_general by reflexivity. mymax.\nQed.\n\n(* Pain, pain. *)\n\nLemma length_insert_reverse_1:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  x < k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n",
                "context_tokens": 709,
                "proof_start_offset": 22315,
                "proof_end_offset": 22446,
                "proof": "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\nunfold agree.\nintros.\nelimtype False.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  intros. unfold agree. apply identity_unit.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.",
                    "Lemma agree_empty_right: forall A (e : env A), agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "te length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_reverse_2:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k + 1 ->\n  length e <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\nLemma length_insert_independent:\n  forall A (e : env A) k x a,\n  length (insert x a e) <= k ->\n  forall y o,\n  y < k ->\n  length (raw_insert y o e) <= k.\nProof.\n  intros. erewrite length_insert_general in * by reflexivity. mymax.\nQed.\n\n(* Applying a transformation to an environment does not affect its length. *)\n\nLemma length_map_general:\n  forall A B (f : A -> B) (e : env A),\n  length (map f e) = length e.\nProof.\n  induction e as [| [|] ]; simpl; intros; congruence.\nQed.\n\nLemma length_map:\n  forall A B (f : A -> B) (e : env A) k,\n  length e <= k ->\n  length (map f e) <= k.\nProof.\n  intros. rewrite length_map_general. assumption.\nQed.\n\nHint Resolve length_empty length_insert length_map : length.\n\nHint Resolve length_insert length_map : construction_closed.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\n",
                "context_tokens": 668,
                "proof_start_offset": 22562,
                "proof_end_offset": 22977,
                "proof": "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\nunfold agree.\ndo 8 intro.\nintros n ?.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; do 2 lookup_insert; eauto with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. rewrite agree_equation.\n  destruct (zlt k 0).\n  rewrite (zlt_succ_eq k 0).\n  rewrite <- IHl. rewrite <- (add_0_r (k+1)).\n  apply add_lt_reg_r with k.\n  omega.\n  omega.\n  omega.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct e1; simpl.\n  auto.\n  rewrite <- (same_involutive l) at 1.\n  rewrite <- H.\n  rewrite <- (same_involutive l) at 1. rewrite <- H.\n  auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. rewrite <- (same_undef_notin e1) by auto.\n  apply agree_keys_norepet_elements_elements_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_norepet_keys_disjoint.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  rewrite agree_alt.\n  apply eqm_trans with (k + 1 - 1 - 1).\n    apply eqm_add_distr_r. apply eqm_add_distr_r.\n  apply eqm_add_distr_r.\n  apply eqm_add_distr_l.\n  apply eqm_trans with (k + 1 - 1).\n    apply eqm_add_distr_r. apply eqm_add_distr_r.\n  apply eqm_add_distr_l.\n  apply eqm_trans with (k + 1 - 1).\n    apply eqm_add_distr_l. apply eqm_add_distr_r.\n  apply eqm_add_distr_r.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  destruct H as [x [k [H1 H2]].\n  assert (x < k + 1).\n  { rewrite H1, H2. apply H1. auto. }\n  rewrite <- H1.\n  rewrite <- H2.\n  rewrite <- H1.\n  apply H2.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. unfold agree.\n  set (k' := fst (fst x)).\n  set (k'' := fst (snd x)).\n  set (k'' := fst (snd x)).\n  set (k'' := snd (snd x)).\n  set (k'' := snd (snd x)).\n  set (k'' := fst (snd x)).\n  set (k'' := snd (snd x)).\n  assert (fst (fst (snd x)) = snd (snd x)).\n  { unfold k'' in H. rewrite <- H. auto. }\n  rewrite H. auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. unfold agree, raw_insert.\n  destruct (x - k) eqn:E.\n  + rewrite e. auto.\n  + rewrite e1. auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. unfold agree. rewrite! PTree.gempty.\n  destruct (peq x x).\n  apply env_gss. apply env_gss.\n  apply env_gso. apply env_gso. apply env_gso. apply env_gss. apply env_gso. apply env_gso. auto.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros. rewrite <-!same_insert_equiv.\n  apply agree_compat.\nQed.",
                    "Lemma agree_insert: forall A (e1 e2 : env A) k, agree e1 e2 k -> forall x o, x <= k -> agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  intros.\n  generalize (REC (REC e1 e2) (REC e1 e2)).\n  induction e1; simpl; intros.\n  auto.\n  destruct H0.\n  subst x0.\n  replace (k - 1) with (k - 1) by omega. auto.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "---------------------------------------------------------------------- *)\n\n(* The definitions and properties that follow should be independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  ",
                "context_tokens": 692,
                "proof_start_offset": 23694,
                "proof_end_offset": 23786,
                "proof": "Lemma osub_None: forall o, osub o None.\nProof.\nunfold osub.\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o.\n    intro H.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o.\n    destruct o0.\n    destruct o.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0. destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0.\n    destruct o0. destruct o0.\n    destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destruct o0. destruct o0.\n    destructQed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros.\n    unfold osub.\n    apply sub_symmetric.\n    apply sub_reflexive.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros. destruct o; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros. destruct o. auto. destruct o. auto. destruct o. auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros. unfold osub. destruct o; try contradiction; simpl; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intro. destruct (o1 o2). auto.\n    destruct (o1 o1). destruct (o2 o2). destruct (o3 o3).\n    simpl; intuition.\n    destruct H0; auto.\n    destruct H0; auto.\n    destruct H0; auto.\n    destruct H0; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o.\n    induction o; simpl; auto.\n    exists a1; split; auto.\n    destruct (o1 o0); split; auto.\n    destruct (o2 o1); split; auto.\n    destruct (o2 o2); split; auto.\n    destruct (o2 o3); split; auto.\n    destruct (o2 o3); split; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    unfold osub. intros. destruct o. left. apply H.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intro.\n    unfold osub.\n    destruct o; simpl; auto.\n  Qed.",
                    "Lemma osub_None: forall o, osub o None.\n  Proof.\n    intros o. split.\n    - intros [a1 a2]. exists a1; exists a2; auto.\n    - intros [a1 a2]. exists a1; exists a2; auto.\n    - intros [a1 a2]. exists a1; exists a2; auto.\n    - intros [a1 a2]. exists a1; exists a2; auto.\n    - intros [a1 a2]. exists a2; auto.\n    - intros [a1 a2]. exists a2; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " independent of the\n   details of the definitions of [empty], [lookup], [insert], and [map]. *)\n\nOpaque empty lookup raw_insert map.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  ",
                "context_tokens": 707,
                "proof_start_offset": 23790,
                "proof_end_offset": 23970,
                "proof": "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\nProof.\nunfold osub.\nintros ? ? ? ? h.\ninjection h; clear h; intro; subst; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. destruct H.\n    exists a1. destruct H.\n    subst.\n    split.\n    apply H.\n    unfold retrub.\n    destruct H0.\n    subst.\n    apply H.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold seub, retr.\n    destruct o; simpl; eauto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold reub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. destruct a1; destruct a2; destruct a3; destruct a4; try congruence.\n    apply trub_None.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. destruct a1. destruct a2. destruct a1.\n    destruct H. destruct H. destruct H.\n    exists a1. destruct H0.\n    left. exists x. auto.\n    right. exists x. auto.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold trub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_Some_Some: forall a1 a2, sub a1 a2 -> osub (Some a1) (Some a2).\n  Proof.\n    intros. unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "----------------------------------------- *)\n\n(* A definition of when two environments agree up to length [k]. *)\n\nDefinition agree A (e1 e2 : env A) (k : nat) :=\n  forall x,\n  x < k ->\n  lookup x e1 = lookup x e2.\n\n(* A simple consequence of the definition. *)\n\nLemma agree_below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  ",
                "context_tokens": 738,
                "proof_start_offset": 23974,
                "proof_end_offset": 24170,
                "proof": "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\nProof.\nunfold osub.\nintros ? h.\ngeneralize (h _ eq_refl).\nclear h.\nintros [ a1 [ ? ? ]].\ncongruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    intros a1 a2.\n    destruct a2.\n    - left; auto.\n    - right; auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros [|] H.\n    case (eq_nat_dec x n); [case (eq_nat_dec x n); intro H1; auto |].\n    destruct H.\n    injection H; clear H; intro.\n    destruct H.\n    case (eq_nat_dec x n); [case (eq_nat_dec x n); intro H2; auto|].\n    destruct H1.\n    case (eq_nat_dec x n); [case (eq_nat_dec x n); intro H2; auto |].\n    destruct H2.\n    injection H1; intro.\n    destruct H1.\n    elimtype False; omega.\n    elimtype False; omega.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    intros a2 H.\n    destruct (constructive_unique _ _ _ H); clear H; intro; subst; eauto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. congruence.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros [|] [|]; eauto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros [|] [|]; simpl. apply trub_Some_Some; auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros [=] h.\n    rewrite <- h.\n    rewrite <- h.\n    rewrite <- h.\n    rewrite <- h.\n    auto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros'), h. injection h; clear h; intro; subst; eauto.\n  Qed.",
                    "Lemma osub_None_Some: forall a2, osub None (Some a2) -> False.\n  Proof.\n    unfold osub. intros [|] H.\n    destruct (proj1_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig _))))))).\n    unfold osub. congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "below:\n  forall A (e1 e2 : env A) x a k,\n  lookup x e1 = Some a ->\n  x < k ->\n  agree e1 e2 k ->\n  lookup x e2 = Some a.\nProof.\n  do 6 intro. intros hlookup??.\n  rewrite <- hlookup. symmetry.\n  eauto.\nQed.\n\n(* The empty environment agrees with every environment up to length [0]. *)\n\nLemma agree_empty_left:\n  forall A (e : env A),\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 24174,
                "proof_end_offset": 24381,
                "proof": "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\nProof.\nintros.\ndestruct o1.\neauto.\nelimtype False.\neauto using osub_None_Some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros.\n    destruct (h _ eq_refl).\n    left; auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct a2; simpl in *; intuition.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. generalize (h _ eq_refl). clear h. intros [a1 [a2 [? [??]]]].\n    exists a1; split.\n    generalize (h _ eq_refl). clear h. intros [a1 [a2 [? [??]]]].\n    congruence.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros.\n    generalize (h _ eq_refl). clear h. intros [ a1 [??]?].\n    destruct (h _ eq_refl).\n    exists a1.\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a1.\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a1.\n    destruct (h _ eq_refl).\n    exists a1.\n    destruct (h _ eq_refl).\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a1.\n    destruct (h _ eq_refl).\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    destruct (h _ eq_refl).\n    exists a2.\n    destruct (h _ eq_refl).\n    exists a1.\n    destruct (h _ eq_reflQed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros.\n    generalize (h _ eq_refl). clear h. intros [a1 [a2 [? [??]]]].\n    exists (a1, a2).\n    apply (h _ eq_refl).\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros????? H.\n    generalize (h _ eq_refl). clear h. intros [ a1 [??]?.\n    exists a1.\n    split; auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros.\n    generalize (h _ eq_refl). clear h. intros [ a1 [a2 [? [??]]]].\n    generalize (h _ eq_refl). clear h. intros [ a2 [a3 [? [??]]]].\n    exists a2; split; auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    unfold osub. intros???.\n    generalize (h _ eq_refl). clear h. intros [ a1 [??]].\n    destruct (h _ eq_refl).\n    exists a1, a2.\n    split; auto.\n    exists a2, a1, a2.\n    split; auto.\n    intros [??].\n    destruct (h _ eq_refl).\n    exists a2, a3.\n    split; auto.\n    apply osub_Some_inversion.\n    intros [??].\n    destruct (h _ eq_refl).\n    exists a1, a2.\n    split; auto.\n    destruct (h _ eq_refl).\n    exists a1, a2.\n    split; auto.\n    apply osub_None_Some; auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct (h _ eq_refl). clear h. intros [a1 [a2 [? [??]]]].\n    exists a1; exists a2.\n    split.\n    apply sub_same. auto.\n  Qed.",
                    "Lemma osub_Some_inversion: forall o1 a2, osub o1 (Some a2) -> exists a1, o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros.\n    generalize (h _ eq_refl). clear h. intros [ a1 [??]?].\n    congruence.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n  agree (@empty _) e 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\nLemma agree_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  ",
                "context_tokens": 744,
                "proof_start_offset": 24601,
                "proof_end_offset": 24690,
                "proof": "Lemma osub_reflexive: forall o, osub o o.\nProof.\nunfold osub.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intro.\n    apply (unub_unit (exp x e1)).\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold club. intros. red. auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros. rewrite empty_empty_right.\n    apply H.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros. apply (update_push e1).\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros. unfold parmove. rewrite H. reflexivity.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros. unfold osub. apply cont_push. auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold reos. intros. rewrite mk_ex_is_ex_is_ex. auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    intros. unfold osub.\n    apply step_congruence.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros. destruct o. auto.\n  Qed.",
                    "Lemma osub_reflexive: forall o, osub o o.\n  Proof.\n    unfold osub. intros.\n    destruct o; simpl; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "_empty_right:\n  forall A (e : env A),\n  agree e (@empty _) 0.\nProof.\n  unfold agree. intros. elimtype False. omega.\nQed.\n\n(* If two environments that agree up to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  ",
                "context_tokens": 745,
                "proof_start_offset": 24694,
                "proof_end_offset": 24813,
                "proof": "Lemma subsume_reflexive: forall e, subsume e e.\nProof.\nunfold subsume.\neauto using osub_reflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfoldMessage, well_founded. intros.\n    destruct e. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfoldcalc,Fix. intros.\n    apply (proj1 H).\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold Take. intros. destruct e; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold Take. intros.\n    apply (e _ eq_refl).\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold Please, initial_function. intros.\n    destruct e; simpl.\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (e x).\n    destruct (Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros. destruct e; simpl; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros. unfold Take.is_wf, mk_wf.\n    intros.\n    rewrite e. auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold triv. intros. eauto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    intros. destruct e; simpl; intros; auto.\n  Qed.",
                    "Lemma subsume_reflexive: forall e, subsume e e.\n  Proof.\n    unfold cstate, normal. intros.\n    destruct e as [o r].\n    apply (unub_refl (exp x e)).\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " to [k] are extended with a new variable,\n   then they agree up to [k+1]. *)\n\nLemma agree_insert:\n  forall A (e1 e2 : env A) k,\n  agree e1 e2 k ->\n  forall x o,\n  x <= k ->\n  agree (raw_insert x o e1) (raw_insert x o e2) (1 + k).\nProof.\n  unfold agree. do 8 intro. intros n?.\n  (* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  ",
                "context_tokens": 729,
                "proof_start_offset": 24817,
                "proof_end_offset": 25084,
                "proof": "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\nProof.\nunfold osub.\nintros ? ? ? hs1 hs2 a3 h3.\ngeneralize (hs2 _ h3); intros [ a2 [ h2 ? ]].\ngeneralize (hs1 _ h2); intros [ a1 [ h1 ? ]].\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros.\n    destruct o1. eauto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros. destruct o1. eauto. apply osub_push.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold osub. eauto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold rfos; eauto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold inangleub. eauto using osub_trans.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold rfos. eauto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold phos. intros.\n    destruct o1. eauto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros. destruct o1. eauto. eauto.\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    unfold phub. intros. apply (H _ eq_refl).\n  Qed.",
                    "Lemma osub_transitive: forall o1 o2 o3, osub o1 o2 -> osub o2 o3 -> osub o1 o3.\n  Proof.\n    intros.\n    exists (fun x => (trub (trub (o2 x)) x) (trub (o2 x)) (trub (o2 x)) (trub (o2 x)) (trub (o2 x)) (trub (o2 x)).\n    intros x.\n    apply (trub_trans (trub (o2 x)) (trub (o2 x)) (trub (o2 x)) (trub (o2 x)).\n    intros x.\n    apply (trub_trans (trub (o2 x)) (trub (o2 x)) (trub (o2 x)) (trub (o2 x))).\n    intros x.\n    apply (trub_trans (trub (o2 x) (o2) (o2 x)) (trub (o2 x)).\n    intros x.\n    apply (trub_trans (trub (o2 x)) (trub (o2 x)) (trub (o2 x)) (trub (o2 x)).\n    intros x.\n    apply (trub_trans (trub (o2 x)) (trub (o2 xQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "* Reason by cases: [x = n], [x < n], [x > n]. *)\n  case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n  (* In each case, [lookup_insert] simplifies the goal. *)\n  do 2 lookup_insert; eauto with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  ",
                "context_tokens": 730,
                "proof_start_offset": 25088,
                "proof_end_offset": 25260,
                "proof": "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\nProof.\nunfold subsume.\neauto using osub_transitive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold Take. intros????? Ht1 Ht2.\n    generalize (e1 e2); generalize (e2 e3); clear e1 e2.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e2 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e2 e3.\n    generalize (e2 e3); clear e1 e3.\n    generalize (e2 e3); clear e2 e3.\n    generalize (e2 e3); clear e2 e3.\n    generalize (e2 e3); clear e3 e3.\n    generalize (e2 e3); clear e1 e3Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfoldcalc_domain. intros.\n    destruct e1.\n    generalize (ts2 _ h1); intros [ a1 [ h2].\n    generalize (ts2 _ h2); intros [ a2 [ h2].\n    generalize (ts2 _ h3); intros [ a3 [ h3].\n    generalize (ts3 _ h3); intros [ a3 [ h3].\n    generalize (ts3 _ h3); intros [ a3 [ h3].\n    generalize (ts3 _ h3); intros [ a3 [ h3].\n    generalize (ts3 _ h3); intros [ a4 h4].\n    generalize (ts3 _ h3); intros [ a4 h4].\n    generalize (ts3 _ h4); intros [ a4 h5].\n    generalize (ts3 _ h4); intros [ a5 h5].\n    generalize (ts3 _ h5); intros [ a5 h6].\n    generalize (ts3 _ h6); intros [ a5 h6].\n    generalize (ts3 _ h6); intros [ a6 h6].\n    generalize (ts3 _ h6); intros [ a6 h6].\n    generalize (ts3 _ h6); introsQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold Take. eauto with typeclass_instances.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfoldcalc. intros???? h1 h2 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h1] h3.\n    generalize (projT2 _ h3); intros [ a2 [ h2] h3.\n    change (projT1 _ h3) with (projT2 _ h1); auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    intros.\n    generalize (tp_morph1 e2); clear (t1, t2).\n    destruct (t1!t2).\n    destruct (t2!t1).\n    destruct (t2!t1).\n    destruct (t2!t1).\n    destruct (t2!t2).\n    destruct (t2!t1).\n    destruct (t2!t2).\n    destruct (t2!t1).\n    destruct (t2!t1).\n    destruct (t2!t2).\n    destruct (t3!t1).\n    destruct (t3!t1).\n    destruct (t2!t1).\n    destruct (t2!t1).\n    destruct (t2!t1).\n    destruct (t2!t2).\n    destruct (t3!t1).\n    destruct (t3!t2).\n    destruct (t3!t1).\n    destruct (t3!t1).\n    destruct (t2!t1).\n    destruct (t3!t1).\n    destruct (t2!t2).\n    destruct (t3!t1).\n    destruct (t1!t2).\n    destruct (tQed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold raw.\n    intros.\n    generalize (e1 e2); clear e1.\n    generalize (e2 e3); clear e1.\n    destruct (e2 e3); [inversion e3 | inversion e3 ].\n    auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    unfold cstate2. intros.\n    apply (ex2_implies_unique _ _ _ _ _ H H0).\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    unfold classical,constructive in *; intros.\n    apply (e2 _ _ e3); auto.\n  Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros.\n    generalize (e1 e2); clear e1 e2; clear e2.\n    generalize (e1 e2); clear e1 e3.\n    generalize (e1 e3); clear e1 e3.\n    generalize (e1 e3); clear e1 e3.\n    generalize (e1 e3); clear e1 e3.\n    intros [ a1 [ h1] h2.\n    destruct (h1 h2 h3) as [a2 [ h2] h3].\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e1 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e1 e3); clear e3.\n    generalize (e2 e3); clear e3.\n    generalize (e2 e3); clear e3Qed.",
                    "Lemma subsume_transitive: forall e1 e2 e3, subsume e1 e2 -> subsume e2 e3 -> subsume e1 e3.\n  Proof.\n    intros. unfold cstate2. apply (morphub_trans (eval e1 e2) (eval e2 e3) (eval e1 e3) (eval e3 e4)).\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "with omega.\nQed.\n\nHint Resolve defined_implies_below_length agree_below agree_empty_left\nagree_empty_right agree_insert : agree.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* A definition of when an environment subsumes another, up to a notion of\n   subsumption on environment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  ",
                "context_tokens": 722,
                "proof_start_offset": 25323,
                "proof_end_offset": 25471,
                "proof": "Lemma subsume_empty: forall e, subsume e (@empty _).\nProof.\nunfold subsume.\nintros.\nrewrite lookup_empty_None.\napply osub_None.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold Non_empty. intros.\n    generalize (e _ eq_refl). clear e.\n    intros.\n    generalize (e _ eq_refl). clear e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalize e.\n    generalizeQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    destruct e.\n    apply (is_empty_1 e).\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros. unfold tarski. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros. apply (well_founded_induction_type).\n    intros.Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold Term.\n    intros.\n    apply normal_empty.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold raw. unfold well_founded; intros.\n    apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros.\n    generalize (e _ eq_refl).\n    destruct e.\n    auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold raw. eauto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    unfold raw; auto.\n  Qed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros. unfold raw.\n    intros e H.\n    generalize (e e H); clear e H.\n    generalize (e e H); clear e H.\n    generalize (e e H); clear e H.\n    induction e.\n    intros e H0.\n    inversion H0.\n    intros e H1.\n    inversion H1.\n    intros e H2.\n    inversion H2.\n    intros e H3.\n    inversion H3.\n    intros e H4.\n    inversion H4.\n    intros e H4.\n    inversion H4.\n    intros e H5.\n    inversion H5.\n    intros e H5.\n    inversion H6.\n    intros e H6.\n    inversion H6.\n    intros e H6.\n    inversion H7.\n    intros e H7.\n    inversion H8.\n    intros e0 H8.\n    inversion H9.\n    intros e H7.\n    inversion H9.\n    intros e H8.\n    inversion H9.\n    intros e0 H8.\n    inversion H9.\n    intros e0 H8.\n    inversion H8.\n    intros e0 H9.\n    inversion H8.\n    intros e0 H8.\n    inversion H8.\n    introsQed.",
                    "Lemma subsume_empty: forall e, subsume e (@empty _).\n  Proof.\n    intros. apply (Fix_empty_1 _ _ _ _ _ _ _ _ h1 h2).\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "nment entries. *)\n\nSection Subsume.\n\n  Variable A : Type.\n\n  Variable sub : A -> A -> Prop.\n\n  Variable sub_reflexive:\n    forall a,\n    sub a a.\n\n  Variable sub_transitive:\n    forall a1 a2 a3,\n    sub a1 a2 ->\n    sub a2 a3 ->\n    sub a1 a3.\n\n  (* Subsumption is first extended to options. *)\n\n  Definition osub (o1 o2 : option A) :=\n    forall a2,\n    o2 = Some a2 ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  ",
                "context_tokens": 714,
                "proof_start_offset": 25554,
                "proof_end_offset": 25976,
                "proof": "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\nProof.\nunfold subsume.\ndo 7 intro.\nintros n.\ncase (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros; repeat lookup_insert; eauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros. unfold raw_insert.\n    destruct e1.\n    generalize (rf_empty_nil _ _ _ _ H0); intros.\n    apply (rf_empty_1 _ _ _ H0); auto.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert; intros. rewrite make_insert_empty_nil. apply mk_insert.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    intros. apply (nodeosub_nil _ _ _ _ _ _ H H0 H1).\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert; intros.\n    assert (H1: exists e1, pre e2 e1 /\\ pre e2 e3).\n    { unfold raw_insert; intros.\n      do 2 eexists; eauto. }\n    destruct H1 as [e1 [e2 [? [??]]]].\n    destruct H2 as [e3 [e4 [? [??]]]].\n    exists e3.\n    apply (node_set_e1 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e1 e4).\n    apply (node_set_e2 e3).\n    apply (node_set_e1 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e4).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e3).\n    apply (node_set_e2 e3).\n    apply (node_Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert. intros. rewrite <- e1. apply e2.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert. intros. rewrite bind_empty_nil_end. apply He.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert.\n    intros.\n    apply (rf_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_empty (update_update (update_empty (update_empty (update_empty (update_update (update_empty (update_empty (updateQed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert.\n    intros.\n    rewrite insert_empty_nil. apply raw_insert_empty.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert. intros.\n    rewrite H.\n    auto.\n  Qed.",
                    "Lemma subsume_insert: forall e1 e2, subsume e1 e2 -> forall x o1 o2, osub o1 o2 -> subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold raw_insert. intros.\n    rewrite alloc_empty_None. apply seub_nil.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": ".\n\n  Lemma osub_None:\n    forall o,\n    osub o None.\n  Proof.\n    unfold osub. congruence.\n  Qed.\n\n  Lemma osub_Some_Some:\n    forall a1 a2,\n    sub a1 a2 ->\n    osub (Some a1) (Some a2).\n  Proof.\n    unfold osub. intros???? h. injection h; clear h; intro; subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  ",
                "context_tokens": 726,
                "proof_start_offset": 25980,
                "proof_end_offset": 26219,
                "proof": "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\nProof.\ndo 3 intro.\nintros h1 h2.\nintro n.\ndestruct n.\neauto.\ndo 2 rewrite lookup_successor.\neauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold coqtop_insert.\n    intros. rewrite bind_empty_None. apply trub_nil.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold custom. do 6 intro.\n    apply (mkub_identity _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    intros.\n    unfold raw. do 6 intro.\n    (* We need to use this case, it does not be done. *)\n    repeat lookup_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold relativ. do 6 intro.\n    destruct o1.\n    destruct o2.\n    simpl.\n    simpl.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n    apply H.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold raw. do 7 intro.\n    apply raw_lookup_lookup_dep.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold raw. do 6 intro.\n    rewrite bind_empty_nil_nil. apply rfub_empty.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold formal. do 6 intro.\n    unfold raw_insert.\n    rewrite <- insert_leaf_leaf.\n    applyscub_trans with (lb:=lb); auto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold raw_insert. intros.\n    repeat lookup_insert; eauto.\n  Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold custom. do 5 intro.\n    apply (peub_reflexive _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma subsume_cons: forall o e1 e2, osub o (lookup 0 e2) -> subsume e1 (tl e2) -> subsume (o :: e1) e2.\n  Proof.\n    unfold locals. do 3 intro.\n    apply mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mk.mkQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " subst; eauto.\n  Qed.\n\n  Lemma osub_None_Some:\n    forall a2,\n    osub None (Some a2) ->\n    False.\n  Proof.\n    unfold osub. intros? h.\n    generalize (h _ eq_refl). clear h. intros [ a1 [?? ]].\n    congruence.\n  Qed.\n\n  Lemma osub_Some_inversion:\n    forall o1 a2,\n    osub o1 (Some a2) ->\n    exists a1,\n    o1 = Some a1 /\\ sub a1 a2.\n  Proof.\n    intros. destruct o1. eauto. elimtype False. eauto using osub_None_Some.\n  Qed.\n\n  (* Then, it is extended pointwise to environments. *)\n\n  Definition subsume (e1 e2 : env A) :=\n    forall x,\n    osub (lookup x e1) (lookup x e2).\n\n  (* Subsumption of environments is reflexive and transitive. *)\n\n  Lemma osub_reflexive:\n    forall o,\n    osub o o.\n  Proof.\n    unfold osub. eauto.\n  Qed.\n\n  Lemma subsume_reflexive:\n    forall e,\n    subsume e e.\n  Proof.\n    unfold subsume. eauto using osub_reflexive.\n  Qed.\n\n  Lemma osub_transitive:\n    forall o1 o2 o3,\n    osub o1 o2 ->\n    osub o2 o3 ->\n    osub o1 o3.\n  Proof.\n    unfold osub. intros??? hs1 hs2 a3 h3.\n    generalize (hs2 _ h3); intros [ a2 [ h2? ]].\n    generalize (hs1 _ h2); intros [ a1 [ h1? ]].\n    eauto.\n  Qed.\n\n  Lemma subsume_transitive:\n    forall e1 e2 e3,\n    subsume e1 e2 ->\n    subsume e2 e3 ->\n    subsume e1 e3.\n  Proof.\n    unfold subsume. eauto using osub_transitive.\n  Qed.\n\n  (* Every environment subsumes the empty environment. *)\n\n  Lemma subsume_empty:\n    forall e,\n    subsume e (@empty _).\n  Proof.\n    unfold subsume. intros. rewrite lookup_empty_None. apply osub_None.\n  Qed.\n\n  (* Extending two environments with a new variable preserves subsumption. *)\n\n  Lemma subsume_insert:\n    forall e1 e2,\n    subsume e1 e2 ->\n    forall x o1 o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  ",
                "context_tokens": 719,
                "proof_start_offset": 26223,
                "proof_end_offset": 26458,
                "proof": "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\nProof.\ndo 4 intro.\nintro h.\nsplit.\neapply (h 0).\nintro n.\neapply (h (1 + n)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. do 6 intro.\n    case (le_gt_dec o1 o2); [ case (eq_nat_dec o1 o2);\n    intros; destruct n; simpl in *; try tauto.\n    repeat lookup_insert.\n    applyscub_leaf.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold raw. do 3 intro. intros n.\n    destruct n.\n    auto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    intros. intros. unfold relativ. do 6 intro.\n    destruct (o1!o2) eqn:H; auto.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold raw. do 6 intro. intros.\n    split.\n    + destruct 1.\n      * destruct 2.\n        destruct (In_dec _ _ H).\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H1.\n        apply H1.\n      * destruct 2.\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H2.\n      * destruct 2.\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H1.\n      * destruct 2.\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H1.\n      * destruct 2.\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H1.\n      * destruct 2.\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H1.\n      * destruct 2.\n        destruct (In_dec _ _ H0).\n        subst.\n        rewrite H0.\n        apply H1.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold Categories. do 6 intro.\n    rewrite insert_conj. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros.\n    rewrite insert_conj. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewrite insert_conj. rewrite insert_conj. rewrite insert_conj.\n    intros. rewriteQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. do 5 intro.\n    generalize (ok e1 e2); intros.\n    generalize (ok e2 e3); intros.\n    generalize (ok e3 e4); intros.\n    generalize (ok e3 e4); intros.\n    generalize (ok e4 e4); intros.\n    generalize (ok e4 e5); intros.\n    generalize (ok e4 e5 e6 e7 e8 e9 e9 e10 e10 e11 e12 e13 H14 H15 H16 H17 H17 H17 H18 H19 H19 H19 H19 H21 H22 H22 H22 H22 H23 H23 H23 H31 H23 H23 H23 H30 H31 H33 H34 H34 H35 H36 H35 H36 H37 H37 H37 H36 H37 H38 H37 H37 H35 H37 H36 H35 H37 H36 H37 H41 H41 H44 H43 H41 H41 H44 H41 H42 H43 H44 H44 H44 H44 H45 H46 H47 H49 H49 H49 H49 H49 H49 H49 H49 H49 H49 H49 HQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold coqc_cnf. intros.\n    generalize (rf_insert_in_ex _ _ _ _ _ _ _ _ H0); intros.\n    split; intros.\n    apply (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (projQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold custom. do 7 intro. intros n.\n    (* UnMorphism by hypothesis: [x = n], [x >= n], [x < n]. *)\n    case (le_gt_dec x n); [case (eq_nat_dec x n) | intros; [auto | ].\n    rewrite (proof_irrelevance _ _ _ _ H0).\n    rewrite (proof_irrelevance _ _ _ H1).\n    destruct (eq_nat_dec x n); [auto | ].\n    rewrite (proof_irrelevance _ _ _ H1).\n    destruct (eq_nat_dec x n); [auto | ].\n    rewrite (proof_irrelevance _ _ _ H1).\n    destruct (eq_nat_dec x n); [auto | ].\n    rewrite (proof_irrelevance _ _ _ H1).\n    destruct (eq_nat_dec x n); [auto | ].\n    rewrite (proof_irrelevance _ _ _ H1).\n    destruct (eq_nat_dec x n); [auto | ].\n    rewrite (proof_irrelevance _ _ _ H1).\n    destruct (eq_nat_dec x n); [auto | ].\n    rewrite (proof_irrelevance _ _ H2).\n    destruct (eqQed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfold subsume. do 6 intro. intros. simpl. rewrite union_empty_None. apply landL1.\n  Qed.",
                    "Lemma subsume_cons_cons_inversion: forall o1 o2 e1 e2, subsume (o1 :: e1) (o2 :: e2) -> osub o1 o2 /\\ subsume e1 e2.\n  Proof.\n    unfolddifferent, Software_eq. simpl.\n    unfold%:~_eq. simpl.\n    unfold%:~_eq. simpl.\n    unfold'_eq.\n    simpl.\n    rewrite <- insert_empty_end.\n    apply build_insert; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " o2,\n    osub o1 o2 ->\n    subsume (raw_insert x o1 e1) (raw_insert x o2 e2).\n  Proof.\n    unfold subsume. do 7 intro. intros n.\n    (* Reason by cases: [x = n], [x < n], [x > n]. *)\n    case (le_gt_dec x n); [ case (eq_nat_dec x n) | ]; intros;\n    (* In each case, [lookup_insert] simplifies the goal. *)\n    repeat lookup_insert; eauto.\n  Qed.\n\n  Lemma subsume_cons:\n    forall o e1 e2,\n    osub o (lookup 0 e2) ->\n    subsume e1 (tl e2) ->\n    subsume (o :: e1) e2.\n  Proof.\n    do 3 intro. intros h1 h2. intro n. destruct n.\n    eauto.\n    do 2 rewrite lookup_successor. eauto.\n  Qed.\n\n  Lemma subsume_cons_cons_inversion:\n    forall o1 o2 e1 e2,\n    subsume (o1 :: e1) (o2 :: e2) ->\n    osub o1 o2 /\\\n    subsume e1 e2.\n  Proof.\n    do 4 intro. intro h.\n    split.\n    eapply (h 0).\n    intro n. eapply (h (1 + n)).\n  Qed.\n\n  Lemma subsume_insert_inversion:\n    forall e1 x a2 e2,\n    subsume e1 (insert x a2 e2) ->\n    exists f1 a1,\n    e1 = insert x a1 f1 /\\\n    subsume f1 e2 /\\\n    sub a1 a2.\n  Proof.\n    (* Really painful. *)\n    induction e1; simpl; intros.\n    (* Base. *)\n    elimtype False.\n    match goal with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  ",
                "context_tokens": 708,
                "proof_start_offset": 27904,
                "proof_end_offset": 28289,
                "proof": "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\nProof.\nintros ? hf ? ? hs.\nintros ? b2 hlm2.\ngeneralize (lookup_map_some_reverse _ _ _ hlm2); intros [ ? [ hl2 ? ]].\nsubst.\ngeneralize (hs _ _ hl2); intros [ a1 [ ? ? ]].\neauto using lookup_map_some.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    destruct e1.\n    simpl.\n    intros.\n    destruct e2.\n    destruct e2.\n    simpl.\n    intros.\n    destruct e2.\n    (* The proof is true for [f] fails *)\n    specialize (IHe1 e1).\n    destruct e2.\n    (* <- [f1] fails *)\n    specialize (IHe2 e1).\n    destruct IHe1 as [e1 [e2 [e3 [e4 [e5 [f6 [f7 [f7 [f8 [f8 [f9 [f9 [f10 [f10 [f10 [f12 [f13 [f14 [f13 [f14 [f14 [f13 [f14 [f14 [f14 [f14 [f14 [f15 [f14 [f14 [f14 [f14 [f15 [f15 [f14 [f15 [f15 [f14 [f15 [f15 [f14 [f15 [f15 [f15 [f15 [f15 [f15 [f15 [f15 [f14 [f15 [f15 [f15 [f25 [f14 [f25 [f15Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold raw_insert, map.\n    apply (well_founded_induction_type (fun e => (fun e => (fun e => (fun e => e + e)%type)).\n    intros e1 e2.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_App.\n    rewrite map_AppQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    (* Base.map_map_map_map_map *)\n    destruct a1.\n    (* Base.map_map_map_map_map *)\n    destruct a2.\n    (* Base.map_map_map_map_map *)\n    destruct a1.\n    (* Base.map_map_map_map_map_map *)\n    destruct a2.\n    (* Base.map_map_map_map_map_map *)\n    destruct a1.\n    (* Base.map_map_map_map_map_map_map_map *)\n    destruct a2.\n    (* Base.map_map_map_map_map_map *)\n    destruct a1.\n    (* Base.map_map_map_map_map_map_map_map *)\n    destruct a2.\n    (* Base.map_map_map_map_map_map_map_map *)\n    destruct a1.\n    (* Base.map_map_map_map_map_map_map_map *)\n    destruct a1.\n    (* Base.map_map_map_map_map_map *)\n    destruct a2.Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold binary. do 2 intro.\n    destruct e1.\n    (* The case is the same, we can use [f] from [f], [f] and [f] and [f] from [f]. *)\n    repeat lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_in_map.\n    admit. (* The case is the same, but we need to prove [f] from [f] to [f] to [f] in the context. *)\n    repeat lookup_lookup_lookup_lookup_lookup_lookup_lookup_in_map.\n    admit. (* The case is the same, but we don't need to use [f] from [f] to [f] from [f]. *)\n    repeat lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_in_map.\n    admit. (* The case is the same, but should be done *)\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold build_map.\n    repeat lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_lookup_insert_val_lookup_insert_repr_eq.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    unfold raw.\n    change (Fix f (fun a => f a)).\n    apply (mkregular_map (fun a => f a)).\n    intros.\n    rewrite map_compose.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_ext.\n    intros.\n    apply map_Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros.\n    induction e1; simpl; intros.\n    (* Base.map *)\n    destruct a1; simpl in *.\n    (* Base.map *)\n    destruct a2; simpl in *.\n    (* Base.map *)\n    destruct (a1 :: e1); simpl in *.\n    (* Base.map *)\n    destruct (a2 :: e2); simpl in *.\n    (* Base.map *)\n    destruct (a1 :: e2); simpl in *.\n    (* Base.map *)\n    destruct (a1 :: e2); simpl in *.\n    (* Base.map *)\n    destruct (a1 :: e2); simpl in *.\n    (* Base.map *)\n    destruct (a2 :: e3); simpl in *.\n    (* Base.map *)\n    destruct (a3 :: e3); simpl in *.\n    (* Base.map *)\n    destruct (a3 :: e3); simpl in *.\n    (* Base.map *)\n    destruct (a3 :: e4); simpl in *.\n    (* Base.map *)\n    destruct (a1 :: e3); simpl in *.\n    (* Base.map *)\n    destruct (a1 :: e3); simpl in *.\n    (* Base.map *)\n    destruct (a2 :: e3);Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros. induction e1; simpl; intros; auto.\n    (* We are not actually a function that is a function is equivalent to the\n     definition of the domain of the domain of the domain of the\n     domain of the domain. *)\n    apply (f_equal (fun x => f (f x))).\n    apply (g x).\n    simpl.\n    rewrite H.\n    rewrite H.\n    rewrite H.\n    rewrite map_repr_or.\n    rewrite H.\n    apply H.\n  Qed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    unfold well_founded; intros.\n    apply functional_extensionality; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear e; intros.\n    generalize (make_map_inversion e); clear eQed.",
                    "Lemma subsume_map: forall f, (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) -> forall e1 e2, subsume e1 e2 -> subsume (map f e1) (map f e2).\n  Proof.\n    intros. induction e1; simpl; auto.\n    intros.\n    destruct e1; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n    intros.\n    destruct e2; simpl; auto.\n  Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "l with h: subsume nil _ |- _ =>\n      generalize (h x); clear h; intro h;\n      rewrite lookup_insert_bingo in h by reflexivity;\n      rewrite lookup_empty_None in h\n    end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 29118,
                "proof_end_offset": 29198,
                "proof": "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; intros.\n  omega.\n  destruct (X n); [omega|].\n  rewrite <- X; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\ninduction n; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  destruct n; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; intros.\n  simpl.\n  omega.\n  simpl.\n  omega.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  induction n.\n  simpl.\n  rewrite map_app.\n  simpl.\n  intros.\n  simpl.\n  rewrite map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.\n  apply map_app.Qed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  intros.\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nil n).\n  rewrite <- (app_nilQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl; auto.\n  destruct a; auto.\nQed.",
                    "Lemma omega_hint_1: forall n, n <= (n + 1) - 1.\nProof.\n  induction n; simpl.\n  destruct (n + 1); simpl; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "   end.\n    solve [ eauto using osub_None_Some ].\n    (* Step. *)\n    destruct x.\n    (* Case [x = 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_zero in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [ h? ];\n      generalize (osub_Some_inversion h); intros [? [?? ]]; subst\n    end.\n    do 2 eexists.\n    rewrite raw_insert_zero.\n    solve [ eauto ].\n    (* Case [x > 0]. *)\n    match goal with h: subsume _ _ |- _ =>\n      rewrite raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\n",
                "context_tokens": 650,
                "proof_start_offset": 29200,
                "proof_end_offset": 29478,
                "proof": "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\ninduction e2; simpl; intros.\nreplace n with n1 by omega.\nassumption.\neauto using length_insert, omega_hint_1 with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  induction e1; [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].\n  destruct (nth_error e2 n2); [simpl; omega |].\n  destruct (nth_error e1 n2); [simpl; omega |].\n  destruct (nth_error e1 n2); [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].\n  destruct (nth_error e2 n2); [simpl; omega |].\n  destruct (nth_error e2 n2); [simpl; omega |].\n  destruct (nth_error e1 n2); [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].\n  destruct (nth_error e2 n2); [simpl; omega |].\n  destruct (nth_error e2 n2); [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].\n  destruct (nth_error e2 n1); [simpl; omega |].Qed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (length e1) as [ | n1 e2].\n  apply H.\n  omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (app_length e1 e2) as [n1 H1].\n  destruct (app_length e2 e1) as [n2 H2].\n  destruct (app_length e2 e2) as [n3 H3].\n  rewrite app_length in H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  rewrite H3.\n  reflexivity.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct e1 as [ | e1 IH]; simpl in *.\n  destruct e2 as [ | e2 IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n2) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) as [ | e' IH]; [simpl in *; omega |].\n  destruct (n + n1) asQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros.\n  destruct (le_gt_dec n1 n); [left|right].\n  + destruct (le_gt_dec n1 n); [left|right].\n    + destruct (le_gt_dec n1 n); [left|right].\n      + destruct (le_gt_dec n2 n); [left|right].\n        + destruct (le_gt_dec n1 n); [left|right].\n        + destruct (le_gt_dec n2 n); [left|right].\n          + destruct (le_gt_dec n2 n); [left|right].\n          + destruct (le_gt_dec n2 n); [left|right].\n          + destruct (le_gt_dec n2 n); [left|right].\n          + destruct (le_ge_dec n2 n); [left|right].\n          + destruct (le_ge_dec n2 n); [left|right].\n          + destruct (le_ge_dec n2 n); [left|right].\n          + destruct (le_gt_dec n2 n); [left|right].\n          + destruct (le_ge_dec n2 n); [left|rightQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; simpl; intros.\n  omega.\n  destruct e2; simpl.\n  omega.\n  destruct e1; simpl.\n  omega.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; intros.\n  simpl.\n  apply app_nil.\n  rewrite rev_involutive. apply rev_involutive.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  apply (IHemp H).\n  destruct n; auto.\nQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  induction e1; intros.\n  auto.\n  destruct (le_gt_dec n1 n); [omega |].\n  destruct (le_gt_dec n2 n1); [omega |].\n  destruct (le_gt_dec n2 n2); [omega |].\n  destruct (le_gt_dec n1 n2); [omega |].\n  destruct (le_gt_dec n2 n1); [omega |].\n  destruct (le_gt_dec n1 n2); [omega |].\n  destruct (le_gt_dec n2 n2); [omega |].\n  rewrite (H0 n1).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (H0 n1).\n  rewrite (H0 n1).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (H0 n1).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (H0 n1).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (H0 n2).\n  rewrite (HQed.",
                    "Lemma length_concat: forall A (e2 : list A) (e1 : env A) n1 n, length e1 <= n1 -> n1 + length e2 = n -> length (concat e1 e2) <= n.\nProof.\n  intros. omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " raw_insert_successor in h;\n      generalize (subsume_cons_cons_inversion h); clear h; intros [? h ];\n      generalize (IHe1 _ _ _ h); clear IHe1; intros [ f1 [ a1 [? [?? ]]]]; subst\n    end.\n    exists (a :: f1). exists a1.\n    rewrite raw_insert_successor. simpl.\n    split; [ | split ].\n    reflexivity.\n    eauto using subsume_cons.\n    eauto.\n  Qed.\n\n  (* Applying a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\n",
                "context_tokens": 670,
                "proof_start_offset": 29680,
                "proof_end_offset": 29946,
                "proof": "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\ninduction e; simpl; intros.\nreplace n with k by omega.\nassumption.\neauto using agree_insert with omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; intros.\n  simpl. apply H.\n  simpl. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; intros.\n  simpl.\n  assert (k = n) by omega. subst k.\n  simpl. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  rewrite H.\n  destruct (n + S n) eqn:E; auto.\n  rewrite IHl1. rewrite IHl2. rewrite IHl1. rewrite IHl2. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  - auto.\n  - auto.\n  - rewrite (app_comm (n + 1)).\n    rewrite (app_comm (n + 1)).\n    rewrite <- (app_assoc (n + 1)).\n    rewrite (app_comm (n + 1)).\n    apply H.\n  - rewrite (app_comm (n + 1)).\n    rewrite (app_comm (n + 1)).\n    apply H.\n  - rewrite (app_comm (n + 1)).\n    rewrite (app_comm (n + 1)).\n    rewrite (app_comm (n + 1)).\n    apply H.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; intros.\n  simpl.\n  destruct (H a). destruct H0. subst. auto.\n  simpl.\n  destruct (H a). destruct H0. subst. auto.\n  simpl. destruct (H a). destruct H0. subst. auto.\n  simpl. destruct (H a). destruct H0. subst. auto.\n  simpl. destruct (H a). destruct H0. subst. auto.\n  simpl. destruct (H a). destruct H0. subst. auto.\n  simpl. destruct (H a). destruct H0. subst. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  - auto.\n  - auto.\n  - auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  - auto.\n  - simpl. rewrite IHl. rewrite IHl. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  + auto.\n  + intros. destruct (eq_dec n0 n).\n    subst. rewrite H. auto.\n    rewrite IHl. auto.\n  + intros. destruct (eq_dec n0 n).\n    subst. rewrite H. auto.\n    rewrite IHl. auto.\nQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  intros.\n  assert (forall a b e, In a (e1 ++ e2) <-> exists n, In a (e1 ++ e2).\n  {\n    intros. rewrite In_app_iff in e; auto. }\n  destruct H as [n [H1 H2]].\n  destruct (in_app_or _ _ _ H1) as [n' [H2 H3]].\n  destruct (in_app_or _ _ _ H2) as [n' [H3 H4]].\n  destruct (in_app_or _ _ _ H3) as [n' [H4 H5]].\n  destruct (in_app_or _ _ _ H5) as [n' [H5 H6]].\n  destruct (in_app_or _ _ _ H4) as [n' [H5 H6]].\n  destruct (in_app_or _ _ _ H5) as [n' [H6 H7]].\n  exists (n' + n').\n  rewrite H5 in H5.\n  inversion H5. subst n'.\n  replace (n' + n') with (n' + n') by omega.\n  rewrite H5 inQed.",
                    "Lemma agree_concat: forall A (e : list A) (e1 e2 : env A) k n, agree e1 e2 k -> k + length e = n -> agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e1; simpl; intros.\n  auto.\n  destruct e2; simpl in *; auto.\n  destruct e2; simpl in *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " a transformation [f] pointwise to two environments preserves\n     environment subsumption, provided [f] preserves [sub]. *)\n\n  Lemma subsume_map:\n    forall f,\n    (forall a1 a2, sub a1 a2 -> sub (f a1) (f a2)) ->\n    forall e1 e2,\n    subsume e1 e2 ->\n    subsume (map f e1) (map f e2).\n  Proof.\n    intros? hf?? hs. intros? b2 hlm2.\n    generalize (lookup_map_some_reverse _ _ _ hlm2); intros [? [ hl2? ]]. subst.\n    generalize (hs _ _ hl2); intros [ a1 [?? ]].\n    eauto using lookup_map_some.\n  Qed.\n\nEnd Subsume.\n\nHint Resolve osub_reflexive osub_Some_Some subsume_reflexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\n",
                "context_tokens": 672,
                "proof_start_offset": 30028,
                "proof_end_offset": 30412,
                "proof": "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\ninduction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\nrewrite insert_insert by omega.\nerewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\neauto with f_equal omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  - auto.\n  - simpl. rewrite IHl1. simpl. rewrite IHl2. reflexivity.\n  - simpl. rewrite IHl1. reflexivity.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  - apply IHl.\n  - simpl.\n    replace n with (n - 1) by omega.\n    destruct o; simpl; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros.\n  + simpl. rewrite <- IHl. reflexivity.\n  + simpl. rewrite <- IHl. reflexivity.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; simpl.\n  - auto.\n  - destruct a.\n    + destruct (a0 == a0).\n      rewrite IHl; auto.\n    + destruct (a0 == a1).\n      rewrite IHl; auto.\n    + destruct (a0 == a1).\n      rewrite IHl; auto.\n    + destruct (a0 == a1).\n      rewrite IHl; auto.\n  - destruct (a0 == a1).\n    rewrite IHl; auto.\n  - destruct (a0 == a1).\n    rewrite IHl; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  - auto.\n  - destruct o; auto.\n  - destruct o; auto.\n  - destruct o; auto.\n  - destruct e; auto.\n  - destruct e; auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros.\n  - auto.\n  - rewrite <- IHl. rewrite IHl. rewrite <- IHl. reflexivity.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  - auto.\n  - destruct a.\n    + simpl.\n      rewrite IHl.\n      destruct (x0 :: x0).\n      + subst.\n        destruct (x0 :: x1); simpl.\n          auto.\n        rewrite IHl.\n        reflexivity.\n      + simpl.\n        rewrite IHl.\n        destruct (x0 :: x1); simpl.\n          auto.\n      + simpl.\n        rewrite IHl.\n        destruct (x0 :: x1); simpl.\n          auto.\n        rewrite IHl.\n          destruct (x0 :: x1); simpl.\n          auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  intros.\n  rewrite (insert_app_eq _ _ H).\n  apply Permutation_sym.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; simpl; intros.\n  - auto.\n  - simpl. rewrite IHl. rewrite <- IHl. auto.\nQed.",
                    "Lemma insert_concat: forall (A : Type) n x nx (o : option A) e1 e2, length e2 = n -> n + x = nx -> raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; simpl.\n  - apply IHx; auto.\n  - apply IHx; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "flexive\nsubsume_transitive subsume_empty subsume_insert subsume_map : subsume.\n\n(* ---------------------------------------------------------------------------- *)\n\n(* Extending an environment with a list of bindings found in a pattern. *)\n\n(* Note that we cannot define the concatenation of two environments, because\n   we view environments as total functions, so we do not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 30691,
                "proof_end_offset": 30815,
                "proof": "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\ninduction n; simpl; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl.\n  auto.\n  destruct (eq_dec n a).\n  - subst. rewrite IHl by auto. auto.\n  - rewrite IHl by auto. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros; simpl.\n  rewrite app_nil_r.\n  rewrite app_ass. simpl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  rewrite <- beq_nat_refl.\n  rewrite IHl. auto.\n  rewrite IHl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  rewrite app_nil_r.\n  auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; intros.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  destruct a; auto.\n  destruct a; auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\n  rewrite IHl. simpl. auto.\nQed.",
                    "Lemma length_replicate: forall (A : Type) n (a : A), length (replicate n a) = n.\nProof.\n  induction n; intros.\n  auto.\n  destruct a. simpl. rewrite IHl. auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": " not have precise control\n   over their domain. Only a list has finite domain. *)\n\n(* Concatenation is just an iterated version of [insert 0]. *)\n\nFixpoint concat (A : Type) (e1 : env A) (e2 : list A) : env A :=\n  match e2 with\n  | nil =>\n      e1\n  | cons a e2 =>\n      concat (insert 0 a e1) e2\n  end.\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\n",
                "context_tokens": 701,
                "proof_start_offset": 30859,
                "proof_end_offset": 31110,
                "proof": "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; destruct a; simpl; auto.\n  destruct (ident_eq i n).\n  + auto.\n  + simpl.\n    rewrite <- IHl1.\n    auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros.\n  destruct a; simpl in *.\n  rewrite (IHel (a :: e1)).\n  rewrite app_ass.\n  simpl.\n  rewrite app_ass.\n  rewrite sepcon_assoc.\n  simpl.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite app_ass.\n  rewrite (sepcon_comm (a :: e1)).\n  rewrite sepcon_assoc.\n  f_equal.\n  rewrite sepcon_assoc.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  rewrite sepcon_assoc.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_assoc.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_comm.\n  rewrite sepcon_comm.\n  f_equal.\n  rewrite sepcon_Qed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  + rewrite list_disjoint_nil in H. destruct H.\n    apply (IHl (a :: e1)); auto.\n  + rewrite list_disjoint_cons.\n    apply (IHl (a :: e1)); auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl; auto.\n  destruct (in_dec eq_dec a0 a).\n  + subst; auto.\n  + destruct (in_dec eq_dec a0 a).\n    + subst; auto.\n    + simpl in *; rewrite IHl by auto.\n      rewrite IHl by auto.\n      apply IHm.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl; auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; simpl; intros.\n  replace n with n; auto.\n  rewrite (IHl a b) by auto.\n  rewrite IHl by auto.\n  auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl in *.\n  + auto.\n  + rewrite insert_local.\n    simpl.\n    rewrite insert_local.\n    simpl.\n    rewrite insert_local.\n    auto.\n  + rewrite insert_local.\n    rewrite insert_local.\n    auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl; auto.\n  rewrite IHi1.\n  destruct (eq_dec n 0); [left|right]; auto.\n  destruct (eq_dec n (length a)); [left|right]; auto.\n  destruct (IHel x a); auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros.\n  simpl; auto.\n  rewrite map_app.\n  rewrite (map_app (mid ++ x)) by auto.\n  rewrite map_app.\n  rewrite map_app.\n  apply map_ext.\n  intros.\n  apply (IHgfs x a0 b0 a e). auto.\nQed.",
                    "Lemma insert_concat_replicate: forall (A : Type) n x nx (a : option A) (b : A) e1, n + x = nx -> raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  induction n; intros; simpl; auto.\n  destruct a; auto.\n  rewrite insert_local by auto.\n  rewrite IHl by auto.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/dblib/src/Environments.v",
                "context": "\n\n(* Concatenation acts upon the length of the environment in an obvious\n   manner. *)\n\nLemma omega_hint_1:\n  forall n,\n  n <= (n + 1) - 1.\nProof.\n  intros. omega.\nQed.\n\nLemma length_concat:\n  forall A (e2 : list A) (e1 : env A) n1 n,\n  length e1 <= n1 ->\n  n1 + length e2 = n ->\n  length (concat e1 e2) <= n.\nProof.\n  induction e2; simpl; intros.\n  replace n with n1 by omega. assumption.\n  eauto using length_insert, omega_hint_1 with omega.\nQed.\n\nHint Resolve length_concat : length construction_closed.\n\n(* If [e1] and [e2] agree up to depth [k], then, after extending them\n   with a common suffix [e], they agree up to depth [k + length e]. *)\n\nLemma agree_concat:\n  forall A (e : list A) (e1 e2 : env A) k n,\n  agree e1 e2 k ->\n  k + length e = n ->\n  agree (concat e1 e) (concat e2 e) n.\nProof.\n  induction e; simpl; intros.\n  replace n with k by omega. assumption.\n  eauto using agree_insert with omega.\nQed.\n\nHint Resolve agree_concat : agree.\n\n(* Concatenation and insertion commute. *)\n\nLemma insert_concat:\n  forall (A : Type) n x nx (o : option A) e1 e2,\n  length e2 = n ->\n  n + x = nx ->\n  raw_insert nx o (concat e1 e2) = concat (raw_insert x o e1) e2.\nProof.\n  induction n; intros; subst; destruct e2; simpl in *; try discriminate; auto.\n  rewrite insert_insert by omega.\n  erewrite <- (IHn (1 + x)) by first [ congruence | eauto ].\n  eauto with f_equal omega.\nQed.\n\n(* [replicate n a] is a list of [n] elements, all of which are\n   equal to [a]. *)\n\nFixpoint replicate (A : Type) (n : nat) (a : A) : list A :=\n  match n with\n  | 0 =>\n      @nil _\n  | S n =>\n      cons a (replicate n a)\n  end.\n\n(* The list [replicate n a] has length [n]. *)\n\nLemma length_replicate:\n  forall (A : Type) n (a : A),\n  length (replicate n a) = n.\nProof.\n  induction n; simpl; auto.\nQed.\n\n(* A special case of [insert_concat]. *)\n\nLemma insert_concat_replicate:\n  forall (A : Type) n x nx (a : option A) (b : A) e1,\n  n + x = nx ->\n  raw_insert nx a (concat e1 (replicate n b)) = concat (raw_insert x a e1) (replicate n b).\nProof.\n  eauto using insert_concat, length_replicate.\nQed.\n\n(* [concat. (replicate. a)] is just an iterated version of [insert. a]. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 31191,
                "proof_end_offset": 31414,
                "proof": "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\nintros.\nsimpl.\neauto using insert_concat, length_replicate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; intros; simpl.\n  auto.\n  simpl. rewrite IHn.\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  induction n; simpl; auto.\n  rewrite (firstn_nil _ a).\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (firstn_nil n a) by auto.\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  induction n; simpl; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- app_nil_r.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  rewrite map_app.\n  auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (map_map (fun t => reptype t = reptype t)).\n  apply map_ext.\n  rewrite map_map.\n  reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  induction n; simpl; auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  destruct (eq_dec n n).\n  + subst.\n    rewrite map_app.\n    auto.\n  + rewrite map_app.\n    auto.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- map_app.\n  reflexivity.\nQed.",
                    "Lemma concat_replicate_is_iterated_insert: forall (A : Type) n (a : A) e, insert n a (concat e (replicate n a)) = concat e (replicate (S n) a).\nProof.\n  intros.\n  rewrite <- (map_map (fun it => reptype (field_type (fst it) = true) (co_members (get_co id)) (get_co id)) (co_members (get_co id)) (co_members (get_co id))).\n  rewrite map_map.\n  reflexivity.\nQed."
                ]
            }
        ],
        "disel": [
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\n",
                "context_tokens": 571,
                "proof_start_offset": 1849,
                "proof_end_offset": 2122,
                "proof": "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal !(step_is_local l H N).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>S H1 H2; rewrite /nam /= /nam /= /S /= /nam /= /S /= /S.\npose: exists s2, s2 = s2.\n- move=>s2; have H3: s2 = s2 by apply: (H3 H3).\n  by apply: (H3 H3); rewrite /nam /= /nam /= /nam /= eq_sym.\nmove=>s2 H3; have H4: s2 = s2 by apply: (H3 H4); rewrite /nam /= eq_sym.\nmove=>s2 H4; have H5: s2 = s2 by apply: (H4 H5); rewrite -eq_sym.\nmove=>s3 H5; have H6: s3 = s3 by apply: (H3 H5); rewrite -eq_sym.\nmove=>s4 H5; have H6: s3 = s4 by apply: (H5 H6).\nmove=>s4 H6; apply: (H4 H5); rewrite -eq_sym.\nmove=>s4 H6; move/Qed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2; rewrite /is_seq; case: H1 H2=>r [[H1 H2] | H1];\nby rewrite /= H1.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros H1 H2; unfold getS in *; simpl in *.\n  (* We need to give the proof of the fact that the schedule is step *)\n  eapply step_trace_monotone; eauto.\n  (* we can start that the schedule is the one of the schedule *)\n  eapply step_trace_monotone; eauto.\n  (* the schedule is the schedule, so that the schedule is the schedule *)\n  eapply step_trace_monotone; eauto.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H; case: (getS s2 r)=>H1 H2; move: (getS s2 r)=>H3.\nmove: (getS s2 r)=>H4; move: (getS s3 r)=>H5.\nmove: (getS s3 r)=>H5; move: (getS s4 r)=>H5.\nby rewrite H5.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2; apply: (iffP idP)=>H2; move: H1; move: H2; move: H2.\nby move=>H3; apply: (iffP idP)=>H3; move: H3.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2 H3; apply: (iffP (step_valid H1 H2)); apply: (iffP (step_valid H2 H3)).\nmove=>H3; apply: (iffP (step_valid H3)); apply: (iffP (step_valid H3)).\nby apply: (iffP (step_valid H3)); apply: (step_valid H3).\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H; rewrite /getS in H.\nset H1 := (getS s2 l).\nset H2 := (getS s2 l).\nset H3 := (getS s1 l).\nset H4 := (getS s2 l).\nset H4 := (getS s2 l).\nset H4 := (getS s2 l).\nset H5 := (getS s2 l).\nset H5 := (getS s2 l).\nset H5 := (getS s2 l).\nset H5 := (getS s2 l).\nset H5 := (getS s2 l).\nset H5 := (getS s2 l).\nset H5 := (getS s2 l).\nset H6 := (getS s2 l).\nset H6 := (getS s2 l).\nset H6 := (getS s2 l).\nset H6 := (getS s2 l).\nset H6 := (getS s2 l).\nset H6 := (getS s2 l).\nset H6 := (getS s2 l).\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\n  intros s1 s2 r n tr.\n  apply: (step_step (step_step (step_step (step_step (step_step (step_step (step_step (step_step (step_step (step (step_step n _ _ _) _) _) _) s1 r)).\n  apply: (step_step (step_step (step_step (step_step (step_step (step_step (step_step n _ _) _) _) _ _ tr)).\n  apply: (step_step (step_step (step_step (step_step (step_step (step_step n) _ _) _) _ _ tr)).\n  apply: (step_step (step_step (step_step (step_step (step_step (step_step n) _) _ _ _ tr)).\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H; apply: (step_implies _ H); first by apply/at_external.\nby apply/at_external=>x; rewrite!inE.\nQed.",
                    "Lemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1): this != n -> a_step pf s2 r -> getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>H1 H2; move: (H2 H1); move: (H2 H2); move: (H3 H4); move: (H4); move: (H4); move: (H5); move: (H5); move: H5; move: (H5).\nby move: (H3 H4)=>/=; move: (H1 H2); move: (H3 H4)=>H5; move: (H5).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "X Protocols Worlds NetworkSem.\nRequire Classical_Prop.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(* \"Atomic\" send/receive actions, coherent with the network semantics *)\n\nModule Actions.\n\nSection Actions.\n\nVariable W : world.\nNotation getS s l := (getStatelet s l).\n\n(*\n\nAction is defined with respect to the world (i.e., a number of\nprotocols) and label.\n\nIt changes the state as a whole, but, in fact, affects only a specific\nstatelet in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\n",
                "context_tokens": 748,
                "proof_start_offset": 2515,
                "proof_end_offset": 2608,
                "proof": "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nby rewrite -pf=>/(coh_s l).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>S H; split=> [|x s]; first by apply: H.\nby apply: H.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>S s1 s2; apply: (step_start _ S s1); first by apply: (step_valid S s2).\nby rewrite /getS /= /= => ->.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by move=>H s; rewrite /getP; case: s => //= H1 s1 s2; apply: H1. Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>S s; case: s l => [|x s] /= /S1P s1 /=.\nby rewrite /empty => ->; apply: (step_valid S).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>p H1 H2; apply: (step_ret H1 H2).\nby rewrite /set1 /set2 /set2 /set3 /set4/set4/set4/set4/set4/set4/set4/set4/set4/set4/set4/set4.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H s1 s2; case: s1 s2=>[[/= H1 H2] H1 H2.\nrewrite /getS; case: s2=>s2 H2; move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H1); move: (step_upd S2 H2); move: (step_upd S2 H1); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H1); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H1); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H2); move: (step_upd S2 H1); move: (step_upd S2 H2); moveQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by move=>H s; apply: H; apply: H. Qed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H s; elim: s H=>[|x s IH] //=.\nby case: s H=>[|y s IH] //=; rewrite /un0h.\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>S H1 H2; apply: (step_mono H1 H2); apply: (step_mono H2).\nby apply: (step_mono H2 H1).\nQed.",
                    "Lemma safe_local s : skip_safe s -> coh p (getS s l).\nProof.\nmove=>H; apply: (iffP idP); rewrite /getS.\nby rewrite -sub_emp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "let in it, associated with a specific label.\n\n\n*)\n\n\nStructure action (V : Type) (this : nid)\n  := Action\n       {\n         (* a_lab : Label; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\n",
                "context_tokens": 738,
                "proof_start_offset": 2826,
                "proof_end_offset": 2945,
                "proof": "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nby exists s, (f (safe_local S)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof.\nmove=>H1 H2; move: (step_step H1 H2).\nby apply: (safe_step_sound H2).\nQed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by move=>H; exists s'; apply: H. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed.",
                    "Lemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "; *)\n         (* a_lab_dom : a_lab \\in ddom W; *)\n\n         a_safe : state -> Prop;\n\n         a_safe_coh : forall s, a_safe s -> s \\In Coh W;\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 2947,
                "proof_end_offset": 3016,
                "proof": "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed.",
                    "Lemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": ";\n\n\n         (* safe_coh : forall s, a_safe s -> coh (getP a_lab) (getS s a_lab); *)\n\n         a_step : forall s1, (a_safe s1) -> state -> V -> Prop;\n\n         step_total : forall s (pf : a_safe s), exists s' r, a_step pf s' r;\n\n         (* step_coh  : forall s1 s2 r, Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> coh (getP a_lab) (getS s2 a_lab); *)\n\n         (* step_frame : forall s1 s2 r z, *)\n         (*     a_lab!= z -> Coh W s1 -> *)\n         (*     a_safe s1 -> a_step s1 s2 r -> getS s1 z  = getS s2 z; *)\n         \n         (* Action step semantics respects the overall network semantics *)\n         step_sem  : forall s1 (pf : a_safe s1) s2 r,\n             a_step pf s2 r -> network_step W this s1 s2\n\n       }.\n\n\n(* Framing follows from the network semantics *)\nLemma step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3018,
                "proof_end_offset": 3160,
                "proof": "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nby move=>H; apply: Idle; case: H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>H1 H2; move: (step_sem S2)=>H2; move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2).\nby move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2); move: (step_proj S2).\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: (safe_safe_safe H). Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by rewrite -posS; case: S. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>S1 S2; move: (step_step_step_step_step S2 S1 S2 S2 S3 S3 S4 S5 S6 S6 S6 S7 S7 S8 S9 S8 S9 S10).\nby rewrite -ptr_mem.\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof.\nmove=>H.\nby rewrite /getS in H; move/(prefix_step_safe H).\nQed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma skip_step_sem s1 (S : skip_safe s1) s2 r: skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: (step_step_step H). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " step_other this V (a : action V this) l s1 s2 r n (pf : a_safe a s1):\n  this!= n -> a_step pf s2 r ->\n  getLocal n (getS s1 l) = getLocal n (getS s2 l).\nProof.\nmove=>N S2; move: (step_sem S2)=>H.\nby rewrite eq_sym in N; rewrite /getLocal!(step_is_local l H N).\nQed.\n\nEnd Actions.\n\nSection SkipActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\nVariable l : Label.\nVariable p : protocol.\nVariable pf : getP l = p.\n\nDefinition skip_safe s := Coh W s.\n\nVariable V : Type.\n\n(* Skip-like actions allow for reading from the state *)\nVariable f : forall s, coh p (getS s l) -> V.\n\nLemma safe_local s : skip_safe s -> coh p (getS s l).\nProof. by rewrite -pf=>/(coh_s l). Qed.\n\nDefinition skip_step s1 (pf : skip_safe s1) (s2 : state) r :=\n  [/\\ s1 \\In Coh W, s1 = s2 & r = f (safe_local pf)].\n\n(* Lemma skip_step_safe s1 s2 r: skip_step s1 s2 r -> skip_safe s1. *)\n(* Proof. by case. Qed. *)\n\nLemma skip_step_total s (S : skip_safe s) : exists s' r, skip_step S s' r.\nProof. by exists s, (f (safe_local S)). Qed.\n\nLemma skip_safe_coh s1 : skip_safe s1 -> Coh W s1.\nProof. by []. Qed.\n\nLemma skip_step_sem s1 (S : skip_safe s1) s2 r:\n  skip_step S s2 r -> network_step W this s1 s2.\nProof. by move=>H; apply: Idle; case: H. Qed.\n\nDefinition skip_action_wrapper :=\n  Action skip_safe_coh skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3842,
                "proof_end_offset": 3922,
                "proof": "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nby [].\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (iffP idP)=>H.\nby rewrite eq_sym in H; apply: (iffP idP)=>H; apply.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (iffP idP). Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (iffP idP)=>H3.\nby apply: (iffP idP)=>H3; apply: (iffP idP)=>H4; apply: H3.\nQed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: tryrecv_act_safe_safe_safe_safe_safe; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (iffP idP)=>H; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (val_inj_pre_pre_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: tryrecv_valid_next_safe; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: (iffP idP)=>H; apply: H. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by case=>s ->; case: s. Qed.",
                    "Lemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by move=>H; apply: injP; apply: injP; apply: injP. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " skip_step_total skip_step_sem.\n\nEnd SkipActionWrapper.\n\n\nSection TryReceiveActionWrapper.\n\nVariable W : world.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\n(* \n\nFilter for specific \n - protocol labels\n - message tags\n - message bodies\n *)\nVariable filter : Label -> nid -> nat -> pred (seq nat).\n\n(* Necessary validity lemmas *)\nVariable f_valid_label : forall l n t m,\n    filter l n t m -> l \\in dom (getc W).\n\n(* Variable f_valid_tags : forall l t m, *)\n(*     filter l t m -> t \\in rcv_tags (getP l). *)\n\nDefinition tryrecv_act_safe (s : state) := s \\In Coh W.\n\nLemma tryrecv_act_safe_coh s : tryrecv_act_safe s -> Coh W s.\nProof. by []. Qed.\n\n(* Can we make it decidable rather than classic? *)\nDefinition tryrecv_act_step s1 s2 (r : option (nid * nat * seq nat)) :=\n  exists (pf : s1 \\In Coh W),\n  (* No message to receive -- all relevant messages are marked *)\n    ([/\\ (forall l m tms from rt b,\n          this \\in nodes (getP l) (getS s1 l) -> \n          Some (Msg tms from this b) = find m (dsoup (getS s1 l)) ->\n          rt \\In (rcv_trans (getP l)) ->\n          tag tms = (t_rcv rt) ->\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5368,
                "proof_end_offset": 6467,
                "proof": "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)), let: d := getS s l in [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)), rt \\In (rcv_trans (getP l)), tag tms = (t_rcv rt), msg_wf rt (coh_s l C) this from tms & filter l from (t_rcv rt) (tms_cont tms)])); last first.\nmove=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\napply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\nby exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d := getS s l in let loc' := receive_step rt from tms (coh_s l C) T in let: f' := upd this loc' (dstate d) in let: s' := consume_msg (dsoup d) m in upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2; split.\n- move=>H2; move: (H2 H3); case=>x [H3]; case=>x [H4]; case=>x [H5]; case=>x [H5]; case=>x [H5]; case=>x [H5]; case=>x [H5]; case=>x [H5]; case=>x [H5]; case=>x [H6]; case=>x [H6]; case=>x [H7|]; case=>x [H8|]; case=>x [H7|]; case=>x [->|].\ncase=>x [H1 H2]; case=>x [H2 H3]; case=>x [H4]; case=>x [H5]]; case=>x [H5]; case=>x [H6|]; case=>x [H7|]; case=>x [H7|]; case=>x [->|].\ncase=>x [H1 H2]; case=>x [H3]; case=>x [H5]; case=>x [H5]; case=>x [H5]; case=>x [H6]; case=>x [H6]; case=>H7|]; case=>Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2; apply: (unvP H1 H2); first by move=>x; move/H2; move/H3.\nhave: s = s by move/H3; move/H3; move/H3.\nhave: s' = s by move/H3; move/H3; move/H3; move/H3; move/H3.\nby move=>x; move/H3; move/H3; move/H3; move/H3; move/H4; move/H4; move/H4; move/H5.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>n; move: s; move: s; move: s; move: s; move: s; move: s.\nmove: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move/s; move: s; move/s; move: s; move: s; move: s; move: s; move/s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move/s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move: s; move/s; move: s; move: s; move: s; move/s; move: s; move/s; move/s; move/s; move: s; move/s; move/sQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>i s; split=> [[H1 H2]] [[H3]] [[H4]] [[H4]] [[H5]] [[H5]] [[H5]] [[H5]] [[H5]] [[H6]] [[H7]] [[H7]] [[H8]] [[H9]] [[H9]] [[H10]] [[H12]] [[H12] [H12] [H12]] [[H13]] [[H13] [H14]] [[H14] [H14]] [[H14]] [[H15]] [[H15]] [H15]] [[H15]] [[H15]] [[H15]] [[H15] [[H15]] [[H15]] [[H15]] [H15]] [H15]] [[H15]] [H16]] [[H15]] [[H15] [H15]] [[H15]] [[H15] [H15]] [H15]] [H16]] [[H15]] [H15] [H15]] [[H15] [H15]] [H15] [H15] [H15] [H15]] [[H15]] [H15] [H15]][H15Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2.\nhave H3: s = s' by apply: (proj1 H3).\nhave H4: s' = s' by apply: (proj2 H3).\nhave H5: s' = s' by apply: (proj2 H3).\nhave H5: s' = s' by apply: (proj2 H3).\nhave H5: s' = s' by apply: (proj2 H3).\nhave H5: s' = s' by apply: (proj2 H3).\nhave H5: s' = s' by apply: (proj2 H3).\nhave H6: s' = s' by apply: (proj2 H3).\nhave H7: s' = s' by apply: (proj2 H3).\nhave H7: s' = s' by apply: (proj2 H3).\nhave H8: s' = s' by apply: (proj2 H3).\nhave H8: s' = s' by apply: (proj2 H3).\nhave H8: s' = s' by apply: (proj2 H3Qed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2; apply: (iffP idP) => [[s' [H3 H4]].\nby exists s'; exists s'; exists s'; exists s'; exists s'; split=>//.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2 H3; apply: (IHv_step_wf s); assumption.\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>n s1 s2 /= [[s' [[H1 H2]] [H2] H3].\nby rewrite (IH H3).\nQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H; move: H; move: H; move: H; move: H.\nmove=>H; move: H; move: H; move: H; move=>H; move: H; move: H; move: H; move/H=>H; move: H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: H=>H; move: HQed.",
                    "Lemma tryrecv_act_step_total s: tryrecv_act_safe s -> exists s' r , tryrecv_act_step s s' r.\nProof.\nmove=>H1 H2; apply: (iffP idP); case: s H1=>s1 s2 H3.\nby case: s1 H2=>s2 H4; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s1; exists s2; exists s2; exists s2; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s1; exists s2; exists s1; exists s2; exists s2; exists s1; exists s2; exists s2; exists s2; exists s1; exists s1; exists s2; exists s2; exists s2; exists s2; split; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "_wf rt (coh_s l pf) this from tms ->\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms) ->\n          ~~b),\n    r = None & s2 = s1] \\/\n   (* There is a message to receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\n",
                "context_tokens": 728,
                "proof_start_offset": 6469,
                "proof_end_offset": 6577,
                "proof": "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step_stable.\ncase: (bool_eq (getS s1 r)); move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step_def_stable.\ncase: (classic (exists l m tms from t,\n                exists r,\n                  step (by (by (split; first [exists t; exists t; exists t; exists t; exists t; exists t; exists t; exists t; exists m; exists t; exists t; exists m; exists t; exists m; exists m; exists m; exists t; exists m; exists t; exists m; exists m; exists t; exists m; exists t; exists t; exists m; exists m; exists t; exists t; exists m; exists m; exists t; exists m; exists t; exists m; exists m; exists m; exists t; exists m; exists t; exists m; exists m; exists t; exists m; exists t; exists m; exists t; exists m; exists m; exists t; exists m; exists m; exists t; exists m; exists t; exists m; exists m; exists m; split=> //.\n- move=>H; move=>H; move=>H; move: (H m H)=>H; move: (H mQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from t,\n                     (t_cl_step (getS s1 l) m) (getS s2 l))) => [[m' [C' C'] | [m' [C' D' C'']]] | [m' [C'' D'' D'']]] | [m'' [D'' D'' D'']]] | [m'' [C'' D'' D'' D'' D'']]] | [m'' [C'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' D'' E'' E'' E'' M'' E'' M'' M'' E'' M'' H'' M'' M'' M'' M''' E'' H'' H'' H'' H'' H''.\nby apply: (IHev _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from t,\n                 is_true (t_rav t) (t_rav t)) => [[s' [H1 H2]] | [t' [H3 H4]]; last first.\n- move=>H; exists s'; split=>//.\n  by apply/eqP; rewrite H1; apply: H2.\nmove=>H; apply/eqP; rewrite H1; apply/eqP.\nmove=>H; apply/eqP; rewrite H1; apply/eqP.\nmove=>H; apply/eqP; rewrite H1; apply/eqP.\nby move=>H; apply/eqP; rewrite H1; apply/eqP.\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>D; case: (classic (exists l m tms from t,\n                  exists n, exists l,\n                  (n <= length l /\\ m < length l /\\ m < length l /\\ m < length l /\\ m < length l /\\ m < length l)).\n- move=>D; case: (classic (exists l m tms from t,\n                exists n, exists l,\n                  (n < length l /\\ m < length l /\\ m < length l /\\ m < length l /\\ m < length l)).\n  - move=>D; case: (classic (exists l m tms from t,\n                  (n < length l /\\ m < length l /\\ m < length l /\\ m < length l /\\ m < length l)).\n    move=>D; case: (classic (exists l m tms from t,\n                  (n < length l /\\ m < length l /\\ m < length l /\\ m < length l)) => //.\n    move=>D; case: (m < length l) => [m' [l' [m' [n' [n' [H' [H' [H' [H'' [H'' H'']]]]]].\n    exists m', l'; split;Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step_stable; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H;Qed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_stable; case: (altP (exists l m tms from t) & D).\n- by move=>H; exists (fun t => m t); exists (fun t => m t).\nby move=>H; exists (fun t => m t); exists (fun t => m t).\nQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /andbrecv_act_step; move=>H; apply/andP; split=> //.\n- move=>H; exists (fun s => exists r, r \\In s r); split=> //.\n  by move=>H; apply/andP; split=> //; apply/andP; split=> //.\n  by move=>H; apply/andP; split=> //; apply/andP; split=> //; apply/andP; split.\n- move=>H; exists (fun s => exists r, r \\In s r); split=> //.\n  by move=>H; apply/andP; split=> //; apply/andP; split=> //; apply/andP.\n  by move=>H; apply/andP; split=> //; apply/andP; split=> //; apply/andP; split.\n- move=>H; exists (fun s => exists r, r \\In s r); split=> //.\n  by move=>H; apply/andP; split=> //; apply/andP; split=> //; apply/andP; split=> //; apply/andP.\n  by move=>H; apply/andP; split=> //; apply/andP; split=> //; apply/andP.\n- move=>H; existsQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /andbrecv_act_step_stable.\ncase: (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s2 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s2 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s2 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s2 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s2 l)) (bool_eq_dec (getS s1 l)) (bool_eq_dec (getS s1 lQed.",
                    "Lemma tryrecv_act_step_safe s1 s2 r: tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof.\nmove=>C; rewrite /tryrecv_act_step_def; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H; move=>H;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " receive and the transition can be executed *)\n   exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s1 l)),\n     let: d :=  getS s1 l in\n     [/\\ [/\\ Some (Msg tms from this true) = find m (dsoup (getS s1 l)),\n          rt \\In (rcv_trans (getP l)),\n          tag tms = (t_rcv rt),\n          (* This is required for safety *)\n          msg_wf rt (coh_s l pf) this from tms &\n          (* The filter applies *)   \n          filter l from (t_rcv rt) (tms_cont tms)],\n      let loc' := receive_step rt from tms (coh_s l pf) pf' in\n      let: f' := upd this loc' (dstate d) in\n      let: s' := consume_msg (dsoup d) m in\n      s2 = upd l (DStatelet f' s') s1 &\n      r = Some (from, tag tms, tms_cont tms)]).\n\nImport Classical_Prop.\n\nLemma tryrecv_act_step_total s:\n  tryrecv_act_safe s -> exists s' r, tryrecv_act_step s s' r.\nProof.\nmove=>C; rewrite /tryrecv_act_step.\ncase: (classic (exists l m tms from rt (pf' : this \\in nodes (getP l) (getS s l)),\n                   let: d :=  getS s l in\n                   [/\\ Some (Msg tms from this true) = find m (dsoup (getS s l)),\n                    rt \\In (rcv_trans (getP l)),\n                    tag tms = (t_rcv rt),\n                    msg_wf rt (coh_s l C) this from tms &\n                    filter l from (t_rcv rt) (tms_cont tms)])); last first.\n- move=>H; exists s, None, C; left; split=>//l m tms from rt b T E1 E2 E3 E M.\n  apply/negP=>Z; rewrite Z in E1; clear Z b; apply: H.\n  by exists l, m, tms, from, rt.\ncase=>[l][m][tms][from][rt][T][E1 E2 E3 E M].\nexists (let: d :=  getS s l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\n",
                "context_tokens": 713,
                "proof_start_offset": 6579,
                "proof_end_offset": 6961,
                "proof": "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; apply: tryrecv_act_step_stable.\nby apply: tryrecv_act_step_stable.\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; apply: tryrecv_act_step_wf; apply: tryrecv_act_step_wf; apply: tryrecv_act_step_wf; apply: tryrecv_act_step_wf; apply: tryrecv_act_step_wf; apply: tryrecv_step_wf; apply: tryrecv_act_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_update_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_step_wf; apply: tryrecv_post_wf; apply: tryrecv_step_wf; apply: tryrecv_post_wf; apply: tryrecv_step_wf; apply: tryrecv_post_wf; apply: tryrecv_Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>S; apply: tryrecv_act_step_wf.\nby case=>s2 [A B]; rewrite /= A; apply: (splitS v).\nQed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /and3P; case: (altP (exists l m tms from ST (getS s1 l))).\n- by case: (classic (exists l m tms from ST (getS s1 l))).\n- by move=>S; apply: (iffP idP)=> [/eqP->|/eqP-> /IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IHIH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IHIH/IH/IH/IH/IH+/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/IH/Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nby case=>[n][l][m] s1 r]; case=>s2 r; case=>s3 r; case=>s4 r; case=>s4 r; case=>s4; case=>s4; case=>s4; case=>s4; case=>s4; case=>s4; case=>s4; case=>s4; case=>s4; case=>s4; case=>s5; case=>s4; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s6; case=>s5; case=>s5; case=>s5; case=>s6; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s6; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s5; case=>s6;Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof. by case. Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /tryrecv_act_step_step_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n- by rewrite /tryrecv_act_step_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n  by rewrite /and3Pv_act_step_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n- by rewrite /and3Pv_act_step_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n  by rewrite /and3Pv_act_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n- by rewrite /and3Pv_act_step_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n  by rewrite /and3Pv_act_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n- by rewrite /and3Pv_act_stable.\ncase: (eqVneq S 0) => [-> | _ /eqP].\n- by rewrite /and3Pv_act_Qed.",
                    "Lemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r: tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\nmove=>C; rewrite /andbrecv_act_step.\ncase: (eqVneq S 0) => // [[s1 s2] /= [[s1 s2] /= [[s1 s2] /= [[s1 s2]] /= [[s1 s2] /= [[s1 s2] /= [[s2 s3] /= [[s1 s2] [s1 s2] [s1' [s2' [s3' [t [t [t [t [t [t [t [t [t [t [t [t [t [t [t [t [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t' [t'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " l in\n        let loc' := receive_step rt from tms (coh_s l C) T in\n        let: f' := upd this loc' (dstate d) in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\n",
                "context_tokens": 743,
                "proof_start_offset": 8145,
                "proof_end_offset": 8221,
                "proof": "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (unulup_coherent_safe_safe_safe (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW hW (gethW (gethW (gethW (gethW hW (gethW hL)))))))).\nby apply: (unulup_coherent_safe_safe_safe (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW (gethW hW (geth hW hW))))))); eauto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (iffP (proj1 (proj2 (proj2 (proj2 (proj2 (proj2 (proj2 H)))).\nby rewrite /send_safe_safe_safe; case=>s _ /(_ _ _ _); apply: (proj2 (proj2 (proj2 (proj2 (proj2 H)))).\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (unulup s).\n- by apply: (Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (iffP idP)=> [[s1 H1] [[s2 H2]][s3 H4] H5].\nby apply: (iffP idP)=> [[s2 H3] [[s3 H4] [[s4 H5] [[s5 H6] H7] H8].\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by move=>H; apply: (L idP); apply: (L idP); apply: (L idP). Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>x y; apply: (iffP (proj1 (s:=m))=>s; apply: send_act_safe_safe s.\nmove=>s; apply: (iffP (proj2 (s:=m))=>s; apply: sQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2 H3; apply: (iffP idP)=>[/= H1][s2][s3 [[H4 H5]] H6].\nhave H6: s2 = s2 by apply: H5; apply: H6.\nhave H6: s3 = s3 by apply: H5; apply: H6.\nhave H7: s3 = s3 by apply: H7; apply: H8.\nhave H7: s3 = s4 by apply: H7; apply: H8.\nhave H8: s4 = s4 by apply: H8.\nhave H8: s4 = s4 by apply: H8; apply: H8.\nhave H8: s4 = s4 by apply: H8.\nhave H8: s4 = s4 by apply: H8; apply: H8.\nhave H8: s4 = s4 by apply: H8; apply: H8.\nhave H8: s4 = s4 by apply: H8.\nhave H9: s4 = s4 by apply: H9.\nhave H9: s4 =Qed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (iffP (iffP idP)) => [[s H1] [[s H2] H3]].\nby apply: (iffP (iffP idP)) => [[s H3] [[s H4] [[s H5]] [[s H6] [[s H7]] [[s H7] [[s H7]] [[s H8] [[s H9] [[s H9] [[s H10]] [[s H10] [[s H11] [s11] [[s12 H12]] [[s12 H12] [[s13]] [[s13 H12] [[s13]] [[s13 [s13 [s13 [s13 [s13 [s14 [s13 H14 [s14 [s14 [s14 [s14 [s14 [s14 [s14 [s15 [s14 [s14 [s15 [s14 [s14 [s14 [s14 [s14]]]]]]]]]]] | ] ] ] ] => [[s13 [s14 [s13 [s14 [s14 [s15 [s14 [s14 [s14 [s14 [s14 [s14 [sQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H; apply: (unulup (h:=s)); first by move=>p; apply: (unulup (h:=s)); eauto.\nQed.",
                    "Lemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof.\nmove=>H1 H2; apply: (unpl_oks H1 H2).\napply: (unpl_oks H2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": " in\n        let: s' := consume_msg (dsoup d) m in\n        upd l (DStatelet f' s') s), (Some (from, tag tms, tms_cont tms)).\nby exists C; right; exists l, m, tms, from, rt, T. \nQed.\n\nLemma tryrecv_act_step_safe s1 s2 r:\n  tryrecv_act_step s1 s2 r -> tryrecv_act_safe s1.\nProof. by case. Qed.\n\nLemma tryrecv_act_step_sem s1 (S : tryrecv_act_safe s1) s2 r:\n  tryrecv_act_step s1 s2 r -> network_step W this s1 s2.\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8223,
                "proof_end_offset": 8319,
                "proof": "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=>S s1 s2; move: (svalP s2); rewrite /is_seer_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe.\nby rewrite /is_se_nd; case: (getS s2); rewrite?svalP.\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>C; case=>T; case: (findS s); case=>s [s [C D]].\ncase: (findS s); case=>s [C D]; case=>s [D D].\ncase: (findS s); case=>s [D D].\ncase: (findS s); case=>s [D D]].\ncase: (findS s); case=>s [D D].\ncase E: (findS s); case=>s [D D].\ncase: (findS s); case=>s [D D]].\ncase E: (findS s); case=>s [D D]].\ncase: (findS s); case=>s [D D].\ncase E: (findS s); case=>s [D D].\ncase E: (findS s); case=>s [D D]].\ncase E: (findS s); case=>s [D D].\ncase E: (findS s); case=>s [D D].\ncase E: (findS s); case=>s [D D].\ncase E: (findS s); case=>s [D D].\ncase EQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nmove=>W s.\nby apply: (unamulacts_cat_safe_safe_safe (gethW (snd_sym p)) (snd_sym p)).\nQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\nby case: s => [[s1 s2]] [[s1 s2]] [[s1 s2]] [[s1 s2]] [[s1 s2]] [[s1 s2]] [[s2] [[s2]] [[s2]] [[s2]] [[s2]] [[s3]] [[s4]] [[s5]] [[s6] [[s6] [[s7] [[s7] [[s7]] [[s7] [[s8]] [[s8]] [[s8] [[s9]] [[s9] [[s8]] [[s8]] [[s9] [[s10]] [[s9]] [[s11 [s11 s12] [[s12]] [[s13]] [[s13]] [[s13] [[s14]] [[s14] [[s14]] [[s13]] [[s14]] [[s14] [[s14]] [s14]] [[s13] [[s15]] [s14]] [[s14] [[s14]] [[s14]] [[s14]] [[s13]] [[s14]] [[s14]] [[s13] [[s13]] [[s13]] [s14]] [[sQed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.",
                    "Lemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof.\ncase=>S H1 H2; case=>s [H1 H2]; case=>s H1 H2; case=>s [H2 H3]; case=>s [H4]; case=>s [H4]; case=>s [H5]; case=>s [H5]; case=>s [H5]; case=>s [H5]; case=>s [H5]; case=>s [H5]; case=>s [H5]; case=>s [H6]; case=>s [H6]; case=>s [H6]; case=>s [H7]; case=>s [H8]; case=>s [H8]; case=>s [H7]; case=>s [H8]; case=>s [H9]; case=>s [H8]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; case=>s [H9]; caseQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Core/Actions.v",
                "context": "\nProof.\ncase=>C; rewrite /tryrecv_act_step; case; first by case=>_ _ ->; apply: Idle.\ncase=>[l][m][tms][from][rt][Y][[E R E1 M]]F/=Z _.\nhave X1: l \\in dom s1 by move: (f_valid_label F); rewrite (cohD C).\nby apply: (ReceiveMsg R X1 E1 (i := m) (from := from)).\nQed.\n\nDefinition tryrecv_action_wrapper :=\n  Action tryrecv_act_safe_coh tryrecv_act_step_total tryrecv_act_step_sem.\n\nEnd TryReceiveActionWrapper.\n\n(* A wrapper for the send-action *)\nSection SendActionWrapper.\n\nVariable W : world.\nVariable p : protocol.\nNotation getP l := (getProtocol W l).\nNotation getS s l := (getStatelet s l).\nVariable this : nid.\n\nVariable l : Label.\n\nVariable pf : (getProtocol W l) = p.\n\n(* A dedicated send-transition *)\nVariable st: send_trans (coh p).\n(* The transition is present *)\nVariable pf' : st \\In (snd_trans p).\n\n(* The message and the recipient *)\nVariable msg : seq nat.\nVariable to  : nid.\n\n(* This check is implicit in the action semantics *)\nDefinition can_send (s : state) := (l \\in dom s) && (this \\in nodes p (getS s l)).\n\n\n(* Take only the hooks that affect the transition with a tag st of *)\n(* protocol l *)\nDefinition filter_hooks (h : hooks) :=\n  um_filter (fun e => e.2 == (l, t_snd st)) h.\n\nDefinition send_act_safe s :=\n  [/\\ Coh W s, send_safe st this to (getS s l) msg, can_send s &\n      (* All hooks from a \"reduced footprint\" are applicable *)         \n      all_hooks_fire (filter_hooks (geth W)) l (t_snd st) s this msg to].\n\nLemma send_act_safe_coh s : send_act_safe s -> Coh W s.\nProof. by case. Qed.\n\nLemma safe_safe s : send_act_safe s -> send_safe st this to (getS s l) msg.\nProof. by case. Qed.\n\nDefinition send_act_step s1 (S: send_act_safe s1) s2 r :=\n   r = msg /\\\n   exists b,\n     Some b = send_step (safe_safe S) /\\\n     let: d :=  getS s1 l in\n     let: f' := upd this b (dstate d) in\n     let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg)\n                                         this to true)).1 in\n     s2 = upd l (DStatelet f' s') s1.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 8680,
                "proof_end_offset": 9239,
                "proof": "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nrewrite /send_act_step/send_act_safe.\ncase: S=>C S J K.\nmove/(s_safe_def): (S)=>[b][S']E.\nset s2 := let: d := getS s l in let: f' := upd this b (dstate d) in let: s' := (post_msg (dsoup d) (Msg (TMsg (t_snd st) msg) this to true)).1 in upd l (DStatelet f' s') s.\nexists s2, msg; split=>//; exists b; split=>//.\nmove: (safe_safe (And4 C S J K))=> S''.\nby rewrite -E (pf_irr S'' S') .\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>f; apply/send_act_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe_safe.\ncase=>s1 s1 r1 r2 /S r1 r2 /S r2 r3 /S r1 r2.\ncase=>i; case: s1 r2 r3 /S r1 r2 r3 /S r3 r4 /S r3 r4.\ncase=>i; case: s2 r3 r4 /S r1 r3 r4 /S r3 r4 /S r4 r4.\ncase=>i; case: s2 r3 r4 /S r4 r4 /S r4 r4.\ncase=>i; case: s2 r4 r4 /S r4 r4 r5 /S r4 r5.\ncase=>i; case: s2 r4 r4 /S r4 r5 /S r4 r5 /S r4 r5.\ncase=>i; case: s2 r3 r4 /S r4 r5 /S r5 r6 /SQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>S r; elim: r s r => [|b s'];\n[move: b s'];\n[move: b s'];\n[move: b s'; rewrite /update /s' /= /= /s' /= /s' /= /s' /= /s' /= /s' <- /s' <- //.\ncase: b s' => /= ->.\nby rewrite (cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat_cat.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nelim.\n- (* s should not true *)\n  destruct s.\n  + (* s' *)\n    destruct s' as [b tl].\n    exists b; split.\n    + (* s' *)\n      destruct s' as [b tl].\n      * (* s' *)\n        destruct s' as [b tl].\n        * (* s' *)\n          inversion H. subst. apply H.\n          exists b; split.\n          * apply IHIH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH. apply IH.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>S; apply: (iffP idP)=> [/eqP-> | [s2 [b []]].\nby exists (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b (s2b s2)))))))).\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nelim: S => [|s1 IH1] s1 r1 IH1 r2 r1 r2; try (by apply: IH1; auto).\ncase: s2 r2 => //=; case: s2 r2 r1 => //=; case: s2 r2 r2 => //=; case: s2 r2 => //; case.\ncase: s2 r2 r2 => //=; case: s2 r2 r2 => //=; case: s2 r2 r2 => _; case: s2 r2 => //=; case.\ncase: s2 r1 => //=; case: s2 r2 r2 => //=; case: s2 r2 r3 => //; case.\ncase: s2 r2 r2 => //=; case: s2 r2 r2 => //=; case: s2 r2 r3 => _; case.\ncase: s2 r2 r3 => //=; case: s2 r2 r3 => //=; case: s2 r3 r3 => //=; case: s3 r3 => //.\ncase: s2 r3 r3 => //=; case: s3 r3 r3 => //= _; case: s3 r3 r4 => //= _; case.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>S; move=>S; move=>S; move=>S; move=>S; move=>S; move=>S; move=>S; move=>S; move=>S.\nmove=>S; move=>S; move=>S; move=>S; move=>S; move=>S.\nmove=>S; move=>S; move=>S; move=>S; move=>S; move=>S; move=>S.\nmove=>S; move=>S; move=>S; move=>S; move=>S; move=>S; move=>T.\nmove=>S; move=>T; move=>T; move=>T; move=>T; move=>T.\nmove=>S; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move=>T; move/T=>T.\nby move=>T; move=>T; move=>T; move=>T; move/T; move=>T; move=>T; move=>T; move/T; move/T; move=>TQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>S; apply/idP/idP=> [H1 H2].\napply/idP/idP=> [H2 H3]; exists s1; split=>//.\n- apply: (IH (sPtrofs_act_step S) (fun e => e.2 = (l, t_snd st)) s1.\n  by exists (r, t_snd st).\n- by exists (r, t_snd st).\nby exists (r, t_snd st).\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>S s' r; apply: (iffP (iffP (S _)) => [[b Hb]].\nby move: (H _ Hb); rewrite Hb.\nQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\nmove=>s1 s2 r; case: s1 s2 r; case: s2 r; case: s2 r; case: s2 r; case: s1 r; case: s2 r; case: s2 r; case: s2 r; case: s3 r; case: s3 r; case: s3 r; case: s4; case: s4; case: s4; case: s5; case: s5; case: s5; case: s5; case: s6; case: s6; case: s6; case: s6; case: s6; case: s6; case: s6; case; case: s6; case.\ncase: s2 s3 s4 r; case: s5 s6 s6 s7; case: s7; case: s6; case: s7; case: s6; case: s6; case: s6; case: s7; case: s7; case: s6; case: s7; case: s7; case.\ncase: s2 s4 s4 s4 s5 H1 H2 HQed.",
                    "Lemma send_act_step_total s (S: send_act_safe s): exists s' r , send_act_step S s' r.\nProof.\ncase=>p [[b][]].\ncase: b=>[s1][b][s2][b][s2].\ncase: b=>[s1][b][s2][b][s2].\ncase: b=>[s2][s3][b][s3].\ncase: b=>[s3][b][s3][b][s4].\ncase: b=>[s3][b][s4][b][s4].\ncase: b=>[s4][b][s4][b][s4][s4].\ncase: s5=>[s4][b][s4].\ncase: s4=>[s5][b][s4][s4].\ncase: s5=>[s4][s5][s4][b][s4][s5].\ncase: s6=>[[s5][b][s4][s5].\ncase: s5=>[s5][s6][b][s4][s5].\ncase: s6=>[s4][b][s4][s5].\n- case: s5=>[s4][s5][s6].\n- by case: s6=>[[s4][sQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\n",
                "context_tokens": 479,
                "proof_start_offset": 1831,
                "proof_end_offset": 1898,
                "proof": "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D1 D2; apply/eqP; rewrite D1 /isbyte_nat /isbyte_nat.\nhave: has_spec_true (rev dl) by move=> -> /eqP->.\ncase: (rev dl) => [m D1 | m D2]; rewrite /isbyte_nat /= => D1 D2.\ncase: (rev dl) => [m1 D2 | m1 D2]; rewrite /isbyte_nat /= => D3.\nhave D1: has_spec_false (rev dl) by move=> -> /eqP ->.\ncase: (rev dl) => [m1 D1 | m1 D1]; rewrite /isbyte_nat /= => D1 D2.\ncase: (rev dl) => [m2 D2 | m2 D3]; rewrite /isbyte_nat /= => D3.\ncase: (rev dl) => [m3 D3 | m3 D3]; rewrite?D3.\ncase: (rev dl) => [m3 D3 | m3 D3]; rewrite?D3.\ncase: (rev dl) => [m3 D3 | m3 DQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> [[n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [n [nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=>D; apply: (l1 d); first by rewrite /is_redblack /is_redblack /is_redblack /is_redblack.\nmove: (l2 d); rewrite /is_redblack /is_redblack /is_redblack /is_redblack.\nmove: (l1 d); rewrite /is_redblack /is_redblack /is_redblack /is_redblack.\nmove: (l2 d); rewrite /is_redblack /is_redblack /is_redblack /is_redblack.\nmove: (l1 d); rewrite /is_redblack /is_redblack /is_redblack.\nmove: (l2 d); rewrite /is_redblack /is_redblack /is_redblack.\nmove: (l1 d); rewrite /is_redblack /is_redblack /is_redblack /is_redblack.\nmove: (l2 d); rewrite /is_redblack /is_redblack /is_redblack.\nmove: (l2 d); rewrite /is_redblack /is_redblack /is_redblack.\nmove: (l2 d); rewrite /is_redblack /is_redblack /is_redblack.\nmove: (l2 dQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D; split; last by move=> D; case: D => D /= ->.\nby move=> D1 D2; apply: D1; apply: D2; apply: D1.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D; rewrite /is_nth.\ncase: d=>[a D] /= D D; case: (dorder D); last first.\n- by case: D D=>s D /= ->.\n- by move: D; rewrite D; move: D.\n- by move: D; rewrite D; move: D.\n- by move: D; rewrite D; move: D.\n- by move: D; rewrite D; move: D; move: D; move: D.\n- by move: D; rewrite D; move: D; move: D.\n- by move: D; move: D; move: D; move: D.\n- by move: D; move: D; rewrite D; move: D; move: D; move: D; move: D.\n- move: D; move: D; move: D; move: D; move: D; move: D.\n- move: D; move: D; move: D; move: D; move: D.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> N1 N2.\nhave N1 N2: N1 * N2 = N2 * N1 * N2.\n  move=> N1 N2 N3 N4.\n  apply N1; apply N2; apply N1; apply N2; apply N3; apply N4.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D; split; last first.\n  move: D; case=> n D /= D n D; exists n.\n  by rewrite D; exists n.\nmove: D; case: d D=> D n D /= D D n; exists n.\ncase: D n D=> [n D /= D n D /= D n D /= D n D.\n  by rewrite D; exists n.\nby move: D n D; case: D n D D /= D n D /= D n D.\nQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D1 D2; split; case: d=>[h1 D2]; case: d=>[h2 D3]; case: d=>[h2 D3]; case: d=>[h3 D4]; case: d=>[h4 D5]; case: d=>[h5 D6].\nrewrite D1 D2 D3 D4 D5 D6 D7 D8 D9 D9 D10 D9 D10.\nmove: D1 D2 D4; case: d=>[h1 D3] D5; case: d=>[h2 D4] D6; case: d=>[h5 D6] D6.\ncase: d=>[h1 D3] D7; case: d=>[h2 D5] D7; case: d=>[h4 D5] D8.\nrewrite D1 D2 D4 D8 D9 D10 D11 D12 D9 D11 D10 D11 D9 D11 D10.\nmove: D1 D2 D3 D4; case: d=>[h1 D2] D11 D8; case: d=>// D1 D2 D4.\ncase: d=>[h3Qed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D1 D2.\nhave: dss =i (D1 ++ D2) by rewrite /D1 D2.\nhave D2: m dss =i (D2 ++ D2) by rewrite /D2 D1 D2.\nhave D3: m dss =i (D2 ++ D3) by rewrite /D3 D3.\nhave D4: m dss =i (D3 ++ D4) by rewrite /D3 D4 D4.\nhave D4: m dss =i (D4 ++ D5) by rewrite /D4 D4 D4 D5.\nhave D5: m dss =i (D5 ++ D4) by rewrite /D4 D5 D5 D6 D7 D8 D9 D9 D9 D10.\nhave D6: m dss =i (D4 ++ D5) by rewrite /D4 D1 D2 D6 D7 D9 D10 D10 D10 D10 D10 D10 D10.\nhave D9: m dss =i (D2 ++ D4) by rewrite /D3 D1 D2 DQed.",
                    "Lemma l1 d: greeter_coh d -> valid (dstate d).\nProof.\nmove=> D1 D2; apply/is_valid_cond=>n D1.\nhave: d =i D1 by exists n; exists (n, n).\nrewrite /D1 /D2; case: n=> [|n]; case: n=> [|n] /= D1 D2.\n  by exists n; exists (n, n).\nrewrite /dctx /D2; case: n=> [|n]; case: n=> // D1 D2; exists n.\nrewrite /D2; case: n=> [|n]; case: n=> [|n]; case: n=> //=.\ncase: n=> [|n]; case: n=> [|n]; case: n=> /=.\n  by rewrite D1 D2 D1 D2; case: n=> //= D2 D3; case: D2 D3.\ncase: n=> [|n]; case: n=> [|n]; case: n=> //.\nby rewrite D2 D1 D2 D3; case: D3 D3 D4; case: D4 D4; case: D5 D4; case: D5 D5; case: D5 D5;\ncase:Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\n",
                "context_tokens": 505,
                "proof_start_offset": 1900,
                "proof_end_offset": 1972,
                "proof": "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof.\nby case; case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by move=> N1 N2 /R1 N2 /R2 /R3/R3/R3/R4/R5. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case. Qed.",
                    "Lemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by move=> D1 D2; exists D2; rewrite /is_valid; case: D1. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "From mathcomp.ssreflect\nRequire Import ssreflect ssrbool ssrnat eqtype ssrfun seq.\nFrom mathcomp\nRequire Import path.\nRequire Import Eqdep.\nRequire Import Relation_Operators.\nFrom fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\n",
                "context_tokens": 535,
                "proof_start_offset": 1974,
                "proof_end_offset": 2050,
                "proof": "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d => // d1 s2 ->. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=> // d; rewrite /dcond /dcond /dcond /dcond. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d => [[n] [/eqP-> /eqP-> /eqP-> /eqP-> /eqP-> ->. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case: d=>[H1][H2][H3][H4]. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed.",
                    "Lemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case; case. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "om fcsl\nRequire Import axioms pred prelude ordtype finmap pcm unionmap heap.\nFrom DiSeL\nRequire Import Freshness State EqTypeX Protocols Worlds NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\n",
                "context_tokens": 686,
                "proof_start_offset": 2529,
                "proof_end_offset": 2640,
                "proof": "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof.\nby move=> H; case: C => _ _ _/(_ n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> n; apply: lcoh. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> m n; rewrite /llim; case: m=> //= m [] []; exists m. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> m; apply: lcoh. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> m n; rewrite /llim /dlock /=!llim_set0. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> m n; rewrite /llim_mx_block?C. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> m n; apply/matrixP=> i j; rewrite!mxE. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case=> m D [n ->]; exists n. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: m=> m /= /orP[]. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by case: m=> m [] [|[|n]] //; exists m. Qed.",
                    "Lemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> a b c d; rewrite /dmachine; case: a=> /= ->. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": "NetworkSem Rely.\nFrom DiSeL\nRequire Import Actions Injection Process Always HoareTriples InferenceRules.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(* The Hello World example - a distributed protocol, allowing anyone send\nanyone a greeting message. *)\n\nModule GreeterProtocol.\nSection GreeterProtocol.\n\n\nVariable fixed_nodes : seq nid.\n\nSection GreeterCoh.\n\n(* All nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\n",
                "context_tokens": 693,
                "proof_start_offset": 2642,
                "proof_end_offset": 2815,
                "proof": "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof.\nby move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H1 H2; rewrite /llim /rlim /rlim /rlim /rlim. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C; case: C=> [] // H1 H2; case: C. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> n; rewrite lcoh0. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C=>D _ _ /(_ n H)/D; rewrite D. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C=>D _ /(_ n H D); case: C D => // ->. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: C=>m H; case: CQed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C=>D _ _ /(_ n H) D; rewrite D. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => // _ /(_ n H) ->. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C=>m H1 H2; case: C=>m H2; case: C. Qed.",
                    "Lemma cohN n v : n \\in fixed_nodes -> find counter (getLocal n d) = Some v -> dyn_tp v = nat.\nProof. by move=> H; case: C => /= _ /(_ n H) ->. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " nodes are welcome to participate in the protocol *)\nDefinition nodes (d : dstatelet) : pred nid := mem fixed_nodes.\n\n(* Defining coherence predicate for the greeter statelet *)\n\nDefinition hello := [:: 3; 1; 1; 0].\nDefinition counter := ptr_nat 1.\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3043,
                "proof_end_offset": 3233,
                "proof": "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (n \\in has_pred) => // _; case: (n \\in has_pred) => // ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (n =P 0)=>m ->; rewrite findPt. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>H1 H2; case: (n =P 0) => [|n] H2; first by rewrite findPt.\ncase: (n =P 0) => [-> | _ _ _ /(_ n H2) H3].\nby rewrite H1 H2 eq_sym H3.\nQed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: m => // ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (n =P 0)=>m ->; rewrite findPt // (eqP eq_refl). Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=> H; case: (n =P 0)=>m ->; rewrite findPt => -> ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: m n => // [s _ _ H] _ _ /negbTE ->. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: m => // _ _ /(_ n H)/eqP. Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof. by move=>H; case: (m) (getnP _) => //= H; rewrite findPt; case: (_ =P _). Qed.",
                    "Lemma getNK n (Hn : n \\in fixed_nodes) m: getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>H1 H2; apply: (iffP idP); last first.\n  by rewrite -(add0mx (cancelN _)) find_eta.\nby case: (n =P 0) => [-> | /addn0]; case: (n =P 0) => [-> | /addn0]; case: (n =P 0) => [-> | /addn0]; case: (n =P 0) => [-> | /addn0].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": ".\n\n(* All messages have fixed shape *)\nDefinition soupCoh : Pred soup :=\n  [Pred s | valid s /\\\n            forall m msg,\n              find m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 3250,
                "proof_end_offset": 3355,
                "proof": "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=> H1; rewrite /simplify; apply: (iffP idP) => [[m]] /= /eqP.\nmove: (H1)=>m; apply: (IH (m := m) (m := m) (n := m).\nby rewrite /simplify; apply: eq_sym; apply: (IH (m := m) (n := m).\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=> // H; apply: (getProp_of_d); rewrite /getProp_of_d.\nby move=> m1 m2; rewrite /getProp_of_d.\nQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (findP _). Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=>H; case: (dmachine_in_pf ST)=>m ->; rewrite /getN.\nmove: (m)=>H; move: (m)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; rewrite H in H.\nmove: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; rewrite H in H.\nmove=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; rewrite H in H.\nmove: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; rewrite H in H.\nmove=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; move: (H)=>H; rewrite H in H.\nmove:Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof.\nmove=> this D; apply/andP; split.\n  by apply/andP; split.\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp; move: (H m).\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp; move: (H m).\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp=>H; move: (H m); rewrite /is_emp.\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp.\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp.\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp=>H; move: (H m); rewrite /is_emp.\nmove: (H m); rewrite /is_emp; move: (H m); rewrite /is_emp.\nmove: (H mQed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (dctx H)=>m ->; rewrite /getN_in_pf. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; rewrite /= /bump_in_pf // => ->. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (dam_step H); apply: (IHnd H). Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; apply: prefixN. Qed.",
                    "Lemma this_in_pf this to d msg : greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by move=>H; case: (find_some H)=>H1; apply: proof_irrelevance. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/disel/Examples/Greeter/Greeter.v",
                "context": " m s = Some msg ->\n              let: from := from msg in\n              let: tag := tag (content msg) in\n              let: val := tms_cont (content msg) in\n              [/\\ from \\in fixed_nodes, \n                  tag == 0 & behead val == hello]].\n\n(* Coherence for the local state ensures that is has just one counter,\n   which we will later use to count incoming messages  *)\nDefinition localCoh : Pred heap :=\n  [Pred h | exists n : nat, h = counter :-> n].\n\n(* Overall coherence *)\nDefinition greeter_coh d : Prop :=\n  let: dl := dstate d in\n  let: ds := dsoup d in\n  [/\\ soupCoh ds, dom dl =i fixed_nodes,\n   valid dl &\n   forall n, n \\in fixed_nodes -> localCoh (getLocal n d)].\n\n(* Axioms of the coherence predicate *)\nLemma l1 d: greeter_coh d -> valid (dstate d).\nProof. by case. Qed.\n\nLemma l2 d: greeter_coh d -> valid (dsoup d).\nProof. by case; case. Qed.\n\nLemma l3 d: greeter_coh d -> dom (dstate d) =i nodes d.\nProof. by case. Qed.\n\n(* Wrapping up the coherence predicate *)\nDefinition GreeterCoh := CohPred (CohPredMixin l1 l2 l3).\nEnd GreeterCoh.\n\nSection GreeterSend.\n\nSection SendBase.\n\nNotation coh := GreeterCoh.\n\n(* Defining send and receive transitions *)\nDefinition greet_safe (this n : nid) (d : dstatelet) msg :=\n  [/\\ this \\in fixed_nodes,\n      n \\in fixed_nodes,\n      exists m, msg == m :: hello &\n      coh d].\n\nSection GreetAux.\n\nVariables (this : nid) (d : dstatelet)\n          (C : coh d).\n\nLemma lcoh n : n \\in fixed_nodes -> localCoh (getLocal n d).\nProof. by move=> H; case: C => _ _ _/(_ n H). Qed.\n\nLemma cohN n v :\n  n \\in fixed_nodes ->\n  find counter (getLocal n d) = Some v ->\n  dyn_tp v = nat.\nProof. by move=>H; case: (lcoh H)=>m->; rewrite findPt /=; case=><-. Qed.\n\nDefinition getN n (pf : n \\in fixed_nodes) : nat := \n  match find counter (getLocal n d) as f return _ = f -> _ with\n    Some v => fun epf => icast (sym_eq (cohN pf epf)) (dyn_val v)\n  | None => fun epf => 0\n  end (erefl _).\n\nLemma getNK n (Hn : n \\in fixed_nodes) m:\n  getLocal n d = counter :-> m -> getN Hn = m.\nProof.\nmove=>E; rewrite /getN; move: (cohN)=>H.\nby move: (H n)=>{H}; rewrite E=>H/=; apply: eqc.\nQed.\n\nEnd GreetAux.\n\nLemma this_in_pf this to d msg :\n  greet_safe this to d msg -> this \\in fixed_nodes.\nProof. by case. Qed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 3357,
                "proof_end_offset": 3445,
                "proof": "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nby case.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m.\napply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m.\nby apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat=>m; apply/unvs_cat.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H; apply/eqP; rewrite -has_cat => /findgr_has_cat.\nby rewrite -H_has_cat.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by case. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H; case: m=> //= m H; case: m=> //= m H; move: (H m); rewrite!inE => /eqP.\ncase: m=> /= H; move: (H m); rewrite!inE => /eqP.\ncase: m=> //= m H; move: (H); rewrite!inE => /eqP.\ncase: m=> // m H; move: (H m); rewrite!inE=> /eqP.\ncase: m=> // m H; move: (H); rewrite!inE=> /eqP.\ncase: m=> /= m H; move: (H m); rewrite!inE=> /eqP.\ncase: m=> // m H; move: (H); rewrite!inE=> /eqP.\ncase: m=> //= m H; move: (H m); rewrite!inE => /eqP.\ncase: m=> //= m H; move: (H); rewrite!inE=> /eqP.\ncase: m=> //= m H; move: (H m); rewrite!inE=> /eqP.\ncase: m=> //= m H; move: (H m); rewrite!inE => /eqP.\ncase: mQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: m H => // H _ _ /H_F_pre. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /seq_of_d /= (ddom_get, ddom_get, ddom_get, ddom_get, ddom_get, ddom_get, ddom_get, ddom_find, ddom_find, ddom_find, ddom_find, ddom_find, ddom_find. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof.\nmove=>H1 H2; apply/permP=> [[d1 d2] [[d2 d3]] /= H3; rewrite!unvs_cat.\nby rewrite!unvs_cat!unvs_cat!unvs_cat!unvs_cat!unvs_cat!unvs_cat!unvs_cat.\nQed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; case: (m); [left | right]. Qed.",
                    "Lemma greet_safe_coh this to d m : greet_safe this to d m -> coh d.\nProof. by move=>H; rewrite /unulet_safe; apply: (unul_coherent_coherent_coherent_coherent_coherent). Qed."
                ]
            }
        ],
        "zchinese": [
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\n",
                "context_tokens": 86,
                "proof_start_offset": 284,
                "proof_end_offset": 841,
                "proof": "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros.\nclear H4 H5 H7 H10.\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H.\nunfold is_group in H0.\nintuition.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\napply (well_founded_induction_type (fun x y => x = y \\/ x = y));\nintros; apply H1; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold group in H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H2.\nrewrite H1.\nrewrite H2.\nrewrite H2.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H1.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H1.\nrewrite H3.\nrewrite H4.\nrewrite H2.\nrewrite H1.\nrewrite H4.\nrewrite H3.\nrewrite H3.\nrewrite H3.\nrewrite H4.\nrewrite H1.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H1.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nrewrite H4.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewriteQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\napply H.\napply H0.\nintros x0 y z H0 H1; apply H1; assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  unfold G in H.\n  assert (H0 := H0 H1).\n  unfold G in H0.\n  assert (H1 := H1).\n  assert (H2 := H2).\n  unfold G in H2.\n  elim H1; intros.\n  assumption.\n  unfold G in H3.\n  assert (H4 := H5).\n  unfold G in H4.\n  elim H5; intros.\n  assumption.\n  unfold G in H4.\n  elim H5; intros.\n  assumption.\n  unfold G in H4.\n  elim H5; intros.\n  assumption.\n  unfold G in H4.\n  elim H6; intros.\n  assumption.\n  unfold G in H4.\n  elim H6; intros.\n  assumption.\n  unfold G in H4.\n  elim H7; intros.\n  assumption.\n  unfold G in H8.\n  elim H8; intros.\n  assumption.\n  unfold G in H8.\n  elim H8; intros.\n  assumption.\n  unfold G in H8.\n  elim H8; intros.\n  assumption.\n  unfold G in H8.\n  elim H8; intros.\n  assumption.\n  unfold G in HQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nintros.\nunfold G in H.\napply H.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  assert (H0 := H0 x).\n  rewrite H0 in H0.\n  rewrite H0 in H1.\n  assumption.\nQed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\n  intros.\n  unfold is_group in H0.\n  elim H0; intros.\n  unfold group_eq in H2.\n  elim H2; intros.\n  unfold group_eq in H4.\n  elim H4; intros.\n  unfold group_eq in H5.\n  elim H5; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H6.\n  elim H6; intros.\n  unfold group_eq in H7.\n  elim H7; intros.\n  unfold group_eq in H8.\n Qed.",
                    "Lemma regular_l : is_group -> forall y z : S, G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nunfold is_group in H0.\nelim H0; intros H1 H2; elim H2; intros H3 H4; elim H4;\n intros H5 H6; elim H7; intros H7 H8; elim H8;\n intros H9 H10; elim H10; intros H10 H10; elim H10;\n intros H10 H11; elim H10; intros H11; elim H12; intros H13;\n elim H13; intros H14 H15; elim H14; intros H15; elim H15; \n intros H15 H15; elim H16; intros H17 H17; elim H16; \n intros H16 H18; elim H16; intros H18; elim H18; \n intros H18 H18; elim H18; intros H19 H20; elim H19; \n intros H20 H20; elim H20; intros H18 H20; elim H22; \n intros H18 H19; elim H19; intros H20 H20; elim H22;\n intros H20 H20; elim H20; intros H18 H20; elim H20;\n intros H20Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\n",
                "context_tokens": 316,
                "proof_start_offset": 843,
                "proof_end_offset": 1170,
                "proof": "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; intros; elim H4; intros; elim H5;\n clear H4 H5 H6 H7 H8 H10 H11.\n(* use of opposite *)\nelim (H7 (Add x1 y1) x2 y1); intros; elim H6; clear H5 H6.\n(* use of opposite *)\nelim (H7 (Add y1 y2) x1); intros; elim H6; clear H5 H7 H8 H9 H10.\n(* use of opposite *)\nelim (H7 (Add y1 y2) x2 y1); intros; elim H6; clear H6 H6.\nelim (H7 (Add y1 y2) x2 y1); intros; elim H6; clear H6 H7 H8 H9 H10.\n(* use of opposite *)\nelim (H7 (Add y1 y2) x1 y1); intros; elim H6; clear H6 H7 H9 H10.\nclear H3.\nelim (H7 (Add y1 y2) x2 y1);Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nclear H4 H5 H6 H7.\nrewrite <- H0; rewrite <- H1; rewrite <- H2; auto.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n clear H4 H5 H8 H9 H10.\nelim (H12 y1 H1); intros; elim H5; clear H5 H5 H7 H8 H9.\nelim (H12 y2 H1); intros; elim H5; clear H5 H5 H8 H9.\nelim (H12 y2 H2); intros; elim H6; clear H6 H7 H8 H9.\nelim (H13 y1 H2); intros; elim H6; clear H6 H7 H8 H9.\nelim (H12 y2 H3); intros; elim H6; clear H6 H7 H8 H9.\nelim (H12 y2 H3); intros; elim H6; clear H6 H7 H9.\nelim (H13 y2 H3); intros; elim H6; clear H6 H7 H8 H9.\nelim (H13 y2 H3); intros; elim H6; clear H6 H7 H8 H9.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros; elim H;\n intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H; intros;\n elim H; intros; elim H; intros; elim H0; intros;\n elim H0; intros; elim H0; intros; elim H1; intros;\n elim H1; intros; elim H2; intros;\n elim H2; intros; elim H3; intros; elim H4; intros;\n elim H5; intros; elim H6; intros; elim H6;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros;\n elim H4; clear H4 H5 H6 H7; intros.\nclear H4 H5 H7 H8 H9 H10 H11.\nelim (H1 z H1); intros; elim H5; clear H5 H5 H6 H7 H8 H9 H10.\nelim (H2 z H2); intros; elim H5; clear H5 H6 H7 H8 H9 H10.\nelim (H2 z H1); intros; elim H5; clear H5 H6 H7 H8 H9 H10.\nelim (H1 z H2); intros; elim H5; clear H5 H5 H7 H9 H10.\nelim (H3 z H1); intros; elim H5; clear H5 H6 H7 H9.\nelim (H3 z H1); intros; elim H6; clear H5 H6 H7 H8 H9.\nelim (H3 z H1); intros; elim H6; clear H6 H7 H9.Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H2; clear H1 H2; intros.\nclear H4 H6 H7 H8 H9 H10 H11.\nrewrite H4; reflexivity.\nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros;\n elim H1; intros; elim H3; intros; elim H4; intros;\n elim H4; intros; elim H5; intros; elim H5; intros;\n elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; \n elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H9; intros; \n elim H8; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H11; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \nQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H5; clear H5.\nelim (H10 y H1); intros; elim H6; clear H6.\nelim (H10 y H1); intros; elim H7; clear H7 H8 H8 H9 H10.\n(* use of opposite *)\nelim (H8 y H3); intros; elim H7; clear H7 H8 H9.\nelim (H10 y H3); intros; elim H8; clear H8 H8 H9 H10.\nelim (H10 y H4); intros; elim H8; clear H8 H8 H9 H10.\nelim (H10 y H4); intros; elim H8; clear H8 H8 H9 H10.\nelim (H10 y H4); intros; elim H8; clear H8 H9 H9 H10.\nelim (H10 y H4); intros; elim H8; clear H8 H9 H9 H10.\nelim (H10 y H4); intros; elim H8; clear H8 H9 H9 H10.\nelim (H10 y H4); intros;Qed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H; intros; elim H3; intros; elim H4; clear H4 H5.\nelim (H7 y H1); intros; elim H5; clear H5 H5 H6.\nelim (H7 y H1); intros; elim H5; clear H5 H6.\nelim (H7 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H7 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H2); intros; elim H6; clear H6 H6.\nelim (H8 y H2); intros; elim H5; clearQed.",
                    "Lemma add_add : commutativity S Add -> associativity S Add -> forall x1 y1 x2 y2 : S, Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros.\nelim H0; intros; elim H1; intros; elim H3; intros; elim H3; clear H3.\nelim (H7 y H1); intros; elim H3; intros; elim H4; clear H4 H5 H6.\nelim (H7 y H2); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H7 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H2); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H5; clear H5 H6.\nelim (H8 y H1); intros; elim H6; clear H6 H6.\nelim (H8 y H3); intros; elim H6; clear H6 H6.\nelim (H9 y H1); intros; elim H6; clear H6 H6.\nelim (H7 y H1); intros; elim H6; clear H6.\nelim (H7 y HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\n",
                "context_tokens": 459,
                "proof_start_offset": 1172,
                "proof_end_offset": 1792,
                "proof": "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H0; intros; elim H2; intros.\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\nelim (H7 (Opp x) x y).\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\nelim H9; intros; elim (H0 (Opp x) H3); intros.\nexact H1.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; clear H1 H2.\nelim (H1 (Add x1 y1)); intros; elim H3; intros; clear H3 H4.\nrewrite (IH y1 x2 y1); elim (IH y1 y1 y2); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3;\n clear H3 H4 H5 H6 H7 H8 H9 H10 H11.\nrewrite <- (minus_n_O_eq _ _ H); rewrite (minus_n_O_eq _ _ H0); reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros x y H.\nrewrite (ass (Add x y) x y); elim (minus_irrefl y H).\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2;\n clear H1 H2 H3.\nelim (H3 x1); intros; elim H3; intros; elim H4; clear H4 H5 H6.\nelim (H3 x1); intros; elim H5; clear H5 H6 H7.\nelim (H3 x1); intros; elim H6; clear H6 H7.\nelim (H4 x1); intros; elim H6; clear H6 H7.\nelim (H5 x1); intros; elim H6; clear H6 H7.\nelim (H6 x1); intros; elim H6; clear H6 H7.\nelim (H6 x1); intros; elim H6; clear H6 H7.\nelim (H6 x1); intros; elim H6; clear H6 H7.\nelim (H7 x1); intros; elim H6; clear H6 H7.\nelim (H7 x2); intros; elim H6; clear H6 H7.\nelim (H7 x1); introsQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H0; intros; elim H0; intros; elim H1;\n intros; elim H1; intros; elim H2; intros; elim H3;\n intros; elim H4; intros; elim H4; intros; elim H5;\n intros; elim H5; intros; elim H6; intros; elim H6;\n intros; elim H6; intros; elim H6; intros; elim H7;\n intros; elim H7; intros; elim H7; intros; elim H8; \n intros; elim H8; intros; elim H8; intros; elim H9; \n intros; elim H9; intros; elim H9; \n intros; elim H9; intros; elim H9; intros; elim H9; \n intros; elim H10; intros; elim H9; intros; elim H10; \n intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10Qed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2;\n intros; elim H3; clear H3 H4; intros; elim H4;\n intros; elim H5; clear H5 H7; intros; elim H5;\n clear H5 H7 H8 H9 H10 H11.\nrewrite <- H0; rewrite <- H1; rewrite <- H2; reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H; intros; elim H; intros; elim H; intros;\n elim H0; clear H0; intros; elim H0; intros; elim H0; intros.\nclear H0.\nrewrite H0; rewrite H1; reflexivity.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; clear H3.\nintros; apply H1; apply H2; apply H3; apply H4; apply H4; apply opp_inj; auto.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\napply same_morphism_l.\nQed.",
                    "Lemma opp_unicity : is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\nelim H; intros; elim H0; intros; elim H1; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5;\n clear H4 H5 H6 H7.\n(* use of neutral *)\nelim (H0 x H1); intros; elim H3; intros; elim H5; intros; elim H6;\n clear H5 H7 H8 H9 H10.\nrewrite <- H1; rewrite <- H2; rewrite <- H4; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "Require Export Lci.\nRequire Export misc.\n\nSection groups.\n\nVariable S : Set.\nVariable G : S -> Prop.\nVariable Add : S -> S -> S.\nVariable O : S.\nVariable Opp : S -> S.\n\nDefinition is_group :=\n  intern S G Add /\\\n  associativity S Add /\\ neutral S G Add O /\\ opposite S G Add O Opp. \n\nLemma regular_l :\n is_group ->\n forall y z : S,\n G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.\nProof.\nintros.\nelim H; intros; elim H5; intros; elim H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 1794,
                "proof_end_offset": 2147,
                "proof": "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (Ropp_involutive x); rewrite Ropp_involutive; reflexivity.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite H; rewrite H; rewrite H0; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite <- H; clear H0.\nrewrite <- H; clear H0.\nrewrite H; clear H0.\nrewrite <- H; clear H0.\nrewrite H; clear H0.\nrewrite H; clear H0.\nrewrite <- H; clear H0Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (inj_pos_pos x H).\nrewrite (inj_pos_pos x H).\nrewrite (inj_pos_neg x H).\nrewrite <- (inj_pos_neg x H).\nrewrite (inj_pos_pos x H).\nrewrite <- (inj_neg_pos x H).\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nring.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_Qed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros; elim H; intros; rewrite H; clear H; rewrite opp_def; clear H; auto.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive x).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (opp_involutive (- x)).\nrewrite <- (oppQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite (opp_involutive x H).\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H.\nring.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite (add_comm x x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nrewrite (opp_involutive x).\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply Ropp_involutive.\nQed.",
                    "Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H0.\nrewrite H.\nrewrite H.\nrewrite H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": " H7; intros; elim H8; intros. \nclear H4 H5 H7 H10.\n(* use of neutral *)\nelim (H11 y H0); intros; elim H5; clear H4 H5.\nelim (H11 z H1); intros; elim H5; clear H4 H5 H8 H11.\n(* use of opposite *)\nelim (H9 x H2); intros; elim H5; intros; elim H8; intros; elim H11. \nclear H4 H5 H7 H8 H9 H10 H11.\n(* use of associativity *)\nelim (H6 (Opp x) x y); elim (H6 (Opp x) x z).\nelim H3; reflexivity.\nQed.\n\nLemma add_add :\n commutativity S Add ->\n associativity S Add ->\n forall x1 y1 x2 y2 : S,\n Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).\nProof.\nintros com ass x1 y1 x2 y2.\nrewrite (ass (Add x1 y1) x2 y2); elim (ass x1 y1 x2); elim (com x2 y1).\nrewrite (ass x1 x2 y1); elim (ass (Add x1 x2) y1 y2); reflexivity.\nQed.\n\nLemma opp_unicity :\n is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.\nProof.\nintros.\n(* [G y] *)\nelim H0; intros; elim H2; intros.\n(* [y = 0+y] *)\nelim H; intros; elim H6; intros; elim H8; intros; elim H9; intros.\nelim (H12 y H3); intros; elim H14; clear H H2 H3 H5 H6 H8 H11 H12 H13 H14.\n(* [0=(-x)+x] *)\nelim (H10 x H1); intros; elim H2; intros; elim H5; intros; elim H8.\nclear H H1 H2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 2149,
                "proof_end_offset": 3302,
                "proof": "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry in |- *; apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros.\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros.\nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros.\nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\nelim H7; intros; exact (H0 O H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x) y).\nunfold is_group in |- *; split.\nelim H0; intros; elim H2; intros; elim H3; intros; elim H4; intros; elim H5; intros; \n elim H5; intros; elim H6; intros; elim H6; intros; \n elim H6; intros; elim H7; intros; elim H7; intros; \n elim H8; intros; elim H8; intros; elim H8; intros; \n elim H8; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H9; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; introsQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H; intros; elim H1; intros; elim H2; intros; elim H4; intros; elim H4; intros; \n elim H5; intros; elim H5; intros; elim H5; intros; \n elim H7; intros; elim H8; intros; elim H8; intros; \n elim H9; intros; elim H9; intros; elim H9; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; \n intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros; elim H10; intros; \n elim H10; intros; elim H10; intros;Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_transitive H (Opp x y)).\napply (opp_unicity H (Equivalence y) (Equivalence y)).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\napply (opp_unicity H (Opp x y)).\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_domain in |- *; intros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Opp y x)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Float x y)).\nunfold is_group in |- *; intros.\napply (opp_unicity H (Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) (x:=y) (x:=y) (x:=y) (x:=y) (y:=x) (y:=x) (y:=y) (x) (z:=y) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z) (z:=z)Qed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y)).\nunfold is_group in |- *; split.\nelim H; intros; elim H3; intros; elim H4; intros; elim H5; intros; clear H5 H6;\n elim (H7 x H5); intros; elim H7; intros; elim H8; intros; clear H8;\n elim H9; intros; elim H9; intros; clear H10;\n elim H10; intros; elim H10; clear H10;\n elim (H10 x H1); intros; elim H10; intros; clear H10;\n elim H10; intros; elim H10; clear H10;\n elim (H10 x H1); intros; clear H10; \n elim (H10 x H1); intros; clear H10; \n elim H10; intros; elim H10; clear H10; \n elim (H10 x H1); intros; clear H10; \n elim (H10 x H1); intros; clear H10; \n elim (H10 x H1); intros; clear H10; \n elim H10; intros; elim H10; clear HQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (mk:=fun x y => x) (x:=y) (y:=x) (y:=x));\n try assumption.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\nrewrite (opp_transitive H (Opp x y)).\nunfold is_group in |- *; split.\nelim H0; intros; elim H2; intros; elim H3; intros; elim H4; intros; clear H4 H5 H6 H7;\n apply opp_involutive; auto with *.\nQed.",
                    "Lemma opp_add : is_group -> commutativity S Add -> forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros.\napply (opp_unicity H (Opp x y) H).\nunfold is_group in |- *; simpl in |- *; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/groups.v",
                "context": "2 H5 H6 H8 H10.\n(* [((-x)+x)+y=(-x)+(x+y)] *)\nelim (H7 (Opp x) x y).\n(* [x+y = 0] *)\nelim H4; intros; rewrite H; clear H H0 H1 H4 H7.\n(* [(-x)+0=(-x)] *)\nelim H9; intros; elim (H0 (Opp x) H3); intros. exact H1.\nQed.\n\nLemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).\nProof.\nintros.\napply (opp_unicity H (Opp x) x).\nunfold is_opposite in |- *; split.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros. \nelim H8; trivial.\nelim H; intros; elim H2; intros; elim H4; intros; elim (H6 x H0); intros.\nelim H8; intros; elim H10; auto.\nQed.\n\nLemma opp_add :\n is_group ->\n commutativity S Add ->\n forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).\nProof.\nintros; symmetry  in |- *;\n apply (opp_unicity H (Add x y) (Add (Opp x) (Opp y))).\nunfold is_opposite in |- *; split.\n(* [G (x+y)] *)\nelim H; intros; apply (H3 x y H1 H2).\nsplit.\n(* [G ((-x)+(-y))] *)\nelim H; intros; elim H4; intros; elim H6; intros; clear H4 H5 H6 H7.\nelim (H8 x H1); intros; elim H5; intros; clear H4 H5 H7.\nelim (H8 y H2); intros; elim H5; intros.\napply (H3 (Opp x) (Opp y) H6 H7).\n(* [(x+y)+((-x)+(-y)) = 0 & ((-x)+(-y))+(x+y) = 0] *)\nelim H; intros; elim H4; intros; clear H3 H4 H6.\nrewrite (add_add H0 H5 x y (Opp x) (Opp y)).\nrewrite (add_add H0 H5 (Opp x) (Opp y) x y); clear H5.\nelim H; intros; elim H4; intros; elim H6; intros. \n  (* [x+(-x) = 0 (-x)+x = 0] *)\nelim (H8 x H1); intros; elim H10; intros; elim H12; intros. \nrewrite H13; rewrite H14.\nclear H H0 H1 H3 H4 H5 H6 H9 H10 H11 H12 H13 H14.\n  (* [y+(-y) = 0 (-y)+y = 0] *)\nelim (H8 y H2); intros; elim H0; intros; elim H3; intros. \nrewrite H4; rewrite H5.\nclear H H0 H1 H2 H3 H4 H5 H8.\n  (* [0+0 = 0] *)\nelim H7; intros; exact (H0 O H).\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 3304,
                "proof_end_offset": 3522,
                "proof": "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros.\nelim (opp_unicity H O O).\nreflexivity.\nunfold is_opposite in |- *.\nelim H; intros; elim H1; intros; elim H3; intros; elim H4; intros.\nelim (H7 O H6); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nintros; apply (opp_unicity H (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (Opp (OppQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros.\napply (opp_unicity H (Opp (O * O) H)).\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; simpl in |- *.\nintros; apply not_eq_sym; apply not_eq_sym.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O in |- *; intros.\napply opp_opp.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp in |- *; intros; rewrite <- (opp_id O); auto with *.\nQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nsplit.\nrewrite H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H0.\nrewrite <- H.\nrewrite <-Qed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, O, OQed.",
                    "Lemma opp_neutral : is_group -> Opp O = O.\nProof.\nunfold Opp, O in |- *; simpl in |- *.\nintros; rewrite opp_sym; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_involutive; rewrite opp_involutive; rewrite opp_involutive;\n rewrite opp_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 122,
                "proof_end_offset": 234,
                "proof": "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intro A P.\n  apply (Build_extensionality A P).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P.\n  apply (Build_Predicate (P:=fun a => P a)).\n  exact (fun (a:A) (b:A) => P a).\n  Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  apply functional_extensionality with (R := A).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P H.\n  exists (fun x => P (f x)).\n  apply (H (f x)).\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP.\n  apply HP.\n  apply HQ.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP x.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, R x x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, R x x -> Prop).\n  intros x HP.\n  pose (R := forall x : A, R x x).\n  intros x HP.\n  pose (R := forall x : A, P x -> Prop).\n  intros x HP.\n  pose (R :=Defined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP x.\n  elim (R x); [left | right ]; intros; assumption.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P P HP.\n  apply P.\n  intro x.\n  destruct x.\n  reflexivity.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P.\n  destruct (H (fun x : A => P (f x))).\n  left.\n  apply (H _ (fun x : A => P (f x))).\n  left.\n  apply H.\nDefined.",
                    "Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\n  intros A P HP x.\n  destruct (HP x) as (x,Hx).\n  assumption.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\n",
                "context_tokens": 89,
                "proof_start_offset": 236,
                "proof_end_offset": 378,
                "proof": "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nintros x H1; inversion_clear H1.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_clear H2.\nintros x H2; inversion_Qed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p.\nintros.\napply H.\nintros x0.\napply H0.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction 1; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed.",
                    "Lemma pi2 : forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/misc.v",
                "context": "Require Export Lci.\n\nDefinition antisym (A : Set) (R : A -> A -> Prop) :=\n  forall x y : A, R x y -> R y x -> x = y :>A.\n\nDefinition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.\nProof.\nsimple induction 1; auto.\nDefined.\n\nLemma pi2 :\n forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).\nProof.\nsimple induction p; unfold pi1 in |- *; trivial.\nQed.\n\nDefinition inversible (S : Set) (Mult : S -> S -> S) \n  (I x : S) := exists y : S, Mult x y = I /\\ Mult y x = I.\n\n\n",
                "context_tokens": 192,
                "proof_start_offset": 495,
                "proof_end_offset": 763,
                "proof": "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nintros; unfold inversible in |- *.\nelim H0; intros.\nexists x0.\nsplit.\nassumption.\nelim (H x x0); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S x0).\nrewrite H0.\ntrivial.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H1.\ninversion H1.\ninversion H2.\ninversion H2.\ninversion H3.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H4.\ninversion H5.\ninversion H6.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H6.\ninversion H6.\ninversion H6.\ninversion H7.\ninversion H6.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nexists (S x0).\nexists (S x0).\nexists (S x0).\nexists (S x0).\nreflexivity.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H7.\ninversion H7.\ninversion H5.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H9.\ninversion H9.\ninversion H8.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H11; intros.\nelim H12; intros.\nelim H11; intros.\nelim H13; intros.\nelim H13; intros.\nelim H14; intros.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\nelim H0.\nelim H1.\n intros.\nelim H2.\nelim H3; intros.\nelim H3; intros.\nelim H4; intros.\nexists (S x0).\nsplit; trivial.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H5; intros.\nelim H6; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; introsQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; intros.\ninversion H0.\ninversion H1.\ninversion H2.\ninversion H3.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H4.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H5.\ninversion H6.\ninversion H6.\ninversion H6.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H7.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H8.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\ninversion H9.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; auto.\nintro H0; case H0; intros.\nexists (S x0); exists (S x0); split; auto.\nQed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 1; simpl in |- *; intros.\nelim H1; clear H1; intros.\nelim H2; clear H2; intros.\nelim H3; clear H3; intros.\nelim H4; clear H4; intros.\nelim H4; clear H4; intros.\nelim H4; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H6; intros.\nelim H6; clear H5; intros.\nelim H7; clear H7; intros.\nelim H7; clear H7; intros.\nelim H7; clear H7; intros.\nelim H7; clear H7; intros.\nelim H7; clear H7; intros.\nelim H7; clear H7; intros.\nelim H8; clear H8; intros.Qed.",
                    "Lemma inv_com : forall (S : Set) (Mult : S -> S -> S) (I x : S), commutativity S Mult -> (exists y : S, Mult x y = I) -> inversible S Mult I x.\nProof.\nsimple induction 2; intros.\nexists y0.\nexists (S x0).\ntrivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\n",
                "context_tokens": 65,
                "proof_start_offset": 227,
                "proof_end_offset": 453,
                "proof": "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; unfold Z_group;\n unfold Z_group; unfold Z_group; simpl; unfold Z_group;\n unfold Z_inverse; unfold Z_inverse;Qed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  intros.\n  unfold Z.\n  apply (Z_group_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse Z_inverse ZQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  unfold Z_group in |- *.\n  intros x y z.\n  case z; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z.opp in |- *.\nintros x; case x.\nsimpl in |- *; auto with *.\nintros x y z; simpl in |- *; auto with *.\nintros x y z; simpl in |- *; auto with *.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  now intros [x1 x2| x2| x3]; simpl.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nintro x; unfold Z_group; simpl.\nintros x; case x.\nsimpl.\nintros x H'; case H'; auto.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\n  constructor.\n  exact Z_group_power_nat_eq_compat.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z_group, Z_group, Z_group, Z_group in |- *.\nintros x y.\nrewrite <- (group_inverse _ y) in H0.\napply Z_group_inverse.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nunfold Z_group in |- *.\nintros x; case x.\nsimpl in |- *.\nauto with *.\nQed.",
                    "Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nunfold Z.opp.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_mult.\nrewrite Z_group_multQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n",
                "context_tokens": 167,
                "proof_start_offset": 529,
                "proof_end_offset": 762,
                "proof": "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nexact Z_group.\nsplit.\nunfold intern in |- *.\nintros.\nexact I.\nsplit; red in |- *; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; simpl in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; simpl in |- *.\nsplit; simpl in |- *.\nintros H H0; case H0; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\napply Z_ring_unit_left.\napply Z_ring_unit_left.\nQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nintros p; case p; simpl in |- *; auto with zarith.\nintros p; case p; simpl in |- *; auto with zarith.\nintros p; case p; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl in |- *; auto with zarith.\nintros p0; case p0; simpl inQed.",
                    "Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\n",
                "context_tokens": 245,
                "proof_start_offset": 764,
                "proof_end_offset": 1037,
                "proof": "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit.\nexact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; intros.\napply Z_unitary_facts_ring.\napply Z_unitary_for_ring.\napply Z_unitary_for_ring.\napply Z_unitary_ring.\napply Z_unitary_ring.\napply Z_unitary_ring.\napply Z_unitary_ring.\napply Z_unitary_ring.\napply Z_unitary_ring.\napply Z_unitary_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_unitary_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply Z_uniting_ring.\napply ZQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit; red in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nintros x y H H0.\napply Z_unit_for_left_inverse_inverse_inverse_inverse_inverse_inverse_inverse; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *; auto with zarith.\napply Z_unit_for_ring; auto with zarith.\nQed.",
                    "Theorem Z_unitary_commutative_ring : is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitfor_unitfor_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\n",
                "context_tokens": 346,
                "proof_start_offset": 1070,
                "proof_end_offset": 1413,
                "proof": "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\nintros; left; reflexivity.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_char, Z_one in |- *.\nintros.\nelim H; intros.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_antisym.\napply Zle_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_one in |- *.\nrewrite (fun x : Z => (- x)%Z).\napply Z_one.\napply Z_one.\napply Z_one.\napply Z_one.\napply Z_one.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_char in |- *.\napply Z_normal_eq; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nunfold Z_scope.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nsplit.\nred in |- *; auto with zarith.\napply Z_one_div_one_div_one_div_one_div_one_div_one_div_one.\napply Z_one_div_one_div_one_div_one_div_one_div_one_div.\napply Z_one_div_one_div_one_div_one_div.\napply Z_one_div_one_div_one_div.\napply Z_one_div_one_div.\napply Z_one_div_one_div.\napply Z_one_div_one_div.\napply Z_one_div_one_div.\napply Z_one_div_one_div.\napply Z_one_div_div.\napply Z_one_div_one_div.\napply Z_one_div_div.\napply Z_one_div_div.\napply Z_one_div_div.\napply Z_one_div_div.\napply Z_one_div_div.\napply Z_one_div_div.\napply Z_oneQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nsplit.\nred in |- *; auto with zarith.\nsplit.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_pos.\napply Z_div_Qed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_char in |- *.\nsplit.\nexact Z_scalar_bound_Z.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold is_scalar in |- *.\nsplit.\nred in |- *; auto with zarith.\nQed.",
                    "Theorem integrityZ : integrity Z Zmult 0%Z.\nProof.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\napply Z_ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zchinese/Zstruct.v",
                "context": "Require Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export groups.\nRequire Export rings.\nRequire Export ZArith.\nRequire Import Omega.\n\n(* Addition on Z, (Z, +) is a group *)\n\nDefinition IdZ (x : Z) := True.\n\nTheorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.\nProof.\nsplit.\nred in |- *; trivial.\nsplit.\nred in |- *; auto with zarith.\nsplit; red in |- *.\nsplit; auto with zarith.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\nTheorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.\nProof.\nunfold is_ring in |- *.\nsplit.\nred in |- *; auto with zarith.\nsplit. exact Z_group.\nsplit. unfold intern in |- *. intros. exact I.\nsplit; red in |- *; auto with zarith.\nQed.\n\nTheorem Z_unitary_commutative_ring :\n is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.\nProof.\nunfold is_unitary_commutative_ring in |- *.\nsplit. exact Z_ring.\nsplit.\nred in |- *; auto with zarith.\nsplit.\nunfold IdZ in |- *; trivial.\nsplit; auto with zarith.\nQed.\n\n(* Z is an integral domain *)\n\nTheorem integrityZ : integrity Z Zmult 0%Z.\nProof.\nunfold integrity in |- *.\nintros a b; elim a.\n(* OZ *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* neg n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.\n\n",
                "context_tokens": 458,
                "proof_start_offset": 1415,
                "proof_end_offset": 2552,
                "proof": "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nunfold inversible in |- *.\nintros.\ninversion_clear H.\ninversion_clear H0.\nclear H1.\ngeneralize H; clear H.\nelim (Z_lt_ge_dec 0 x); intros.\nleft.\nelim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.\ncut (1 > x0)%Z; intros.\nabsurd (0 < x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with x; auto with zarith.\napply Zmult_gt_reg_r with x; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.\nelim (Z_le_lt_eq_dec x 0); auto with zarith; intros.\nclear b.\nright.\nelim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.\ncut (1 > - x0)%Z; intros.\nabsurd (0 < - x0)%Z; intros; auto with zarith.\napply Zgt_lt.\napply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\napply Zmult_gt_reg_r with (- x)%Z; auto with zarith.\nrewrite Zmult_1_l; rewrite Zmult_comm.\nrewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r; auto with zarith.\nrewrite b0 in H; simpl in H; inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; case x.\n(* neg n *)\nintros H; left.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; right.\nrewrite H; auto.\n(* pos n *)\nintros H; left.\nrewrite H; auto.\n(* pos n *)\nintros H; left.\nrewrite H; auto.\n(* pos n *)\nintrosQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; right; left; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; clear H; intros.\n(* pos n *)\nintros; left; reflexivity.\n(* neg n *)\nintros; left; reflexivity.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\n(* pos n *)\nintros; right.\ngeneralize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H.\ncase (Zle_or_lt 0 x).\nintros H; right; right.\nright; left; reflexivity.\nright; left; reflexivity.\nright; left; reflexivity.\nright; right; left; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; elim Hx; clear Hx; intros.\n(* positive *)\nintros; right.\ngeneralize Hx; clear Hx; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hy; simpl in Hy.\ngeneralize Hx; clear Hy; simpl in Hy.\ngeneralize Hx; clear Hy; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hx.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hy; simpl in Hy.\ngeneralize Hx; clear Hy; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hx; simpl in Hy.\ngeneralize Hx; clear Hy; simpl in Hy.Qed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H; elim H.\nintros; right; right; reflexivity.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; case x.\nintros; right.\napply Z_mult_cancel_l with (1 := Hx).\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; elim H.\nintros; right.\ngeneralize H; clear H; simpl in |- *; case x; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x Hx; case x; case x; simpl in |- *; intros; inversion H; trivial.\nQed.",
                    "Lemma inversibleZ : forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \\/ x = (-1)%Z.\nProof.\nintros x H; split.\napply Z_linear_Zmult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_mult.\napply Z_linear_Qed."
                ]
            }
        ],
        "zfc": [
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\n",
                "context_tokens": 334,
                "proof_start_offset": 1596,
                "proof_end_offset": 1761,
                "proof": "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* Proof of lem_irrefl *)\nunfold fun in |- *; unfold fun_ in |- *; unfold fun_ in |- *; unfold fun_ in |- *;\n unfold fun_ in |- *; unfold fun_ in |- *; intros.\nelim\n (axs_comprehension\n    (fun f : E =>\n     fun_ f : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ f_ : E =>\n     fun_ fQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n\n(* Proof of lem_pair_is_a_empty. *)\nunfold singleton in |- *; simpl in |- *; intros.\napply axs_extensionnalite; unfold iff in |- *; split; intros.\nunfold dom in H0; unfold iff in H0; unfold iff in |- *;\n split; intros.\nunfold dom in H0; unfold iff in H0; unfold iff in H0;\n split; intros.\nunfold dom in H0; unfold iff in H0; unfold iff in H0;\n split; intros.\nunfold dom in H0; unfold iff in |- *; split; intros.\nunfold dom in H0; unfold iff in H0; unfold iff in H0;\n split; intros.\napply H0; assumption.\n\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof fun E : Ens => fun F : Ens => refl_antisym E F.\n\nTheorem empty_is_empty : forall (E : Ens) (x : E), ~ in_dom E x.\nProof fun E : Ens => fun F : Ens => fun F : Ens => refl_antisym E F.\n\nSection empty.\nVariable E : Ens.\nHypothesis\n  union_empty :\n    forall (A : Ens) (x : E),\n    in_part A x -> in_part A x.\n\nDefinition union (A B : Ens) (x : E) : Prop :=\n  in_part A x /\\ in_part A x.\n\nEnd empty.\n\nTheorem empty_not_empty : forall (E : Ens) (x : E), ~ in_part E x.\nProof fun E : Ens => fun F : Ens => empty_not_empty E F.\n\nTheorem empty_not_empty_not_empty : forall (E : Ens) (x : E), in_part A x.\nProof fun E : Ens => empty_not_empty E F.\n\nSection empty.\nVariable E : Ens.\nHypothesis\n  union_emptyQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\n(* Proof of lem_irrefl                                            *)\nintros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof fun E : Ens => ex_and E empty.\n\nSection empty_not_empty_empty.\nVariable E : Ens.\n\nLet f : IN E (fun f : F => False) (f : E).\n\nLemma empty_not_empty_not_empty : forall x : E, ~ in_empty E x.\nProof empty_not_empty_not_empty.\n\nSection empty_not_empty_empty.\nVariable E : Ens.\nHypothesis f : ~ In E (fun f : F => ~ in_part E (fun f : F => in_part E (f (f (single x)) f)).\n\nLet f : ~ In E (fun f : F => in_part E (f (single x)) f.\nProof empty_not_empty_not_empty.\n\nSection empty_not_empty_empty_empty.\nVariable E : Ens.\nHypothesis f : ~ In E (fun f : F => in_part E (f (single x)) f.\n\nLet f : ~ In E (fun f : F => in_part E (f (single x)) f.\nProof fun E f :Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof fun E : Ens => ex_and E Zero.\n\nSection union_def.\nVariable E : Ens.\nHypothesis f : union E E.\n\nLet E : Ens := union E (union E (union E (single f))).\n\nLemma union_def :\n forall (E : Ens) (f : part_set E), is_subspace E f -> union E (union E (single f)).\nProof union_def.\n\nLemma union_def :\n forall (E : Ens) (f : part_set E), is_subspace E f -> is_subspace E (union E (single f)).\nProof union_def.\n\nunfold is_subspace in |- *.\nintros E f H' H'0; try assumption.\nelim H'0; intros H'2 H'3; elim H'3; intros H'4 H'5; clear H'0 H'1 H'2 H'3.\nexists (f x); split; [ idtac | idtac ].\napply in_part_comp_l with (f := x); auto with algebra.\napply in_part_comp_l with (f := x); auto with algebra.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof fun E : Ens => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun g : F => fun f : F => fun f : F => fun f : F => fun g : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : FQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof\n  fun (f : F) (Af : IN E Vide) =>\n  forall x : Ens, (exists y : Ens, (exists y : Ens, y = f y) -> x = y.\n\n(* A \"empty\" is defined in the empty set of the empty set of the empty set. *)\n\nSection empty.\nVariable E : Ens.\nHypothesis f : is_empty E.\n\nLemma empty_empty : forall x : E, f (empty E) (empty E).\nProof\n  fun (f : F) (Af : IN E Vide) =>\n  forall x : Ens, (exists y : Ens, (exists y : Ens, y = f y) -> x = y.\n\nEnd empty.\n\nTheorem empty_empty : forall x : E, empty E x.\nProof empty_empty E x.\n\nSection empty.\nVariable E : Ens.\nHypothesis f : is_empty E.\nHypothesis f : is_empty E.\n\nLet f := Build_Map (dom E) (dom E).\n\nLet E := union (dom E) (empty E) (empty E).\n\nLet E := union (dom E)Qed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *.\nintros E F; red in F.\napply F.\napply H.\nQed.",
                    "Theorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nProof fun E : Ens => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => fun f : F => f.\n\nSection empty.\nVariable E : Ens.\nHypothesis f : is_finite E f.\n\nLet f (f : is_finite E f) : Prop :=\n  forall x : E, in_part x (f x).\n\nLet f (f : is_finite E f) : Prop :=\n  forall x : E, in_part x (f x).\n\nHypothesis\n  f_inj :\n    forall x : E, in_part x (f x).\n\nHypothesis\n  f_inj :\n    forall x : E, in_part x (f x).\n\nHypothesis\n  f_inj :\n    forall x : E, in_part x (f x).\n\nLemma f_inj :\n    forall x : E, in_part x (f x) -> in_part x (f x).\nProof\n  fun x : E =>\n  union_part x (f x).\n\nLemma union_part_comp :\n forall (E F : Ens -> Prop) (f : isQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1764,
                "proof_end_offset": 2028,
                "proof": "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H0; red in |- *; intros E H0.\nelim H0; intros y E; elim E; intros H1 H2; elim H2; intros H3 H4;\n elim H3; intros H4 H5; elim H5; intros H6 H7;\n elim H7; intros H7 H8; elim H8; intros H8 H9;\n elim H9; intros H10; elim H10; intros H11;\n elim H11; intros H12; elim H12; intros H13; elim H13; \n intros H13 H14; elim H14; intros H14;\n elim H14; intros H14 H14; elim H15; intros H15 H15; \n elim H16; intros H15 H17; elim H18; intros H18 H18; \n elim H19; intros H18 H19; elim H20; intros H19 H20; \n elim H20; intros H18 H20; elim H20; intros H19 H20; \n elim H20; intros H20 H20; elim H20; intros H20 H20; \n elim H20; intros H20Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; elim H; intros H0 H1; elim H1; intros H2 H3.\nelim H1; intros H3 H4; elim H4; intros H5 H6.\nelim H3; intros H6 H7; elim H7; intros H8.\nelim H7; intros H9 H10; elim H10; intros H10 H11; elim H10;\n intros H10 H11; elim H10; intros H11 H12; elim H10;\n intros H11 H12; elim H12; intros H11 H12; elim H12;\n intros H13 H14; elim H13; intros H14 H15; elim H14;\n intros H14 H15; elim H14; intros H15 H15; elim H15;\n intros H15 H16; elim H16; intros H17 H17; elim H18;\n intros H17 H18; elim H18; intros H18 H19; elim H19;\n intros H18 H19; elim H19; intros H18 H19; elim H19;\n intros H20 H20; elim H19; intros H20 HQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; elim H; clear H.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; red in H; intros H'0; elim H'0.\nelim H'; intros H'1 H'2; red in H'0; elim H'2.\napply H'; auto with sets.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; try assumption.\nelim H; intros x E; elim E; intros H'0 H'1; try exact E.\nred in |- *; intros x E; elim E; intros H'1 H'2; try exact E.\nred in |- *; intros x E; elim E; intros H'1 H'2; try exact E.\nred in |- *; intros x E; elim E; intros H'2 H'3; try exact E.\nred in |- *; intros x E; elim E; intros H'2 H'3; try exact E.\nred in |- *; intros x E; elim E; intros H'3 H'4; try exact E.\nred in |- *; intros x E; elim E; intros H'4 H'5; try exact E.\nred in |- *; intros x E; elim E; intros H'5 H'6; try exact E.\nred in |- *; intros x E; elim E; intros H'7 H'8; try exact E.\nred in |- *; intros x E; elim E; intros H'8 H'9; try exact E.Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; cut False.\n2: red in |- *; intro H'0; elim H'0; intros H'1 H'2; try exact H'1; clear H'1.\nred in |- *; intro H'1; elim H'1; intros H'2 H'3; elim H'3;\n intros H'3 H'4; elim H'5; intros H'6 H'7; elim H'7;\n intros H'7 H'8; elim H'8; intros H'8 H'9; elim H'9;\n intros H'9 H'10; elim H'10; intros H'11 H'12; elim H'12;\n intros H'11 H'13; elim H'13;\n intros H'13 H'14; elim H'14; intros H'15 H'16; clear H'15 H'16.\nred in |- *; intro H'14; elim H'14; intros H'15 H'16; clear H'15 H'16.\nred in |- *; intro H'14; elim H'14; intros H'15Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; elim H.\nelim H; intros x H'; elim H'; intros H'0 H'1; try exact H'1; clear H'.\nelim H'; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H'.\nelim H'; intros H'3 H'4; elim H'4; intros H'5 H'6; clear H'.\nelim H'; intros H'7 H'7; elim H'8; intros H'8 H'8; clear H'.\nelim H'8; intros H'8 H'9; elim H'9; intros H'9 H'10; clear H'.\nelim H'9; intros H'9 H'10; elim H'10; intros H'11 H'12; clear H'14.\nelim H'11; intros H'12 H'13; elim H'14; intros H'13 H'14; clear H'15.\nelim H'14; intros H'14 H'14; elim H'14; intros H'15 H'16; clear H'14.\nQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H'; elim H'.\nunfold not in |- *; intros H'0; elim H'0; intros H'1 H'2.\nelim H'0; intros H'2 H'3; elim H'3; intros H'4 H'5.\nexists (couple x (couple x (f x)) (couple x (f x))).\nelim H'1; intros x0; elim H'1; intros H'5 H'6.\nexists (couple x (couple x (f x)) (couple x (f x))).\nelim H'1; intros H'6 H'7; elim H'7; intros H'8 H'9; clear H'1 H'2 H'3 H'4.\nexists (couple x (couple x (f x)) (couple x (f x))).\nelim H'1; intros x0; elim H'1; intros H'7 H'9; clear H'1 H'2 H'3 H'5.\nelim H'0; intros x0 H'7; elim H'8; intros H'9 H'10; clear H'0 H'1 HQed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; simpl in |- *; intros E H; cut False.\n2: red in |- *; intro H'0; elim H'0; intros H'1 H'2.\ncut (In E'0 (fun y : Ens => In (couple x y) (couple x y))).\n2: red in |- *; intro H'3; elim H'3; intros H'3; elim H'3; intros H'4 H'5.\nexists x; split; [ auto with zfc | idtac ].\nelim H'3; intros x E; exists x; split; [ auto with zfc | idtac ].\nexists x; split; [ auto with zfc | idtac ].\nelim (axs_parties (couple x y) (couple x y)); intros; generalize (H'0 H);\n clear H'3 H'3 H'4; intros.\nelim H'3; intros H'4 H'5; elim H'5; intros H'6 H'7; elim H'7;\n intros H'8 H'9; clear H'3 H'4 H'5 H'6 H'7; clear H'3 H'4 H'5Qed.",
                    "Theorem tout_vide_est_Vide : forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\nunfold not in |- *; intros E H; apply H.\nelim H; intros x H'; elim H'; intros H'0 H'1; try exact H'1.\nelim H'; intros x H'; elim H'; intros H'1 H'2; try exact H'1.\nelim H'; intros x H'; elim H'; intros H'1 H'2; try exact H'2.\nelim H'; intros x H'0 H'1; try exact H'1.\nelim H'; intros x H'; elim H'; intros H'2 H'3; try exact H'3.\nred in |- *; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2042,
                "proof_end_offset": 2158,
                "proof": "Definition Paire : forall E E' : Ens, Ens.\nProof.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Paire : forall E E' : Ens, Ens.\nProof\n  fun E : Ens =>\n  ex_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide.\n\nTheorem inc_vide_vide_vide : forall E : Ens, Set.\nProof\n  fun E : Ens =>\n  ex_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide_vide.\n\n(* Quceptic cases *)\n\nDefinition singleton (A : Ens) : Prop :=\n  forall X : Ens, X = couple A X.\n\nTheorem singleton_not_empty : forall (A : Ens) (f : A), {A : Ens | ~ A = f}.\nProof\n  fun A : Ens =>\n  union (fun A : Ens => ~ A = f).\n\nTheorem singleton_not_empty : forall (A :Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'; elim H'.\n\nintros E H'0; elim E; intros E'0 E'1; elim E'; intros H'1 H'2; clear E H'0.\nexists E; auto with zfc.\n\nintros E H'0; elim E; intros E'0 E'1; elim E'; intros H'1 H'2; clear E H'1.\nexists E; auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros E H; elim H; intros H0 H1; elim H1;\n intros H2 H3; elim H3; intros H4 H5; elim H5;\n intros H5 H6; elim H6; intros H7 H8; elim H8;\n intros H8; elim H8; intros H9; elim H9;\n intros H10; elim H10; intros H11; elim H11;\n intros H11; elim H11; intros H12; elim H12;\n intros H12; elim H12; intros H13; elim H14;\n intros H14; elim H14; intros H15 H15; elim H15;\n intros H16 H17; elim H16; intros H17 H18; elim H16;\n intros H18 H20; elim H19; intros H19 H20; elim H20;\n intros H20 H20; elim H20; intros H20 H20; elim H20;\n intros H20 H20; elim H20; intros H20 H20; elim H20;\n intros H20 H20; elim H20; intros H20 H21Defined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nDefinition D' : Set := Set.\n\nTheorem D_eq_reflexive : forall E : Ens, D' E -> forall x : BDDvar, In x E' -> In x E'.\nunfold D' in |- *; intros E H' x H'0; split.\napply H'; auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nTheorem lem_inc_vide : forall E : Ens, (forall E : Ens, ~ In E E) -> E' -> E'.\nunfold Vide in |- *; intros E H0; elim H0; intros E H0; elim H1; intros H2 H3;\n split.\napply H2; assumption.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; auto with zfc.\n\n(* End of proof of lem_incchples. *)\n\nTheorem lem_incam : forall E : Ens, E -> exists f : E, E' f /\\ E' f.\nunfold Img in |- *; auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\n\n(* The empty set of lems of lems of lems of the set of lems. *)\n\nDefinition inc (f : E) (Af : fun_ f), fun_ f -> fun_ f.\n(* Proof of lems of lems of lems of lems of lems of lems of lems. *)\nintros; elim H; intros.\nelim (lem_couple_propertie (f a) (couple x y) H0); intros;\n elim H0; clear H0 H1; intros.\nelim H0; clear H0; intros.\nelim (lem_couple_propertie x x0 y H0); intros; generalize (H1 H0);\n clear H1 H2 H3; intros.\ngeneralize H1; rewrite H2; clear H1 H2 H3; intros.\ngeneralize H2; rewrite H3; clear H2 H3; intros.\ngeneralize H3; rewrite H3; clear H3 H4; intros.\ngeneralize H3; rewrite H4; clear H4; intros.\ngeneralize H3; rewrite H4; clear H4; intros.\ngeneralize H4; rewrite <- H4; clearDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nunfold Vide in |- *; simpl in |- *; intros E H; elim H; intros H0 H1;\n split.\nintros x; elim (H0 (e x)); auto with zfc.\n\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'; try assumption.\n\nexact (H0 (e x)); auto with zfc.\nDefined.",
                    "Definition Paire : forall E E' : Ens, Ens.\nintros E E' H'; elim H'.\n\n(* End of proof of lem_ochas_ Copyright 2006-2016 Microsoft Corporation and Inria.                  *)\n\nTheorem lem_ochas_in_dom :\n forall E : Ens, (forall x : Elt, ~ In x E -> In x E').\nunfold Vide in |- *; intros E H'; elim H'.\n\n(* the second part of lem_ochas_in_dom *)\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\nelim (lem_union_propertie x x); intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\napply axs_extensionnalite; intros.\nelim (lem_union_propertie x x); intros.\napply H0; unfold iff in |- *; split; intros.\nunfold iff in |- *; split; intros.\napply axs_extensionnalite; intros.\nelim (axs_comprehension (fun x : E =>Defined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\n",
                "context_tokens": 537,
                "proof_start_offset": 2204,
                "proof_end_offset": 2521,
                "proof": "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; intros A' B B H'; split.\nexact (H' B).\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; simpl in |- *; intros A' B H' H'0; split.\napply (H' (e x)); auto with zfc.\napply (H' (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros.\napply (sup (Var (Var A) B)).\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; intros A A' B B H'; red in |- *; intros H' H'0; \n elim H'; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Bs in |- *; simpl in |- *; intros A' B B H H0; split.\nexact (H (e x)).\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A A' B H H0; try assumption.\napply (Id (e x)); auto with zfc.\nred in |- *; intros.\napply H0.\napply (dans_empty_is_empty A); assumption.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; intros A' B; split.\napply (proj1 (singleton (sup A' B) (sup B) (sup A B)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Vide in |- *; simpl in |- *; intros A' B H H0; split.\napply (H0 (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Img in |- *; simpl in |- *; intros A' B B H' H'0; split;\n [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B' B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B' B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B' H'0; split; [ auto with zfc | auto with zfc ].\nred in |- *; intros A' B H'0; split; [ auto with zfc | auto with zfc ].Qed.",
                    "Theorem Paire_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nintros A A' B H'; red in |- *; intros A' H'0; elim H'0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "er version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 603,
                "proof_start_offset": 2523,
                "proof_end_offset": 2823,
                "proof": "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paour in |- *.\nsimpl in |- *.\nintros; split.\napply (H (e x)); auto with zfc.\n\nunfold surj in |- *.\nsimpl in |- *.\nintros; split; auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold ITally in |- *.\nintros.\nelim (H (e x)); intros; elim (H0 (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Equenting in |- *.\nsimpl in |- *.\nintros; split.\napply (H (e x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Alose in |- *.\nsimpl in |- *.\nintros; split.\napply (proj1 (f (couple A B)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Assore in |- *.\nsimpl in |- *.\nintros; split.\nunfold Vide in |- *.\nexists A; exists B; exists B; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Abire in |- *.\nsimpl in |- *.\nintros; split.\napply (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold IT at 2 in |- *.\nintros; split.\nunfold Suire in |- *.\nintros.\napply H0.\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfoldtuom in |- *.\nsimpl in |- *.\nintros; split.\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Assour in |- *.\nsimpl in |- *.\nintros; split.\nunfold Vide in |- *.\nexists (fun x : E => exists y : E, x = couple y (singleton x)); auto with zfc.\n\nintros; split.\nunfold Vide in |- *.\nexists (fun x : E => exists y : E, x = couple y (singleton x)); auto with zfc.\n\nintros; split.\nunfold Vide in |- *.\nexists (fun x : E => exists y : E, x = couple y (singleton x)); auto with zfc.\n\nintros; split.\nunfold Vide in |- *.\nexists (fun x : E => exists y : E, x = couple y (singleton x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Vide in |- *.\nintros A B B' H' H'0; split.\nunfold Vide in |- *; simpl in |- *.\nintros H' H'1; split.\napply H'1; auto with zfc.\n\nelim (H'1 (eps \\o union (couple x x) (paire x x))).\nintros; elim H'1; intros; clear H'1; elim H'1; intros.\nexists x0; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\n",
                "context_tokens": 660,
                "proof_start_offset": 2910,
                "proof_end_offset": 3057,
                "proof": "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Vide in |- *; simpl in |- *; intros E H; elim H; intros H0 H1; elim H1;\n auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Vide in |- *; unfold Vide in |- *; simpl in |- *; intros E H;\n split.\nelim H; intros x H'; elim H'; clear H'; intros H'0 H'1; elim H'; clear H'0;\n intros H'1 H'2; elim H'2; clear H'2 H'2 H'3; intros H'3 H'4; clear H'3 H'4.\nexists x; exists x; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Vide in |- *; unfold Vide in |- *; simpl in |- *; intros E H; elim H;\n auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Vide in |- *; simpl in |- *; intros E H; try assumption.\n\nelim (H (incus_vide E E' H)); intros.\nelim H; clear H; intros H0 H1; elim H1; clear H1; intros H1 H2; elim H2; clear H2;\n intros H2 H3; elim H3; clear H3; intros H4 H5; clear H5 H6.\nexists (singleton E); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Img in |- *; simpl in |- *; intros E H; apply H.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Img in |- *; simpl in |- *; intros E H; apply H; clear H; intros.\nsplit.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Img in |- *; simpl in |- *; intros E H; elim H.\napply H; auto with zfc.\n\nunfold Img in |- *; simpl in |- *; intros y H; elim H.\nunfold Img in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Img in |- *; simpl in |- *; intros E H; elim H.\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction x.\nintros; exists (parties A); auto with zfc.\n\nsimple induction x; auto with zfc.\n\nintros; elim E; intros x; elim E; intros x0 H1; elim E0; intros H2 H3; elim H3;\n clear H3; intros H3 H4; elim H4; clear H4; intros H5 H6.\n\nrewrite H0; auto with zfc.\n\nunfold Vide in |- *; simpl in |- *; intros.\nelim (H0 (e x)); intros; generalize (H1 H1); clear H1 H2 H3; intros H6.\nelim H1; clear H1; intros H3 H4; elim H4; clear H4; intros H5 H6.\nelim H1; clear H1; intros H6 H7.\nrewrite H0; auto with zfc.\n\nunfold Vide in |- *; simpl in |- *; intros.\nelim (H0 (e x)); intros; generalize (H1 H1); clear H1 H2 H3; intros H7.\nelim H1;Qed.",
                    "Theorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Enil in |- *; simpl in |- *; intros E H; elim H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "                 *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 689,
                "proof_start_offset": 3059,
                "proof_end_offset": 3209,
                "proof": "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Enlexse in |- *; simpl in |- *; auto with zfc.\n\nTheorem SUB_ brs : forall E : Ens, SUB ( brs E) ( ~= E').\nunfold relexer in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Tise in |- *; simpl in |- *; intros E E' H; try assumption.\nelim H; intros x E; elim E; intros x E; elim E; intros x E; elim E; intros x E; elim E; intros x E; elim E;\n intros x E; elim E; intros x E; elim E; intros x E; elim E; intros x E; elim E;\n intros x E; elim E; intros x E; elim E; intros x E; elim E; intros x E; elim E;\n intros x E; elim E; intros x E; elim E; intros x E; elim E; intros x E; elim E; \n intros x E; elim E; intros x E; elim E; intros x E; elim E; \n intros x E; elim E; intros x E; elim E; intros x E; elim E; intros x E; elim E;\n intros x E; elim E; intros x E; elim E; intros x E; elim E; \n intros x E; elim E; intros x E; elim E; intros x E; elim E; \n intros x E; elim E; intros x E; elim E;Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfoldfash in |- *; simpl in |- *; intros E E' H; exists E'.\nunfold Img in |- *; simpl in |- *; intros E' H'0; exists E'.\nunfold Img in |- *; simpl in |- *; intros E' H'1; exists E'.\nunfold Img in |- *; simpl in |- *; intros E' H'2; exists E'.\nunfold Img in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Ense, Ense in |- *; simpl in |- *; intros E' H; try assumption.\n\nelim H; clear H; intros H E' H0; elim E'; clear E' H0; intros H E'0; elim E'; clear E'0;\n intros H E'1 H'2; elim E'2; clear E'2; intros H'2 H'3; elim E'3; clear E'1 H'2; \n intros H'3 H'4; elim E'4; clear E'4; intros H'4 H'5; clear H'4 H'5 H'6; \n clear H'5 H'5 H'5 H'6 H'7 H'8; \n clear H'4 H'5 H'5 H'6 H'8 H'9 H'10 H'11 H'11 H'12 H'12 H'14; \n clear H'4 H'5 H'5 H'6 H'7 H'9 H'11 H'11 H'12 H'13 H'14 H'14 H'15 H'16 H'16 H'18 H'18 H19 H19Qed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Vide in |- *; simpl in |- *; intros E E' H; try assumption.\nexists (Singleton E' (Singleton E' E')).\nunfold Vide in |- *; unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *; \n unfold Vide in |- *; unfold Vide in |- *;\n unfold Vide in |- *; unfoldQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Vide in |- *; simpl in |- *; intros E E' H'0; try assumption.\nexists (singleton E); auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Box, Jan, In, In, In, In, In in |- *;\n simpl in |- *; intros E' H'; apply H'.\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Clse in |- *; simpl in |- *; intros E E' H'; elim H'; clear H'.\n\nunfold Vide in |- *; simpl in |- *; intros E' H'; elim H'; clear H'.\n\nelim H'; clear H'; intros H'0 H'1; elim H'1; clear H'1; intros H'1 H'2; clear H'1.\nexists (couple x x0); split; [ auto with zfc | idtac ].\n\nunfold Vide in |- *; simpl in |- *; intros H'0 H'1; elim H'1; clear H'1.\n\nexists (couple x x0); split; [ auto with zfc | idtac ].\nunfold Vide in |- *; simpl in |- *; intros H'0 H'1; elim H'1; clear H'1.\n\nelim H'; clear H'; intros H'1 H'2; elim H'1; clear H'1.\n\nelim (lem_cartesian_propertie (parties (dom E')) (parties (dom E)));\n auto with zfc.\n\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold REPLACEMENT in |- *; simpl in |- *; intros E H'; elim H';\n [ intros H'0; elim H'0; intros H'1 H'2; clear H'0 H'0 H'1; clear H'0 H'1; clear H'0 H'1 H'2;\n   clear H'0 H'1 H'2 H'2 H'3 H'4 H'4 H'5 H'5 H'6 H'6 H'7 H'7 H'8 H'9 H'10 H'11 H'12 H'12 H'13 H'13 H'14 H'14 H'15 H'15 H'16 H'16 H'18 H'18 H'19 H'19 H'20 H'20 H'20 H'22 H'22 H'22 H'23 H'24 H'24 H'24 H'24 H'24 H'24 H'24 H'24 H'24 H'25 H'25 H'26 H'26 H'26 H'27 H'26 H'26 H'26 H'29 H'30 H'30 H'31 H32 H'34 H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Definitions of the empty set, pair, union, intersection, comprehension  *)\n(*  axiom and powerset, together with their properties                     *)\n\n\nRequire Import Sets.\n\n(* Useful types (actually top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 704,
                "proof_start_offset": 3211,
                "proof_end_offset": 3401,
                "proof": "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nProof.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold REPLACEMENT in |- *; simpl in |- *; intros A A A H H0; split.\napply H0; auto with zfc.\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Assent in |- *; simpl in |- *; intros A E H'; exists A;\n auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold CONAt in |- *; simpl in |- *; intros A B; split.\nred in |- *; intro; apply H1.\napply H0.\napply H1.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold DOsese in |- *; simpl in |- *; intros A B A H H0; split.\nintros; elim (H0 (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Prosese, CON in |- *; simpl in |- *; intros E E' A H'; elim H';\n [ idtac | intros; exists A; exists E'; auto with zfc ].\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold disj at 1 in |- *; simpl in |- *; intros A B; split.\nunfold Vide in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Assement in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Clent in |- *; simpl in |- *; intros; split.\ncut (In A (Singleton A E)); auto with zfc.\n\nintros; elim (H0 (A:=H0 (B:=H1 (B:=H2 (B:=H2 (B:=H3 (B:=H3 (B:=H4 (B:=H4 (B:=H3 (B:=H3 (B:=H4 (B:=H3)))).\nelim H; intros x0; elim x0; intros x1; elim x2; intros x3; elim x4; intros x5;\n [ idtac | elim x3; intros x6; elim x6; intros H7 H8;\n       clear H8; clear H8; intros H9;\n       clear H9; clear H10; intros H9;\n       clear H10; clear H10; intros H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       clear H10;\n       generalize\n       (lem_P1 x0 (couple x0 x1) (couple xQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Prosese in |- *; simpl in |- *; intros A B; split.\nunfold Prosese in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_IN : forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfoldtuort in |- *; simpl in |- *; intros E H'; try exact H'.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " top and bottom)   *)\n\nInductive Un : Set :=\n    void : Un.\n\nInductive F : Set :=.\n\n(* The empty set  (vide = french for empty)   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3620,
                "proof_end_offset": 3709,
                "proof": "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof\n  fun E : Ens =>\n  forall E : Ens,\n    (exists E : Ens, (exists E : Ens, In E E /\\ ~ In E E)).\n\nTheorem lem_inc_r : forall E E' : Ens, SUB (PAIR E E') (PAIR E E').\nProof\n  fun E : Ens =>\n  (fun E : Ens =>\n  forall E : Ens =>\n   exists E : Ens, (exists E : Ens, In E E /\\ ~ In E E)) ->\n   forall E : Ens, (exists E : Ens, In E E /\\ ~ In E E)).\n\nTheorem lem_inc_r : forall E E' : Ens, SUB (PAIR E E) (PAIR E E').\nProof\n  fun E : Ens =>\n  (fun E : Ens =>\n  exists E : Ens, (exists E : Ens, In E E /\\ ~ In E E')) ->\n  forall E : Ens, (exists E : Ens, In E E /\\ ~ In E E)).\n\nSection lem_def_def.\nVariable E : Ens.\nVariable E : Ens.\nHypothesis f : EQ (PAIR E E) (fun f : EQ E => EQ (f (PAIR fQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nProof\n  fun E : Ens =>\n  forall E : Ens, IN E (July 1999) -> E).\n\nTheorem SUB_th1 : forall E E' : Ens, SUB E E' -> ~ E' -> ~ E'.\nProof\n  fun E : Ens =>\n  forall E : Ens, ~ In E E' -> ~ E'.\n\nSection Power_of_nat.\nVariable E : Ens.\nHypothesis f : MAP E E.\nHypothesis f : SUB E E.\n\nLet E := union E f.\n\nLemma Power_of_nat_of_nat_of_nat_of_P :\n forall (A : Ens) (f : MAP A E),\n Equal (image f) (Power f).\nProof\n  fun E : Ens =>\n  forall E : Ens, In E E (Power f).\n\nSection Power_of_nat.\nVariable E : Ens.\nHypothesis f : MAP E E.\n\nLet E := union E f.\n\nLet E := union E f.\n\nLet E := union E f.\n\nLet E := union E f.\n\nLet E := union E f.\n\nLet E := union E f.Qed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Equ in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold ffun in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Proite in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Proion in |- *; simpl in |- *; auto with zfc.\n\nTheorem lem_inc_r : forall E : Ens, EQ E (Inc (Inc (Inc E))).\nunfold Proion in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold REPLACEMENT, Jan in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold REPLACEMENT in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold surj in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold surj in |- *; intros E E; elim E; intros E0 E1; elim E0; intros E1 E2;\n elim E1; intros E2 E3; elim E3; intros E3 E4; elim E4;\n intros E4; elim E5; intros E5 E6; elim E6;\n intros E7 E7; elim E7; intros E7 E8; elim E7;\n intros E8 E9; elim E9; intros E9 E10; elim E10;\n intros E10 E11; elim E11; intros H'12 H'13; elim E10;\n intros H'12 H'14; elim E11; intros H'14 H'14; elim E11;\n intros H'14 H'15; elim E10; intros H'15 H'16; elim E15;\n intros H'16 H'16; elim E15; intros H'17 H'16; elim E15;\n intros H'16 H'16; elim E16; intros H'16 H'17; elim E18;\n intros H'17 H'18; elim E16; intros H'17 HQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": ")   *)\n\nDefinition Vide : Ens := sup F (fun f : F => match f return Ens with\n                                             end).\n\n(* The axioms of the empty set *)\n\nTheorem Vide_est_vide : forall E : Ens, IN E Vide -> F.\nunfold Vide in |- *; simpl in |- *; intros E H; cut False.\nsimple induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3711,
                "proof_end_offset": 3859,
                "proof": "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold surj in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Proite in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfoldcross in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold July in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold ffun, fsub in |- *; auto with zfc.\n\nTheorem SUB_ License_from_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_in_inQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Proite in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Prose in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold surj in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold coqc_domain in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " induction 1.\nelim H; intros x; elim x.\nQed.\n\n\nTheorem tout_vide_est_Vide :\n forall E : Ens, (forall E' : Ens, IN E' E -> F) -> EQ E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e H H0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3902,
                "proof_end_offset": 4058,
                "proof": "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nProof.\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A'); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfoldAge in |- *; auto with zfc.\n\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfolddefinite in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sep in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": "0;\n  split.\nintros; elim (H0 (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n(* Pair *)\n\nDefinition Paire : forall E E' : Ens, Ens.\nintros.\napply (sup bool).\nsimple induction 1.\nexact E.\nexact E'.\nDefined.\n\n(* The pair construction is extentional *)\n\nTheorem Paire_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4091,
                "proof_end_offset": 4278,
                "proof": "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nProof.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; intros E1 E2; elim (umulhire_IN E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; intros E1 E2; apply EQ_backwards with (precision := E1 E2);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; intros E1 E2 H; elim (arr_A_is_transitive E1 E2 H);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold surj in |- *; intros E1 E2; apply EQ_backwards with (xbup A A');\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold surj in |- *; intros E1 E2 H; elim H; auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold surj in |- *; intros E1 E2 H; elim (inc_irreflexive E1 E2 H);\n auto with zfc.\nQed.",
                    "Theorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nunfold Equ in |- *; intros E1 E2 H; elim (sup (Var E1) (Var E2));\n auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\n",
                "context_tokens": 754,
                "proof_start_offset": 4542,
                "proof_end_offset": 4719,
                "proof": "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nProof.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; red in |- *; intro H; elim H.\nintros x H'; elim H'; auto with zfc.\nintros x H'; elim H'; auto with zfc.\nintros x H'; elim H'; auto with zfc.\nintros x H'; elim H'; auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; split; [ auto with zfc | idtac ].\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros.\napply (Build_Predicate (Pred (fun x : A => exists y : _, P x y)) (fun x : A => exists y : _, P x y)).\nintros H; elim H.\nintros x y H'; elim H'.\nintros y H'; elim H'.\nintros y0 H'; elim H'.\nintros y0 H'0 H'1 H'2 H'3 H'4 H'5.\nelim H'5; intros y0 H'5 H'6 H'7; elim H'6.\nintros y0 H'8 H'8 H'9 H'10 H'11 H'11 H'12 H'13 H'14 H'14.\nelim H'9; intros y0 H'10 H'11 H'14.\nexists y0.\nsplit; [ auto with zfc | auto with zfc ].\napply H'0; auto with zfc.\n\nunfold comp in |- *.\napply H'0; auto with zfc.\n\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; split.\nred in |- *; intros x H'; red in |- *; intros x H'; elim H';\n [ intros H'0; elim H'0; intros H'1 H'2; clear H'0 | clear H'0 ]\n | idtac ].\nred in |- *; intros x H'; red in |- *; intros x H'; elim H';\n [ intros H'0; elim H'0; intros H'1 H'2; clear H'0 | clear H'0 ]\n | idtac ].\nred in |- *; intros x H'; elim H';\n [ intros H'0; elim H'0; intros H'1 H'2; clear H'0 | clear H'0 ]\n | idtac ].\nred in |- *; intros x H'; elim H';\n [ intros H'0; elim H'0; intros H'1 H'2; clear H'0 | clear H'0 ]\n | idtac ].\nred in |- *; intros x H'; elim H';\n [ intros H'0; elim H'0; intros H'1 H'2; clear H'0 | clear H'0 ]\n | idtac ].\nred in |- *;Defined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; exists (fun x : A => P x).\nelim H; auto with zfc.\n\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros A P H'; elim H'.\nintros x H'; elim H'.\nintros x H'; elim H'.\nintros x0 H'; elim H'.\nintros x0 H'0 H'1 H'2 H'3 H'4 H'5 H'6 H'7 H'8 H'8 H'9 H'10 H'11 H'11 H'12.\napply H'4; auto with zfc.\napply H'1; auto with zfc.\napply H'1; auto with zfc.\napply H'1; auto with zfc.\napply H'1; auto with zfc.\napply H'2; auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros H H'; elim H'.\nintros x H'0; elim H'0; intros H'1 H'2; clear H'0.\nunfold P in |- *.\napply (H' x); auto with zfc.\n\nintros x H'0; elim H'0; intros H'1 H'2; clear H'0.\nunfold P in |- *.\napply (H' x); auto with zfc.\n\nintros x H'0; elim H'0; intros H'1 H'2; clear H'0.\nunfold P in |- *.\napply (H' x); auto with zfc.\n\nintros x H'0; elim H'0; intros H'1 H'2; clear H'0.\nunfold P in |- *.\napply (H' x); auto with zfc.\n\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; apply (Build_Predicate (P := fun x : A => P x)); auto with zfc.\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros; split.\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\n\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\nexact (Build_Predicate (Pred_fun:=fun x : A => P x)).\nDefined.",
                    "Definition Comp : Ens -> (Ens -> Prop) -> Ens.\nintros H; elim H; clear H.\n\nunfold Comp in |- *.\nintros; apply H; auto with zfc.\n\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Axioms.v",
                "context": " Ens, EQ B B' -> EQ (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\nHint Resolve Paire_sound_right Paire_sound_left: zfc.\n\n(* The axioms of the pair *)\n\nTheorem IN_Paire_left : forall E E' : Ens, IN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem IN_Paire_right : forall E E' : Ens, IN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem Paire_IN :\n forall E E' A : Ens, IN A (Paire E E') -> EQ A E \\/ EQ A E'.\nunfold Paire in |- *; simpl in |- *.\nsimple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve IN_Paire_left IN_Paire_right Vide_est_vide: zfc.\n\n(* The singleton set  *)\n(* Note that we could define it directly using the base type Un *)\n\nDefinition Sing (E : Ens) := Paire E E.\n\n\n(* The axioms  *)\n\nTheorem IN_Sing : forall E : Ens, IN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\nTheorem IN_Sing_EQ : forall E E' : Ens, IN E (Sing E') -> EQ E E'.\nunfold Sing in |- *; intros E E' H; elim (Paire_IN E' E' E);\n auto with zfc.\nQed.\n\n\n\nHint Resolve IN_Sing IN_Sing_EQ: zfc.\n\nTheorem Sing_sound : forall A A' : Ens, EQ A A' -> EQ (Sing A) (Sing A').\nunfold Sing in |- *; intros; apply EQ_tran with (Paire A A');\n auto with zfc.\nQed.\n\nHint Resolve Sing_sound: zfc.\n\nTheorem EQ_Sing_EQ : forall E1 E2 : Ens, EQ (Sing E1) (Sing E2) -> EQ E1 E2.\nintros; cut (IN E1 (Sing E2)).\nintros; auto with zfc.\napply IN_sound_right with (Sing E1); auto with zfc.\nQed.\n\nHint Resolve EQ_Sing_EQ: zfc.\n\n\n\n(* We here need sigma types -- i.e. computational existentials *)\n\nInductive sig (A : Type) (P : A -> Prop) : Type :=\n    exist : forall x : A, P x -> sig A P.\n\n\n(* The set obtained by the comprehension (or separation) axiom *)\n\nDefinition Comp : Ens -> (Ens -> Prop) -> Ens.\nsimple induction 1; intros A f fr P.\napply (sup (sig A (fun x => P (f x)))).\nsimple induction 1; intros x p; exact (f x).\nDefined.\n\n(* The comprehension/separation axioms *)\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4764,
                "proof_end_offset": 4973,
                "proof": "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nProof.\nunfold Comp, INC in |- *; simple induction E; simpl in |- *; intros.\nelim H0; simple induction x; intros; exists x0; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E P.\napply (H (Var (Var (Var x))).\nunfold Comp in |- *; apply (H (Var (Var x))).\nunfold Comp in |- *; apply (H (Var (Var x)).\nunfold Comp in |- *; apply (H (Var (Var x))).\nunfold Comp in |- *; apply (H (Var x)).\nunfold Comp in |- *; apply (H (Var x)).\nunfold Comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var (Var x))).\nunfold Comp in |- *; apply (H (Var x)).\nunfold Comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |- *; apply (H (Var x)).\nunfold comp in |-Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E P H; elim H.\nintros x y H'0; elim H'0; intros H'1 H'2; elim H'3; intros H'3 H'4; clear H'3 H'4; clear H'3 H'4 H'4 H'5.\nsplit; [ exact H'4 | exact H'5 ].\nexact (f_equal (fun x : A => P (f x))).\nred in |- *; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E P.\napply (H (fun x : Ens => P (f x))).\nauto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E P.\napply (sup (sig A (fun x : A => P (f x))).\nred in |- *; intros x H; elim H; intros x H0; elim H0;\n intros x H0; elim H0; intros H1 H2; elim H3; intros H4 H5; elim H5;\n intros H5 H6; elim H6; intros H7 H8; elim H8; \n intros H8; elim H8; intros H9; elim H9; intros H10; elim H10;\n intros H11; elim H11; intros H11; elim H11; \n intros H12; elim H12; intros H12; elim H13; intros H13; elim H13; \n intros H13; elim H14; intros H13; elim H14; \n intros H14; elim H14; intros H14; elim H14; \n intros H15; elim H15; intros H15; elim H15; \n intros H15; elim H16; intros H16; elim H16; \n intros H16 H18; elim H16; intros H16 H18; elim H16;Qed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nintros E P H.\ncut (Strict_Of E P).\nintros P H; elim (H1 P H); intros H1 H2.\napply (H1 P H1); auto with zfc.\n\napply (H2 P H1); auto with zfc.\n\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; auto with algebra.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E P H.\nelim H.\nintros x H'; elim H'.\nintros x0 H'; elim H'.\nintros x1 H'; elim H'.\nintros x2 H'0; elim H'0.\nintros x3 H'1 H'2 H'3 H'4 H'5.\napply H'1 with (y := x1); auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; auto with zfc.\nQed.",
                    "Theorem Comp_INC : forall (E : Ens) (P : Ens -> Prop), INC (Comp E P) E.\nunfold Comp in |- *; intros E P f.\napply (sup (sig A (fun x : Ens => P (f x))).\nauto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\n",
                "context_tokens": 319,
                "proof_start_offset": 1547,
                "proof_end_offset": 2774,
                "proof": "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4; elim (H3 true); simpl in |- *; intros xx; elim xx; simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\napply EQ_tran with A; auto with zfc.\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros.\napply (Build_Predicate (Singleton (Ensemble A) (Singleton B) (Singleton B)) (Singleton B)).\nred in |- *.\nintros x H'; try assumption.\napply (IN_inv A' B' B' H'0).\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple, Couple in |- *.\nintros A A' B B' C' H'0 H'1; try assumption.\napply Trans with (add A B); auto with *.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B' B' H'; red in |- *; intros H'0; apply H'.\napply Trans with (union (union A B) (union A B')); auto with *.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Setminus in |- *.\nintros A B C B' C' C' H0 H1 H2.\nelim (H0 (Singleton (Couple A' B' C) (Singleton (Singleton (Singleton (Singleton A' C'))) (Singleton (Singleton (Singleton A' C'))).\nintros A' B C' C' H1 H2.\nelim H1; intros H3 H4; elim H4; clear H4.\nelim (H0 (Singleton (Singleton (Singleton A' C) (Singleton (Singleton (Singleton A' C'))) (Singleton (Singleton (Singleton (Singleton A' C))) (Singleton (Singleton (Singleton (Singleton A' C'))).\nintros A' B C' C' H1 H2.\nelim H1; intros H4 H5; elim H5; clear H5.\nelim (H0 (Singleton (Singleton (Singleton (Singleton A' C) (Singleton (Singleton (Singleton A' C))) (Singleton (Singleton (Singleton A' C'))).\nintros A' B C' C' H3 H4.\nelim H3; intros H5 H6; elim H6; clear H5.\nintros H6 H7 H8.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'; red in |- *; intros H'0; elim H'.\nintros H'1 H'2; red in H'1; red in H'1.\nelim (H'1 (H'2 (H'3 H'4))).\nintros x0 H'3; elim H'3; intros H'4 H'5; clear H'3 H'4.\nelim (H'1 (H'2 x0)); intros x0 H'5; clear H'1 H'2.\nelim (H'2 x0); intros x0 H'5; clear H'1 H'2.\nelim (H'2 x0); intros x1 H'6; clear H'2 H'3.\nelim H'3; intros H'7 H'8; elim H'8; intros H'8 H'9; clear H'3 H'4.\nelim H'3; intros H'9 H'10; elim H'10; intros H'10 H'10; clear H'3 H'4.\nelim H'9; intros H'10 H'11; elim H'11; introsQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A B B' H'; red in |- *; auto.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' H'; red in |- *; auto.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros A A' B B' C' H'0 H'1 H'2.\nelim H'; intros H'3 H'4; elim H'4; intros H'5 H'6; clear H'4.\nelim H'2; intros H'5 H'6; clear H'2.\nelim (H'3 H'5); intros H'7 H'8; clear H'2.\nelim (H'5 (H'6 (H'7 H'8)) (H'7 H'8));\n intros H'8 H'9; clear H'2.\nelim H'0; intros H'9 H'10; clear H'0.\nelim (H'5 (H'9 H'10)); intros H'10 H'11; clear H'0.\nelim H'10; intros H'10 H'11; clear H'0.\nelim H'10; intros H'10 H'11; clear H'0.\nelim (H'9 H'11); intros H'10 H'11; clear H'0.\nelim (H'10 H'11); intros H'12 H'13Qed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfoldcontra, IN in |- *.\nintros A A' B B' B' C' B' C' C' D' D' E' H'0 H'1; try assumption.\napply H'; auto with algebra.\nQed.",
                    "Theorem Couple_inj_left : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton A' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton A' B)).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton A' B)).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton A' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B').\nintros.\napply Extensionality_Ensembles.\nelim (H (Singleton B' B')).\nintros.\napply Extensionality_Ensembles.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The cartesian product and its properties *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n(* This definition of the ordered pair is slightly different from *)\n(* the usual one, since we want it to work in an intuisionistic   *)\n(* setting. Works the same, neitherless. The soundness proofs are *)\n(* unpleasant.                                                    *)\n\n\nDefinition Couple (E E' : Ens) := Paire (Sing E) (Paire Vide (Sing E')).\n\nTheorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\n",
                "context_tokens": 647,
                "proof_start_offset": 2778,
                "proof_end_offset": 3718,
                "proof": "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nProof.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A' B B' C' C' D' F' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G'.\n\nunfold Couple in |- *.\nintros A A' B C D F G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G'.\n\nintros.\nelim (H0 (G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' & G' &Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A A' B B' C D D' F' H'0 H'1 H'2 H'3.\napply (not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_O_not_OQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Cs in |- *; simpl in |- *.\nintros A A' B B' B' C' C' D' E' F' H'0 H'1.\n\nelim H'; intros H'2 H'3; elim H'3; intros H'4 H'5; clear H'3 H'4.\nelim H'2; intros H'5 H'6; clear H'2 H'5.\nelim H'1; intros H'6 H'7; clear H'2 H'5.\nelim H'2; intros H'7 H'8; clear H'2 H'3 H'4.\nelim H'4; intros H'7 H'8; clear H'3 H'4.\nelim H'4; intros H'7 H'8; clear H'4 H'5.\nelim H'4; intros H'8 H'8; clear H'4 H'4 H'5.\nelim H'4; intros H'9 H'10; clear H'4 H'9.\nelim H'4; intros H'9 H'11; clear H'4 H'9.\nelim HQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A' B B' B' H'; try assumption.\nelim (H' A); intros.\nelim (H' A); intros.\nelim (H' B); intros.\nelim (H' B); intros.\nelim (H' B'); intros.\nelim (H' B); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' B'); intros.\nelim (H' BQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A' B B' C B' C' C' D' E' F' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G'.\n\nTheorem Couple_not_in :\n forall A A' B C : Ens,\n EQ (Singleton A' B) (Singleton B' C) -> EQ A B.\nunfold Resolve Setminus_of in |- *.\nintros A A' B C f; elim A'.\nintros x H'; elim H'; intros H'0 H'1; elim H'1; intros H'2 H'3; clear H' H'1 H'2.\n\nelim (H' x); intros H'3 H'4; clear H'3 H'4.\nelim (H'3 (Singleton B' C) (Singleton B' C) (Singleton B' C) (Singleton B' C));\n intros H'4 H'5; clear H'4.\nelim (H'4 (Singleton B' C) (Singleton B' C) (Singleton BQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A' B B' C C' H H'0 H'1.\nelim H'; intros H'2 H'3; elim H'3; clear H'3 H'4.\n\nelim (H'2 A); intros H'4 H'5; elim H'5; clear H'4.\n\nelim (H'4 A'); intros H'8 H'9; elim H'9; clear H'9.\n\nelim (H'8 A'); intros H'9 H'10; elim H'10; clear H'9.\n\nelim (H'8 A'); intros H'10 H'11; elim H'10; clear H'9.\n\nelim (H'8 A); intros H'10 H'11; elim H'10; clear H'10.\n\nelim (H'9 A); intros H'12 H'12; elim H'10; clear H'10.\n\nelim (H'9 A'); intros H'13 H'14; elim H'14; clear H'14.\n\nelim (H'10 A); intros H'15Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros A A' B B' B' C' H'0 H'1; try assumption.\napply (not_S_O_eq A A'); auto with zfc.\napply (not_S_O_eq A'); auto with zfc.\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold swap, swap, swap, swap in |- *.\nintros A A A' B B' C' B' C' D' F G G G G G' G' G' G' G' G' G' G' G' G' G' G' G' G' G' G'.\n\nunfold swap, swap in |- *.\nintros.\nelim (Ax A); simpl in |- *; auto with zfc.\n\nintros.\ncut (IN (cart A B) (cart A B) (cart A B)).\nsimpl in |- *.\nintros H1; elim (H1 H2); intros H3 H4; elim H4;\n intros H5 H6; elim H6; intros H6 H7; elim H7;\n intros H7 H8; elim H9; intros H9 H10; elim H10;\n intros H10 H11; elim H10; intros H11 H12; elim H11;\n intros H12 H13; elim H10; intros H12 H13; elim H10; \n clear H13 H14; intros H13 H15; elim H10; \n clear H15 H16; intros H15 H16;Qed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold contraFT in |- *; simpl in |- *.\nintros A A' B B' H H0; red in |- *.\nintros H0; elim (H0 (H1 B)); clear H0 H1; intros H2 H3; elim H3;\n clear H3 H4; intros H4 H5; elim H5; clear H5; intros H5 H6; \n elim H5; clear H5; intros H6 H7; elim H6; clear H5; \n intros H7 H8; elim (H7 (H7 (H7 (H7 (H7 (H8 (H9 H10 H11 H11 H12))), H8 H9);\n clear H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11.\n\napply H1; auto with zfc.\n\nQed.",
                    "Theorem Couple_inj_right : forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nintros.\napply (not_O_O_O (Singleton B) (Singleton B) (Singleton B')); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4227,
                "proof_end_offset": 4370,
                "proof": "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, In, Included, Included, Included, Included, In, Included, Included, Included, In, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, Included, In, Included, Included, Included, In, Included, Included, In, Included, In, Included, Included, Included, Included, Included, Included, In.\n\n(* The intersection of the intersection of the intersection of the intersection of the intersection of the intersection of *)\n\n(*  and the intersection of a and its intersection of a given from a part of a *)\n(* and its intersection of a given from a given from a given from a given from a given from a given  *)\n(*  the intersection of a given from a given from a given from a given from a given  *)\n(*  an element of the intersection of a given from a given from a given in a given  *)\n(*  the intersection of a given from a given from a given from a given  *)\n(* aQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *; unfold Prod in |- *; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold eqmap in |- *; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold transpose in |- *; intros A A' B H'; try assumption.\napply Trans with (eqA A' B); auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Union in |- *; auto with algebra.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold equiv in |- *.\nintros A A' B B H'; elim H'.\nintros c H'0 H'1; elim H'.\nintros c H'2 H'3; elim H'.\nintros c H'4 H'5 H'6 H'7 H'8 H'9 H'10 H'11 H'12 H'13 H'13 H'14 H'15 H'16 H'17 H'19 H'19 H'20 H'19 H'20 H'18 H'20 H'21 H'22 H'22 H'22 H'23 H'24 H'23 H'23 H'26 H'26 H'26 H'26 H'26 H'26 H'26 H'27 H'26 H'26 H'26 H'30 H'26 H'26 H'26 H'31 H'26 H'30 H'30 H'26 H'26 H'26 H'31 H'31 H'30 H' H'30 H'32 H'33 H'23 H'33 H'26 H'26 H'31 H'25 H'31 H'31 H'30 H32 H32 H'Qed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold equiv in |- *; intros A A' B H'; elim H'; clear H'; intros H' H'0.\nelim (H'0 B); auto with zfc.\n\nelim (H'0 B); auto with zfc.\n\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nintros A A' B H'; red in |- *.\nauto with algebra.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold inter in |- *; intros A A' B H'; elim H'; auto with zfc.\nQed.",
                    "Theorem Couple_sound_left : forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\nunfold Prod in |- *; intros A' B B f' H'0; apply H'; clear H'0.\n\nunfold Prod in |- *; simpl in |- *.\n\nintros a b c H'0 H'1; apply H'; clear H'0.\napply\n (Build_Map (B:=A) (B:=A') (B:=A') (B':=B') (C:=B') (C':=B') (C':=B') (C':=B') (f':=A')).\nred in |- *; simpl in |- *.\nintros a b c H'0 H'1; apply H'; clear H'0.\napply (H' a b c H'1).\napply (H' a b c H'0).\napply (H' a b c H'1).\napply (H' a b c H'0).\napply (H' a b c H'1).\napply (H' a b c H'1).\napply (H' a b c H'1).\napply (H' a b c H'0).\napply (H' a b c H'0).\napply (H' a b c H'Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": "simple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 4372,
                "proof_end_offset": 4516,
                "proof": "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nProof.\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold cart in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_sound_right : forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\nunfold Eunop in |- *; intros; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": ".\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n\n\n\nTheorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 716,
                "proof_start_offset": 4519,
                "proof_end_offset": 5789,
                "proof": "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0)); auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\napply Couple_sound_left; auto with zfc.\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\nexists true; auto with zfc.\nsimple induction y; exists true; auto with zfc.\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\nsimple induction y.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nauto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Lub in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold cart in |- *; unfold cart in |- *; unfold cart in |- *;\n unfold cart in |- *; unfold cart in |- *;\n unfold cart in |- *; unfold cart in |- *;\n unfold cart in |- *; simpl in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *;\n unfold Ar2 in |- *; unfold Ar2 in |- *; \n unfold Ar2 in |- *; unfold Ar2 in |- *; \n unfold Ar2 in |- *; \n unfold Ar2 in |- *; unfold Ar2 in |- *;Qed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros.\napply Extensionality_Ensembles; unfold iff in |- *; split; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Setminus in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Lub in |- *; auto with algebra.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold disj in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Couple in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold Evar in |- *; intros; auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nintros E1 E2 E1' E2' E3; elim E1; intros E2 E3 E4.\napply\n (Couple_Eq (Couple (Couple E1 E2) (Couple E1' E3) (Couple E1' E3))); auto with zfc.\n\napply Lub_definition_imp_conv_l with (Singleton E2) (Singleton E1' E3);\n auto with zfc.\nQed.",
                    "Theorem Couple_IN_Prod : forall E1 E2 E1' E2' : Ens, IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nunfold disj in |- *; intros.\napply\n (Build_Map (Carrier_of E1) (Carrier_of E2) (Carrier_of E1) (Carrier_of E2)\n    (Carrier_of E1) (Carrier_of E2) (Carrier_of E2)).\n\nelim E1; intros x E1 E2; elim E1; intros H'1 H'2; elim E1; clear E1;\n intros H'2 H'3; elim E2; clear E2 H'3; intros H'3 H'4;\n clear E1 H'3 H'4 H'5 H'6 H'7 H'8.\nelim E1; intros H'3 H'4; elim E1; clear E1;\n intros H'4 H'5; elim E2; clear E1 E2; intros H'5 H'6;\n clear E1 H'4 H'5 H'7 H'8.\nelim H'4; intros H'5 H'6; elim E1; clear E1 E2;\n intros H'7 H'7; elim H'7; clear E1 EQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " zfc.\n\nQed.\n\n\n\n\n\n\n(* Here we cheat. It is easier to define the cartesian product using    *)\n(* the type theoretical product, i.e. we here use non set-theoretical   *)\n(* constructions. We could however use the usual definitions.           *)\n\n\nDefinition Prod (E E' : Ens) : Ens :=\n  match E, E' with\n  | sup A f, sup A' f' =>\n      sup _\n        (fun c : prod_t A A' =>\n         match c with\n         | pair_t a a' => Couple (f a) (f' a')\n         end)\n  end.\n\n\nHint Resolve Paire_sound_left Paire_sound_right: zfc.\n\n\nTheorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\nTheorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n\n\nTheorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 5792,
                "proof_end_offset": 6539,
                "proof": "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nProof.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1; auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2; auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n\nunfold Couple in |- *; intros.\nelim (axs_comprehension (fun x : E => exists y : E, In (couple x y) (reunion E1' E2)) x).\n\nintros x0 y0; elim (IN_cartesian (cartesien E1' E2) (couple x x0)); intros; \n generalize (H0 H); clear H H0 H1; intros.\nelim H; clear H; intros; elim H; clear H; intros.\nelim (lem_cartesian_propertie (couple x y) (reunion (couple x y))); intros;\n generalize (H1 H0); clear H0 H1 H2; intros.\nelim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0; intros; \n elim H0; clear H0; intros.\nelim (lem_cartesian_propertie (couple x y) (reunion (couple x y))); intros;\n generalize (H2 H3); clear H3 H4; intros.\nelim H3; clear H3; intros;Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n(* Proof of lem_Prod_disj_Equiv. *)\n\nunfold disj in |- *; unfold disj in |- *; unfold disj in |- *;\n unfold disj in |- *; intros.\nelim H0; intros H1 H2; clear H H1; intros; elim H2; clear H2; intros.\nelim (IN_EX A1 f1); intros.\nelim (IN_EX A2 f2); intros.\napply H1; clear H1; intros.\nexists (f1 x0); auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n(* Proof of lem_reunion_of_ E1 E1' E2' E2' E3. *)\n\nintros.\ngeneralize (H0 x); clear H0 H1; intros.\nelim (IN_downward_stable (Couple E1' E2) (Singleton E2) x).\nintros x e1; elim (IN_downward_stable (Couple E1' E2) (Singleton E1') x).\nintros x e2; elim (IN_downward_stable (Couple E1' E2) (Singleton E2)));\n auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Img in |- *; intros; split.\napply axs_extensionnalite; intros.\nsplit; intros.\nelim (lem_cartesian_propertie (couple x x0 y) (couple x x0)); intros; generalize (H1 H0);\n clear H H0 H1; intros.\nelim H; clear H; intros; elim H; clear H; intros; elim H0; clear H0;\n intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros; elim H1; clear H1; intros.\nelim H1; clear H1; intros.\nelim (lem_couple_propertie x x0 y); intros; generalize (H3 H3);\n clear H3 H4 H5; intros.\nelim H5; clear H5; intros.\nelim H5; clear H5; intros.\nelim (lem_couple_propertie x x0 y); intros; generalize (H4 H5);\n clear H5 H6 H7; intros.\nelim H5; clear H5; intros.\nelim H6; clear H5; intros.\nelim (lem_couple_propertie x x0 y);Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n\n(* Proof of lem_Equiv_ disj_Prod_IN                                           *)\n\nTheorem axs_extensionnalite_prop_is_in_Carrier :\n forall E1 E2 E3 : Prop,\n E1 <> E2 -> In E1 E2 -> In E2 E3 -> exists f : E1, In (couple E1' E2) (equiv E1' E2).\n(* Proof of lem_Equiv_prop_is_in_Carrier                                            *)\n\nintros E1 E2 E3 E4.\ncut (Equal (Couple (Couple E1' E2) (Couple (Couple E1' E2) (Couple E1' E3)));\n [ idtac | exists f; auto with zfc ].\nelim (H (H0 (H1 (H2 (H3 (H4 H6))).\n\nintros x0 e0 H' H'0; elim H'0; clear H'0 H'0; intros H'1 H'2; clear H'0 H'1 H'2.\nelim H'0; clear H'0; intros H'0 H'1; clear H'0 H'1 H'2.\nexists (Qed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Couple in |- *; intros; split.\n\nintros E1 E2 E3 E4 H0 H1 H2; split; [ auto with zfc | intros ].\nelim (IN_cartesian_propertie (parties (couple x y)) (parties (couple x y)) (couple x y));\n auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n\nunfold Compatible in |- *; intros.\nelim (H (H (fun y : E => exists x : E, In (couple x y) (couple x y))).\nintros x e H H0; elim H0; intros; clear H0; elim H0; clear H0; intros;\n elim H0; clear H0; intros; elim H1; clear H1; intros;\n elim H1; clear H1; intros; elim H1; clear H1; intros;\n elim H1; clear H1; intros; elim H1; clear H1;\n intros; elim H1; clear H1; intros; elim H2; clear H1;\n intros; elim H3; clear H3; intros; elim H3; clear H3;\n intros; elim H3; clear H3; intros; elim H3; clear H3;\n intros; elim H3; clear H3; intros; elim H3; clear H3;\n intros; elim H3; clear H3; intros; elim H4; clear H4;\n intros; elim H3; clear H4; intros; elim H4; clear H4;\n intros; elimQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nunfold Couple in |- *; intros.\nelim (IN_cor_inv _ _ H); intros; auto with zfc.\n\nQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n\n(* Proof of lem_equiv_equiv_rel_sig_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_propQed.",
                    "Theorem Couple_Prod_IN : forall E1 E2 E1' E2' : Ens, IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\n(* Proof of lem_equiv_equiv_1_imp_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_sig_rel_rel_sig_rel_sig_rel_sig_rel_sig_rel_rel_sig_rel_sig_rel_rel_sig_rel_sig_rel_sig_rel_rel_sig_rel_rel_sig_rel_sig_rel_sig_rel_rel_sig_rel_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Cartesian.v",
                "context": " intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n\n\nTheorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n\n\n\n",
                "context_tokens": 715,
                "proof_start_offset": 6543,
                "proof_end_offset": 6911,
                "proof": "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nProof.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\n(* Proof of lem_Prod_prop_fun                                          *)\nintros E E' E' E'' H'0; elim H'0; clear H'0.\n\napply axs_extensionnalite; unfold iff in |- *; split; intros.\nunfold iff in H.\nelim\n (axs_comprehension\n    (fun x : E => exists y : E, In (couple x y) E)\n    (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (reunion (Img A))))))); \n intros.\nelim H'; clear H'.\nelim H'; clear H'.\ngeneralize H'0; clear H'.\nelim H'0; clear H'0.\nintros.\nelim H'0; clear H'0.\nintros; elim H'0; clear H'0.\ngeneralize H'1; clear H'1; intros.\nelim H'0; clear H'0.\nelim H'1; clear H'0.\nintros;Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\n(* Proof of lem_Rel_EX_Out_Out_Out_Out_Out_Out_Out_Out_fun_eq_back_fun_and_back_eq_fun_back_fun_back_and_back_fun_back_and_back_fun_back_and_back_back_and_back_back_fun_back_back_and_back_and_back_back_back_back_back_and_back_back_back_back_or_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_back_backQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\n(* Proof of lem_Prod_Prop                                                    *)\nintros E E' E'' H'0; generalize (H' H'0); clear H'0 H'1.\n\nelim (H' (fun B : Ens => EQ (Couple A B) E)); intros B E;\n generalize (H' H'0); clear H' H'0 H'1; intros.\nelim (H' (fun B : Ens => EQ (Couple A B) E')); intros B E;\n generalize (H' H'0); clear H' H'0 H'1; intros.\nelim (H' (fun B : Ens => EQ (Couple A B) E)); intros B E;\n generalize (H' H'0); clear H' H'0 H'1; intros.\nelim (H' (fun B : Ens => EQ (Couple A B) E)); intros B E;\n generalize (H' H'0); clear H' H'0 H'1; intros.\nelim (H' (fun B : Ens => EQ (couple A B) B)); intros B E;\n generalize (H' H'0); clear H' H'0 H'Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n(* Proof of lem_Prod_fun_choice                                       *)\nintros E E' E'' E'' E'' F G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G G.\n\napply axs_extensionnalite; intros.\nunfold iff in |- *.\nelim\n (axs_comprehension\n    (fun c : E =>\n     exists x : E, (exists y : E, c = couple x y /\\ c = couple y x))\n    (cartesien (E' := fun c : E => c = couple y c) \n    (cartesien (E' := fun c : E => c = couple y c)) \n    (cartesien (E' := fun c : E => c = couple y c)) \n    (cartesien (E' := fun c : E => c = couple y c) \n    (cartesien (E' := fun c : E => c = couple y c)).\n(* Proof of lem_Img_fun_choice                                       *)\nintros.\nelim\n (axs_comprehension\n    (fun c : E =>\n     exists x : E, (exists y : E,Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\nunfold iff in |- *.\nintros E E' E' E' H'0; elim H'0; clear H'0.\nunfold iff in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\n(* Definition of lem_fun_function_of_function_of_function_of_function_of_function_of_function_of_statement *)\n\n(***************************************************************************)\n(* Provi, application de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'image de l'imageQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n(* Proof of lem_Prod_EXType. *)\n\nLemma lem_equiv_prop : forall E : Ens, SUB E E.\n(* Proof of lem_equiv_prop                                              *)\nintros.\napply axs_extensionnalite; intros; apply axs_extensionnalite; intros; apply axs_extensionnalite;\n intros; apply axs_extensionnalite; intros; apply axs_extensionnalite; intros;\n apply axs_extensionnalite; intros; apply axs_extensionnalite; intros.\nunfold iff in |- *; intros.\nelim\n (axs_comprehension\n    (fun x0 : E => exists x0 : E, In x0 (parties (Img E)) /\\ In x0 (parties (Img E)))\n    (fun x : E => exists x0 : E, In x0 (parties (Img E)))\n    (fun x : E => exists x0 : E, In x0 (parties (Img E)) /\\ In x0 (parties (Img E)))\n    (fun x : E => exists x0 : E, In x0 (parties (Img E)))\n    (fun x : E => exists x0 : E, In x0 (parties (Img E)) /\\ In x0 (parties (Img E)))\n    (fun xQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\n(* Proof of lem_Prod_prop                                                    *)\nintros E E' E'' E'' E'' E'' H'.\nelim (IN_EX (fun A : Ens => existsType _ (fun B : Ens => EQ (Couple A B) E')))\n    (fun A : Ens => existsType _ (fun B : Ens => EQ (Couple A B) A)) (fun B : Ens => EQ (dir A B)) (fun B : Ens => EQ (Couple A B) E'))\n    (fun A : Ens => existsType _ (fun B : Ens => EQ (Couple A B) A)) (fun B : Ens => EQ (Couple A B) A)).\n\nTheorem lem_cartesian_is_in :\n forall E E' : Ens,\n IN (parties E) (parties E') -> existsType _ : Ens, In (parties E) (parties E').\nintros E E' H'.\nelim (IN_parties_in (fun A : Ens => existsType _ : Ens => EQ (couple A B) A)).\n\n (fun A : Ens => existsType _ : Ens => EQ (couple A B) A) (fun B : Ens => EQ (couple AQed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\n(* Proof of lem_equiv_fun_choice                            *)\nunfold iff in |- *; intros; apply axs_extensionnalite; intros.\nunfold iff in |- *; intros.\nunfold iff in H.\nelim\n (axs_comprehension\n    (fun c : E =>\n     exists x : E,\n       (exists y : E,\n          (exists y : E,\n             In (couple x y) (equiv (Couple A B) y) /\\ c = couple x y))\n    (cartesien (parties (dom E')) (parties (dom E'))); intros.\nelim H; clear H; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros.\nelim (axs_reunion (parties (dom E')) (parties (dom E))); intros.\nelim H0; clear H0; intros; elim H0; clear H0; intros.\nexists x; auto with zfc.\n\nelim (axs_reunion (parties (dom E')) (parties (dom E))); intros.\nelim H0; clear H0; intros; elim H0; clear H0; intros; elim H0; clear H0;\n intros.\nelim (axs_reunion (Qed.",
                    "Theorem IN_Prod_EXType : forall E E' E'' : Ens, IN E'' (Prod E E') -> EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\n\nTheorem lem_choice_imp_transitive :\n forall (E : Ens) (f : E) (Af : fun_ f), fun_ f Af.\n\n(* Proof of lem_choice_imp_transitive                                              *)\nintros.\napply axs_extensionnalite; intros.\nelim (axs_comprehension (fun y : E => exists B : Ens, In B E) (parties B)).\nintros H0; elim H0; intros.\nexists (fun x : E => exists B : Ens, In B E).\nsplit; [ idtac | auto with zfc ].\nelim (axs_reunion (reunion (reunion (reunion (Img f))) (reunion (Img f)))).\nintros H0; elim H0; intros.\nexists (fun x : E => exists B : Ens, In B E).\nsplit; [ idtac | auto with zfc ].\nelim (axs_reunion (reunion (reunion (Img f))) (reunion (Img f))).\nintros H1; elim H1; intros.\nexists (fun x : E => exists B : Ens, In B E).\nsplit; [ idtac | auto with zfc ].\nelim (axs_reunion (reunion (Img f)) (reunion (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\n",
                "context_tokens": 399,
                "proof_start_offset": 1897,
                "proof_end_offset": 2155,
                "proof": "Definition EQC : Ens -> Ens -> Type.\nProof.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition EQC : Ens -> Ens -> Type.\nexact (Build_Predicate (Pred_fun:=fun x : Prop => ~ P x)).\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintro.\napply (Build_Predicate (fun x : X => EQC x)).\nred in |- *.\nintros x H'; elim H'; intros H'0 H'1; clear H'.\nintros x0 H'0.\ngeneralize (H' x0); clear H'.\nelim H'; intros H'1 H'2; clear H'.\nelim H'; intros H'2 H'3; clear H'.\nelim H'; intros H'3 H'4; clear H'.\nelim H'; intros H'4 H'5; clear H'.\nelim H'; intros H'5 H'6 H'7; clear H'.\nelim H'5; intros H'7 H'8; clear H'5 H'7.\nelim H'8; intros H'8 H'8; clear H'8 H'8 H'9; clear H'8 H'9 H'10 H'11.\nelim H'8; intros H'9 H'10; clear H'9 H'10.\nelim H'10; intros H'10 H'10; clear H'10.\nelim H'10; intros H'10 H'10;Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQC : Ens -> Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQC : Prop := EQC 1.\n\nDefinition EQDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nDefinition EQC : Prop := (fun C : Prop => (C -> Prop)) -> EQC.\n\nDefinition EQC : Prop -> Prop := (fun C : Prop => (C -> Prop)) -> EQC.\n\nDefinition EQC : Prop -> Prop := (fun C : Prop => (C -> Prop)) -> EQC.\n\nDefinition EQC : Prop -> Prop := (fun C : Prop => (C -> Prop)) -> EQC.\n\nRecord EQC := { equivC : Prop; equivC : EQC; equivC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC : EQC; EQC; EQC : EQC; EQC : EQC; EQC; EQC : EQC; EQC; EQC : EQC; EQC; EQC; EQC : EQC; EQC; EQCDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\n(* We show that the domain of an relations and  *)\n(*   Lemma: the reflexive closure of an equivalence relation  *)\n\n(*  - A is a total relation for the image of an relation on the  *)\n(*  elements of the elements of the domain of the domain of  *)\n(*   elements of the elements of its elements of the elements of the  *)\n(*   the set of the set of its elements of the set is a  *)\n(*  - A is the set of the elements of the set of A *)\n(*  - A is a subset of the set of the set of A *)\n(*  - A is the set of the set of the set of the elements of the set of the  *)\n(*   - A is a subset of the set of the set of the set of A *)\n(*  - A is the set of the set of the set of the set of A *)\n(*  - A is the set of the set of the set of the set of the set of A *)\n(*  - A is the set of the set of the set of the set of A *)\n(*  - A is the set of the set of the set of theDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\n\nRecord EQ (A : Ens) : Prop :=\n  {x : A; y : Prop;\n   EQ1 : EQA x;\n   EQ2 : EQA x;\n   EQ3 : EQA x;\n   EQ4 : EQA x;\n   EQ4 : EQA x;\n   EQ4 : EQA x;\n   EQ5 : EQA x;\n   EQ5 : EQA x;\n   EQ6 : EQA x;\n   EQ6 : EQA x;\n   EQ7 : EQ A x;\n   EQ7 : EQ A x;\n   EQ7 : EQ A x;\n   EQ7 : EQ A x;\n   EQ8 : EQ A x;\n   EQ9 : EQ A x;\n   EQ9 : EQ A x;\n   EQ9 : EQ A x;\n   EQ9 : EQ A x;\n   EQ9 : EQ A x;\n   EQ9 : EQ A x;\n   EQ9 : EQ A x;\n   EQ10 : EQ A x;\n   EQ10 : EQ A x;\n   EQ10 : EQ A x;\n   EQ10 : EQ A x;\n   EQ10 : EQ A x;\n   EQ10 : EQ A x0;\n   EQ10 : EQ A x0;Defined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintro H.\napply H0.\nexact (Build_Predicate (fun x : IN (I x) => x) (fun x : IN (I x) => H0 x)).\nred in |- *.\nintros x H'.\nelim H'.\nintros x H'.\nelim H'.\nintros x0 H'0.\nelim H'0; intros x1 H'1 H'2; elim H'1; intros H'3 H'4; clear H'0 H'1 H'2 H'3 H'4.\nelim H'1; intros x2 H'5; clear H'1 H'1 H'5.\nelim H'1; intros x3 H'6; clear H'1 H'1 H'6.\nelim H'1; intros x4 H'7; clear H'1 H'1 H'7.\nelim H'7; intros x5 H'7; clear H'1 H'1 H'8.\nelim H'8; intros x5 H'7; clear H'1 H'5 H'7.\nelim H'7; intros x6 H'7; clear H'7 HDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintro.\napply (Build_Predicate (Pred_fun:=fun x : IN _ => EQC x)).\nred in |- *.\nintros x y H'; elim H'; intros H'0 H'1; elim H'0; intros H'1 H'2; clear H'0.\nexists x; exists y; split; [ auto | idtac ].\napply Trans with (y := y); auto.\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nexact (Build_Predicate (fun _ => EQC) (fun _ => EQC)).\nDefined.",
                    "Definition EQC : Ens -> Ens -> Type.\nintro H.\napply H.\nred in |- *; intro H0.\napply H0.\nred in |- *; intro H0.\napply H0.\nred in |- *; intro H1.\napply H0.\nred in |- *; intro H1.\napply H0.\nred in |- *; intro H1.\napply H1.\nred in |- *; intro H2.\napply H2.\nred in |- *; intro H3.\napply H3.\nred in |- *; intro H3.\napply H3.\nred in |- *; intro H3.\napply H3.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\napply H3.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\napply H4.\nred in |- *; intro H4.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\n",
                "context_tokens": 502,
                "proof_start_offset": 2179,
                "proof_end_offset": 2298,
                "proof": "Definition CIN : Ens -> Ens -> Type.\nProof.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CIN : Ens -> Ens -> Type.\nintros C D.\napply (Build_Predicate (fun x : A => ~ (CIN (CIN x)))).\nexact (Build_Predicate (fun x : A => ~ (CIN (CIN x))).\nexact (Build_Predicate (fun x : A => ~ (CIN (CIN x)))).\nexact (Build_Predicate (fun x : A => ~ (CIN (Cconj x)))).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nexact (Build_Predicate (fun x : A => exists y : B, f y = f y)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros.\napply (Build_Predicate (fun A : Ens => ~ A)).\nexact (Build_Predicate (fun A : Ens => ~ A)).\nexact (Build_Predicate (fun A : Ens => ~ A)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros C D f H'; elim H'; intros H'0; elim H'0; intros H'1; elim H'1; intros H'2; clear H'0.\nexact (fun x : A => forall y : B, (forall x : B, x = y) -> CER _ (fun x : A => eq2 x (g y))).\nexact (fun x : A => forall y : B, (forall x : B, x = y) -> CER _ (fun x : A => eq2 x (g y)).\nexact (fun x : A => forall y : B, (forall x : B, x = y) -> CER _ (fun x : A => eq2 x (g y))).\nexact (fun x : A => forall y : B, (forall x : B, x = y) -> CER _ (fun x : A => eq2 x (g y))).\nexact (fun x : A => forall y : B, (forall x : B, x = y) -> CER _ (fun x : A => eq2 x (g y))).\nexact (fun x : A => forall y : B, (forall xDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1; intros C0 f eq1.\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nexact (Build_Setoid (C:=C)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros.\napply (Build_Predicate (fun A : Ens => EQC A)).\nexact (Build_Predicate (fun A : Ens => EQC A)).\nexact (Build_Predicate (fun A : Ens => EQC A)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nsimple induction 1.\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nexact (Build_Predicate (fun x : A => x)).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros C D.\napply (Build_Predicate (fun x : A => exists y : C, exists x : C, In x (g y)).\nred in |- *.\nintros x y H'; elim H'; intros y0 H'0; exists y0; auto with algebra.\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros H x.\napply (Build_Predicate (fun x : A => forall y : B, CIN _ (f y))).\nexact (Build_Predicate (fun x : A => forall y : B, CIN _ (f x))).\nDefined.",
                    "Definition CIN : Ens -> Ens -> Type.\nintros H; elim H.\nintros x y H'0; elim H'.\nintros x y H'1; elim H'0.\nintros x y H'1; elim H'1; intros H'2 H'3; apply H'3; clear H'.\nexact (fun x y : A => eq1 x y /\\ x = y).\nexact (fun x y : A => eq1 x y /\\ x = y).\nexact (fun x y : A => eq1 x y /\\ x = y).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\n",
                "context_tokens": 551,
                "proof_start_offset": 2319,
                "proof_end_offset": 2425,
                "proof": "Definition CINC : Ens -> Ens -> Type.\nProof.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nexact (Build_Map (fun y : A => EQC X (e y))).\n\n(* DARTES *)\n\nDefinition C : Ens -> Prop := forall x y : A, EQC (e x) (e y).\n\nDefinition C : Ens -> Prop := forall x y : A, EQC (e x) (e y).\n\nRecord C : Set := { C : Ens; D : Ens }.\n\nRecord C : Set := { D_in : C; D_in : C}.\n\nDefinition C : Set := Set.\nRecord C : Set := { D_in_in : D; D_in_in_ : D_in}.\n\nDefinition D : C -> Set := Set.\n\nRecord D (D : Ens) := { D_in_in : D; D_in_in_ : D_in D_in}.\n\nDefinition D_in_in : D -> D -> C :=\n  fun x : D => exists y : D, D_in D D_in D_in D_in D_in D_in D_in D_in D_in D_in D_Defined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X)))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nexact (Build_Map (fun X : Ens => EQC X (e X))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (Build_Strict (fun y : A => EQC X (e y))).\nexact (Build_Setoid (C:=C) (fun x : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nintros.\nexact (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_compatible (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_compatible (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible (Build_compatible_compatible_compatible (Build_compatible (m n))))\n    (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_compatible (Build_compatible (Build_compatible (Build_compatible_compatible (Build_compatible (Build_compatible_compatible (m n))))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (Build_Map (fun x : A => EQC X (e y))).\nexact (Build_Map (fun x : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 2.\nexact (Build_PreCategory (fun y : A => EQC X (e y))).\nexact (Build_PreCategory (fun y : A => EQC X (e y))).\nexact (Build_PreCategory (fun y : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nexact (fun y : A => EQC X (e y)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (Build_Setoid (fun x : A => EQC X (e y))).\nexact (Build_Setoid (fun x : A => EQC X (e y))).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nexact (Build_Setoid (C:=Prop)).\nDefined.",
                    "Definition CINC : Ens -> Ens -> Type.\nsimple induction 1.\nintros.\nexact (CART (fun y : A => EQC X (e y))).\nexact (CART (fun y : A => EQC X (e y))).\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "ms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\n",
                "context_tokens": 589,
                "proof_start_offset": 2470,
                "proof_end_offset": 2634,
                "proof": "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\nexists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nTheorem EQC_trans : forall E : Ens, EQC E (E (E (E (E (E (E (E E)))) -> EQC E (E (E (E (E E) (E E) (E E))).\nProof EQC_trans.\n\nTheorem EQC_trans : forall E E : Ens, EQC E E -> EQC E (E E) (E (E (E E) (E E)).\nProof EQC_trans.\n\nTheorem EQC_trans : forall E E : Ens, EQC E (E (E (E E) (E (E E) (E E))).\nProof EQC_trans.\n\nTheorem EQC_trans : forall E E : Ens, EQC E (E E) (E (E E) (E E) (E E).\nProof EQC_trans.\n\nTheorem EQC_trans : forall E E : Ens, EQC E (E (E E) (E E) (E E) (E EQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall (E : Ens) (X : Ens) (X : Ens), EQ (PAIR X X) X.\nProof EQC_sym.\n\nTheorem EQC_sym : forall (E : Ens) (X : Ens) (X : Ens), EQ (PAIR X X) X.\nProof EQC_sym.\n\nTheorem EQC_sym : forall (E : Ens) (X : Ens) (X : Ens), EQ (PAIR X X) X.\nProof EQC_sym.\n\nTheorem EQC_trans :\n forall (E : Ens) (X : Ens) (X Y : Ens), EQ (PAIR X Y) Y.\nProof EQC_sym.\n\nTheorem EQC_symm :\n forall (E : Ens) (X : Ens) (X Y : Ens), EQ (PAIR X Y) X.\nProof EQC_symm.Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_sym : forall E : Ens, EQC E E -> EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQC E E -> EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQC E E -> EQ C E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQ C E -> EQ C E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQ C E -> EQ C E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQ C E -> EQ C E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQ C E -> EQ C E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQ C E -> EQ C E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQ C E -> EQ C EQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_trans :\n forall (A B : Ens) (B C' : Ens) (f : EQ C' B C') (f : EQ C' B C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C')\n(g : EQ C' C) (g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C')\n(g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C')\n(g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C')\n(g : EQ C' C') (g : EQ C' C') (g : EQ C' C') (g : EQ C' C')\n(g :Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_sym : forall E : Ens, EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQC E E.\nProof EQC_sym.\n\nTheorem EQC_sym : forall E : Ens, EQC E E.\nProof EQC_sym.\n\nTheorem EQC_trans : forall E E : Ens, EQC E E -> EQC E E.\nProof EQC_sym.\n\nTheorem EQC_trans : forall E E : Ens, EQC E E -> EQC E E.\nProof EQC_trans E.\n\nTheorem EQC_trans : forall E E : Ens, EQC E E -> EQC E E.\nProof EQC_trans E.\n\nTheorem EQC_trans : forall E E : Ens, EQC E -> EQC E -> EQC E.\nProof EQC_trans E.\n\nTheorem EQC_trans : forall E E' : Ens, EQC E' -> EQC E' -> EQC E' E'.\nProof EQC_trans E'.\n\nTheorem EQC_Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nintros E.\nexact (Build_Setoid (C:=E) (C:=E)).\nexact (Build_Setoid (C:=E) (C:=E)).\nexact (Build_Setoid (C:=E) (C:=E) (C':=E)).\nQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nTheorem EQC_sym : forall (E : Ens) (x y : E), EQC E x y.\nProof EQC_sym (EQC_sym (EQC E x y)).\n\nSection EQC_trans_proof.\nVariable E : Ens.\nHypothesis f : EQ C E.\n\nLet step1 : EQ C E.\nProof EQC E.\n\nLet step2 : EQ C E.\nProof EQC E.\n\nLet step3 : EQ C E.\nProof EQC E.\n\nLet step4 : EQ C E.\nProof EQC E.\n\nLet step5 : EQ C E.\nProof EQC E.\n\nLet step6 : EQ C E.\nProof EQC E.\n\nLet step6 : EQ C E.\nProof EQC E.\n\nLet step7 : EQ C E.\nProof EQC E.\n\nLet step7 : EQ C E.\nProof EQC E.\n\nLet step8 : EQ C E.\nProof EQC E.\n\nLet step9 : EQ C E.\nProof EQC E.\n\nLet step8Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nunfold EQC in |- *.\nintros.\nexact (Build_Predicate (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_Predicate (Build_Predicate (Build_fun:=fun x : A => EQC (f x))).\nexact (Build_PredicateQed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\nEnd EQC_refl.\n\nTheorem C_trans : forall E : Ens, EQC E E.\nProof EQC_trans.\n\nSection D_trans_in_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_dom_in_dom_in_dom_in_dom_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_in_dom_Qed.",
                    "Theorem EQC_refl : forall E : Ens, EQC E E.\nProof EQC_refl.\n\n\n(**************)\n(*   To do not need to define the following proof of the same definition *)\n(* of the proof of the same properties *)\n(* we have the same properties of the same properties *)\n(* and the proof of the same properties *)\n\nTheorem B_sym_eq_eq_0 : forall A : Ens, A -> A = B.\nProof B_sym_eq_0.\n\nTheorem B_sym_eq_0 : forall A B : Ens, A -> B = B.\nProof B_sym_eq_0.\n\nTheorem B_trans_eq_0 : forall A B C : Ens, A -> B = C -> B = C.\nProof B_trans_eq_0.\n\n(**************)\n\n(**************)\n\n(**************)\n\nDefinition B_1 (A : Ens) := forall i j : B, A i j -> B i j.\n\nTheorem B_1_proof_Out : IN A.\nProof B_1_proof_Out.\n\n(**************)\n\n(**************)\n\nDefinition B_1 (A : Ens) := forall i j : B, A i jQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                              *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\n",
                "context_tokens": 602,
                "proof_start_offset": 2636,
                "proof_end_offset": 3027,
                "proof": "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *; intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3 (fun x : A => EQC E1 (fun x : A => EQC E2 (f x))).\n\nTheorem EQC_symm :\n forall (A B C : Ens) (f : EQ C A), EQ (EQC A) (EQC B) (EQC C A).\nProof\n  fun (A B C : Ens) (f : EQ C A) =>\n  EQC (EQC A) (EQC A) (EQC B) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQC A) (EQQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3 E4.\n\nTheorem EQC_trans : forall E1 E2 E3 E4 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3 -> EQC E1 E3.\nProof\n  fun E1 E2 E3 E4 : Ens =>\n  EQC E1 E2 E3 E4.\n\nTheorem EQC_trans : forall E1 E2 E3 E4 : Ens, EQC E1 E2 -> EQC E1 E2 -> EQC E1 E3 -> EQC E2 E4.\nProof\n  fun E1 E2 E3 E4 : Ens =>\n  EQC E1 E2 E4.\n\nTheorem EQC_trans :\n forall E1 E2 E3 E4 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3 -> EQC E1 E4.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3 E4.\n\nTheorem EQC_trans :\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\n\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3 (fun E1 : Ens => EQC E1 E2 -> CIN E1 E2) (fun E2 : Ens => EQC E1 E2 -> EQC E1 E2) (fun E3 : Ens => EQC E1 E2 E3) (fun E4 : Ens => EQC E1 E2 E3) (fun E5 : Ens => EQC E1 E2 E3) (fun E5 : Ens => EQC E1 E2 E3) (fun E5 : Ens => EQC E1 E2 E3) (fun E5 : Ens => EQC E1 E2 E3) (fun E5 : Ens => EQC E1 E2 E3) (fun E6 : Ens => EQC E1 E2 E3) (fun E7 : Ens => EQC E1 E2 E3) (fun E7 : Ens => EQC E1 E2 E3) (fun E7 : Ens => EQC E1 E2 E3) (fun E7 : Ens => EQC E1 E2 E3Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  forall E : Ens, EQC E1 E2 -> EQ C E2 -> EQ C E3 -> EQ C E1 E3.\n\nProof\n  fun E1 E2 E3 : Ens =>\n  forall E : Ens, EQ C E -> EQ C E2 -> EQ C E1 E3 -> EQ C E1 E3.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQ C E1 E2 -> EQ C E2 -> EQ C E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  forall E : Ens, EQ C E -> EQ C E2 -> EQ C E1 E3.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQ C E1 E2 -> EQ C E2 -> EQ C E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  forall E : Ens, EQ C E -> EQ C E1 E2 -> EQ C E1 E3.\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQ C E1 E2Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof\n  fun (fun E : Ens => EQC E E1 E2 -> EQC E1 E2 -> EQC E1 E3) (fun E1 : Prop => EQC E1 E2 E3).\n\n (fun E : Ens => EQC E (fun y : Ens => EQC E (f y))).\n\nTheorem EQC_symm : forall E : Ens, EQC E (fun y : Ens => EQC E (f y)).\nProof\n  fun (fun (A : Ens) (f : A -> E) (g : A -> E) (g : A -> E) =>\n  EQC_symm (fun (A : Ens) (f g : A -> E) (g : A -> E) =>\n  EQC_symm (fun (A : Ens) (g : A -> E) (g : A -> E) =>\n  EQC_symm (fun (A : Ens) (g : A -> E) (g : A -> E) =>\n  EQC_symm (fun (A : Ens) (g : A -> E) (g : A -> E) =>\n  EQC_symm (fun (A : Ens) (Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nintros E1 E2 E3 E4.\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nexact (Build_Map (fun x : A => EQC (f x))).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nunfold C at 1 in |- *; intros E1 E2 E3.\nexact (EQC_irrefl (E1:=E2)).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof.\nunfold C at 1 in |- *; intros E1 E2 E3 H0.\napply (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Functor_cat E1 E2)))) (E1 E2)).\nexact (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Build_PreCategory (Functor_cat E1 E2)))) (E1 E2)).\nQed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3 -> EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\n\nSection Compar2.\nVariable E F : Ens -> Set.\nHypothesis i : E.\n\nLet i2 := Build_definedness E (F2 F).\nLet i3 := Build_definedness E (F2 F).\nLet i3 := Build_definedness F (F2 F).\nLet i3 := Build_definedness F (F2 F).\nLet i4 := Build_definedness F (F2 F).\nLet i4 := Build_definedness F (F2 F).\n\nLet i6 := Build_definedness F (F2 F).\n\nLet i7 := Build_definedness F (F2 F).\n\nLet i7 := Build_definedness F (F2 F).\n\nLet i7 := Build_definedness F (F2 F).\n\nLet i7 := Build_definedness F (F2 F).\n\nLet i7 := Build_definedness F (F2 F).\n\nLet i8 := Build_definedness F (F2 F).Qed.",
                    "Theorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\n\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3 (fun x : A => EQC E1 (f x)).\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQ C E1 E3 -> EQ C E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 (fun x : A => EQC E1 (f x)).\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E1 E2 -> EQ C E2 -> EQ C E3 -> EQ C E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 (fun x : A => EQC E1 (f x)).\n\nTheorem EQC_trans :\n forall E1 E2 E3 : Ens, EQC E1 E2 -> EQ C E2 -> EQ C E1 E3.\nProof\n  fun E1 E2 : Ens =>\n  EQC E1 (fun x : A => EQC E1 (f x)).\n\nDefinition EQCQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "                                                  *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\n",
                "context_tokens": 692,
                "proof_start_offset": 3029,
                "proof_end_offset": 3283,
                "proof": "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nunfold EQC in |- *; intros E1 E2; apply EQC_sym.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nunfold EQC, EQC, EQC in |- *; intros.\nsplit; intros.\napply H0.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nunfold EQC in |- *; auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\n\nsimple induction E1; intros; apply EQC_sym; intros.\nsplit; [ elim X2; intros ].\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nexists x1.\napply X2; assumption.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; intros E2 E3.\nexists E2.\nsplit; [ try assumption | idtac ].\napply EQC_sym; assumption.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nunfold EQC in |- *; intros E1 E2; exists E2; split; intros.\nsplit; [ elim (H0 x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nelim (a x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nintros E1 E2 E3.\nexact (Build_equiv C E1 E2 E3).\n\nTheorem EQC_trans : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nProof\n  fun E1 E2 E3 : Ens =>\n  EQC E1 E2 E3; auto with zfc.\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nsimple induction E1; intros A f Ht; elim Ht;\n [ intros x0; apply X1; exists x0; auto with zfc\n | intros x0; elim (a x0); intros.\nelim (a x0); intros.\nelim (a0 x0); intros.\nelim (a0 x0); intros.\nexists x0.\napply X2 with (e0 x0); auto with zfc.\n\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nProof.\nunfold EQC in |- *; intros E1 E2.\napply (EQC_trans (fun y : A => EQC E1 E2) (e0 x0)).\nQed.",
                    "Theorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\n\n(* Proof of lem_sym_sym_sym_sym_sym_sym_sym_sym_sym_sym_sym. *)\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E1 E2.\nProof.\nintros E1 E2 E3.\nexact (fun E1 E2 : Ens => EQC E1 E2).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "oor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* Peter Aczel's Encoding of CZF *)\n\n(* Using the same definition \"Ens\" of sets, we can developp Peter Aczel's   *)\n(* encoding of \"Constructive Type Theory\" (CZF).                            *)\n(* It is basically a simillar developement, but this time, the propositions *)\n(* are objects of type \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 3285,
                "proof_end_offset": 3557,
                "proof": "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nProof.\nsimple induction E; simple induction E'; simpl in |- *; intros; unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n(* Proof of lem_pair_th_pr_sym; intros.\ngeneralize (equivC_Var X E' E' H); intros.\ngeneralize (equivC_Var X E' H); intros.\ngeneralize (equivC_Var X E' H'); intros.\ngeneralize (equivC_Var X E' H'); intros.\ngeneralize (equivC_Var X E' H'); intros.\ngeneralize (equivC_Var X E' H'); intros.\nelim (b0 x); intros.\nelim (a x); intros.\nelim (a0 x0); intros.\nelim (a0 x0); intros.\nelim (a0 x0); intros.\nelim (a0 x0); intros.\nelim (a x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n\n(* Proof of lem_pr_sym                                            *)\nintros.\nunfold C in |- *; intros.\nelim (axs_comprehension (fun y : A => EQC X (e y))).\nintros a y H; apply H; clear H H0 H1; intros.\nsplit; intros.\nelim (lem_cartesian_propertie a a y); intros.\nelim (lem_cartesian_propertie a a y); intros.\nelim (lem_cartesian_propertie a a y); intros.\nelim H0; intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n\n(* Proof of lem_rel_and_sym                                            *)\n\nintros; apply EQC_sym; apply EQC_sym; apply EQC_sym; apply EQC_sym; apply EQC_sym;\n assumption.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E E' E' H'.\ncut (EQC E' E' /\\ C<> E').\nintros.\napply EQC_trans with (fun y : E => EQC E' y) (e0 y); auto with zfc.\nelim (b0 x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nexists x0; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nintros E E' H'.\napply EQC_trans with (fun y : E => EQC E' E' y).\nexact (fun x : E => EQC E' x).\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_commut_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E1 E2.\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_assoc_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E1 E2.\n(* Proof of lem_assoc_sym                                            *)\n\nTheorem lem_assoc_sym : forall E1 E2 E3 : Ens, EQD E1 E2 -> EQC E2 E3 -> EQC E1 E3.\n(* Proof of lem_assoc_sym                                            *)\n\nTheorem lem_assoc_sym : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\n(* Proof of lem_assoc_sym                                            *)\n\nTheorem lem_assoc_sym : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\n(* Proof of lem_assoc_sym                                            *)\n\nTheorem lem_assoc_Qed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n\n(* Proof of lem_and_pair_th_prop                                      *)\n\nunfold C in |- *; intros.\nsplit; intros.\nelim H0; intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nunfold EQC in |- *; intros E' H'; try assumption.\nelim (lem_cartesian_propertie A B C H').\nQed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_commut_sym : forall E E' : Ens, EQC E E' -> EQC E' -> EQC E'.\n\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_commut_sym : forall E E' : Ens, EQC E' -> EQC E' -> EQC E'.\n\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_commut_sym : forall E E' : Ens, EQC E' -> EQC E'.\n\n(* Proof of lem_commut_sym                                               *)\n\nTheorem lem_commut_sym : forall E E' : Ens, EQC E' -> EQC E'.\n\n(* Proof of lem_commut_sym                                               *)\n\nTheorem lem_commut_sym : forall E E' : Ens, EQC E' -> EQC E'.\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_commut_sym : forall E E' : Ens, EQC E' -> EQ C E'.\n(* Proof of lem_commut_sym                                            *)\n\nTheorem lem_assoc_sym : forall E E'Qed.",
                    "Theorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\n\n(* Proof of lem_rel_trans E' E' H'.\n(* Proof of lem_rel_trans E' E' H'.\n(* Proof of lem_rel_trans E' E' H'. *)\nintros.\nunfold EQC in |- *; unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;\n unfold EQC in |- *; unfold EQC in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " \"Type\", i.e. are on the same level (resp. above) the *)\n(* sets. The advantage is that we can extract the constructive witness of an*)\n(* existential proof. The drawbacks are:                                    *)\n(*  - no definition of the powerset                                         *)\n(*  - complicated difference between bounded and unbounded quantification   *)\n(*  - excluded middle is now much more \"dangerous\"                          *)\n\n\nRequire Import Sets.\nRequire Import Axioms.\n\n\nDefinition EQC : Ens -> Ens -> Type.\nsimple induction 1; intros A f eq1.\nsimple induction 1; intros B g eq2.\nrefine (prod_t _ _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3604,
                "proof_end_offset": 3966,
                "proof": "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *; intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x))); try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros.\napply EQC_trans with (e x0); auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; unfold CINC in |- *; simpl in |- *;\n auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\n\nTheorem C_pr1 : forall E E' : Ens, CINC E E' -> CINC E E'.\n\nTheorem C_pr2 : forall E E' : Ens, CINC E E' -> CINC E' E'.\n\nTheorem C_pr1 : forall E E' : Ens, CINC E E' -> CINC E' E'.\n\nTheorem C_pr2 : forall E E' : Ens, CINC E E' -> CINC E' E'.\nProof\n  C_pr1 (fun E : Ens => C) (C_pr1 E E' C_pr2).\n\nTheorem C_pr1 : forall E E' : Ens, CINC E E' -> C_pr E' E'.\nProof\n  C_pr1 (fun E : Ens => C) (C_pr1 E E' C_pr1).\n\nTheorem C_pr2 : forall E E' : Ens, C_pr E E' -> C_pr E' E'.\nProof\n  C_pr2 (fun E : Ens => C) (C_pr1 E E' C_pr2).\n\nTheorem C_pr3 :Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros E' E' H'.\napply H'.\n\nexact (fun x y : E => EQC (e x) (e y) (e y)).\n\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nunfold C at 1 in |- *; intros E E' H'0 H'1 H'2.\ngeneralize (equivC_trans _ _ _ H'0 H'1).\n\nunfold C at 1 in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nintros.\napply CINC_EQC.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; intros.\napply EQC_trans with (e0 x); auto with zfc.\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nintros E E' E' H'.\nexact (Build_invC_sym E C E' H' H').\nQed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\n\n(* Proof of lem_inc_sym                                            *)\n\nTheorem C_trans : forall E E' : Ens, CINC E E' -> CINC E E'.\n(* Proof of lem_inc_sym                                            *)\n\nTheorem C_trans : forall E E' : Ens, CINC E E' -> C_trans E' E'.\n(* Proof of lem_inc_sym                                                 *)\n\nTheorem C_trans : forall E E' : Ens, C_trans E' E' -> C_trans E' E'.\n(* Proof of lem_inc_sym                                            *)\n\nTheorem C_trans : forall E E' : Ens, C_trans E' E' -> C_trans E' E'.\n(* Proof of lem_trans_sym                                            *)\n\nTheorem C_trans : forall E E' : Ens, C_trans E' E' -> C_trans E' E'.\n(* Proof of lem_trans_sym                                            *)\n\nTheorem C_trans : forall E E' : Ens, C_trans E E' -> C_trans E' E'.\n(* Proof of lem_trans_sym                                  *)\n\nTheorem C_trans : forall E E'Qed.",
                    "Theorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nProof.\nunfold CINC in |- *.\nintros E E' H'0 H'1 H'2.\ngeneralize (H'0 E'1 H'2).\n\nrewrite <- H'1; rewrite <- H'2; auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " _).\nexact (forall x : A, depprod _ (fun y : B => eq1 x (g y))).\nexact (forall y : B, depprod _ (fun x : A => eq1 x (g y))).\nDefined.\n\n\n\n(* APPARTENANCE *)\n\nDefinition CIN : Ens -> Ens -> Type.\nsimple induction 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4001,
                "proof_end_offset": 4205,
                "proof": "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\n\nTheorem CIN_rev_l : forall E F G : Ens, EQF G E -> C<>G -> C<>G.\n\nTheorem CIN_rev_r : forall E F G : Ens, EQF G E -> C<>G -> C<>G.\n\nTheorem CIN_rev_r : forall E F G : Ens, EQF G E -> C<>G.\n\nTheorem CIN_rev_r : forall E F G : Ens, EQF G E -> C<>G.\n\nTheorem CIN_rev_r : forall E F G : Ens, EQF G E -> C<>G.\n\n forall G G : Ens, EQG G E -> C<>G.\nProof\n  fun G G : Ens, EQG G E -> C<>G.\n\nTheorem C G_next_r : forall E F G : Ens, EQG G E -> C<>G.\nProof\n  fun G G : Ens =>\n  forall G : Ens, EQG G E -> C<>G.\n\nTheorem C G_next_r : forall E F G : Ens, EQG G E -> C<>G.\nProof\n  fun G G :Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nunfold CIN in |- *.\nintros E E' E'' H0 H1; elim H0; intros.\nelim (lem_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_andQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\n\nTheorem CIN_rev_th : forall E E' : Ens, EQC E E' -> C<> E'.\n\nTheorem CIN_rev_th : forall E E' : Ens, EQC E' -> C<> E'.\n\nTheorem CIN_rev_th : forall E E' : Ens, EQC E' -> C<> E'.\n\nTheorem CIN_rev_th_rev_th :\n forall E E' : Ens, EQC E' -> C<> E'.\n\nTheorem CIN_rev_th_rev_th :\n forall E E' : Ens, EQC E' -> C<> E'.\n\nTheorem CIN_rev_th_rev_th_rev_th :\n forall E E' : Ens, EQC E' -> C<> E'.\n\nTheorem CIN_rev_th_rev_th_rev_th :\n forall E E' : Ens, EQC E' -> C<> E'.\n\nTheorem CIN_rev_th_rev_th_rev_th_rev_th_rev_th :\n forall E E' : Ens, EQC E' -> C<> E'.\nProofQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nunfold Cconj in |- *; intros E E' E'' H0 H1 H2; try assumption.\nred in |- *; intros; elim H1; intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\n\nTheorem CIN_equiv_prop_prop : forall E E' : Ens, EQC E' -> C<>E'.\n\nTheorem CIN_equiv_prop_prop_prop_prop : forall A B C D : Prop, EQC A B -> C<>D -> C<>D -> ~ EQC E D.\nProof C D C D.\n\nTheorem CIN_equiv_prop : forall A B C D : Prop, EQC A B -> C<>D -> ~ EQC E D.\nProof C D C D.\n\nTheorem CIN_equiv_prop_prop : forall A B C D : Prop, EQC A B -> C<>D -> ~ EQC E D.\nProof C D C D.\n\nTheorem C<>E : forall A B C : Prop, ~ EQC A B -> C<>D -> ~ EQC E A.\nProof C D.\n\nTheorem C<>E : forall A B C : Prop, ~ EQC A B -> C<>E.\nProof C D.\n\nSection CIN_T_proof.\nVariable F : Ens.\nVariable F : Ens.\nVariable F : Ens.\nVariable F :Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nintros E E' E' E'' H'.\ngeneralize E; clear E.\ngeneralize E; clear E.\nelim E; intros; elim E'; intros.\nelim (a x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nelim (b x); intros.\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nProof.\nunfold CIN in |- *; intros E E' E'' H0 H1; elim H0; clear H0 H1; intros.\nsplit; [ auto with zfc | split; auto with zfc ].\nQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\n\nTheorem CIN_Out_th : forall E E' : Ens, EQ C E' -> C'= E'.\n\nTheorem CIN_iff_th : forall E E' : Ens, EQ C E' -> C'= E'.\n\nTheorem CIN_Out_th : forall E E' : Ens, C<> E' -> C'= E'.\n\nTheorem CIN_Out_th : forall E E' : Ens, C<> E' -> C'<> E'.\n\nTheorem CIN_Out_th : forall E E' : Ens, C<> E' -> C'= E'.\n\nTheorem CIN_Out_th : forall E E' : Ens, C<> E' -> C'= E'.\n\nProof\n  fun E E' : Ens =>\n  forall (E : Ens) (F : Ens) (s : list (Domain E E')) (n : nat),\n  C<> E' -> C<> E'.\n\nTheorem CIN_Out_th : forall E E' F : Ens, C<> E' -> C<> E'.\nProof\n  fun E F G H : Ens =>\n  forall (s : Ens) (s : list (Domain E FQed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\n\nTheorem CIN_ty : forall E E' : Ens, EQC E E' -> COR E' E'.\n\nTheorem CIN_ty : forall E' : Ens, EQC E' -> COR E E'.\n\nDefinition COR : Ens -> Prop :=\n  forall (e : E) (e : E), P e -> P e.\n\nTheorem CIF_ty : forall E : Ens, ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~Qed.",
                    "Theorem CIN_sound_left : forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\n\nTheorem CCA_2 : forall E E' : Ens, CIN E E' -> CIf E' E'.\n\nTheorem CAC_2 : forall E E' : Ens, CIF E' E' -> CIf E' E'.\n\nTheorem CAC_2 : forall E E' : Ens, CIN E E' -> C If E' E'.\n\nTheorem CAC_3 : forall E E' : Ens, CER E E' -> CIf E' E'.\n\nTheorem CAC_4 : forall E E' : Ens, CER E E' -> C <> E'.\n\nTheorem CAC_4 : forall E E' : Ens, CER E E' -> C <> E'.\n\nTheorem CAC_4 : forall E E' : Ens, CER E E' -> C <> E'.\n\n(* We use this one properties of the same properties of the same properties of \n   the same properties of the same properties of the same properties of \n   the same properties of the same properties. *)\n\nTheorem C1 : ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " 2.\nintros.\nexact (depprod _ (fun y : A => EQC X (e y))).\nDefined.\n\n\n\n(* INCLUSION *)\n\nDefinition CINC : Ens -> Ens -> Type.\nintros E1 E2.\nexact (forall E : Ens, CIN E E1 -> CIN E E2).\nDefined.\n\n\n\n(* EQ EST UNE RELATION D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4207,
                "proof_end_offset": 4489,
                "proof": "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0; exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nunfold CIN in |- *; intros E E' E'' H0 H1 H2; try assumption.\napply CIN_complete_right with (fun x : A => EQC (e0 x) (e x));\n auto with zfc.\nred in |- *; intros.\nelim X1; intros.\nelim (lem_cartesian_propertie (fun x : A => EQC (e0 x) (e x)));\n [ auto with zfc | exists x; auto with zfc ].\n\nred in |- *; intros; exists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\n\nTheorem CIN_main_right :\n forall E E' E'' : Ens, EQC E E' -> C<> E''.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E''.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\nTheorem CIN_main_right : forall E E' : Ens, EQ C E' -> C<> E'.\n\n forall E E' : Ens, EQ C E' -> C<> E'.Qed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E; intros.\napply E1.\nexists x; auto with zfc.\n\nelim (lem_fun_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and.\n\nunfold CIN in |- *.\napply C; auto with zfc.\n\nunfold Cinter in |- *.\nintros.\napply C; auto with zfc.\n\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\n\nTheorem CIN_and_and_and_and_and_and_and_and_or_and_and_and_and_and_and_or_and_and_and_and_and_and_and_and_or_and_and_and_or_and_and_or_and_and_and_and_or_and_and_and_and_and_or_and_or_and_and_or_and_or_and_and_or_and_or_and_or_and_and_or_and_and_and_or_or_or_and_or_and_or_or_and_or_or_and_or_and_or_and_or_and_or_or_or_and_or_and_and_or_or_and_or_and_or_or_or_or_and_and_or_or_and_and_or_and_or_or_or_or_and_or_or_and_or_and_or_or_or_and_and_or_or_or_and_or_Qed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nProof.\nunfold CIN in |- *; intros E E' E' H0 H1 H2 H3.\nelim H1; intros x0 y0 H4; elim H4; intros H5 H6.\nelim (lem_invC_sym A (fun x : A => EQC (e0 x) (e x0));\n auto with zfc.\nQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E; intros.\nelim (H E'); intros.\nelim (H0 E'); intros.\nelim (H0 E''); intros.\nelim (H0 E''); intros.\nelim (H1 E'); intros.\nelim (H1 E'); intros.\nelim (H1 E''); intros.\nelim (H2 E'); intros.\nelim (H1 E'); intros.\nelim (H2 E'); intros.\nelim (H2 E'); intros.\nelim (H3 E'); intros.\nelim (H3 E'); intros.\nelim (H4 E'); intros.\nelim (H5 E'); intros.\nelim (H5 E'); intros.\nelim (H5 E'); intros.\nelim (H5 E'); intros.\nelim (H5 E'); intros.\nelim (H6 E'); intros.\nelim (H6 E'); intros.\nelim (H6 E); intros.\nelim (H6 E'); intros.\nelim (H6 E'); intros.\nelim (H7 E'); intros.\nelim (H6 E'); intros.\nelim (H7 E'); intros.\nelim (H7 E');Qed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\n\nTheorem CIN_Out_trans :\n forall E E' E'' : Ens,\n EQC E' E'' -> C'=E'' -> C'=E'' -> C'=E'' -> C'=E'' -> C'<>E''.\n\nTheorem CIN_Out_trans :\n forall E E' E'' : Ens,\n EQC E' E'' -> C'=E'' -> C'=E'' -> C'=E'' -> C'=E''.\n\nTheorem CIN_Out_trans :\n forall E E' E'' : Ens,\n EQC E' E'' -> C'=E'' -> C'=E'' -> C'=E''.\n\n(* E'o E'o E'o E'o E'o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o E''o EQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\n\nTheorem Cequiv_transitive_th :\n forall E E' E'' : Ens,\n EQC E E' -> C<>D -> C'=D -> C'=D -> C<>D -> E'' -> C'=D -> E'' -> E'' C''=E'.\n\nTheorem Cequiv_transitive_th :\n forall E E' E'' : Ens,\n EQC E E' -> C<>D -> C'=D -> C'=D -> E'' -> C'<>E -> C'=E''.\n\nTheorem Cequiv_transitive_th :\n forall E E' E'' : Ens,\n EQC E E' -> C<>E' -> C'=E'' -> C'=E''.\n\nTheorem Cequiv_transitive_th :\n forall E E' E'' : Ens,\n EQC E E' -> C<>E' -> C'=E''.\n\nProof\n  fun E E' : Ens =>\n  (fun E : Ens =>\n  (fun E : Ens =>\n  (fun E : Ens =>\n  fun (f : E) (g : E) (h : E) (k : E) =>\n  EQC (fun E : Ens =>\n  fun (f : EQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\n\nTheorem CIN_Out_Out : forall E E' : Ens, CIN E E' -> CIN E E'.\n\nTheorem CIN_Out_trans :\n forall E E' E'' : Ens,\n E <> E' -> C<> E'' -> C<> E' -> C<> E'' -> E = C' -> E = C' -> E = C'.\n\nTheorem CIN_Out_trans :\n forall (E E' : Ens) (m m' : E' m' : E' m' : E' m' m' : E' m' m' : E' m' m' : E' m' m' : E' m' : E' m' m' : E' m' m' : E' m' : E' m' m' : E' m' m' : E' m' : E' m' m' : E' m' : E' m' m' : E' m' : E' m' m' : E' = E' : E' m' m' m' : E' m' m' : E' m' = E' : E' : E' = EQed.",
                    "Theorem CIN_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\n\nTheorem CIN_uniqueness : forall E E' : Ens, EQC E' E -> CIF E E'.\n\nTheorem CIN_uniqueness : forall E E' : Ens, EQC E E' -> CIF E E'.\n\nTheorem CIN_uniqueness : forall E E' : Ens, EQC E' -> CIF E E'.\n\nTheorem COut_uniqueness : forall E E' : Ens, SUB C E' -> CIF E E'.\n\nDefinition Cconj (E E' : Ens) :=\n  forall (x y : Elt), ~ In E' x -> in_not_in E E' -> in_not_in E' E'.\n\nTheorem Cconj_not_in_in_in_in_in_in :\n forall (E E' : Ens) (x y : terms), ~ In E' x -> in_not_in E E' -> in_not_in E' E'.\n\nTheorem Cequiv_not_in_in_in_in_in_in :\n forall (E E' : Ens) (x : terms), ~ In E' x -> in_not_in E E' -> inQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " D'EQUIVALENCE *)\n\nTheorem EQC_refl : forall E : Ens, EQC E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 4491,
                "proof_end_offset": 4577,
                "proof": "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem C6_trans :\n forall (E F : Ens) (x : E),\n In (x, (y, (sym E F)) (PAIR x y) -> In (x, y) F.\n\nTheorem C6_trans :\n forall (E F : Ens) (x : E),\n In (x, (y, (sym F)) (PAIR x y) -> In (x, y) F.\n\nTheorem C7_trans :\n forall (E F : Ens) (x : E),\n In (x, (y, (sym F)) (PAIR x y) -> In (x, y) F.\n\nTheorem C7_trans :\n forall (E F : Ens) (x : E),\n In (x, (y, (sym F)) (PAIR x y) -> In (x, y) F.\n\nTheorem C7_cons :\n forall (E F : Ens) (x : E),\n In (x, (y, (sym F)) (PAIR x y) -> In (x, y) F.\n\nTheorem C7_comp :\n forall (E F : Ens) (x : EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem C_trans : forall E E' E'' : Ens, CINC E E' -> C<> E'.\nintros E E' E'' E'' H.\ngeneralize (C_uniqueness_uniqueness_uniqueness_uniqueness C C C H H).\n\nTheorem C_uniqueness_uniqueness_uniqueness :\n forall E E' E' : Ens, C<> E' -> C<> E' -> C<> E'.\nintros E E' E' E' H.\ngeneralize (C_uniqueness_uniqueness_uniqueness C C C H H).\n\nTheorem C_uniqueness_uniqueness :\n forall E E' : Ens, C<> E' -> C<> E' -> C<> E'.\nintros E E' E' H.\ngeneralize (C_uniqueness_uniqueness C C C H H).\n\nTheorem C_uniqueness_uniqueness :\n forall E E' : Ens, C<> E' -> C<> E' -> C<> E'.\nintros E E' E' H'.\ngeneralize (C_uniqueness_uniqueness C C H H).\n\nTheorem C_uniqueness_uniqueness :\n forall E E' : Ens, C<> E' -> C<> E' -> C<> E'.\nQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem C [[D : Ens] : Ens.\nProof.\n\nTheorem D_pr1 : forall (P : Ens -> Prop), P (fun A => P A) (fun B : Ens => P A) (fun B : Ens => P B).\n\nTheorem D_pr2 : forall (P : Ens -> Prop) (p : P) (p : P), P (fun B : Ens => P B) (fun B : Ens => P B).\nProof\n  fun (P : Ens -> Prop) (p : P) (p : P (fun B : Ens => P B) (fun B : Ens => P B))).\n\nTheorem D_pr1 : forall (P : Ens -> Prop) (p : P) (p : P) (r : P p), P (fun B : Ens => P B) (fun B : Ens => P B).\nProof\n  fun (P : Ens -> Prop) (p : P (fun B : Ens => P B)) (fun B : Ens => P A) (fun B : Ens => P B).\n\nTheorem D_pr2 : forall (P : Ens -> Prop) (p : P) (pQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem Clem_sym : forall E : Ens, Cert_inv E E.\n\nTheorem Clem_sym : forall (E : Ens) (P : Ens -> Prop), P E -> C<> E.\n\nTheorem Clem_sym : forall (E : Ens) (P : Ens -> Prop), P E -> P E.\n\nTheorem Clem_trans : forall (E : Ens) (P : Ens -> Prop), P E -> P E -> P E.\n\n forall (E : Ens) (P : Ens -> Prop), P E -> P E.\n\nTheorem Clem_trans :\n forall (E : Ens) (P : Ens -> Prop) (s : Ens), P E -> P E.\n\n forall (E : Ens) (P : Ens -> Prop), P E -> P E.\n\nTheorem Clem_trans :\n forall (E : Ens) (P : Ens -> Prop), P E -> P E -> P E.\n\n forall (E : Ens) (P : Ens -> Prop), P E -> P E.\n\nTheorem Clem_proj1 :\n forall (E : Ens) (P : Ens -> Prop) (Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem CVar_trans : forall E E' : Ens, CINC E E' -> C<> E'.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E'.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E'.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E'.\n\nTheorem CVar_trans : forall E E' E' : Ens, C<> E' -> C<> E'.\n\nProof CVar_trans.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E' -> C<> E'.\nProof CVar_trans.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E'.\nProof CVar_trans.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E'.\nProof CVar_trans.\n\nTheorem CVar_trans : forall E E' : Ens, C<> E' -> C<> E'.\nProof CQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\nProof CINC_refl.\n\nTheorem CIf_sym : forall E : Ens, Cops E (PAIR E E).\nProof Cops_sym_sym_sym_sym.\n\nTheorem CIf_sym : forall E : Ens, Cops E (PAIR E E).\nProof Cops_sym_sym_sym.\n\nTheorem CIf_sym : forall E : Ens, Cops E (PAIR E E).\nProof Cops_sym_sym_sym.\n\nTheorem CIf_sym : forall E : Ens, Cops E (PAIR E E).\nProof Cops_sym_sym_sym.\n\nTheorem CIf_inv : forall E : Ens, Cops E (PAIR E E).\nProof Cops_inv E (PAIR E E).\n\nTheorem CIf_inv : forall E : Ens, Cops E (PAIR E E).\nProof Cops_inv E (PAIR E E).\n\nTheorem CIf_inv : forall E : Ens, Cops E (PAIR E E).\nProof C gvars_inv E (PAIR E E).\n\nTheorem CIf_inv : forall E : Ens, Cops E (PAIR E EQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem Clem_sym : forall E : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (fun x : A => EQC (f x) (f x)).\n\nTheorem Clem_trans : forall E E' : Ens, CINC E (funQed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem Clem_trans : forall E F : Ens, C gvar E F -> CEvar E F.\n\nTheorem Clem_trans : forall E F : Ens, CEvar E F -> CEvar E F.\n\nTheorem Clem_trans : forall E F : Ens, CEvar E F -> CEvar E F.\n\nTheorem Clem_trans : forall F F' : Ens, CEvar F' F' -> CEvar F' F'.\n\nTheorem Clem_trans : forall F F' F' : Ens, CEvar F' F' -> C <> F' -> C <> F'.\n\nHint Resolve Clem_trans.\n\nTheorem Clem_trans :\n forall (F F' F' : Ens) (p : F' F' F' F'' : Ens) (p : F' F'' F'' : Prop),\n C = F'' -> F' = F'' -> F' = F'' ->\n C = F'' ->\n C = F'' ->\n C = F'' ->\n C = F'' ->\n C' = F'' ->\n C = F'' ->\n C'' = F'' ->\n C'' = F'' ->Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\nTheorem Clem_is_o : forall E : Ens, C temp E E.\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\n(* Proof Clem_is_o : forall E : Ens, C lvar E E. *)\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\n(* Proof Clem_is_o : forall E : Ens, C lvar E E. *)\n\nTheorem Clem_is_o : forall E : Ens, C lvar E E.\n\n(* Proof Cth_is_o : forall E F : Ens, F lvar E F. *)\n\nTheorem Clem_is_o : forall E : Ens, F lvar E E.\n\n(* Proof Cth_eq_Qed.",
                    "Theorem CINC_refl : forall E : Ens, CINC E E.\n\nTheorem COR_prop_th :\n forall E E' : Ens, CINC E E' -> C<> E'.\n\nTheorem COR_prop_th :\n forall E E' : Ens, C<> E' -> C<> E'.\n\n(* Proof of lem_prop_th *)\n\nTheorem COR_prop_th :\n forall E E' : Ens, C<> E' -> C<> E'.\n\n(* Proof of lem_prop_th *)\n\nTheorem COR_prop_th :\n forall (E E' : Ens) (E' : Ens),\n C<> E' -> C<> E' -> C<> E'.\n\n(* Proof of lem_prop_th *)\n\nTheorem COR_prop_th :\n forall (E E' : Ens) (E' : Ens) (E' : Ens),\n C<> E' -> C<> E' -> C<> E'.\n\n(* Proof of lem_prop_th *)\n\nTheorem COR_prop_th :\n forall (E E' : Ens) (E' : Ens) (E' : Ens),\n C<> E' -> C<> E' -> C<>Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " x; auto with zfc.\n\nexists y; auto with zfc.\nQed.\n\nTheorem EQC_tran : forall E1 E2 E3 : Ens, EQC E1 E2 -> EQC E2 E3 -> EQC E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4579,
                "proof_end_offset": 4703,
                "proof": "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem CINC_trans : forall E E' E'' : Ens, CINC E E' -> C|- E' -> C<>E'.\n\nTheorem CINC_trans : forall E E' : Ens, CINC E E' -> C<>E'.\n\nTheorem Cel_not_inc : forall E E' : Ens, C<>E' -> C<>E'.\n\nTheorem Cel_not_inc : forall E E' : Ens, C<>E' -> C<>E'.\n\nTheorem Cel_not_inc : forall E E' : Ens, C<>E' -> C<>E'.\n\nTheorem C15_not_inc : forall E E' : Ens, C<>E' -> C<>E'.\nProof\n  fun E E' : Ens =>\n  ~ C<>E' /\\ C<>E'.\n\nTheorem C15_not_inc : forall E E' : Ens, C<>E -> C<>E'.\nProof\n  fun E E' : Ens =>\n  ~ C<>E' /\\ C<>E'.\n\nTheorem C15_not_inc : forall E E' : Ens, C<>E' -> C<>E'.\nProofQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nHint Resolve C [[E: Ens] (at level 40).\n\nTheorem C11_8 : forall E E' E'' : Ens, C11 E E' -> C11 E' E'' -> C11 E' E''.\n\nTheorem C11_8 : forall E E' : Ens, C11 E E' -> C11 E' E'.\n\nTheorem C11_8 : forall E E' : Ens, C11 E E' -> C11 E E'.\nProof\n  fun E' : Ens =>\n  C11_8 (fun E : Ens => C11 E E' -> C11 E' E)).\n\nTheorem C11_8 : forall E E' : Ens, C11 E E' -> C11 E E'.\nProof\n  fun E' : Ens =>\n  C11_8 (fun E : Ens => C11 E E' -> C11 E' E').\n\nTheorem C11_10 : forall E E' : Ens, C11 E E' -> C11 E E'.\nProof\n  fun E' : Ens =>\n  C11_10 (fun E : Ens => C11 E E' -> C11 E' E')).\n\nTheorem CQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem C14_7 : forall E E' E'' : Ens, CINC E E' -> C<>E' -> C<>E'.\n\nTheorem C14_7 : forall E E' E'' : Ens, CINC E E' -> C<>E' -> C<>E'.\n\nTheorem C15_8 : forall E E' E'' : Ens, C<>E' -> C<>E' -> C<>E'.\nProof\n  fun E E' : Ens =>\n  fun E' : Ens =>\n  match E' with\n  | E' : Ens =>\n    match E' with\n    | E' : Ens =>\n       match E' with\n       | E' : Ens =>\n            match E' with\n              | E' : Ens => (EQC E' E') (EQC E' E'))\n              | E' : Ens => (EQC E' E') (EQC E' E')\n              | E' : Ens => (EQC E' E') (EQC E' E')\n              | E' : Ens => (EQC E' E') (EQC E' E')\n              | E' : Ens => (EQC E' E') (EQC E'Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem CINC_trans : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> C <> E''.\n\nTheorem C11_trans : forall E E' E'' : Ens, CINC E E' -> C <> E''.\n\nTheorem C11_uniqueness : forall E E' E'' : Ens, CINC E' E'' -> C <> E'').\n\nTheorem C11_uniqueness : forall E E' E'' : Ens, CINC E E' -> C <> E''.\n\nTheorem C11_uniqueness : forall E E' E'' : Ens, CINC E' E'' -> C <> E''.\n\n forall E E' : Ens, CINC E E' -> C <> E''.\n\nTheorem C11_uniqueness : forall E E' E'' : Ens, CINC E E' -> C <> E''.\nProof C11_uniqueness.\n\nTheorem C11_uniqueness : forall E E' E'' : Ens, CINC E E' E'' -> C <> E''.\nProof C11_uniqueness.\n\nTheorem C11_uniqueness : forall E E' : Ens, C lvar E E' E' ->Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem C27_sym : forall E E' : Ens, CINC E E' -> CLE E' E''.\n\nTheorem C27_sym : forall E E' : Ens, CINC E E' -> CINC E' E''.\n\nTheorem C26_sym : forall E E' : Ens, CINC E E' -> CINC E' E'.\n\nTheorem C27_sym : forall E E' : Ens, CINC E E' -> CINC E' E'.\nProof\n  C27_sym; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem CEvar_E_E :\n forall E F : Ens, CINC E F -> C<> E'.\n\n(* Proof of the C but it is distributed in |- *; if it is not in |- *; if it is not in |- *; if it is not in |- *; if it is not in |- *; if it is not in |- *; *)\n\nTheorem C_If_E_E : forall F : Ens, F <> E -> C<> F -> ~ E <> F.\n\n(* Proof of the C_If_E_E F F G G H E' F G' H' F G' H' F G' H' H'0 H'1 H'2 H'3 H'3 H'4.\n\nTheorem C_If_E :\n forall F G : Ens, F <> G -> C<> F -> ~ E <> F -> ~ F <> G -> ~ E <> F.\n(* Proof of the C_If_E F G H F G H E' F G' H' F G' H' H'1 H'3 H'3 H'4.\n*)\n\nTheorem C_If_E_E : forall F G :Qed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\n forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 E E' -> C11 E E'.\n\n forall E E' : Ens, C11 E E' -> C11 E E'.\n\nTheorem C11_not_inc : forall E E' : Ens, C11 EQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem CSt_trans : forall E E' E'' : Ens, CINC E E' -> CINC E' E''.\nunfold CHint in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_tran : forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\n\nTheorem CStructField_trans : forall E E' : Ens, CINC E E' -> C<>E' -> C<>E'.\n\n(* Proof of lem_trans_in_dom_prop_left. *)\n\nTheorem Cund_trans_in_dom :\n forall (E E' : Ens) (p : E' F) (q : E' F),\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C**E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C<>E ->\n C**E ->\n C**E ->\n C<>E ->\n C**E ->\n C**E ->\n C**E ->\n C**E ->\n C**E ->\n C**E ->\n C**E / C**E ->\n C**E ->\n C**E / C**E ->Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " E1 E3.\nsimple induction E1; simple induction E2; simple induction E3; simpl in |- *;\n intros.\nsplit; (elim X2; intros; elim X3; intros).\nelim (a x); intros.\nelim (a0 x0); intros.\nexists x1.\napply X with (e0 x0); auto with zfc.\nelim (b0 y); intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4706,
                "proof_end_offset": 4939,
                "proof": "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nProof.\nsimple induction E''; unfold CINC in |- *; simpl in |- *; intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold C at 1 in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold Cinter in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nintros E E' E'' E'' H'.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CHint in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_left : forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nunfold CINC in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " intros.\nelim (b x); intros.\nexists x0.\napply X with (e0 x); auto with zfc.\nQed.\n\nTheorem EQC_sym : forall E1 E2 : Ens, EQC E1 E2 -> EQC E2 E1.\nsimple induction E1; simple induction E2; simpl in |- *; intros.\nelim X1; intros; split; intros.\nelim (b x); intros.\nexists x0; auto with zfc.\nelim (a y); intros; exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\n",
                "context_tokens": 732,
                "proof_start_offset": 4941,
                "proof_end_offset": 5258,
                "proof": "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nProof.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *; intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f X1 E0 i; apply X1.\napply CIN_sound_right with (e x0); auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E; unfold C lvar in |- *; intros E E' E'' H0; apply H0.\napply C6_inclus with E'; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\n\nTheorem C lvar_sound_right : forall E E' E'' : Ens, C lvar E E' E'' -> C <> E'.\n\nTheorem C lvar_correct_right_comm : forall E E' E'' : Ens, C lvar E E' E'' -> C <> E''.\n\nTheorem C lvar_correct_right_comm : forall E E' E'' : Ens, C lvar E E' E'' -> C <> E''.\n\nTheorem C lvar_correct_left_comm : forall E E' E'' : Ens, C lvar E E' E'' -> C <> E'').\n\nTheorem C lvar_correct_right_comm : forall E E' E'' : Ens, C <> E'' -> C <> E'').\n\nTheorem C lvar_correct_left_comm : forall E E' E'' : Ens, C <> E'' -> C <> E''.\n\n(* Proof of the tactic tactic tactic tactic tactic used *)\n\nTheorem C1_1 : ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~Qed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E''; unfold C lvar in |- *; intros A f X1 E0 i; apply X1.\napply C; apply C; apply E0.\napply C; apply C; apply E0.\napply C; apply E0.\napply C; apply C; apply E0.\napply C; apply E0.\napply C; apply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply C; apply E0.\napply D; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply E0; apply C0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.\napply C; apply E0.Qed.",
                    "Theorem CINC_sound_right : forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " exists x; auto with zfc.\nQed.\n\nTheorem EQC_INC : forall E E' : Ens, EQC E E' -> CINC E E'.\nsimple induction E; simple induction E'; simpl in |- *; intros;\n unfold CINC in |- *; simpl in |- *.\nelim X1; intros.\nelim X2; intros.\nelim (a x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5264,
                "proof_end_offset": 5529,
                "proof": "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H; split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n\n(******************************************************)\n(* Probfthiomes                                     *)\n(******************************************************)\n\nDefinition D := D \\/ D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D /\\ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D = D.\n\nDefinition D := D \\/ D = D \\/ D =Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold not in |- *; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nProof.\nunfold CINC in |- *; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n\n(******************************************************)\n(*    E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'o E'oQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n\n(* Proof of lem_ac_vide_est_reesC. *)\n\nTheorem C_inter_or_or_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_and_Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E E' E'; unfold not in |- *; intros E' H'; elim H'.\napply H'.\napply H'.\napply H'.\napply H'.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n\nintros E E H; try assumption.\nelim H; intros; elim H; intros.\nelim (classic (exists y : Ens, (exists y : Ens, (exists y : Ens, (exists y : Ens, C' y /\\ F' y))).\nintros H0; elim H0; clear H0; intros y0; elim H1; clear H1; intros y0; elim H1;\n clear H1; intros y0; elim H1; clear H1; intros y1; elim H1;\n clear H1; intros y2; elim H2; clear H2; intros y3; elim H3;\n clear H3; intros y3; elim H3; clear H3; intros y4; elim H4;\n clear H4; intros y5; elim H5; clear H4; intros y6; elim H5; clear H5;\n intros y6; elim H5; clear H5; intros y6; elim H6; clear H6; intros H6; \n elim H7; clear H8; intros y6; elim H7; clear H7; intros H7; \n elim H8; clear H9Qed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nintros E E; elim E; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold C in |- *; auto with zfc.\nQed.",
                    "Theorem tout_vide_est_VideC : forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\nunfold C in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " with (e x); auto with zfc.\nQed.\n\nHint Resolve EQC_sym EQC_refl EQC_INC: zfc.\n\nTheorem CINC_EQC : forall E E' : Ens, CINC E E' -> CINC E' E -> EQC E E'.\nsimple induction E; simple induction E'; unfold CINC in |- *; simpl in |- *;\n intros; split; intros.\napply X1.\nexists x; auto with zfc.\ncut (depprod A (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\n",
                "context_tokens": 729,
                "proof_start_offset": 5532,
                "proof_end_offset": 5852,
                "proof": "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nProof.\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A A' B H; split.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CLE_sym.\napply CQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros.\napply H with (inc (Second A' B) ( \"_ A' B)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A A' B H'; split.\nintros; elim (H' (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold C at 1 in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A' B H'; red in |- *; intros.\nelim (H' (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A A' B H'; red in |- *; intros.\nelim (H (e x)); auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Vide in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros.\nelim (H (e x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_leftC : forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold not in |- *; intros A A' B H; elim H; intros H1.\nunfold not in |- *; intros.\nelim (H0 (e x)); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " (fun x : A => EQC (e0 y) (e x)));\n try (simple induction 1; intros x p; exists x; auto with zfc).\napply X2; exists y; auto with zfc.\nQed.\n\nHint Resolve CINC_EQC: zfc.\n\n\n\n\n\nTheorem CIN_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\n",
                "context_tokens": 730,
                "proof_start_offset": 5854,
                "proof_end_offset": 6157,
                "proof": "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nProof.\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold IT at 1 in |- *; unfold C at 1 in |- *; simpl in |- *;\n intros.\napply H; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold IT at 1 in |- *.\nsimpl in |- *.\nintros; split.\nunfold B in |- *; simpl in |- *.\nintros; elim (H (e x); auto with zfc.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Syise in |- *.\nsimpl in |- *.\nintros; split.\nunfold C at 1 in |- *; auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Flort in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists false; auto with zfc.\n\nintros; elim (H (e x)); auto with zfc.\n\nintros; elim (H (e x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold inc in |- *; intros A B B' H; split.\nunfold inc in |- *; intros.\nelim (H (e x); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold ITise in |- *.\nsimpl in |- *.\nintros; split.\nauto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Vide in |- *; intros.\napply B; apply B.\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Vide in |- *; intros.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Vide in |- *; intros.\napply axs_extensionnalite; unfold iff in |- *; intros.\nelim (H (e x); intros.\nelim (H (e x)); intros.\nelim (H (e x)); intros.\nelim (H (e x); intros.\nelim (H0 (e x)); intros.\nelim (H0 (e x); intros.\nelim (H0 (e x)); intros.\nelim (H0 (e x); intros.\nelim (H1 (e x); intros.\nelim (H2 (e x)); intros.\nelim (H3 (e x)); intros.\nelim (H3 (H2 (e x)); intros.\nelim (H3 (H3 H3)); intros.\nelim (H4 H3); intros.\nelim (H4 H3); intros.\nelim (H5 H3); intros.\nelim (H6 H6); intros.\nelim (H6 H7); intros.\nelim (H7 (H7 H7); intros.\nelim (H7 H7); intros.\nelim (H7 H7); intros.\nelim (H7 H7);Qed.",
                    "Theorem Paire_sound_rightC : forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Vide in |- *; intros.\nelim (H (e x)); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN E E'' -> CIN E' E''.\nsimple induction E''; simpl in |- *; intros.\nelim X1; intros y p; exists y.\napply EQC_tran with E; auto with zfc.\nQed.\n\nTheorem CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 6160,
                "proof_end_offset": 6309,
                "proof": "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold C at 2 in |- *; intros; split.\napply CIN_addIr with (e x); auto with zfc.\n\nunfold C at 2 in |- *; apply CIN_trichotomy; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold C at 1 in |- *; intros.\nunfold C at 1 in |- *; unfold C at 1 in |- *; simpl in |- *.\nintros; split.\nunfold C at 1 in |- *; apply CIN_ttt.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CIF in |- *; simpl in |- *; intros; split.\napply CIN_ received with (lambda (lambda (lambda E'))); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros; split.\nunfold Cdisj in |- *; simpl in |- *.\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Cdisj in |- *; intros E E' H'; split.\nunfold Cdisj in |- *; intros y H'; elim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' y); intros.\nelim (H' yQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold C in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold C at 1 in |- *; intros; split.\nunfold C at 1 in |- *; unfold C at 1 in |- *; simpl in |- *.\nintros; elim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold C at 1 in |- *; intros; split.\nunfold C at 1 in |- *; intros.\nelim (H (eps_D E)); intros.\nelim (H0 (eps_D E)); intros.\nexists x; auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Cdisj in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold CEP in |- *; intros; split.\nred in |- *; intros.\nelim (H (e x); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CIN_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CIN E E' -> CIN E E''.\nsimple induction E'; simple induction E''; simpl in |- *; intros.\nelim X1; intros Xl Xr; elim X2; intros y p; elim (Xl y); intros y0 p0;\n exists y0; apply EQC_tran with (e y); auto with zfc.\nQed.\n\nTheorem CINC_refl : forall E : Ens, CINC E E.\nunfold CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 6311,
                "proof_end_offset": 6463,
                "proof": "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nProof.\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold C at 1 in |- *; simpl in |- *; intros; split.\nred in |- *; intros.\nelim (H (e x); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; intros E E' H; apply CIN_ Kblocked with (e x);\n auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros; split.\napply CIN_GrimalIN_ contributors).\napply CIN_ Assistant.\napply CIN_idempotent with (e x); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros; split.\nunfold Cdisj in |- *.\nintros.\nelim (H (e x)); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold CIN in |- *; simpl in |- *; intros; split.\napply CIN_ vptr with (e x); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros; split.\nunfold Cdisj in |- *; simpl in |- *.\nintros; elim (H (e x); auto with zfc.\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros; split.\nred in |- *; intros; elim (H (e x)); auto with zfc.\n\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; unfold Cdisj in |- *; simpl in |- *;\n auto with zfc.\n\nQed.",
                    "Theorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Cdisj in |- *; simpl in |- *; intros.\nelim (H (e x)); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " CINC in |- *; auto with zfc.\nQed.\n\nTheorem CINC_tran :\n forall E E' E'' : Ens, CINC E E' -> CINC E' E'' -> CINC E E''.\nunfold CINC in |- *; auto with zfc.\nQed.\n\n\nTheorem CINC_sound_left :\n forall E E' E'' : Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\n",
                "context_tokens": 727,
                "proof_start_offset": 6591,
                "proof_end_offset": 6793,
                "proof": "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nProof.\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b; simpl in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold C at 2 in |- *.\nunfold C at 2 in |- *.\nintros E' A B C H'0 H'1; try assumption.\napply Trans with (C := C); auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\n\nTheorem D_has_rel : forall A B C : Prop, C<>D -> C<>D -> C<>E -> C<>E.\nintros A B C D_has_rel; red in |- *; intros A B C D_has_rel.\nelim (classic (exists x : _, C x /\\ D x)); intros; apply C6; clear C D_has_rel.\nelim (classic (exists x : _, C x /\\ D x)); intros; apply C7; clear C D_has_rel.\nelim (classic (exists x : _, C x /\\ D x)); intros; apply C7; clear C D_has_rel.\nelim (classic (exists x : _, C x /\\ D x)); intros; apply C7; clear C D_has_rel.\nelim (classic (exists x : _, C x /\\ D x)); intros; apply C7; clear C7 D_has_rel.\nelim (classic (exists x : _, C x /\\ D x)); intros; apply C7; clear C7 D_has_rel.\nelim (classic (exists x :Qed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Cdisj in |- *; simpl in |- *; intros A B H'; elim H';\n [ idtac | exists t; auto with zfc ].\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold C in |- *; intros E E' A B H' H'0; try assumption.\napply prod_comp; auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold D in |- *; auto with zfc.\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold not in |- *; intros.\nelim (H (e x)); auto with zfc.\n\nQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold CIN in |- *; simpl in |- *; intros.\nelim (X2 E); intros.\nelim (classic (X2 E)); intros.\nunfold not in |- *; intro.\nunfold not in |- *; intro.\nunfold not in |- *; intro.\nunfold not in |- *; intro.\nunfold not in H0.\nelim H0; clear H0; intros.\nunfold not in |- *; intro.\nunfold not in H0.\nelim H0; clear H0; intros.\nunfold not in H1.\nelim H1; clear H1; intros.\nunfold not in |- *; intro.\nunfold not in H2.\nelim H1; clear H1; intros.\nunfold not in |- *; intro.\nunfold not in H2.\nelim H2; clear H2; intros.\nunfold not in |- *; intro.\nelim H3; clear H3; intros.\nunfold not in H3.\nelim H3; clear H3; intros.\nunfold not in H3.\nelim H3; clear H3; intros.\nunfold not in |- *; intro.\nelim H3; clear H3; intros.\nunfold notQed.",
                    "Theorem Paire_CIN : forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Cdisj in |- *; simpl in |- *; intros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nintros.\nelim (X2 E); auto with zfc.\n\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": " Ens, EQC E E' -> CINC E E'' -> CINC E' E''.\nsimple induction E''; unfold CINC in |- *; simpl in |- *;\n intros A f XR e X1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 6863,
                "proof_end_offset": 6954,
                "proof": "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nProof.\nunfold Sing in |- *; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_else : forall E : Ens, CIN E (Returnstate E).\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_else : forall E : Ens, CIN E (Returnstate E).\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_else : forall E : Ens, CIN E (Returnstate E).\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_ Public : forall E : Ens, CIN E (Singleton E E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_ Public : forall E : Ens, CIN E (Singleton E E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_ Public : forall E : Ens, CIN E (Singleton E E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold C in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_ October : forall E : Ens, CIN E (Singleton E (Singleton E E)).\nunfold C in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_INTER : forall E : Ens, CIN E (Singleton E E).\nunfold C in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_Strict : forall E : Ens, CIN E (Singleton E (Singleton E E)).\nunfold C in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CEQ in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_ congr : forall E : Ens, CIN E ( congr E).\nunfold CEQ in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_inr : forall E : Ens, CIN E ( congr E).\nunfold CEQ in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_irrefl : forall E : Ens, CIN E ( congr E).\nunfold CEQ in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_Inc : forall E : Ens, CIN E (Inc E E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_Inc : forall E : Ens, CIN E (Inc E E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_Inc : forall E : Ens, CIN E (Inc E E).\nunfold C at 1 in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; intros; auto with zfc.\n\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold CIN in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_bigl : forall E : Ens, CIN E (Singleton E E).\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\n\nTheorem CIN_Returnstate : forall E : Ens, CIN E (Singleton E E).\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Cdisj in |- *; simpl in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Constructive.v",
                "context": "1 E0 i; apply X1.\napply CIN_sound_right with E'; auto with zfc.\nQed.\n\nTheorem CINC_sound_right :\n forall E E' E'' : Ens, EQC E' E'' -> CINC E E' -> CINC E E''.\nsimple induction E'; simple induction E''; unfold CINC in |- *; simpl in |- *;\n intros.\nelim (X2 E0); try assumption; intros.\nelim X1; intros XA XB; elim (XA x); intros.\nexists x0; apply EQC_tran with (e x); auto with zfc.\nQed.\n\n\n\n\n\nTheorem tout_vide_est_VideC :\n forall E : Ens, (forall E' : Ens, CIN E' E -> F) -> EQC E Vide.\n unfold Vide in |- *; simple induction E; simpl in |- *; intros A e X H;\n  split.\nintros; elim (H (e x)); auto with zfc.\nexists x; auto with zfc.\nsimple induction y.\nQed.\n\n\nTheorem Paire_sound_leftC :\n forall A A' B : Ens, EQC A A' -> EQC (Paire A B) (Paire A' B).\nunfold Paire in |- *.\nsimpl in |- *.\nintros; split.\nsimple induction x.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\nQed.\n\nTheorem Paire_sound_rightC :\n forall A B B' : Ens, EQC B B' -> EQC (Paire A B) (Paire A B').\nunfold Paire in |- *; simpl in |- *; intros; split.\nsimple induction x.\nexists true; auto with zfc.\nexists false; auto with zfc.\nsimple induction y.\nexists true; auto with zfc.\nexists false; auto with zfc.\nQed.\n\n\nTheorem CIN_Paire_left : forall E E' : Ens, CIN E (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists true; simpl in |- *;\n auto with zfc.\nQed.\n\nTheorem CIN_Paire_right : forall E E' : Ens, CIN E' (Paire E E').\nunfold Paire in |- *; simpl in |- *; exists false; simpl in |- *;\n auto with zfc.\nQed.\n\nInductive sum_t (A B : Type) : Type :=\n  | inl_t : A -> sum_t A B\n  | inr_t : B -> sum_t A B.\nHint Resolve inl_t inr_t: zfc.\n\nTheorem Paire_CIN :\n forall E E' A : Ens, CIN A (Paire E E') -> sum_t (EQC A E) (EQC A E').\nunfold Paire in |- *; simpl in |- *; simple induction 1; intros b; elim b;\n simpl in |- *; auto with zfc.\nQed.\n\nHint Resolve CIN_Paire_left CIN_Paire_right: zfc.\n\n(* Singleton *)\n\nTheorem CIN_Sing : forall E : Ens, CIN E (Sing E).\nunfold Sing in |- *; auto with zfc.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 6956,
                "proof_end_offset": 7108,
                "proof": "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nProof.\nunfold Sing in |- *; intros E E' H; elim (Paire_CIN E' E' E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Cdisj in |- *; auto with algebra.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Cdisj in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIF in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold Sep in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; auto with zfc.\nQed.",
                    "Theorem CIN_Sing_EQ : forall E E' : Ens, CIN E (Sing E') -> EQC E E'.\nunfold CIN in |- *; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\n",
                "context_tokens": 351,
                "proof_start_offset": 1480,
                "proof_end_offset": 1579,
                "proof": "Definition Nat : nat -> Ens.\nProof.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Nat : nat -> Ens.\nexact (Build_Predicate (fun x y => x = y \\/ x = y).\nDefined.",
                    "Definition Nat : nat -> Ens.\nintro H'; red in |- *; intros x H'; elim H'.\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\n\nexact (H0 x).\nexact (H0 x).\n\nexact (H0 xDefined.",
                    "Definition Nat : nat -> Ens.\nProof.\nexact (Build_Setoid (Ap:=fun (a b : Nat) (b : Nat) => ia a b)).\n\nDefinition Build_Setoid (A : Ens) (B : Ens) :=\n  forall (a b : Nat), (B a b) -> B a b.\n\nDefinition Map_is_assoc (A B : Ens) (B : Ens) (a b c : B) : Prop :=\n  forall (a b c : B), (A a b) -> (B a b c) -> B a b c.\n\nDefinition Map_is_assoc (A B : Ens) (B : Ens) (a b c : B) : Prop :=\n  forall (a b c : B), (A a b) -> (B a b c) -> B a b c.\n\nDefinition Map_is_assoc (A B : Ens) (B : Ens) (a b c : B) : Prop :=\n  forall (a b c : B), (B a b c) -> (B a b c) -> B a b c.\n\nDefinition Map_is_assoc (A B : Ens) (B : Ens) (a b cDefined.",
                    "Definition Nat : nat -> Ens.\napply Build_Setoid_of_nat_of_nat_of_nat_of_P_of_nat_of_P_nat_of_P_of_nat_of_P_succ_morphism\n  in_part_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_prop_Defined.",
                    "Definition Nat : nat -> Ens.\nintro H'; red in |- *; auto with algebra.\nDefined.",
                    "Definition Nat : nat -> Ens.\nProof.\n  auto with sets.\nDefined.",
                    "Definition Nat : nat -> Ens.\nintro H'; elim H'.\n\n(*\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_nat (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\n(*\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n*)\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinition nat_of_Z (n : nat) : Prop := n = n.\n\nDefinition nat_of_Z (n : nat) : Prop := n : nat.\n\nDefinitionDefined.",
                    "Definition Nat : nat -> Ens.\nintros; auto with sets.\nDefined.",
                    "Definition Nat : nat -> Ens.\nexact (fun s : Triangle => forall x : Elt, s x = x).\n\nDefinition nat_of_nat (P : Ens -> Prop) :=\n  forall n : nat, P n -> P n.\n\nDefinition nat_of_nat (P : Ens -> Prop) :=\n  forall n : nat, P n -> P n.\n\nDefinition nat_of_nat (P : Ens -> Prop) :=\n  forall n : nat, P n -> P n.\n\nDefinition nat_of_nat_of_nat (P : Ens -> Prop) :=\n  forall n : nat, P n -> P n.\n\nDefinition nat_of_nat_of_nat (P : Ens -> Prop) :=\n  forall n : nat, P n -> P n.\n\nDefinition nat_of_nat_of_nat (P : Ens -> Prop) :=\n  forall n : nat, P n -> P n.\n\nDefinition nat_of_nat_of_nat_of_nat_of_P :\n forall (P : Ens -> Prop) (n : nat), P n -> P n.\n\nDefinition nat_of_nat_of_nat_of_nat_Defined.",
                    "Definition Nat : nat -> Ens.\nintro H.\napply (Build_Map (Ap:=fun a : nat => a) (Var (Var a))).\nred in |- *; simpl in |- *; auto with algebra.\nDefined."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\n",
                "context_tokens": 427,
                "proof_start_offset": 1709,
                "proof_end_offset": 1881,
                "proof": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nintros E; unfold Class_succ in |- *; unfold Sing in |- *; apply IN_Union with (Paire E E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nunfold Reflexive, In, In in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\n(*\nHint Resolve nat_Rel.\n\nTheorem E_sup : (E:Ensf)(Id E) (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Var (Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nunfold E in |- *; intros E H; elim H;\n [ intros E | idtac | intros E | idtac ].\nexact (H (S E)).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\n(*\nParameter\n  E_next :\n    forall (n m:nat)(x y : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    m = n ->\n    forall (x y : E) (m : E),\n    m = n ->\n    forall (x y : E) (mQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nsimple induction 1; intros.\nexact (H (S (S (S (S (S (S (S (S O)))))))) x)).\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\nDefinition Omega : Ens := ex (fun E : Ens => EQ E (Var X)).\n\nSection Singleton.\nVariable E : Ens.\nVariable f : forall E : Ens, E -> E.\n\nInductive old : Prop :=\n  | old : forall (a b : E), ~ a -> ~ b -> ~ a -> ~ b -> a -> f.\n\nRecord Singleton (A B : Ens) := {\n  full_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)\n  {\n  single_function : (B -> Prop)Qed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\nDefinition Finite : Ens := Build_Setoid (Build_Setoid (Build_Setoid (Build_Setoid (E:=E))) (E:=E) (E:=E) (E:=E) (E:=E) (E:=E) (E:=E) (E:=E) (E:=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=E) (E':=EQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nProof.\nunfold Omega, nat, nat, nat, nat, nat in |- *; auto with algebra.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\nTheorem Comp_th1 : forall E : Ens, SUB E E.\n\n(*\nTheorem Comp_th2 : forall E : Ens, SUB E E.\n*)\n\nTheorem Comp_th4 : forall E : Ens, SUB E E.\nProof Comp_th1 E (fun E : Ens => SUB E E (Var E));\n auto with sets.\nQed.",
                    "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\n\nTheorem Set_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_eq_succ :\n forall E : Ens, (E: Ens) (o E) -> E.\n\nSection Set_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_eq_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_eq_of_nat_of_nat_of_nat_eq_minus.\n\nDefinition nat_of_group (E : Ens) (n : nat) :=\n  forall (X Y : Ens) (o : E),\n exists x : E, (exists y : E, In (couple xQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 484,
                "proof_start_offset": 1884,
                "proof_end_offset": 2044,
                "proof": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nProof.\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold E in |- *; auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold E in |- *; auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; intros E H; unfold E in |- *; unfold E in |- *; unfold E in |- *;\n apply H.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold E in |- *; unfold E in |- *; unfold E in |- *;\n apply Definition_of_nat_of_nat_of_nat_of_P_of_succ.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nintros E; unfold E in |- *; unfold E in |- *; unfold E in |- *; unfold E in |- *; unfold E in |- *;\n apply Trans with (sup (sup E)); auto with algebra.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\n\nTheorem Ex_Build_Setoid :\n forall (E : Ens) (p : E),\n EQ E p -> forall x : E, In x p -> In x p.\nintros E p; unfold E in |- *; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_Setoid; unfold In in |- *;\n apply Ex_Build_SetoidQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\n\nTheorem In_occ_sup :\n forall E : Ens,\n EQ E (Set_succ E) -> EQ E (Set_succ E).\n\nTheorem In_occ_sup :\n forall E : Ens,\n EQ E (Set_succ E) -> EQ E (Set_succ E).\n\nTheorem In_occ_sup :\n forall (E : Ens) (n : nat),\n In E (Set_succ E) -> EQ E (Set_succ E).\n\nTheorem In_occ_sup :\n forall (E : Ens) (n : nat),\n In E (Set_succ E) -> EQ E (Set_succ E).\n\nTheorem In_occ_sup :\n forall (E : Ens) (n : nat),\n In E (Set_succ E) -> EQ E (Set_succ E).\n\nTheorem In_occ_sup :\n forall (E : Ens) (n : nat),\n In E (Set_succ E) -> In E (Set_succ E).\nProof\n  fun E : Ens =>\n  fun E : Ens =>\n  fun E : Ens =>\n  fun E : Ens =>\n  fun E : Ens =>\n  exQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold E in |- *; auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; unfold EV in |- *; unfold Comp in |- *;\n apply In_Pred with (sup E) (sup E); auto with zfc.\nQed.",
                    "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nred in |- *; intros E H; unfold E in |- *; unfold E in |- *; unfold E in |- *;\n apply H; clear H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\n",
                "context_tokens": 554,
                "proof_start_offset": 2096,
                "proof_end_offset": 2507,
                "proof": "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nProof.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H'; unfold Definition_of_in in |- *; unfold inc, Rstar in |- *;\n apply H.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; split; red in |- *; intros.\napply Trans with (sup E (fun x => x)); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold EQ in |- *; unfold E' in |- *; unfold E' in |- *; unfold E' in |- *;\n apply Trans with (sup (Var y)); auto with algebra.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold EQ in |- *; unfold Equivalence_def in |- *; intros.\napply EQ_Pred with (Pred_of_Power E' (Power E E)); auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold EQ in |- *; unfold E in |- *; unfold E in |- *; unfold E in |- *; unfold E in |- *;\n apply H.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold E' in |- *; unfold E' in |- *; unfold E' in |- *;\n apply (H (Build_Predicate _ (Pred_of_prod E' E) (Pred_of_prod E E'));\n auto with algebra.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nunfold E', Included in |- *; unfold E', Included in |- *; simpl in |- *;\n intros.\napply H.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold E in |- *; apply H; clear H; intros.\nexact (H E' H0).\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold Definition_of_fin in |- *;\n apply H; clear H; unfold E' in |- *; clear H;\n auto with zfc.\nQed.",
                    "Theorem IN_Class_succ_or : forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' H; unfold E in |- *; unfold E' in |- *; unfold E' in |- *;\n apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\n",
                "context_tokens": 684,
                "proof_start_offset": 2510,
                "proof_end_offset": 2819,
                "proof": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nProof.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\n\nunfold E in |- *; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E in |- *; unfold F in |- *; intros E E' F G G G G G G G G G G G G G G G G G G G G G G G G.\nintros.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_next_or.\napply F_Qed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\n\nunfold E in |- *; intros E H; elim H; intros H E0 H1; elim H1;\n [ idtac | apply E_not_IN_E with (sup E0); auto with zfc ].\n\nelim (axs_comprehension (Singleton E E) (Singleton E (Var v)) (sup v)).\nintros; left; apply E_not_IN_E with v; auto with zfc.\n\nelim (axs_comprehension (Singleton E E) (Singleton E (Var v)) (sup v)).\nintros; left; apply E_not_IN_E with v; auto with zfc.\n\nelim (axs_comprehension (Singleton E E) (Singleton E (Var v)) (sup v)).\nintros; left; apply E_not_IN_E with v; auto with zfc.\n\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\n\nunfold E in |- *; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E in |- *; intros E E F; unfold F in |- *; intros G F.\nelim (axs_comprehension (Ap (fun E : Ens => E) F) G);\n intros G G; apply (GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nunfold E in |- *; intros E E' H'; elim H'; auto with zfc.\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\n\nunfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *;\n split; [ auto with zfc | idtac ].\n\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold E in |- *; intros E F G.\nelim (Union_IN E F G F G G G G G G);\n auto with zfc.\n\nQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nintros E F; unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *;\n unfold F in |- *; unfold F in |- *; unfold F in |- *;\n unfold F in |- *; unfold F in |- *; unfold F in |- *;\n unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F in |- *; unfold F in |- *; unfold F in |- *; \n unfold F in |- *; unfold F inQed.",
                    "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\n\nunfold E in |- *; unfold F in |- *; unfold F in |- *; intros.\nelim (Union_IN E F (single E) (single E) (single E));\n intros; left; absurd (In E (single E)); auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": "Y; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\n",
                "context_tokens": 744,
                "proof_start_offset": 2822,
                "proof_end_offset": 2931,
                "proof": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; elim n; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros n; elim n; auto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nProof.\nunfold F in |- *; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold F in |- *; intros n; split; red in |- *; intros a e.\ncut (In A (f a)).\nauto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold E in |- *; intros n; elim n; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nsimple induction n; intros.\napply (Build_Map (Ap (Ap (Ap (sgroup_sgroup_hom_map (monoid_sgroup_hom_map (monoid_sgroup_hom_map (monoid_sgroup_hom_map f))) f)).\nauto with algebra.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold E in |- *; intros n; elim n; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold Reflexive in |- *; intros n; elim n.\napply O_trans with (In (Ap (fun a0 : nat => a0 = a0)) (Ap (fun a0 : nat => a0 = a0));\n auto with zfc.\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nunfold not in |- *; intros n; unfold nat in |- *; intros.\nelim (M (sup (sup (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) H0).\n\nintros; left; exists (sup A f); auto with zfc.\n\nQed.",
                    "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nsimple induction n; intros; unfold E_not_IN_E, In in |- *;\n apply E_not_IN_E; intros.\nelim (E_not_IN_E (sup A f) (sup A f) i); intros a e.\nrewrite e.\nrewrite <- (H_not_IN_E (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup A f) (sup AQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(* The set of natural numbers  *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\n",
                "context_tokens": 734,
                "proof_start_offset": 2966,
                "proof_end_offset": 3139,
                "proof": "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nProof.\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\n\nTheorem E_not_EX_EX : forall E : Ens, ~ ~ ~ ~ ~ E.\nintros E E; apply (E_not_EX_Prop H E).\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\n\n(*\n\nDefinition E := EV E (fun n : nat => E (fun m : nat => E (S n)).\n\nLemma E_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_O_case_OQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E E H; unfold Definition_of_NN in |- *; unfold is_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_a_in_in_a_in_a_in_a_in_a_in_a_in_in_a_in_a_in_a_in_in_a_in_a_in_in_a_in_a_in_a_in_in_a_in_a_in_a_in_in_a_in_a_Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\n\nProof fun E_a : forall E : Ens, SUB E (Set_Of E) (Set_Of E).\n\nTheorem E_ab : forall E : Ens, SUB E E.\nProof fun E_a : forall E : Ens, SUB E (Set_Of E) (Set_Of E).\n\nTheorem E_ab : forall E : Ens, SUB E E.\nProof fun E_a : forall E : Ens, SUB E E -> exists E_a : E, In E a.\n\nTheorem E_ab : forall E : Ens, SUB E E.\nProof fun E_a : forall E : Ens, SUB E E.\nProof fun E_a : forall E : Ens, SUB E E -> exists E_a : E, In E a.\n\nTheorem E_ab_in : forall E : Ens, SUB E E.\nProof fun E_a : forall E : Ens, SUB E E -> exists E_a : E, In E a.\n\nSection E_ab.\nVariable E : Ens.\nHypothesis h : forall E : Ens, EQ E E.\nHypothesis h : forall E : Ens, EQ E E.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E H; elim H; intros H0 H1; elim H1; intros H2 H3.\nexists (f a); auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E; unfold Definition_of_nat_of_P in |- *.\nelim (axs_comprehension (Singleton E (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat:=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat':=E) (Tfloat').\n\n(*\nLemma E__vector_eq : forall E F : Ens, E_vector_eq E F -> exists F : Ens, E_vector_eq E F.\nintros E F; unfold E_vector_eq in |- *.\nelim (axs_comprehension (Singleton E (COMP:=E) (COMP:=E) (COMP':=E) (COMP':=E) (COMP':=E) (COMP':=E) (COMP':=E) (COMP':=E)Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros E E; unfold fun_of_NN in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nunfold not in |- *; intros E H; elim H; auto with zfc.\nQed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\n\nProof fun E_dec_compatible_def_or.\n\nTheorem E_not_O_EX : forall E : Ens, ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~Qed.",
                    "Theorem IN_Omega_EXType : forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nintros; unfold Definition_of_NN in |- *; unfold Map in |- *;\n apply E_not_EX_Prop; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " *)\n\nRequire Import Sets.\nRequire Import Axioms.\n\nDefinition Class_succ (E : Ens) := Union (Paire E (Sing E)).\n\n(*\nInductive Ord : Ens -> Prop :=\n  Oo : (Ord Vide)\n| So : (E:Ens)(Ord E)->(Ord (Class_succ E))\n| Lo : (E:Ens)((e:Ens)(IN e E)->(Ord e))->(Ord (Union E))\n| Eo : (E,E':Ens)(Ord E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\n",
                "context_tokens": 726,
                "proof_start_offset": 3141,
                "proof_end_offset": 3491,
                "proof": "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nProof.\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\nintros.\nelim (H E); auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E.\nexists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1; intros.\napply H with (n := n); auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nunfold not in |- *; intros.\nsplit.\nunfold not in |- *; intro.\napply H.\napply H.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; intros p E; elim E; intros p E; elim E; intros p E; elim E;\n intros p E; elim E; introsQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E; exists E; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E E; simpl in |- *; intros n E f.\napply E_not_Eq_EXType with (P := fun n : nat => ~ P (fun p : nat => EQ E (Nat p))).\nred in |- *; intros n E f.\nunfold E_eq in |- *; simpl in |- *; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nintros n E E; exists E; auto with zfc.\nQed.",
                    "Theorem IN_Nat_EXType : forall (n : nat) (E : Ens), IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimpl in |- *; simple induction 1.\nintros n E f p.\nexists n; auto with zfc.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zfc/Omega.v",
                "context": " E)->(EQ E E')->(Ord E').\n\nHints Resolve Oo So Lo : zfc.\n*)\n\n\nDefinition Nat : nat -> Ens.\nsimple induction 1; intros.\nexact Vide.\nexact (Class_succ X).\nDefined.\n\n(*\nTheorem Nat_Ord : (n:nat)(Ord (Nat n)).\nInduction n; Simpl; Auto with zfc.\nSave.\n*)\n\nDefinition Omega : Ens := sup nat Nat.\n\nTheorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n\n\nTheorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n\nHint Resolve IN_Class_succ INC_Class_succ: zfc.\n\n\nTheorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n\n\nTheorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n\n\nTheorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\nHint Resolve Nat_IN_Omega: zfc.\n\n\nTheorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n\nTheorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n\n\n",
                "context_tokens": 754,
                "proof_start_offset": 3494,
                "proof_end_offset": 4079,
                "proof": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nProof.\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\napply IN_sound_left with (Nat n).\nauto with zfc.\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\napply IN_sound_right with e; auto with zfc.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; intros.\napply Extensionality_Ensembles.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Finite, In in |- *.\nintros x y H' H'0; elim H'0.\nintros x y H'0; elim H'0.\nintros x y H'1; elim H'1; intros H'2 H'3; elim H'3.\nintros x y H'1; elim H'1; intros H'3 H'4; elim H'4.\nintros x y H'1; elim H'1; intros H'4 H'5; elim H'5.\nintros x y H'1; elim H'1; intros H'5 H'6; elim H'6.\nintros x y H'1; elim H'1; intros H'6 H'7; elim H'7.\nintros x y H'1; elim H'1; intros H'7 H'8; elim H'8.\nintros x y H'2; elim H'1; intros H'9 H'9; elim H'10; intros H'10 H'11.\nexists x; split.\nrewrite <- H'10; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; red in |- *; intros; apply Omega_intro_injective.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *.\nintros x y H'; red in |- *; intro.\napply H'; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Symmetric in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Symmetric in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Symmetric in |- *; unfold Transitive in |- *;\n unfold Transitive in |- *; unfold Transitive in |- *;\n unfold Transitive inQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Omega in |- *.\nintros.\napply Extensionality_Ensembles.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Included, Included, In in |- *; intros.\napply Extensionality_Ensembles.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Same in |- *; intros.\napply X_eq_S_n_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O.\nintros.\napply X_eq_S_n_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O_eq_O.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nunfold Reflexive, Negation in |- *; intros.\napply H; auto with zfc.\nQed.",
                    "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\nred in |- *; intros.\ncut (Equal (Union Omega) (Union Omega)).\nauto with zfc.\nQed."
                ]
            }
        ],
        "dep-map": [
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  ",
                "context_tokens": 255,
                "proof_start_offset": 944,
                "proof_end_offset": 1028,
                "proof": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\nProof.\nintros.\nnow symmetry.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros; apply eq_sym, eq_sym. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. unfold eq; intros. discriminate. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros; subst; reflexivity. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros; red; intros. apply H. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros; apply (@eq_sym _ O). Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. rewrite <- (eq_sym x y). apply eq_sym. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq; intros. apply O.lt_trans with x; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof.\n    unfold eq; intros.\n    red; simpl; auto.\n  Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. rewrite H. apply eq_sym. Qed.",
                    "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros; red; auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  ",
                "context_tokens": 285,
                "proof_start_offset": 1032,
                "proof_end_offset": 1144,
                "proof": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now apply eq_sym, eq_trans, eq_trans. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now apply eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros; now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros; now apply eq_sym, eq_sym. Qed.",
                    "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. now transitivity (y = x). Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  ",
                "context_tokens": 321,
                "proof_start_offset": 1148,
                "proof_end_offset": 1260,
                "proof": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\nProof.\nintros.\netransitivity; eassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. unfold lt. now apply compare_eq. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now transitivity (y + x). Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply compare_eq. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. rewrite <- H. apply lt_trans with z. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with (y := z). assumption. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply compare_eq. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. eapply lt_not_eq; eauto. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. now apply lt_trans with (y := z). Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply lt_trans with (y := z). now apply lt_trans with x. Qed.",
                    "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. apply le_trans with x; assumption. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  ",
                "context_tokens": 357,
                "proof_start_offset": 1263,
                "proof_end_offset": 1413,
                "proof": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\nProof.\nintros ? ? Hlt Heq.\nrewrite Heq in Hlt.\nrevert Hlt.\napply StrictOrder_Irreflexive.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. now apply not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply (StrictOrder_Irreflexive x). Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply eq_sym. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply (StrictOrder_Irreflexive x). Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. apply lt_not_eq. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros. now symmetry. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/dep-map/Coqlib.v",
                "context": "Require Import SetoidList.\nRequire OrderedType.\nRequire Import Orders.\n\n\n\n(** Some preliminary results  **)\nInstance not_symmetric (A : Type) (R: relation A) `{Symmetric A R} : Symmetric (fun x y => ~R x y).\nProof. intros?? Hnot HR. apply Hnot. symmetry. assumption. Qed.\n\nInstance InA_compat {A : Type} : Proper (subrelation ==> eq ==> eq ==> impl) (@InA A).\nProof.\nintros inA inB Hin. do 6 intro; subst. intro Hl. rewrite InA_alt in *.\ndestruct Hl as [? [??]]. eexists. split; eauto.\nQed.\n\nDefinition full_relation {A : Type} : relation A := fun x y : A => True.\n\n\n(** Conversion module between the two kinds of [OrderedType]. **)\nModule OTconvert (O : OrderedType) : OrderedType.OrderedType\n          with Definition t := O.t\n          with Definition eq := O.eq\n          with Definition lt := O.lt.\n  \n  Definition t := O.t.\n  Definition eq := O.eq.\n  Definition lt := O.lt.\n  \n  Definition eq_refl : forall x, eq x x := reflexivity.\n  Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n  Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n\n  Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n  Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros?? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n\n  ",
                "context_tokens": 404,
                "proof_start_offset": 1417,
                "proof_end_offset": 1681,
                "proof": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\nProof.\nintros x y.\nassert (H := (O.compare_spec x y)).\ndestruct (O.compare x y).\nconstructor 2.\nnow inversion H.\nconstructor 1.\nnow inversion H.\nconstructor 3.\nnow inversion H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now transitivity (O.lt x y). Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply Compare_dec. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros; apply O.lt_not_eq. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply LT. trivial. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now apply Compare_eq_sym. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now rewrite compare. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. apply compare_eq. apply compare_eq. apply compare_eq. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. now symmetry. Qed.",
                    "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof. intros. unfold lt.\n   case_eq (O.compare x y); intros.\n   apply LT.lt_not_eq in Hlt.\n   destruct Hlt as [Hm|Hm]; [apply LT; auto | apply GT; auto ].\n  Qed."
                ]
            }
        ],
        "chinese": [
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\n",
                "context_tokens": 445,
                "proof_start_offset": 2094,
                "proof_end_offset": 2161,
                "proof": "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  induction n.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\ninduction n; simpl; auto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n; simpl in |- *; trivial.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n.\n  reflexivity.\n  simpl.\n  intros.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  intro; reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nunfold multneg.\n simple induction n.\nreflexivity.\nsimpl in |- *.\nauto.\nintros n0 H.\nrewrite H.\nrewrite H.\napply le_plus_distr_r.\nauto.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\nsimple induction n.\nreflexivity.\nauto with arith.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n.\n  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.  simpl in |- *.  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n  simple induction n.\n  reflexivity.\n  simpl in |- *.\n  reflexivity.\nQed.",
                    "Lemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n intros; unfold multZ in |- *; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 475,
                "proof_start_offset": 2163,
                "proof_end_offset": 2234,
                "proof": "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 508,
                "proof_start_offset": 2236,
                "proof_end_offset": 2350,
                "proof": "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros n1 n2.\n unfold mult, multZ in |- *.\n rewrite plus_comm.\n rewrite mult_comm.\n rewrite (mult_comm (mult_comm n1)).\n rewrite mult_assoc.\n rewrite (mult_comm (mult_comm n1)).\n rewrite mult_assoc.\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_comm (mult_comm n1)).\n rewrite mult_assoc.\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_assoc (mult_comm n1)).\n rewrite mult_assoc.\n rewrite (mult_comm (mult_comm n1)).\n rewrite mult_assoc.\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_assoc (mult_comm n1)).\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_comm (mult_comm n1)).\n rewrite (mult_assoc (mult_comm n1)).\n rewrite (mult_comm (mult_comm n1)).Qed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n intros.\n rewrite multZ_eq2.\n rewrite multZ_eq_1.\n reflexivity.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq3 : forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 563,
                "proof_start_offset": 2352,
                "proof_end_offset": 2428,
                "proof": "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "***********************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\n",
                "context_tokens": 580,
                "proof_start_offset": 2430,
                "proof_end_offset": 2552,
                "proof": "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n intros.\n rewrite multZ_eq_0.\n rewrite multZ_eq_0.\n rewrite mult_0_l.\n rewrite <- mult_assoc.\n rewrite <- plus_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm n1).\n rewrite (mult_comm n1).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm n1).\n rewrite mult_assoc.\n rewrite (mult_comm n1).\n rewrite mult_assoc.\n rewrite (mult_comm n1).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm (S n1)).\n rewrite mult_assoc.\n rewrite (mult_comm n1).\n rewrite (mult_comm n1).\n rewrite mult_assoc.\n rewrite (mult_comm n1).\n rewrite (mult_comm (S n1)).\n rewriteQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.",
                    "Lemma multZ_eq5 : forall (n1 : nat) (n : Z), multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                 Zmult.v                                  *)\n(****************************************************************************)\nRequire Export Lci.\nRequire Export misc.\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(* Multiplication on Z, (Z, +, *, 0, 1) is a unitary commutative ring *)\n\n(*Recursive Definition multZ : Z -> Z -> Z := \n        OZ      y  => OZ\n | (pos O)      y  => y\n | (pos (S n1)) y  => (addZ (multZ (pos n1) y) y)\n | (neg O)      y  => (oppZ y)\n | (neg (S n1)) y  => (addZ (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\n",
                "context_tokens": 728,
                "proof_start_offset": 2860,
                "proof_end_offset": 3465,
                "proof": "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; simpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H4.\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros.\nrewrite H5.\nsymmetry in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite <- (mult_comm x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc y x).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_comm x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_comm x y).\n rewrite (mult_comm x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc x y).\n rewrite <- (mult_assoc x y).\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_OZ_l :\n forall (x y : nat) (y : Z),\n multZ (neg (S x)) y = multZ (pos x) y.\nProof multZ_eq_5.\n\nLemma mult_Pmult_nat_1 : forall (x y : nat) (y : Z),\n multZ (pos x) y = multZ (pos x) y.\nProof multZ_eq_6.\n\nLemma mult_Pmult_nat_2 : forall (x y : nat) (y : Z),\n multZ (pos x) y = multZ (pos x) y.\nProof multZ_eq_6.\n\nLemma mult_monotony_nat_3 : forall (x y : nat) (y : Z),\n multZ (pos x) y = multZ (pos x) y.\nProof mult_well_founded_nat_3.\n\nLemma mult_preserves_nat_4 : forall (x y : nat) (y : Z),\n multZ (nat_of_nat (S x)) y = mult_to_nat (nat_of_Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq4.\n\nLemma mult_OZ_l : forall x y : Z, multZ (neg (S x)) y = -x + y.\nProof multZ_eq5.\n\nLemma mult_permute_r :\n forall (x y : Z) (n : nat),\n multZ (pos x) y = multZ (neg x) (pos y).\nProof multZ_eq5.\n\nLemma mult_permute_r :\n forall (x y z : Z) (n : nat),\n multZ (neg (S x)) y = multZ (pos x) (pos y) n.\nProof multZ_eq5.\n\nLemma mult_permute_l :\n forall (x y z : Z) (n : nat),\n multZ (pos x) y = multZ (pos x) (pos y) n.\nProof mult_permute_r.\n\nLemma mult_permute_r :\n forall (x y z : Z) (n : nat),\n multZ (pos x) y = multZ (pos x) (pos y) n.\nProof mult_permute_r.\n\nLemmaQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_succZ_r : forall x y : Z, multZ (Zneg x) y = multZ (neg x) y.\nProof multZ_eq5.\n\nLemma mult_comm : forall x y z : Z, multZ (Zneg x) y = multZ (pos x) y.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (Zneg x) y = multZ (Zpos y) z.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (Zpos x) y = multZ (Zneg y) z.\nProof mult_comm.\nLemma mult_comm : forall x y z : Z, multZ (Zneg x) y = multZ (Zneg y) z.\nProof plus_comm.\nLemma mult_comm : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) z.\nProof mult_comm.\nLemma mult_assoc : forall x y z : Z, multZ (Zpos x) y = multZ (Zpos y) z.\nProof mult_Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n intros.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- mult_assoc.Qed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq_5.\n\nLemma mult_permute_l_reverse : forall x y : Z, multZ (Zneg x) y = oppZ (pos x) (neg y).\nProof mult_permute_l_reverse.\n\nLemma mult_permute_r_reverse : forall x y : Z, multZ (Zneg x) y = oppZ (neg x) (neg y).\nProof mult_permute_l_reverse.\n\nLemma mult_permute_l_reverse : forall x y : Z, multZ (Zneg x) y = multZ x (Zneg y).\nProof mult_permute_l_reverse.\n\nLemma mult_permute_r_reverse : forall x y : Z, multZ (Zneg x) y = multZ x (Zneg y).\nProof mult_permute_l_reverse.\n\nLemma mult_permute_l_reverse : forall x y : Z, multZ (Zneg x) y = multZ x (Zneg y).\nProof mult_permute_l_reverse.\n\nLemma mult_permute_l_reverse : forall x y : Z, multZ (Zneg x) y = multZ x (Zneg yQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\nintros.\napply mult_comm.\nQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma tech_mult_negZ :\n forall (x y : Z) (n : nat),\n multZ (pos x) y = multZ (neg x) (neg y) n.\nProof.\n intros.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_comm.\n rewrite mult_assoc.\n rewrite <- mult_assoc.\n rewrite <- (mult_comm x y n).\n rewrite mult_assoc.\n rewrite <- (mult_comm x y n).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_comm.\n rewrite (mult_comm x y n).\n rewrite mult_assoc.\n rewrite (mult_comm x y n).\n rewrite mult_assoc.\n rewrite (mult_comm x y n).\n rewrite (mult_comm x y n).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm x y n).\n rewrite mult_assoc.\n rewrite mult_assoc.\n rewrite (mult_comm x y n).\n rewrite mult_assoc.\n rewrite (mult_comm xQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof multZ_eq5.\n\nLemma mult_comm_reverse_reverse : forall x y : Z, multZ (Zneg x) y = mult x y.\nProof mult_comm_reverse_reverse.\n\nLemma mult_comm_reverse_reverse : forall x y : Z, multZ (Zneg x) y = mult x y.\nProof mult_comm_reverse_reverse.\n\nLemma mult_comm_reverse_reverse : forall x y z : Z, multZ (Zneg x) y = mult x y.\nProof mult_comm_reverse_reverse.\n\nLemma mult_comm_reverse_reverse : forall x y z : Z, multZ (Zneg x) z = mult x y.\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse_reverse : forall x y z : Z, multZ (Zpos x) y = mult x z.\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse_reverse_reverse : forall x y z : Z, multZ (Zpos x) y = mult x y.\nProof mult_comm_reverse.\n\nLemma mult_comm_reverse_reverse : forall x yQed.",
                    "Lemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\nProof.\n trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " (multZ (neg n1) y) (oppZ y)).\n*)\n\n\nFixpoint multpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => x2\n  | S n0 => addZ (multpos x2 n0) x2\n  end.\n\nFixpoint multneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => oppZ x2\n  | S n0 => addZ (multneg x2 n0) (oppZ x2)\n  end. \n\nDefinition multZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => OZ\n  | pos n => multpos x2 n\n  | neg n => multneg x2 n\n  end.\n\n\nLemma multZ_eq1 : forall n : Z, multZ OZ n = OZ.\nProof.\n auto.\nQed.\n\nLemma multZ_eq2 : forall n : Z, multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 3487,
                "proof_end_offset": 4087,
                "proof": "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\nintros; elim x.\nsimpl in |- *; reflexivity.\nintros; elim n.\nsimpl in |- *; symmetry in |- *.\nelim (addZ_opposite y I); intros.\nelim H0; intros; elim H2; intros; exact H3.\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros.\nelim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\nintros; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* op (S n) *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* id n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* id n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* id n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(*Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq_5.\n\nLemma mult_predZ_r : forall x y : Z, multZ (predZ x) y = predZ (multZ x y) (oppZ y).\nProof mult_Grimal.\nLemma mult_zint_r : forall x y : Z, multZ (zdrop x) y = predZ (multZ x y) (plusZ x y).\nProof mult_:(?Z_of_nat_of_nat_of_nat_of_Z_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_nat_of_eq_nat_of_eq_minus_minus_minus_minus_minus_minus_minus_minus_minus_minus_minus_minus_minus_minus_minus_Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq_5.\n\nLemma mult_succZ_l : forall x y : Z, multZ (predZ x) y = predZ (multZ x y) (oppZ y).\nProof multZ_eq_6.\n\nLemma mult_predZ_r : forall x y : Z, multZ (addZ x y) y = predZ (multZ x y).\nProof mult_OZ_l.\n\nLemma mult_OZ_r : forall x y : Z, multZ (predZ x y) = predZ (multZ x y) (multZ x y).\nProof mult_ Corporation.\n intros; elim x.\n(* rvarlift1 *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* lift *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* lift *)\nQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq5.\n\nLemma mult_OZ_l : forall x y : Z, multZ (Zneg x) y = oppZ (pos x) (oppZ y).\nProof mult_comoid_l.\n\nLemma mult_succZ_r : forall x y : Z, multZ (Zneg x) y = oppZ (pos x) (neg y).\nProof mult_comoid_l.\n\nLemma mult_Znat_r : forall x y : Z, multZ (Zneg x) y = oppZ (Zpos y) (Z_of_nat x).\nProof mult_comoid_l.\n\nLemma mult_Znat_r : forall x y : Z, multZ (Zneg x) y = oppZ (Zpos y) (Z_of_nat x).\nProof mult_comoid_r.\n\nLemma mult_Z_eq : forall x y : Z, multZ (Zneg x) y = multZ (Zpos y) (Z_of_nat x).\nProof mult_comoid_r.\n\nLemma mult_Z_eq : forall x y : Z, multZ (Zpos x) y = multZ (Zpos x) (Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* contexte gauche *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq5.\n\nLemma mult_succZ_r : forall x y : Z, multZ (predZ x) y = predZ (multZ x y) (oppZ y).\nProof multZ_eq5.\n\nLemma mult_predZ_r : forall x y : Z, multZ (predZ x) y = predZ (multZ x y) (multZ x y).\nProof multZ_eq5.\n\nLemma mult_succZ_r : forall x y : Z, multZ (zdrop x) y = OZ (multZ x y) (multZ x y).\nProof multZ_eq5.\n\nLemma mult_lincomb_r : forall x y : Z, multZ (zdrop x) y = OZ (multZ x y) (multZ x y).\nProof mult_commutative.\n\nLemma mult_commutative :\n forall x y : Z, multZ (zdrop x) y = multZ (zdrop x) y.\nProof mult_commutative.\n\nLemma mult_commutative :\n forall x y z : Z, multZ (zdrop x) y = multZ (Qnum y) (multZ x y) (multZ xQed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof.\n intros; elim x.\n(* branch *)\nintros; elim n.\n(* negative *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* positive *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros;Qed.",
                    "Lemma mult_predZ_l : forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\nProof multZ_eq4.\n\nLemma mult_predZ_l : forall x y : Z, multZ (succZ x) y = oppZ (addZ x y) (oppZ y).\nProof mult_comoid_l.\n\nLemma mult_succZ_r : forall x y : Z, multZ (succZ x) y = oppZ (addZ x y) (oppZ y).\nProof mult_comoid_l.\n\nLemma mult_OZ_r : forall x y z : Z, multZ (predZ x) y = oppZ (addZ x y) (Zmult z y).\nProof mult_comoid_l.\n\nLemma mult_reverse_l : forall x y z : Z, multZ (posnatMult x y) z = oppZ (addZ x y) (Zmult z y).\nProof mult_comoid_l.\n\nLemma mult_reverse_r : forall x y z : Z, multZ (zdrop x y) z = oppZ (zdrop x y) (Zmult z y).\nProof mult_reverse_l.\n\nLemma mult_reverse_r : forall x y z : Z, multZ (zdrop x y) z = oppZ (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": ", multZ (pos 0) n = n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq3 :\n forall (n1 : nat) (n : Z), multZ (pos (S n1)) n = addZ (multZ (pos n1) n) n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq4 : forall n : Z, multZ (neg 0) n = oppZ n.\nProof.\n auto.\nQed.\n\nLemma multZ_eq5 :\n forall (n1 : nat) (n : Z),\n multZ (neg (S n1)) n = addZ (multZ (neg n1) n) (oppZ n).\nProof.\n auto.\nQed.\n\n(*******************)\nLemma tech_mult_posZ :\n forall (x : nat) (y : Z), multZ (pos (S x)) y = addZ (multZ (pos x) y) y.\n\nProof multZ_eq3.\n\n(*******************)\nLemma tech_mult_negZ :\n forall (x : nat) (y : Z),\n multZ (neg (S x)) y = addZ (multZ (neg x) y) (oppZ y).\n\nProof multZ_eq5.\n\n(*****************)\nLemma mult_succZ_l : forall x y : Z, multZ (succZ x) y = addZ (multZ x y) y.\n\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *. \nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H4.\n(* neg (S n0) *)\nintros; unfold succZ in |- *; rewrite (tech_mult_negZ n0 y).\nelim (addZ_associativity (multZ (neg n0) y) (oppZ y) y).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros. rewrite H5.\nsymmetry  in |- *; exact (add_OZ (multZ (neg n0) y)).\nQed.\n\n(*****************)\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 737,
                "proof_start_offset": 4109,
                "proof_end_offset": 5383,
                "proof": "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsymmetry in |- *; exact (add_IZ_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\nsimple induction n.\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y).\nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* IZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos n *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nintros; elim n.\n(* pos (Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg n (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos n (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos n (S n0) *)\nintros; elim n.\n(*Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* neg (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* neg (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; reflexivity.\n(* neg (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; reflexivity.\n(* neg (S n0) *)\nintros; simpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; reflexivity.\n(* neg (S n0) *)\nintros; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* Idem *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* xor n *)\nintros; elim n.\n(* xor n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* xor n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(*local n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(*local n *)\nintros; elim n.\n(*local n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(*local n *)\nintros; elim n.\n(*local n *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(*local n *)\nintros; elim n.\n(*local n *)\nintros; elim n.\n(*local n *)\nsimpl in |- *; reflexivity.\n(*local n *)\nintros; elim n.\n(*local n *)\nintros; elim n.\n(*local n *)\nsimpl in |- *; reflexivity.\n(*local n *)\nintros; elimQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* Idem *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* idl *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* idl *)\nsimpl in |- *; reflexivity.\n(* app *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* idl *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\n(* contexte droit *)\nsimpl in |- *; reflexivity.\n(* abs n *)\nintros; elim n.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* IZ *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* pos (S n0) *)\nsimpl in |- *; reflexivity.\n(* pos (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0) *)\nsimpl in |- *; reflexivity.\n(* neg (S n0) *)\nintros; elim n.\n(* neg (S n0)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)\nintros; elim n.\n(* contexte False *)Qed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\nintros; elim x.\n(* IZ *)\nsimpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\nProof.\n intros; elim x.\n(* word 0 *)\nintros; reflexivity.\n(* sign *)\nintros; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "\nLemma mult_predZ_l :\n forall x y : Z, multZ (predZ x) y = addZ (multZ x y) (oppZ y).\n\nProof.\nintros; elim x.\n(* OZ *)\nsimpl in |- *; reflexivity.\n(* pos n *)\nintros; elim n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *.\nelim (addZ_opposite y I); intros. elim H0; intros; elim H2; intros; exact H3.\n(* pos (S n0) *)\nintros; unfold predZ in |- *; rewrite (tech_mult_posZ n0 y).\nelim (addZ_associativity (multZ (pos n0) y) y (oppZ y)).\nelim (addZ_opposite y I); intros. elim H1; intros; elim H3; intros; rewrite H4.\nrewrite (add_OZ (multZ (pos n0) y)); reflexivity.\n(* neg n *)\nintros; reflexivity.\nQed.\n\n(*****************)\nLemma mult_succZ_r : forall x y : Z, multZ x (succZ y) = addZ (multZ x y) x.\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsymmetry  in |- *; exact (add_IZ_succZ y).\n(* pos (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_posZ y0).\nrewrite H; elim (addZ_commutativity (pos y0) (multZ (pos y0) y)).\nelim (addZ_associativity (pos y0) (multZ (pos y0) y) (succZ y)).\nelim (addZ_commutativity (addZ (multZ (pos y0) y) (succZ y)) (pos y0)).\nrewrite (succ_addZ_r (multZ (pos y0) y) y).\nrewrite (succ_addZ_l (addZ (multZ (pos y0) y) y) (pos y0)).\nelim (succ_addZ_r (addZ (multZ (pos y0) y) y) (pos y0)).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; rewrite (add_mIZ_predZ (oppZ y)); exact (opp_succZ y).\n(* neg (S y0) *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 734,
                "proof_start_offset": 5405,
                "proof_end_offset": 6761,
                "proof": "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; exact (add_mIZ_predZ y).\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\nsimple induction n.\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y))) (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nsimple induction x; simpl in |- *; auto with *.\nintros; simpl in |- *; auto with *.\nintros; simpl in |- *; auto with *.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimpleQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimplQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg O *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* neg (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* pos (S x) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* pos (S y) *)\nreflexivity.\n(* neg (S y) *)\nreflexivity.\n(* neg (S y) *)Qed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* negative *)\nsimple induction n.\n(* pos 0 *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nunfold opp, opp, opp, opp in |- *; simpl in |- *; auto with *.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\n intros; elim x.\n(* neg n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* Rewrite (plus_n Elim Zminus x y); exact (plus_comm x y).\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg n *)\nunfold opp in |- *; unfold opp in |- *; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_predZ_r : forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\nProof.\nintros; elim x.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " *)\nintros y0 H; do 2 rewrite (tech_mult_negZ y0).\nelim H; elim (addZ_commutativity (oppZ y) (multZ (neg y0) y)).\nelim (addZ_associativity (oppZ y) (multZ (neg y0) y) (neg (S y0))).\nelim (addZ_commutativity (addZ (multZ (neg y0) y) (neg (S y0))) (oppZ y)).\nrewrite (opp_succZ y). \nrewrite (pred_addZ_r (multZ (neg y0) (succZ y)) (oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 6778,
                "proof_end_offset": 7151,
                "proof": "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O (-1)).\n(* pos n *)\nsimple induction n.\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (mult_n_O (Zpos n)).\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* negative *)\nsimpl in |- *; reflexivity.\n(* positive *)\nintros n0 H; unfold oppZ in |- *; rewrite (plus_n_O x).\nrewrite (plus_comm x (eq_sym x)).\nrewrite H; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nunfold Z in |- *; intros x; rewrite (mult_comm x); rewrite (mult_comm x); rewrite (mult_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (mult_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (mult_comm x);\n rewrite (plus_comm x); rewrite (mult_comm x); rewrite (plus_comm x);\n rewrite (plus_comm x); rewrite (mult_comm x); rewrite (mult_comm x); rewrite (plus_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (mult_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (plus_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (plus_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (plus_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (plus_comm x);\n rewrite (plus_comm x); rewrite (plus_comm x); rewrite (plus_comm xQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; auto.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* the positive result is hence not in the ring *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* n *)\nsimple induction n.\n(* app *)\nsimple induction n.\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction n.\nsimple induction n.\n(* app *)\nsimple induction n.\nsimple induction n.\n(* app *)\nsimple induction n.\nsimple induction n.\n(* app *)\nsimple induction n.\n(* app *)\nsimple induction nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x; unfold oppZ in |- *; simpl in |- *; reflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* zero *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\n(* pos n *)\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\n(* 0 *)\nreflexivity.\nQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\nrewrite (Z.opp_involutive (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (Z.abs (ZQed.",
                    "Lemma mult_OZ : forall x : Z, multZ x OZ = OZ.\nintros; elim x.\n(* pos n *)\nreflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": "oppZ y)).\nrewrite H; elim (pred_addZ_l (addZ (multZ (neg y0) y) (neg y0)) (oppZ y)).\nelim (pred_addZ_r (multZ (neg y0) y) (neg y0)); unfold predZ in |- *;\n reflexivity.\nQed.\n\n(*****************)\nLemma mult_predZ_r :\n forall x y : Z, multZ x (predZ y) = addZ (multZ x y) (oppZ x).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nsimpl in |- *; symmetry  in |- *; exact (add_mIZ_predZ y).\n(* pos (S n0) *)\nintros n0 H; unfold oppZ in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\n",
                "context_tokens": 750,
                "proof_start_offset": 7168,
                "proof_end_offset": 7648,
                "proof": "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H.\nrewrite (add_IZ_succZ (pos y)); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *; unfold oppZ in |- *.\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* negative *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nassumption.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple induction x.\nsimple induction x.\n(* pos O *)\nreflexivity.\n(* pos S (S x) *)\nintros y H; rewrite (tech_mult_posZ n 0 y); reflexivity.\n(* pos (S y) *)\nsimple induction n.\n(* pos S (S x) *)\nreflexivity.\n(* pos S (S y) *)\nsimple induction n.\n(* pos S (S x) *)\nreflexivity.\n(* pos S (S x) *)\nsimple induction n.\n(* pos S (S x) *)\nreflexivity.\n(* pos S (S y) *)\nsimple induction n.\n(* pos S (S x) *)\nreflexivity.\n(* pos S (S x) *)\nsimple induction n.\n(* pos S (S x) *)\nreflexivity.\n(* pos S (S x) *)\nsimple induction n.\n(* neg S (S x) *)\nsimple induction n.\n(* pos S (S x) *)\nreflexivity.\n(* neg S (S x) *)\nsimple induction n.\n(* pos S (S x) *)\nsimple induction n.\n(* neg S (S x)Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\n(* negative *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(*Qed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple induction x.\nsimple induction x.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* var 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple inductionQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nreflexivity.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* var 0 *)\nsimple induction n.\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\nQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction xQed.",
                    "Lemma mult_IZ : forall x : Z, multZ x IZ = x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zmult.v",
                "context": " in |- *; do 2 rewrite (tech_mult_posZ n0).\nrewrite (pred_addZ_r (multZ (pos n0) (predZ y)) y).\nelim (pred_addZ_l (multZ (pos n0) (predZ y)) y).\nelim (addZ_commutativity y (multZ (pos n0) y)).\nelim (addZ_associativity y (multZ (pos n0) y) (neg (S n0))).\nelim (addZ_commutativity (addZ (multZ (pos n0) y) (neg (S n0))) y).\nrewrite H; elim (pred_addZ_r (multZ (pos n0) y) (oppZ (pos n0))).\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *.\nreplace (pos 0) with IZ; auto.\nrewrite (add_IZ_succZ (oppZ y)).\nexact (opp_predZ y).\n(* neg (S n0) *)\nintros n0 H; do 2 rewrite (tech_mult_negZ n0).\nrewrite H; rewrite (opp_predZ y).\nelim (addZ_commutativity (oppZ (neg n0)) (multZ (neg n0) y)).\nelim (addZ_associativity (oppZ (neg n0)) (multZ (neg n0) y) (succZ (oppZ y))).\nelim\n (addZ_commutativity (addZ (multZ (neg n0) y) (succZ (oppZ y)))\n    (oppZ (neg n0))).\nrewrite (succ_addZ_r (multZ (neg n0) y) (oppZ y)).\nrewrite (succ_addZ_l (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nelim (succ_addZ_r (addZ (multZ (neg n0) y) (oppZ y)) (oppZ (neg n0))).\nreflexivity.\nQed.\n\n(************)\nLemma mult_OZ : forall x : Z, multZ x OZ = OZ.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y OZ); rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y OZ); rewrite H; reflexivity.\nQed.\n\n(************)\nLemma mult_IZ : forall x : Z, multZ x IZ = x.\n\nsimple destruct x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos (S y) *)\nintros y H; rewrite (tech_mult_posZ y IZ); rewrite H. \nrewrite (add_IZ_succZ (pos y)); reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y) *)\nintros y H; rewrite (tech_mult_negZ y IZ); rewrite H; unfold IZ in |- *;\n unfold oppZ in |- *. \nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.\n\n(*************)\n",
                "context_tokens": 744,
                "proof_start_offset": 7666,
                "proof_end_offset": 8216,
                "proof": "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nProof.\nsimple destruct x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_posZ y (neg 0)); rewrite H.\nrewrite (add_mIZ_predZ (oppZ (pos y))); reflexivity.\nsimple induction n.\nreflexivity.\nintros y H; rewrite (tech_mult_negZ y (neg 0)); rewrite H.\nelim (opp_add Z IdZ addZ OZ oppZ Z_group addZ_commutativity (neg y) (neg 0) I I).\nrewrite (add_mIZ_predZ (neg y)); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* sign *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\nsimple induction n.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\nsimple induction m.\n(* neg 0 *)\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos m = 0 *)\nreflexivity.\n(* pos n = 0 *)\nsimple induction n.\n(* pos m = 0 *)\nsimple induction n.\n(* 0 = 0 *)\nsimple induction m.\n(* pos m = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 = 0 *)\nsimple induction m.\n(* 0 = 0 *)\nsimpleQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x; simpl in |- *; auto with zarith.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* pos (S x) *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\n(* 0 *)\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos 0 *)\nsimpleQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* neg 0 *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; reflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* pos 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.\nsimple induction m.\n(* 0 *)\nsimple induction mQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* GG *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* var n *)\nsimple induction n.\nsimple induction n.\n(* neg n *)\nsimple induction n.\nsimple induction n.\nsimple induction n.\n(* pos n *)\nsimple induction n.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nsimpl in |- *.\nintros; reflexivity.\nsimple induction x.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct x.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\n simple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\n simple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\n simple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\n simple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma mult_mIZ : forall x : Z, multZ x (neg 0) = oppZ x.\nsimple destruct x.\n(* cond (S x) *)\nintros x; rewrite (tech_mult_posZ x (pos 0)); rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\n",
                "context_tokens": 272,
                "proof_start_offset": 1823,
                "proof_end_offset": 1986,
                "proof": "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nProof.\nintros; elim x; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nintro; simpl in |- *.\nexact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction 1; auto with arith.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold Incident, absZ in |- *.\nintros x.\ncase (le_gt_dec x 0); intro.\nabsurd (0 < x); auto.\napply lt_le_trans with (neg x); auto.\napply neg_neg; auto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold nodoubles, negZ in |- *.\nintros x H.\nelim H; intros.\nelim H0; intros.\nelim H1; intros.\nelim H1; intros.\nelim H2; intros.\nelim H3; intros.\nelim H4; intros.\nelim H5; intros.\nelim H5; intros.\nelim H7; intros.\nelim H7; intros.\nelim H7; intros.\nelim H8; intros.\nelim H8; intros.\nelim H8; intros.\nelim H9; intros.\nelim H8; intros.\nelim H9; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H10; intros.\nelim H12; intros.\nelim H12; intros.\nelim H13; intros.\nelim H14; intros.\nelim H13; intros.\nelim H14; intros.\nelim H15; intros.\nelim H16; intros.\nelim H16; intros.\nelim H16; intros.\nelim H16; intros.\nelim H18;Qed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold addZ, One in |- *.\nintros x.\nelim x.\nintro.\nintro.\nelim H.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H1.\nintro.\napply pos_absZ.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction y.\nsimple induction y.\nsimple induction x.\nsimple induction x.\nsimple induction y.\nintros.\nsimple induction x.\nsimpl in |- *.\nelim (case_eq (nat_eq_dec x0 x1).\nintros.\nrewrite H3.\nrewrite H4.\nrewrite H5.\ntrivial.\nassumption.\nintro.\nrewrite H6.\nrewrite H6.\ntrivial.\nassumption.\nintro.\nrewrite H6.\nrewrite H6.\ntrivial.\nassumption.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold paired, IZ in |- *.\nintros x H.\nelim H.\nintros.\nelim H.\nintros.\nelim H.\nintros.\nelim H.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H0.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H9.\nintros.\nelim H9.\nintrosQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction y.\nsimpl in |- *.\nauto.\nsimpl in |- *.\nauto.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\napply H5.\ntrivial.\nintro.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\napply H6.\ntrivial.\nintro.\nelim H6.\nintros.\nelim H6.\nintros.\napply H6.\ntrivial.\nintro.\nelim H6.\nintros.\napply H6.\ntrivial.\nintro.\nelim H6.\nintros.\napply H6.\ntrivial.\nQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nunfold OZ in |- *.\nintros x H.\ncase (Z_eq_dec x 0).\nintros.\napply H.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absZ_absZ.\napply absQed.",
                    "Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).\nsimple induction x.\nsimple induction x.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\n",
                "context_tokens": 333,
                "proof_start_offset": 2011,
                "proof_end_offset": 2188,
                "proof": "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nintros x; elim x.\nunfold absZ in |- *; reflexivity.\nunfold absZ in |- *; reflexivity.\nintros; elim H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x2.\nsimple induction x2.\nsimple induction x3.\nsimple induction x3.\nsimple induction x3.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x4.\nsimple induction x5.\nsimple induction x5.\nsimple induction x6.\nsimple induction x6.\nsimple induction x4.\nsimple induction x5.\nsimple induction x6.\nsimple induction x6.\nsimple induction x6.\nsimple induction x6.\nsimple induction x6.\nQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple induction 1.\nsimple inductionQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nauto with arith.\nsimple induction 1.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple induction 1.\nauto with arith.\nsimple inductionQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimpleQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x2.\nsimple induction x1.\nsimple induction x2.\nsimple induction x1Qed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nintros.\nelim H; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simplQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1Qed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x; simple induction 1; simpl in |- *; intros.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl in |- *.\napply I. intro; simpl inQed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nauto with *.\nintros; elim H0; simpl in |- *. exact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I.Qed.",
                    "Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\nProof.\nsimple induction x.\nsimpl in |- *. intros.\napply lt_O_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\n",
                "context_tokens": 398,
                "proof_start_offset": 2217,
                "proof_end_offset": 2811,
                "proof": "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold antisym in |- *; intros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintros n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintros n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold DiLn in |- *.\nintros x y z H; elim H; simpl in |- *.\nunfoldintegral in |- *; intros x H'; elim H; simpl in |- *.\nunfold includes in |- *; intros y H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim H'; simpl in |- *.\nunfold includes in |- *; intros z H'; elim HQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold OZ in |- *; auto.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold shuffle in |- *; intros; elim H.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold WDecide in |- *.\nintros x; elim x. \nunfold absZ in |- *; reflexivity.\nintros; elim H. \nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold surj, IZ, oppZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nunfold sym_pos in |- *; intros. \nelim H. \napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply sym_eq.\napply symQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nelim x.\nunfold absZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nintro; elim x.\nunfold oppZ in |- *; reflexivity.\nintros; elim H.\nunfold oppZ in |- *; reflexivity.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nsimple induction 1.\nsimpl in |- *.\nauto with *.\nsimpl in |- *.\nauto with *.\nsimpl in |- *.\nauto with *.\nQed.",
                    "Theorem leZ_antisymmetric : antisym Z leZ.\nProof.\nsimple induction 1; simpl in |- *.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "     *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\n",
                "context_tokens": 627,
                "proof_start_offset": 2971,
                "proof_end_offset": 3345,
                "proof": "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nreflexivity.\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *; unfold leZ in |- *; intros.\nelim (le_Sn_O n H).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x y; elim x. \nunfold negZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexactQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\nunfold lt_absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nunfold lt_absZ in |- *; intros x y.\nelim y.\nunfold lt_absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x; elim x.\nunfold lt_absZ in |- *; reflexivity.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; intros H1; elim H1;\n [ assumption | apply lt_irrefl with (pos x);\n apply le_plus_l_l; assumption.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x; simpl in |- *; auto with *.\nintros x y H; elim y; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl in |- *.\nexact I. intro; simpl inQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; simpl in |- *.\nexact I.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nsimple induction x.\nintros.\napply neg_absZ.\napply neg_absZ.\napply abs_absZ.\napply abs_absZ.\napply abs_absZ.\napply abs_absZ.\nQed.",
                    "Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\nProof.\nintros x H; elim H; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zle.v",
                "context": "************)\n(*                                  Zle.v                                   *)\n(****************************************************************************)\nRequire Export Arith.\nRequire Export misc.\nRequire Export groups.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\nRequire Export Zadd.\n\n(**************)\n(* order on Z *)\n(**************)\n\n(************)\nDefinition leZ (x y : Z) :=\n  match x return Prop with\n  | OZ =>\n      match y return Prop with\n      | OZ => True\n      | pos n => True\n      | neg n => False\n      end\n  | pos n =>\n      match y return Prop with\n      | OZ => False\n      | pos m => n <= m\n      | neg m => False\n      end\n  | neg n =>\n      match y return Prop with\n      | OZ => True\n      | pos m => True\n      | neg m => m <= n\n      end\n  end.\n\n(**************)\nLemma sign_absZ : forall x : Z, leZ OZ (absZ x).\n\nProof.\nintros; elim x; simpl in |- *. exact I. intro; simpl in |- *. exact I. intro; simpl in |- *. exact I.\nQed.\n\n(********************)\nLemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.\n\nProof.\nintros x; elim x. \nunfold absZ in |- *; reflexivity. unfold absZ in |- *; reflexivity. intros; elim H.\nQed.\n\n(************************)\nTheorem leZ_antisymmetric : antisym Z leZ.\n\nProof.\nunfold antisym in |- *; intros x y; elim x.\n(* OZ *)\nelim y.\n(* OZ OZ *)\nreflexivity.\n(* OZ (pos n) *)\nintros; elim H0.\n(* OZ (neg n) *)\nintros; elim H.\n(* (pos n) *)\nintros n; elim y.\n(* (pos n) OZ *)\nintros; elim H.\n(* (pos n) (pos n0) *)\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\n(* (pos n) (neg n0) *)\nintros; elim H.\n(* (neg n) *)\nintros n; elim y.\n(* (neg n) OZ *)\nintros; elim H0.\n(* (neg n) (pos n0) *)\nintros; elim H0.\n(* (neg n) (neg n0) *)\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n\n(************)\nDefinition ltZ (x y : Z) := leZ (succZ x) y.\n\n(****************)\nDefinition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).\n\n(*******************)\nLemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.\n\nProof.\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold leZ in |- *; intros. \nelim (le_Sn_O n H).\nQed.\n\n(*******************)\n",
                "context_tokens": 742,
                "proof_start_offset": 3369,
                "proof_end_offset": 3510,
                "proof": "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nintros; elim n.\nsimpl in |- *; exact I.\nsimpl in |- *; intros; exact I.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple inductionQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* 0 *)\nunfold lt_absZ in |- *; unfold oppZ in |- *; unfold absZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nauto with *.\nintros; elim H.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *;\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimple inductionQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\napply le_O_n.\nQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n.\nintro; elim n0.\nintro; elim n0.\nintro; elim n0.\nintro; elim n0.\nintro; elim n0.\nintro; elim n1.\nintro; elim n1.\nintro; elim n1.\nintro; elim n2.\nintro; elim n3.\nintro; elim n3.\nintro; elim n3.\nintro; elim n3.\nintro; elim n3.\nintro; elim n1.\nintro; elim n3.\nintro; elim n3.\nintro; elim n3.\nintro; elim n3.\nintro; elim n3.\nintro; elim n1Qed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\napply lt_O_n.\n(* pos n *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold gt in |- *;\n unfold IZ in |- *; intros.\nelim (le_Sn_O n H).\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold ltZ in |- *; unfold ltZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfoldQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\nauto with arith.\nintros; elim H.\n(* (pos n) *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *;\n unfold ltZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; \n unfold gtZ in |- *; unfold gtZ in |- *; \n unfold gtZ in |- *;\n unfold gtZ in |- *; unfold gtZ in |- *; \n unfold gtZ in |- *; unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtZ in |- *; \n unfold gtQed.",
                    "Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).\nProof.\nsimple induction n.\n(* neg n *)\nunfold lt_absZ in |- *; unfold absZ in |- *; unfold ltZ in |- *;\n unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *;\n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |- *; \n unfold oppZ in |- *; unfold oppZ in |-Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\n",
                "context_tokens": 421,
                "proof_start_offset": 2055,
                "proof_end_offset": 2129,
                "proof": "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nunfold rplus, addpos; simpl; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros.\n  unfold addZ in |- *.\n  apply (exp_pos x2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos x2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y1).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n  intros.\n  unfold IZ in |- *.\n  apply (exp_pos y2).\n Qed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nunfold IZ, addpos.\nintros.\ndo 2 rewrite (addneg_eq1 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq1 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addneg_eq2 y).\ndo 2 rewrite (addQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; unfold nodoubles, addpos; rewrite (exp_comm y x); reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nunfold paire, addneg; simpl; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nsimple induction y.\nintros.\napply (pos_subpos (S n1) (S n1)); auto with arith.\napply neg_subpos.\nassumption.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold ZDivides.\n  destruct y.\n  reflexivity.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  intros; unfold addZ; destruct y; simpl; auto.\nQed.",
                    "Lemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\n  unfold imagef, addpos; intros; elim (compare_spec y x); reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 451,
                "proof_start_offset": 2131,
                "proof_end_offset": 2216,
                "proof": "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 486,
                "proof_start_offset": 2218,
                "proof_end_offset": 2338,
                "proof": "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq3 : forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 539,
                "proof_start_offset": 2340,
                "proof_end_offset": 2425,
                "proof": "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "***************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\n",
                "context_tokens": 555,
                "proof_start_offset": 2427,
                "proof_end_offset": 2547,
                "proof": "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.",
                    "Lemma addZ_eq5 : forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "      *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\n",
                "context_tokens": 601,
                "proof_start_offset": 2569,
                "proof_end_offset": 2886,
                "proof": "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\ntrivial.\nsimple destruct n.\nsimpl in |- *; symmetry in |- *; exact (succ_predZ y).\nintros; symmetry in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\nProof.\nauto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "    Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Zadd.v                                  *)\n(****************************************************************************)\n\nRequire Export Arith.\nRequire Export Nat_complements.\nRequire Export Lci.\nRequire Export groups.\nRequire Export rings.\nRequire Export Zbase.\nRequire Export Z_succ_pred.\n\n(* Addition on Z, (Z, +) is a group *)\n\n(*Recursive Definition addZ : Z -> Z -> Z := \n       OZ        y => y\n|   (pos O)      y => (succZ y)\n|   (pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\n",
                "context_tokens": 691,
                "proof_start_offset": 2906,
                "proof_end_offset": 3161,
                "proof": "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nsimple induction x.\nsimple induction x.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arith.\nsimple induction x; simpl in |- *; auto with arithQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nsimple destruct x.\nsimple destruct y.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\n simple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nsimple destruct z.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ y).\n(* neg n *)\nintros; symmetry  in |- *; rewrite Qgt_eq5.\napply succ_addZ_l.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nsimple induction x.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y; auto with arith.\nsimple induction y;Qed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nauto with arith.\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg 0 *)\nsimpl in |- *; symmetry  in |- *; exact (succ_succZ y).\nQed.",
                    "Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\nProof.\nintros; elim x.\n(* IZ *)\nreflexivity.\n(* pos n *)\nsimpl in |- *; reflexivity.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n(* neg n *)\nsimple destruct n.\nsimple destruct n.\n(* pos n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\nsimple destruct n.\n(* abs n *)\nsimple destruct n.\nsimple destructQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "pos (S n1)) y => (succZ (addZ (pos n1) y))\n|   (neg O)      y => (predZ y)\n|   (neg (S n1)) y => (predZ (addZ (neg n1) y)).*)\n\n\n(* this definition introduces unnecessary names *)\n\n\nFixpoint addpos (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => succZ x2\n  | S n0 => succZ (addpos x2 n0)\n  end.\n\nFixpoint addneg (x2 : Z) (n : nat) {struct n} : Z :=\n  match n with\n  | O => predZ x2\n  | S n0 => predZ (addneg x2 n0)\n  end.\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\n",
                "context_tokens": 740,
                "proof_start_offset": 3463,
                "proof_end_offset": 3939,
                "proof": "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\nsimple induction n.\nsimpl in |- *; symmetry in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry in |- *; apply succ_pred_pred_succZ.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof NG_eq_3.\n\n(**********************)\nintros; elim x.\n(* IZ *)\nreflexivity.\n(* neg n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite succ_predZ; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Qcabs_eq4.\n\nLemma tech_add_neg_succZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof addZ_eq4.\n\nLemma tech_add_pos_succZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof addZ_eq4.\n\nLemma tech_add_pos_succZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof rplus_eq4.\n\nLemma tech_add_pos_predZ : forall x y : Z, OZ (neg (S x)) y = succZ (addZ x y).\nProofconcurrent_add_pos_predZ.\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof XY_eq_0.\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof sketch_eq_0.\nLemma tech_Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof(*****************************************)\nintros; elim x.\n(* fvar *)\nreflexivity.\n(* abs n *)\nsimple destruct n.\nsimpl in |- *; symmetry  in |- *; exact (succ_addZ_l x y).\nintros; rewrite succ_addZ_l; trivial.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof addZ_eq3.\n\n(*******************************************************)\n\nLemma succ_addZ_r : forall x y : Z, addZ (pos x) y = succZ (addZ x y).\nProof Monomorphic_eq3.\n\nLemma succ_addZ_r : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof Monomorphic_eq3.\n\n(**************)\n(*           Properties of equality         *)\n(**********************************************)\n\nLemma tech_add_pos_predZ : forall x y : Z, squareZ x y = succZ (addZ x y).\nProof Group.\n\n(**************)\n\nLemma tech_opp_pos_succZ : forall x : Z, squareZ x = expZ (addZ x y).\nProof Group.\n\nLemma tech_opp_pos_succZ : forall x : Z, squareZ (pos x) = expZ (addZ x (neg x)).\nProof Group.\n\nLemma tech_opp_pos_predZ : forall x : Z, squareZ x = expZ (addZ x (neg x)).\nProof Group.\n\nLemma tech_opp_neg_predZ : forall x : Z, squareZ xQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof addZ_eq4.\n\n(**************)\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ (pos (S x)) y = succZ (addZ x y).\nProof rminus_eq4.\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof Sop_eq4.\n\nLemma tech_add_neg_succZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof XY_eq4.\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ x y = succZ (addZ x y).\nProof rGf_eq4.\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ (neg (S x)) y = succZ (addZ x y).\nProof Cartesian_eq4.\n\nLemma tech_add_neg_predZ : forall x y : Z, addZ (pos (S x)) y = succZ (addZ x y).\nProof Cartesian_eq4.\nLemma tech_opp_neg_succZ :Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof paire_eq4.\n\n(**************)\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof XY_eq_5.\n\n(* neg (succ x) *)\nunfold opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, opp, oppQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof(****************************)\nintros; elim x.\n(* rvarlift1 *)\nreflexivity.\n(* Omega1 *)\nreflexivity.\n(* negative *)\nintros.\napply succ_addZ_r with (Z2 := Z2); assumption.\nQed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof Monomorphic_eq5.\n\n(**************)\n(**************)\n\nLemma tech_add_pos_succZ : forall x y : Z, squareZ (pos x) y = succZ (addZ x y).\nProofIrrel_eq3.\n\nLemma tech_add_pos_predZ : forall x y : Z, squareZ (pos x) y = expZ (addZ x y).\nProofIrrel_eq3.\n\nLemma tech_add_pos_predZ : forall x y : Z, squareZ (pos x) y = expZ (addZ x y).\nProofIrrel_eq3.\n\nLemma tech_opp_pos_succZ : forall x y : Z, squareZ (pos x) y = expZ (addZ x y).\nProofIrrel_eq3.\n\nLemma tech_opp_pos_predZ : forall x : Z, squareZ (pos x) y = expZ (addZ x y).\nProofIrrel_eq3.\n\nLemma tech_opp_pos_predZ : forall x y : Z, squareZ (pos x) y = expZ (addZ x y).\nProofIrrel_eq3.\n\nLemma tech_opp_pos_Qed.",
                    "Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\nProof                                                                  _eq3.\n\n(**************)\nLemma tech_add_neg_predZ :\n forall (x y : Z) (z : Z),\nmapsto (pos (S x)) (pos (S y)) z = succZ (addZ x y) z.\nProofIrrel\n\n(**************)\n\nLemma tech_add_neg_predZ :\n forall (x y z : Z) (z : Z),\nmapsto (pos (S x)) (pos (S y)) z = succZ (addZ x z) z.\nProof.\n(******************************************************)\n\nLemma tech_add_neg_succZ :\n forall (x : nat) (z : Z),\nmapsto (pos (S x)) (pos (S y)) z = succZ (addZ x z) z.\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite succ_addZ_l; rewrite pred_succZ; trivial.\nintros; rewrite succ_addZ_l; rewrite pred_addZ_l; rewrite succ_succZ; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\n\nDefinition addZ (x1 x2 : Z) :=\n  match x1 with\n  | OZ => x2\n  | pos n => addpos x2 n\n  | neg n => addneg x2 n\n  end.\n\n\nLemma addZ_eq1 : forall y : Z, addZ OZ y = y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq3 :\n forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\n",
                "context_tokens": 741,
                "proof_start_offset": 3959,
                "proof_end_offset": 4411,
                "proof": "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\nreflexivity.\nsimple induction n.\nsimpl in |- *; apply succ_pred_pred_succZ.\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\nsimple induction n.\nreflexivity.\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof.\nintros; elim x.\n(* neg n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nreflexivity.\n(* neg n *)\nsimple induction n.\n(* pos n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* neg n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nsimple induction n.\n(* abs n *)\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof sZP_eq3.\n\n(**************)\n\nLemma tech_add_pos_predZ : forall x y : Z, IZ (pos (S x)) y = x.\nProofIrrel (pos_addZ x y).\n\nLemma tech_add_pos_predZ : forall x y : Z, neg (pos (S x)) y = neg (addZ x y).\nProofIrrel (neg_addZ x y).\n\nLemma tech_add_pos_succZ : forall x y : Z, square (pos (S x)) y = neg (addZ x y).\nProofIrrel (neg_addZ x y).\n\nLemma tech_add_pos_succZ : forall x y : Z, square (neg (S x)) y = neg (addZ x y).\nProofIrrel (neg_addZ x y).\n\nLemma tech_add_pos_succZ : forall x y : Z, square (pos (S x)) y = neg (addZ x y).\nProofIrrel (neg_addZ x y).\n\nLemma tech_add_pos_predZ : forall x y : Z, square (pos (S x)) y = neg (addZ x y).\nProofIrrel (neg_addZQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof rplus_eq_5.\n\n(**************)\n\nLemma pred_addZ_r : forall x y : Z, addZ x y = predZ (addZ x y).\nProof asFunc_eq_5.\n\n(**************)\n\n(**************)\n\nLemma pred_addZ_r : forall x y : Z, Hload x y = predZ (addZ x y).\nProof.\nunfold Hload, Hload, neg, eq_op in |- *.\nintros; elim x.\n(*cond 0 *)\nintros.\nrewrite (tech_add_neg_predZ n0).\nrewrite H; reflexivity.\n(*cond 0 *)\nsimple induction n.\n(* neg 0 *)\nintros.\nrewrite (tech_add_neg_predZ n0).\nrewrite H; reflexivity.\n(*cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* cond 0 *)\nsimple induction n.\n(* env 0 *)\nsimple induction n.\n(* env 0 *)\nsimple induction n.\n(* env 0 *)\nsimple induction n.\n(* env 0 *)\nsimple induction n.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof addZ_eq4.\n\n(**************)\n(* Properties of equality and equality *)\n(************)\n\nLemma eq_Z_eq_Z : forall x y : Z, ~ ptr x y = y.\nProof.\nunfold eq_Z in |- *.\nintros; elim H; reflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof addZ_eq_5.\n\n(**************)\nLemma pred_addZ_l : forall x y : Z, addZ x y = predZ (addZ x y).\nProof rminus_eq_6.\n\n(**************)\n(*  x = y -> x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* y = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction y.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction y.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction y.\n(* x = y *)\nsimple induction y.\n(* x = y *)\nsimple induction x.\n(* x = y *)\nsimple induction x.\n(* x = yQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof HCs_eq_4.\n\n(**************)\n\nLemma pred_addZ_r : forall x y : Z, addZ (pos x) y = succZ (addZ x y).\nProof Sk.\nunfold succ, oppZ in |- *; intros; symmetry  in |- *; apply succ_pred_succZ.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof UnionPlus_eq_4.\n\n(************)\n(*  nR relation  *)\n(**************)\n\nLemma pred_addZ_r : forall x : Z, expZ x (pos x) = expZ (addZ x y).\nProof.\nsimple induction x; simpl in |- *; auto with arith.\nintros; rewrite exp_pos_predZ.\nelim H; reflexivity.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof nodoubles_eq_6.\n\n(************)\n(*alg relation *)\n(**************)\n\nLemma le_pred_plus_r : forall x y : Z, x + y = S (addZ x y).\nProof.\nsimple induction x.\n(* var 0 *)\nreflexivity.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nreflexivity.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)\nsimple induction x.\n(* var 0 *)Qed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof juicyRestrict_add_neg_predZ.\n\n(**************)\n(*  Quelquessed *)\n(**************)\n\nLemma eq_Z_eq_Z : forall x y : Z, x = y -> x = y.\nProof.\nunfold eq_Z, eq_Z, eq_Z, eq_Z, eq_Z, eq_Z, eq_Z_dec.\nintros x y.\napply eq_Z_eq_Z.\nQed.",
                    "Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\nProof eqlong_eq3.\n\n(***************)\n(* Properties of operations *)\n(***********************************************)\n\nLemma pred_addZ_r : forall x y : Z, addZ x y = predZ (addZ x y).\nProof.\nsimple induction x.\nreflexivity.\nintros; rewrite H; reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": "\nQed.\n\nLemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.\nProof.\nauto with arith.\nQed.\n\nLemma addZ_eq5 :\n forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).\nProof.\nauto with arith.\nQed.\n\n\n\n(***************)\nLemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\n",
                "context_tokens": 751,
                "proof_start_offset": 4427,
                "proof_end_offset": 4728,
                "proof": "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nreflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimpleQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction xQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg 0 *)\nsimple induction n.\n(* (neg S y0) *)\nsimple induction n.\n(* 0 *)\nreflexivity.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction m.\n(* 0 *)\nsimple induction m.Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x.\nsimple induction x0.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x0.\nsimple induction x1.\nsimple induction x1.\nsimple induction x1.\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nsimple induction x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *; reflexivity.\n(* neg x *)\nsimple induction n.\nsimpl in |- *; reflexivity.\n(* abs (S x) *)\nsimple induction n.\n(* abs (S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nsimple induction n.\n(* (neg S x) *)\nQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* false *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\n(* neg 0 *)\nreflexivity.\n(* pos 0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\n(* abs n *)\nsimple induction n.\n(* (pos O) *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* (pos O) *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* (pos 0) *)\nsimple induction n.\n(* (pos O) *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* (pos O) *)\nsimple induction n.\n(* (pos O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction n.\n(* (neg O) *)\nsimple induction m.\n(* (neg O) *)\nsimple induction m.\n(* (neg O) *)\nsimple inductionQed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nintros; elim x.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)\nsimple induction n.\n(* pos 0 *)Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nintros; elim x.\n(* neg 0 *)\nsimple induction n.\n(* pos 0 *)\nreflexivity.\n(* pos 0 *)\nsimple induction n.\n(* abs 0 *)\nintros.\nrewrite (tech_add_neg_succZ n0).\nelim H; reflexivity.\n(* pos 0 *)\nsimple induction n.\n(* neg 0 *)\nsimple induction n.\n(* (pos 0) *)\nsimple induction n.\n(* (pos 0) *)\nsimple induction n.\n(* (pos 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (pos 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)\nsimple induction n.\n(* (neg 0) *)Qed.",
                    "Lemma add_OZ : forall x : Z, addZ x OZ = x.\nProof.\nsimple induction x.\n(* neg 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 0 *)\nsimple induction n.\n(* 1 *)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/chinese/Zadd.v",
                "context": " forall x y : Z, addZ (succZ x) y = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\ntrivial.\n(* neg n *)\nsimple destruct n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; exact (succ_predZ y). \n(* neg (S n0) *)\nintros; symmetry  in |- *; rewrite addZ_eq5.\napply succ_predZ.\nQed.\n\n(***************)\nLemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple destruct n.\nsimpl in |- *; rewrite pred_succZ; trivial.\nintros; rewrite addZ_eq3; rewrite pred_succZ; trivial.\ntrivial.\nQed.\n\n(**********************)\nLemma tech_add_pos_succZ :\n forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).\nProof addZ_eq3.\n\n(**********************)\nLemma tech_add_neg_predZ :\n forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).\nProof addZ_eq5.\n\n(***************)\nLemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\n(* pos O *)\nreflexivity.\n(* pos y0 *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nelim H; reflexivity.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nsimpl in |- *; symmetry  in |- *; apply succ_pred_pred_succZ.\n(* neg y0 *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nrewrite H.\nsymmetry  in |- *; apply succ_pred_pred_succZ.\nQed.\n\n(***************)\nLemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).\n\nintros; elim x.\n(* OZ *)\nreflexivity.\n(* (pos n) *)\nsimple induction n.\n(* (pos O) *)\nsimpl in |- *; apply succ_pred_pred_succZ.\n(* (pos (S y0)) *)\nintros.\ndo 2 rewrite (tech_add_pos_succZ n0).\nrewrite H; apply succ_pred_pred_succZ.\n(* neg n *)\nsimple induction n.\n(* neg O *)\nreflexivity.\n(* neg (S y0) *)\nintros.\ndo 2 rewrite (tech_add_neg_predZ n0).\nelim H; reflexivity.\nQed.\n\n(***********)\nLemma add_OZ : forall x : Z, addZ x OZ = x.\n\nsimple induction x.\n(* OZ *)\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\nQed.\n\n(*****************)\n",
                "context_tokens": 747,
                "proof_start_offset": 4750,
                "proof_end_offset": 4930,
                "proof": "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nProof.\nintros.\ncut (succZ OZ = IZ); intros.\nelim H.\nrewrite (succ_addZ_r x OZ); rewrite (add_OZ x); reflexivity.\nreflexivity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nsimpl in |- *; reflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_addQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* (pos n) *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* (pos n) *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* (pos n) *)simple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* (pos n) *)simple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_predZ; rewrite H; reflexivity.\n(* (pos n) *)simple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* (pos n) *)simple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* (pos n) *)simple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivityQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* Rewrite (tech_add_pos_succZ 0). *)\nsimple induction x.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\n(* 0 *)\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\n(* IZ *)\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nreflexivity.\n(* neg 0 *)\nsimple induction n.\nassumption.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.\nreflexivity.\n(* pos 0 *)\nsimple induction n.Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_pos_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ;Qed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple inductionQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nassumption.\n(* abs n *)\nsimple induction n.\nreflexivity.\n(* abs n *)\nsimple induction n.\nassumption.\n(* abs n *)\nsimple induction n.\nreflexivity.\nQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* posQed.",
                    "Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.\nsimple induction x.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_succZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\n(* neg n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* pos n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ; rewrite H; reflexivity.\n(* abs n *)\nsimple induction n.\nreflexivity.\nintros; rewrite tech_add_neg_predZ;Qed."
                ]
            }
        ],
        "UnifySL": [
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "port Logic.MinimunLogic.ProofTheory.Minimun.\nRequire Import Logic.MinimunLogic.ProofTheory.RewriteClass.\nRequire Import Logic.PropositionalLogic.ProofTheory.Intuitionistic.\nRequire Import Logic.PropositionalLogic.ProofTheory.DeMorgan.\nRequire Import Logic.PropositionalLogic.ProofTheory.GodelDummett.\nRequire Import Logic.PropositionalLogic.ProofTheory.Classical.\nRequire Import Logic.PropositionalLogic.ProofTheory.RewriteClass.\nRequire Import Logic.SeparationLogic.ProofTheory.SeparationLogic.\nRequire Import Logic.SeparationLogic.ProofTheory.DerivedRules.\nRequire Import Logic.SeparationLogic.ProofTheory.RewriteClass.\nRequire Import Logic.Extensions.ProofTheory.Stable.\n\nLocal Open Scope logic_base.\nLocal Open Scope syntax.\nImport PropositionalLanguageNotation.\nImport SeparationLogicNotation.\n\nClass Corable (L: Language) {minL: MinimunLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\n",
                "context_tokens": 639,
                "proof_start_offset": 2647,
                "proof_end_offset": 2756,
                "proof": "Lemma corable_truep: corable TT.\nProof.\napply (@truep_stable L _ _ Gamma corable corable_pstable); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_truep: corable TT.\nProof. apply (@falsep_stable Z _ _ _ TT corable_p_stable); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable_pstable); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@andp_sym mpred _ _ mpred _ mpred _ mpred _ mpred _ mpred _ _ mpred _ mpred _ _ _ _ _ mpred _ _ mpred _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply @corable_andp_sepcon_TT. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@corable_andp_sepcon_sepcon_sepcon_sepcon_andp). Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable_pstable); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply @corable_eq_e. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply @corable_sepcon_TT_TT_left. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply (@falsep_stable L _ _ Gamma corable_pglobals); auto. Qed.",
                    "Lemma corable_truep: corable TT.\nProof. apply @corable_eq_e. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "unLanguage L} {pL: PropositionalLanguage L} {sL: SeparationLanguage L} (Gamma: ProofTheory L) {minAX: MinimunAxiomatization L Gamma} {ipGamma: IntuitionisticPropositionalLogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\n",
                "context_tokens": 676,
                "proof_start_offset": 3431,
                "proof_end_offset": 3600,
                "proof": "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\nintros.\nrewrite andp_comm.\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 L _ _ _ _ _ i j). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_stable_andp_sepcon1 L _ _ _ Gamma corable_pidentity); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_trans (x * y) (x * z) (x * z) (x * z) (x * z)). Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_sepcon_andp_sepcon1 L _ _ _ TT corable_p' (x * y)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_andp_sepcon1 _ _ _ Gamma corable_plinear); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@sepcon_comm (x * z)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_comm (x * z)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_sepcon_sepcon2 L _ _ _ G corable_pnormalize); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@andp_comm (x * y)); auto. Qed.",
                    "Lemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof. intros. apply (@corable_sepcon_sepcon1 _ _ _ _ Gamma corable_p safety); auto. Qed."
                ]
            },
            {
                "filepath": "./coq_projects/UnifySL/Extensions/ProofTheory/Corable.v",
                "context": "ogic L Gamma} {sGamma: SeparationLogic L Gamma} := {\n  corable: expr -> Prop;\n  corable_pstable: PropositionalStable L Gamma corable;\n  corable_sstable: SeparationStable L Gamma corable;\n  corable_sabs: SeparationAbsorbStable L Gamma corable\n}.\n\nSection Corable.\n\nContext {L: Language}\n        {minL: MinimunLanguage L}\n        {pL: PropositionalLanguage L}\n        {sL: SeparationLanguage L}\n        {Gamma: ProofTheory L}\n        {minAX: MinimunAxiomatization L Gamma}\n        {ipGamma: IntuitionisticPropositionalLogic L Gamma}\n        {sGamma: SeparationLogic L Gamma}\n        {CosGamma: Corable L Gamma}.\n\nLemma corable_andp: forall x y, corable x -> corable y -> corable (x && y).\nProof. intros. apply (@andp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_orp: forall x y, corable x -> corable y -> corable (x || y).\nProof. intros. apply (@orp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_impp: forall x y, corable x -> corable y -> corable (x --> y).\nProof. intros. apply (@impp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_iffp: forall x y, corable x -> corable y -> corable (x <--> y).\nProof. intros. apply (@iffp_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_falsep: corable FF.\nProof. apply (@falsep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_truep: corable TT.\nProof. apply (@truep_stable L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_sepcon: forall x y, corable x -> corable y -> corable (x * y).\nProof. intros. apply (@sepcon_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nLemma corable_wand: forall x y, corable x -> corable y -> corable (x -* y).\nProof. intros. apply (@wand_stable L _ _ Gamma corable corable_sstable); auto. Qed.\n\nInstance corable_proper_iff: Proper ((fun x y => |-- x <--> y) ==> iff) corable.\nProof. apply (@stable_proper_iffp L _ _ Gamma corable corable_pstable); auto. Qed.\n\nLemma corable_andp_sepcon1: forall x y z, corable x -> |-- (x && y) * z <--> x && (y * z).\nProof. intros. apply (@stable_andp_sepcon1 L _ _ _ Gamma corable corable_sabs); auto. Qed.\n\nLemma corable_andp_sepcon2: forall x y z, corable y -> |-- (x && y) * z <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.\n\n",
                "context_tokens": 690,
                "proof_start_offset": 3602,
                "proof_end_offset": 3802,
                "proof": "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\nintros.\nrewrite sepcon_comm.\nrewrite (sepcon_comm x z).\napply corable_andp_sepcon1; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@sepcon_wand_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepcon_sepconQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  apply (corable_andp_sepcon_andp_sepcon1 _ _ (x * z)).\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply (@derives_trans _ _ _ (y * z)). Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. rewrite sepcon_comm. apply corable_sepcon_sepcon1; auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof. intros. apply @corable_andp_sepcon1; auto. Qed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite andp_comm.\n  apply corable_andp_sepcon1; auto.\nQed.",
                    "Lemma corable_sepcon_andp1: forall x y z, corable y -> |-- x * (y && z) <--> y && (x * z).\nProof.\n  intros.\n  rewrite sepcon_comm.\n  apply corable_andp_sepcon1; auto.\nQed."
                ]
            }
        ],
        "hoare-tut": [
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Env -> Env :=\n fun x => \n   match x in (ExVar A) return A -> Env -> Env with\n   | VX => fun vx e => (vx,snd e)\n   | VY => fun vy e => (fst e,vy)\n   end.\n\nDefinition get (A:Type): (ExVar A) -> Env -> A :=\n fun x => \n   match x in (ExVar A) return Env -> A with\n   | VX => fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\n",
                "context_tokens": 737,
                "proof_start_offset": 3350,
                "proof_end_offset": 3559,
                "proof": "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H; case H; constructor; intuition (auto with zarith).\nreplace b with (b-a+a)%Z.\nauto with zarith.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d.\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).\ndestruct (Z.gcd_div_eucl b d).Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nunfold Zis_gcd, Z.gcd.\nintros a b d H0.\ncase (Z.gcd_eucl (Zpos d) (Zpos d)) as [H|H].\neasy.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  destruct (Z.gtb_spec a b) as [H|H].\n  + now apply Z.divide_1_r.\n  + now apply Z.divide_1_r.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\ndestruct (gcd_eucl b d) as [H|H].\nsubst.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\nsimpl.\nrewrite H.\ntrivialQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H.\n  replace (d - b - d - (d - a)) with (d - a) by omega.\n  apply (IH _ (a - b)); trivial.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros a b d H.\ndestruct (H 0) as (c,H0).\nrewrite H1.\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (H (b - d)).\nrewrite (Qed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\ndestruct (Z_le_gt_cases a b).\ndestruct (Z.le_gt_cases b a).\ndestruct (Z.le_gt_cases b a).\nrewrite (Z.gcd_comm b d). rewrite Z.mul_assoc.\nrewrite (Z.gcd_comm b d). rewrite Z.mul_assoc.\nrewrite (Z.gcd_comm d (Z.gcd b d)). rewrite Z.mul_assoc.\nrewrite (Z.gcd_comm d (Z.gcd b d)). rewrite Z.mul_assoc.\nrewrite (Z.gcd_comm d (Z.gcd d d)). rewrite Z.mul_assoc.\nrewrite (Z.gcd_comm d (Z.gcd d d)). rewrite Z.mul_comm.\nrewrite (Z.gcd_comm d (Z.gcd d d)). rewrite Z.mul_assoc.\nrewrite (Z.gcd_comm d (Z.gcd d d)). rewrite Z.mul_comm.\nrewrite (Z.gcd_comm d (Z.gcd d d)). rewrite Z.mul_comm.\nrewrite (Z.gcd_comm d (Z.gcd dQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n intros a b d H H0.\n destruct (H0 a).\n apply Zgcd_gcd.\n apply H0.\nQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\nintros.\nassert (H: forall a b, a + b <= d -> b + d < d -> a + d < d).\nclear H.\ndestruct H0.\nunfold Z.pos in H.\nomega.\nassert (H1: forall b, d + d <= d -> b + d < d).\nclear H.\ndestruct H0.\nunfold Z.pos in H.\nomega.\nassert (H2: forall b, d + d <= d -> b + d < d).\nclear H.\ndestruct H2.\nunfold Z.pos in H.\nomega.\nassert (H3: forall b, d + d <= d -> b + d > d).\nclear H.\ndestruct H3.\nunfold Z.pos in H.\nomega.\nassert (H4: forall b, d + d <= d -> b + d > d).\n clear H4.\ndestruct H4.\nunfold Z.pos in H.\nomega.\nassert (H5: forall b, d + d >= d -> b + d >= d).\nclear H4.\ndestruct H4.\nunfold Z.pos in HQed.",
                    "Lemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros.\n  unfold Zis_gcd.\n  split.\n  + intros.\n    apply H.\n    intros.\n    apply (H (b - a) (b - b) (b - d) H0 H1).\n    intros.\n    apply (H (b - b) (b - d) H1 H0).\n  + intros.\n    apply (H (b - d) (b - d) H1 H0).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " fun e => fst e\n   | VY => fun e => snd e\n   end.\n\n(** I consider only two binary operators [PLUS] and [MINUS]. Their\nmeaning is given by [eval_binOP] below *)\nInductive binOP: Type := PLUS | MINUS.\n \nDefinition eval_binOP: binOP -> Z -> Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\n",
                "context_tokens": 742,
                "proof_start_offset": 3674,
                "proof_end_offset": 3889,
                "proof": "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\nintros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool.\ncase (x ?= y)%Z; auto; try (intros; discriminate); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros. destruct (Z_eq_dec x y).\n  - subst; apply Z.ge_le_trans with x; auto with zarith.\n    apply Z.ge_le_trans with y; auto with zarith.\n  - apply Z.ge_le_trans with x; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z_eq_bool x y); auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H; case (Z_eq_bool x y); intro.\n  - apply Z.ge_le; auto with zarith.\n    apply Z.ge_le; auto with zarith.\n  - apply Z.ge_le; auto with zarith.\n    apply Z.ge_le; auto with zarith.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros; rewrite Zneq_bool_true; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_true in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_true in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_bool_false in H.\n  apply Zneq_Qed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros. destruct (Z_lt_eq_dec x y) as [H|H].\n  - apply Zneq_bool_true.\n  - apply Zneq_bool_false.\n  - apply Zneq_bool_false.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H.\n  case (Z_lt_bool x y); intro.\n  rewrite (Z.ltb_antisym x y H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltb_antisym y x H).\n  rewrite (Z.ltbQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros x y H1; case (Z_le_dec x y); auto.\n  intros; apply Zneq_bool_true; auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros. apply Zneq_bool_true. auto.\nQed.",
                    "Lemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n  intros.\n  assert (x=y) by auto.\n  assert (y=x) by auto.\n  assert (y=y) by auto.\n  assert (y=y) by auto.\n  assert (y=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z<>z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z<>z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.\n  assert (z=z) by auto.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/exgcd.v",
                "context": " Z -> Z :=\n fun op => match op with\n  | PLUS => Zplus\n  | MINUS => Zminus\n end.\n\n(** I consider only three comparison operators [EQ], [NEQ] and\n[LE]. Their meaning is given by [eval_relOP] below *)\nInductive relOP: Type := EQ | NEQ | LE.\n\nDefinition eval_relOP: relOP -> Z -> Z -> bool :=\n fun op => match op with\n  | EQ => Zeq_bool\n  | NEQ => Zneq_bool\n  | LE => Zle_bool\n end. \n\n(** Here is the abstract syntax of expressions. The semantics is given\nby [eval] below *)\nInductive ExExpr: Type -> Type :=\n | const: forall (A:Type), A -> (ExExpr A)\n | binop: binOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr Z)\n | relop: relOP -> (ExExpr Z) -> (ExExpr Z) -> (ExExpr bool)\n | getvar: forall (A:Type), (ExVar A) -> (ExExpr A). \n\nDefinition Expr:= ExExpr.\n\nFixpoint eval (A:Type) (expr:Expr A) (e:Env) { struct expr } : A :=\n match expr in ExExpr A return A with\n | const A v => v\n | binop op e1 e2 => eval_binOP op (eval e1 e) (eval e2 e)\n | relop op e1 e2 => eval_relOP op (eval e1 e) (eval e2 e)\n | getvar A x => (get x e)\nend.\n\nEnd Example.\n\n(** * Instantiation of the Hoare logic on this langage. *)\nModule HL :=  HoareLogic(Example).\nImport HL.\nImport Example.\n\n(** These coercions makes the abstract syntax more user-friendly *)\nCoercion getvar: ExVar >-> ExExpr.\nCoercion binop: binOP >-> Funclass.\nCoercion relop: relOP >-> Funclass.\n\n(** A last coercion useful for assertions *)\nCoercion get: ExVar >-> Funclass.\n\n(** ** A [gcd] computation in this language *)\nDefinition gcd := \n  (Iwhile (NEQ VX VY)\n          (Iif (LE VX VY)\n               (Iset VY (MINUS VY VX))\n               (Iset VX (MINUS VX VY)))).\n\n(** A small technical lemma on the mathematical notion of gcd (called\n[Zis_gcd]) *)\nLemma Zgcd_minus: forall a b d:Z, Zis_gcd a (b - a) d -> Zis_gcd a b d.\nProof.\n  intros a b d H; case H; constructor; intuition (auto with zarith).\n  replace b with (b-a+a)%Z.\n  auto with zarith.\n  omega.\nQed.\n\nHint Resolve Zgcd_minus: zarith.\n\n(** Two other lemmas relating [Zneq_bool] function with inequality\nrelation *)\nLemma Zneq_bool_false: forall x y, Zneq_bool x y=false -> x=y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 3891,
                "proof_end_offset": 4060,
                "proof": "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\nintros x y; unfold Zneq_bool.\nintros H H0; subst.\nrewrite Zcompare_refl in H.\ndiscriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; case (Z_eq_bool x y); auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto.\nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool; auto; \n try (intros; discriminate); auto. \nQed.",
                    "Lemma Zneq_bool_true: forall x y, Zneq_bool x y=true -> x<>y.\nProof.\n intros x y H0; apply Zcompare_Eq_eq; generalize H0; clear H0; unfold Zneq_bool. case (x?= y)%Z; auto;\n try (intros; discriminate); auto. \nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": " p e1 e0]\"\n    implies that there exists [n] and [ef] such that \"[execn (S n) e0 (Iwhile cond p) ef]\"\n    and \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 11171,
                "proof_end_offset": 11284,
                "proof": "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\nauto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ => True).\n  apply program_induction with (fun _ =>Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros; red; intros.\n  destruct H as [s1 [s2 [A B]]].\n  destruct (H0 s1) as [y [y [A B]].\n  destruct (H0 s2) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H1 s3) as [z [A B]].\n  destruct (H0 s3) as [z [A B]].\n  destruct (H1 s3) as [z [A B]].\n  destruct (H1 s3) as [z [A B]].\n  destruct (H1 s3) as [z [A B]].\n  destruct (H1 s3) as [z [A B]].\n  destruct (H1Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros. destruct (classic (is_pointer p)).\n  destruct H.\n  subst.\n  econstructor; eauto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  unfold program; intros.\n  apply H.\n  intros p'.\n  destruct (is_not_temp p' (p',p')).\n  destruct (is_not_temp p' (p',p')).\n  destruct p'.\n  auto.\n  destruct p'.\n  apply H.\n  apply H.\n  apply H0.\n  apply H.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct H0 as [p [p' [H1 [H2 [H3 H4]]]].\n  exists p'.\n  split.\n  exists p'. auto.\n  split. auto. auto.\n  split. auto.\n  split. auto.\n  split. auto. auto.\n  split. auto.\n  split. auto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  set (C := fun x => C x).\n  cut (forall y, C y -> C y).\n  intros.\n  assert (forall y, C y -> C y).\n  intros.\n  apply H.\n  destruct H1 as [y [??]].\n  apply H0.\n  destruct H2 as [y [??]].\n  eapply H1; eauto.\n  destruct H2 as [y [??]].\n  eapply H1; eauto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct p as [p1 [p2 [p3 [p4 [p5 [p6 [p6 [p7 [p8 [p9 [p10 [p11 [p11 [p12 [p12 [p12 [p12 [p13 [p13 [p13 [p14 [p14 [p14 [p15 [p15 [p14 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p16 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15 [p15Qed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  destruct (is_basic_or_null p).\n  destruct H as [p H].\n  destruct (is_basic_or_null p).\n  destruct H.\n  subst.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  eapply program_step; eauto.\nQed.",
                    "Theorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n  intros.\n  apply program_no_wp.\n  intros.\n  apply program_no_wp.\n  intros.\n  apply program_no_wp.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/hoare-tut/totalhoarelogic.v",
                "context": "nd \"[execn n e1 (Iwhile cond p) ef]\".\n*)\nLemma reduces_wf: forall cond p, well_founded (reduces cond p).\nProof.\n  unfold well_founded.\n  intros cond p e0; apply Acc_intro.\n  intros e1 H; unfold reduces in H.\n  decompose [ex and] H; clear H.\n  clear H2 H0 e0.\n  case (exec_execn H1).  \n  intros n.\n  generalize cond p e1 x; clear cond p e1 x H1.\n  elim n.\n  (* case 0 *)\n  intros cond p e0 e1 H; inversion_clear H.\n  (* recursive case *)\n  clear n; intros n HR cond p e0 e1 H.\n  inversion_clear H.\n  inversion_clear H0.\n  set (b:=E.eval cond e0) in * |-.\n  cut (E.eval cond e0=b); auto.   \n  generalize H; clear H; case b; simpl.\n  (* case cond=true *)\n    intros H; \n    inversion_clear H.\n    intros; \n    apply Acc_intro.\n    intros e2 H3; unfold reduces in H3.\n    intuition.\n    rewrite (exec_deterministic H3 H0); eauto.\n    (* case cond=false *)\n    intros H H0; apply Acc_intro.\n    unfold reduces; rewrite H0.\n    intuition.\n    discriminate.\nQed.\nHint Resolve reduces_wf: hoare.\n\n(** * Completeness\n\n    The proof of completeness proceeds by induction over [prog] syntax.\n\n*)\nLemma wp_complete: forall prog post, prog [= post =] |= (synt_wp prog post).\nProof.\n unfold wp.\n  intros prog post e H; case H; clear H.\n  intros e' H; case H; clear H.\n  generalize post e e'; clear post e e'; elim prog; clear prog; simpl.\n  (* - case [Iskip] *)\n  intros post e e' H; exec_inversion H; auto.\n  (* - case [Iset] *)\n  intros A v expr post e e' H; exec_inversion H; auto.\n  (* - case [Iif] *)\n  intros cond p1 Hp1 p2 Hp2 post e e' H; exec_inversion H.\n  case (E.eval cond e); simpl; firstorder auto || discriminate.\n  (* - case [Iseq] *)\n  intros p1 Hp1 p2 Hp2 post e e' H.\n  exec_inversion H.\n  eauto.\n  (* - case [Iwhile] *)\n  intros cond p Hp post e e' H H0.\n  constructor 1 with (x:=wp (Iwhile cond p) post).\n  constructor 1 with (x:=reduces cond p).\n  unfold wp; (intuition eauto with hoare);\n    dec2 e1 H1;\n    case H1; clear H1; intros H1;\n    exec_inversion H1;\n    intros e2 H1; exec_inversion H1;\n    rewrite H2; intros e3 H1; exec_inversion H1;\n    unfold reduces; eauto with hoare.\nQed.\n\n(** * Combining the previous results with transitivity of [ |= ] *)\n\nHint Resolve wp_complete wp_sound: hoare.\n\nTheorem soundness: forall pre p post, pre |= (synt_wp p post) -> pre |= p [=post=].\nProof.\n auto with hoare.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 11286,
                "proof_end_offset": 11413,
                "proof": "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintuition auto with hoare.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros; apply H.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  destruct H0 as [n H].\n  apply H0.\n  apply H.\n  eapply H; eauto.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_extensionality.\n  apply functional_Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n auto with hoare.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n intros.\n destruct H as [st1 st2].\n generalize st1 as st1'.\nunfold step in H.\nunfold step.\nunfold step.\ndestruct st1' as [st2' st3'].\ngeneralize st2 as st2'.\nunfold step.\ngeneralize st2 as st3'.\nunfold step.\ngeneralize st2 as st4.\nunfold step.\ngeneralize st4 as st4'.\ndestruct st4 as [st4'' st4''].\ngeneralize st4''.\nunfold step.\ngeneralize st4' as st5''.\ngeneralize st4''.\nunfold step.\ngeneralize st4' as st4''.\nunfold step.\ngeneralize st4''.\nintros st4''.\nunfold step.\ngeneralize st4''.\nunfold step.\ngeneralize st4''.\nintros st4'' st4''.\ninversion H; clear H.\nintros e0 e1' H3 H4.\ninversion H4;\n  inversion H5;\n  inversion H5;\n  inversion H5;\n  inversion H5;\n  inversion H5;\n  inversion H5;\n  inversion H6;\n  inversion H6;\n  inversion H6;\n  inversion H6Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\nintros; apply H.\nQed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros; apply program_induction; intros.\n  destruct H as [x [y [y [y [z [??]]]]]]] | [y [z [z [??]]]]]]]].\n  case_eq (E.eval z); simpl; intros; inv H0.\n  destruct (H0 _ _ _ _ _ _ _ _ _ _ _ _ H0 H1 H2 H3 H4 H5).\n  destruct (H1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H3 H4 H5).\n  destruct (H2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H0 H1 H3 H4 H5).\n  destruct (H1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H1 H3 H4 H5).\n  destruct (H1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H1 H2 H4 H5).\n  destruct (H2 _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Theorem completeness: forall pre p post, pre |= p [=post=] -> pre |= (synt_wp p post).\nProof.\n  intros.\n  apply functional_extensionality.\n  intros st st st' H; simpl; tauto.\n  intros st st' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st st' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* case [C] *)\n  intros st'' st'' H; simpl; tauto.\n  (* - case [C] *)\n  intros st'' H; simpl; tautoQed."
                ]
            }
        ],
        "huffman": [
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \n",
                "context_tokens": 322,
                "proof_start_offset": 2063,
                "proof_end_offset": 2308,
                "proof": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros.\nrewrite (plus_comm n m).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_assoc m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nrewrite (plus_assoc m n).\nrewrite (plus_comm m n).\nrewrite (plus_comm m n).\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros.\napply le_n_S.\napply le_S.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m H'.\napply le_minus_O.\napply lt_le_trans with (m - n).\nrewrite <- plus_n_O.\nrewrite <- plus_n_O.\napply le_n_S.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n m H.\n  apply le_n_S.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros n m H0; elim H0; auto with arith.\n  intros m H H1; generalize (le_minus_O m H1); clear H0.\n  intros H2 H3; elim (lt_gt_O m); auto with arith.\n  intros m H1; elim (lt_not_lt m n); auto with arith.\n  intros m H2; elim (lt_not_lt m n); auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m H; elim H; intros.\nrewrite (plus_comm n m H0) in H0.\nrewrite (mult_comm m n H0) in H0.\napply le_trans with (m := m); auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m H1 H2.\napply le_trans with (m := n + m).\napply le_n_O.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\n  intros.\n  apply lt_n_O.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof.\nintros n m; elim m; simpl in |- *; auto with arith.\nQed.",
                    "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nintros n m H'; elim H'; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 414,
                "proof_start_offset": 2311,
                "proof_end_offset": 2459,
                "proof": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case b; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_trans with (m1 := m1); auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case b; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; auto.\nintros n2 Rec m; case m; simpl in |- *; autoQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 Rec m1.\ncase (le_lt_or_lt n m1); intros H1; auto.\napply (H1 (m1 + m1)); auto with arith.\napply (H1 (m1 + m1)); auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case b; simpl in |- *; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto with arith.\nintros m1 Rec m1; case m1; simpl in |- *; auto with arith.\nintros m1 Rec m1; case m1; simpl in |- *; auto with arith.\nintros m2 Rec m1; case m2; simpl in |- *; auto with arith.\nintros m2 Rec m2; case m1; simpl in |- *; auto with arith.\nintros m2 Rec m2; case m2; simpl in |- *; auto with arith.\nintros m1 Rec m2; case m1; simpl in |- *; auto with arith.\nintros m2 Rec m2; case m1; simpl in |- *; auto with arith.\nintros m1 Rec m1; case m2; simpl in |- *; auto with arith.\nintros m2 Rec m2; case m1; simpl in |- *; auto with arith.\nintros m1 Rec m2; case m1; simpl in |- *; auto with arith.\nintros m1 Rec m1; case m1; simpl in |- *; auto with arithQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim b; simpl in |- *; auto.\nintros m1 Rec m; case m1; simpl in |- *; auto with arith.\nQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 RecQed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; elim a; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2Qed.",
                    "Theorem le_minus : forall a b : nat, a - b <= a.\nProof.\nintros a b; case b; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_le_weak; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "e *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 439,
                "proof_start_offset": 2462,
                "proof_end_offset": 3023,
                "proof": "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0; Contradict H0; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H1; case (le_gt_dec c a); auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H; elim H; simpl in |- *; auto.\nintros n1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec1 m2; case m2; simpl in |- *; auto.\nintros m2 Rec2 m2; case m2; simpl in |- *; auto.\nintros m1 Rec1 m2; case m2; simpl in |- *; auto.\nintros m2 Rec2 m2; case m2; simpl in |- *; auto.\nintros m2 Rec2 m2; case m2; simpl in |- *; auto.\nintros m2 Rec1 m2; case m2; simpl in |- *; auto.\nintros m1 Rec1 m2; case m2; simpl in |- *; auto.\nintros m2 Rec1 m2; case m2; simpl in |- *; auto.\nintros m2 Rec1 m1; case m2; simpl in |- *; auto.\nintros m2 Rec2 m2; case m1; simpl in |- *; auto.\nintros m2 Rec1 m2; case m2; simpl in |- *; auto.\nintros m2 Rec1 m2; caseQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H1 H2; case (le_lt_eq_dec n1 n2); intros H3.\nrewrite <- (plus_comm a b); rewrite (plus_comm (a - b)); auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H1; Contradict H1; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H; case b; simpl in |- *; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H1; case b; simpl in |- *; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m2; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m2Qed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H; elim H; auto.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H; elim H; auto with arith.\nQed.",
                    "Theorem minus_minus_simpl4 : forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof.\nintros a b c H H0; elim H0; intros; auto.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m2; simpl in |- *; auto.\nintros m2 Rec m1; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m1; case m2; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m1 Rec m2; case m1; simpl in |- *; auto.\nintros m2 Rec m2; case m2; simpl in |- *; auto.\nintros m1Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                      *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(**********************************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \n",
                "context_tokens": 524,
                "proof_start_offset": 3026,
                "proof_end_offset": 3298,
                "proof": "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; apply plus_minus_simpl4; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl_l with (p := b + c).\nrepeat rewrite plus_comm.\nrewrite <- plus_assoc_reverse.\nrewrite <- (plus_comm c a).\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- (plus_comm a b).\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- (plus_comm a b).\nrewrite plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- (plus_comm c a).\nrewrite plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- (plus_comm a b).\nrewrite <- plus_assoc_reverse.\nrewrite <- (plus_comm a b).\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverse.\nrewrite <- plus_assoc_reverseQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; apply plus_minus_simpl4; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nintros a b c H; elim H; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl4; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl4; auto with arith.\nrewrite plus_comm; rewrite plus_comm; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus_simpl4; auto with arith.\nrewrite plus_comm.\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm b).\nrewrite plus_assoc.\nrewrite plus_comm.\nrewrite (plus_comm a).\nrewrite (plus_comm b).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm a).\nrewrite (plus_comm b).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm a).\nrewrite (plus_comm b).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm b).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm b).\nrewrite (plus_comm b).\nrewrite (plus_comm b).\nrewrite (plus_comm b).\nrewrite (plusQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; elim H0; intros H1 H2; elim H2; intros H3 H4; apply plus_comm; auto with arith.\nQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0; rewrite <- (plus_comm c).\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite <- plus_assoc.\nrewrite (plus_comm c).\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite (plus_comm a b).\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite <- plus_assoc.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite (plus_comm c).\nrewrite plus_comm.\nrewrite (plus_comm a b).\nrewrite <- plus_assoc.\nrewrite (plus_comm c).\nrewrite (plus_comm b).\nrewrite (plus_comm b).\nrewrite (plus_comm c).\nrewrite (plus_comm b).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plus_comm c).\nrewrite (plusQed.",
                    "Theorem plus_minus_simpl4 : forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite plus_comm; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "****************************************************\n    Proof of Huffman algorithm: Aux.v                                \n                                                                     \n    Auxillary functions & Theorems                                   \n                                                                     \n    Definitions:                                                     \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \n",
                "context_tokens": 593,
                "proof_start_offset": 3392,
                "proof_end_offset": 3555,
                "proof": "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case b; case b; case b; simpl in |- *; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case b; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros.\ncase (eq_bool_dec a b); intro.\nleft; auto.\nright; intro H; injection H; auto.\nright; intro H; injection H; auto.\nright; intro H; injection H; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\n  simple induction a; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simple induction b; simple induction b; simple induction b; simple induction b; simple induction b; simple induction b;\n  simpleDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b; case a; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\ngeneralize a; clear a.\ngeneralize a; clear a.\ngeneralize a; clear a.\ngeneralize a; clear a; generalize a.\nelim b; simpl in |- *; auto.\nintros a b c; rewrite <- eq_sym; auto.\nintros a b c; rewrite <- eq_sym; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\ngeneralize (eq_bool_dec a b); case_eq (negb b); intros; auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros; case (decide equality); auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros; case (eq_bool_dec a b); case (eq_bool_dec a b); auto.\nDefined.",
                    "Definition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nProof.\nintros a b.\ncase (eq_bool_dec a b).\nintros H1.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_dec.\nrewrite H1.\napply eq_bool_Defined."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "                \n      le_bool, map2, first_n, skip_n find_min find_max               \n                                                                     \n    Theorems: minus, map, app                                        \n                                                                     \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nRequire Export List.\nRequire Export Arith.\nFrom Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 3769,
                "proof_end_offset": 4044,
                "proof": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros n1 Rec n1 Rec n2.\nelim n1; simpl in |- *; auto.\nintros n2 Rec n1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros n1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n1; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintros m1 Rec n2.\nelim n2; simpl in |- *; auto.\nintrosQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b H; case a; case b; simpl in |- *; auto.\nintros b1 b2 H H0; case b1; case b2; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 b1; case b1; simpl in |- *; auto.\nintros a2 b2; case b1; simpl in |- *; auto.\nintros a3 b3; case b1; simpl in |- *; auto.\nintros a4 b4; case b1; simpl in |- *; auto.\nintros a5 b6; case b1; simpl in |- *; auto.\nintros a6; case b1; simpl in |- *; auto.\nintros a6; case b1; simpl in |- *; auto.\nintros a6; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nintros a7; case b1; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nsimple destruct a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nintros a1 b; case b; simpl in |- *; auto.\nintros a2 b; case a1; simpl in |- *; auto.\nintros a3 b; case b; simpl in |- *; auto.\nintros a4 b; case a4; simpl in |- *; auto.\nintros a5 b; case a5; simpl in |- *; auto.\nintros a5 b; case a6; simpl in |- *; auto.\nintros a5 b; case b6; simpl in |- *; auto.\nintros a6 b; case a6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *; auto.\nintros a6 b; case b6; simpl in |- *;Qed.",
                    "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof.\nintros a b; case a; case b; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " Huffman Require Export sTactic.\nRequire Import Inverse_Image.\nRequire Import Wf_nat.\n\n(* Some facts about the minus operator *)\nSection Minus.\n \nTheorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4047,
                "proof_end_offset": 4291,
                "proof": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.\nintros n0 H b; case b; simpl in |- *.Qed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H; inversion H.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; case a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; apply le_trans with (n := 0); auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H; inversion H.\nintros n0 H0; inversion H0.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nQed.",
                    "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; autoQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n \nTheorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n \nTheorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n \nTheorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n \nEnd Minus.\nHint Resolve le_minus: arith.\n\n(* Equality test on boolean *)\nSection EqBool.\n \nDefinition eq_bool_dec : forall a b : bool, {a = b} + {a <> b}.\nintros a b; case a; case b; simpl in |- *; auto.\nright; red in |- *; intros; discriminate.\nDefined.\n \nEnd EqBool.\n\n(*A function to compare naturals *)\nSection LeBool.\n \nFixpoint le_bool (a b : nat) {struct b} : bool :=\n  match a, b with\n  | O, _ => true\n  | S a1, S b1 => le_bool a1 b1\n  | _, _ => false\n  end.\n \nTheorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n \nTheorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n \n",
                "context_tokens": 741,
                "proof_start_offset": 4294,
                "proof_end_offset": 4558,
                "proof": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; inversion H1.\nintros n0 H1; apply H.\napply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H; apply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; autoQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; inversion H1.\nintros n0 H2; apply le_S_n; auto.\nQed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; inversion H1.\nintros n0 H2; inversion H1.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2; inversion H2.\nintros n0 H2;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1; inversion H1.\nintros n0 H1;Qed.",
                    "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a b; elim a; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *; auto.\nintros n0 H b; case b; simpl in |- *;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": "Proof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n \nTheorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\n",
                "context_tokens": 736,
                "proof_start_offset": 7607,
                "proof_end_offset": 7753,
                "proof": "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; generalize l1; induction l1; simpl in |- *; auto.\nintros; rewrite <- plus_n_O; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\ninduction l1; simpl in |- *; auto.\nintros l1 l2 H; rewrite <- plus_n_O; rewrite <- plus_n_O; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros; rewrite length_app; rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_app; rewrite length_app;\n rewrite length_app; rewrite length_Qed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1 l2; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; case l2; simpl in |- *; auto.\nintros l1 l2; case l1; simpl in |- *; auto.\nintros l1 l2; caseQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros a l1 l2; case l1; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l1; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nintros a l1 l2; case l2; simpl in |- *; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; generalize l1; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l2; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l2; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l2; simpl in |- *; auto.\nintros a l1 l2 H; elim l2; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros a l1 l2 H; elim l2; simpl in |- *; auto.\nintros a l1 l2 H; elim l1; simpl in |- *; auto.\nintros aQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\ninduction l1; simpl in |- *; auto.\nintros; apply length_app; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\nintros; apply length_app.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof.\ninduction l1 as [| a l1 IH]; simpl in |- *; auto.\ncase (length_app l1 l2); intro H1; case H1; auto.\ncase (length_app l1 l2); intro H2; case H2; auto.\nQed.",
                    "Theorem length_app : forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1 l2; elim l1; clear l1 l2.\nintros; simpl in |- *; auto.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l1; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 l2; elim l2; simpl in |- *; auto.\nintros l1 lQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/Aux.v",
                "context": " (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n \nTheorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n \nEnd fold.\n\n(* Some properties of list operators: app, map,... *)\nSection List.\nVariables (A : Type) (B : Type) (C : Type).\nVariable f : A -> B.\n\n(* An induction theorem for list based on length *)\nTheorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n \nDefinition list_length_induction :\n  forall P : list A -> Type,\n  (forall l1 : list A,\n   (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n  forall l : list A, P l.\nintros P H l;\n apply\n  well_founded_induction_type with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nDefined.\n \nTheorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n\n(* Properties of app *)\nTheorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n \n",
                "context_tokens": 731,
                "proof_start_offset": 7756,
                "proof_end_offset": 7948,
                "proof": "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 l5.\ngeneralize l1; elim l2; simpl in |- *; auto.\nintros a1 l1 l2 H H0 H1; inversion_clear H.\nintros l2 l3 l4 H1 H2 H3 H4 H5.\ninversion_clear H.\nintros l3 l4 H5 H6 H7 H8.\ninversion_clear H.\nintros l4 H8 H8.\ninversion_clear H.\nintros l4 H8.\ninversion_clear H.\nintros l4 H8.\ninversion_clear H.\nintros l4 H8.\ninversion_clear H.\nintros l4 H8.\ninversion_clear H.\nintros l4 H8.\ninversion_clear H.\nintros l4 H8.\ninversion_clear H.\nintros l4 H9.\ninversion_clear H.\nintros l4 H9.\ninversion_clear H.\nintros l4 H9.\ninversion_clear H.\nintros l4 H9.\ninversion_clear H.\nintros l4 H9.\ninversion_clear H.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H0.\napply (app_inv_head _ _ _ _ _ _ _ _ _ _ _ _ _); auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H1 H2; elim l1; simpl in |- *; auto.\nintros a1 l2 l3 H1 H2 H3; rewrite H1; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H; elim l1; simpl in |- *; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4; elim l1; simpl in |- *; auto.\nintros a1 l2 l3 H H0; elim H0; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H H0.\nrewrite <- H0; rewrite H0; rewrite H1; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 H; elim l1; clear l1; simpl in |- *; auto.\nintros a l1 l2 H a0 l3 H a0 l4 H1 H2 H3 H4; inversion H4;\n auto.\nintros a l1 l2 H a0 l3 H a0 l4 H1 H2 H3 H4; inversion H4;\n auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H1 H2.\napply in_or_app.\ndestruct l1; simpl in |- *; auto.\nintros H1; elim H1; auto.\nintros H2; elim H2; auto.\nQed.",
                    "Theorem app_inv_head : forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1 l2 l3 l4 H0.\napply length_app; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "                                                   *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\n",
                "context_tokens": 488,
                "proof_start_offset": 2578,
                "proof_end_offset": 2793,
                "proof": "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  simple induction t; simpl in *; intros.\n  inversion H; subst; auto with arith.\n  inversion H; subst; auto with arith.\n  inversion H; subst; auto with arith.\n  inversion H0; subst; auto with arith.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\n  simple induction n; auto with arith.\n  simple induction n; auto with arith.\n  simple induction n; auto with arith.\n  simple induction n; auto with arith.\n  simple induction n; auto with arith.\n  intros t0 t1 t2 IHt1.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  intros t0 t1 t2 IHt2.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  intros t0 t1 t2 IHt2.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0; auto with arith.\n  simple induction n0Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t; induction n; simpl; auto with arith.\nintros n t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto with arith.\nintros t0; induction n0; simpl; auto withQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\ninduction n; simpl; auto.\nintros n0 t1 t2 l1 l2.\nunfold height_seq.\napply height_pred_inv_right with (n0 := n0) (n2 := n0) (t1 := t2) (t2 := t2) (t2 := t1) (t2 := t2) (t2 := t2) (t3 := t1) (t2 := t2) (t3 := t2) (t4 := t2) (t3 := t3) (t4 := t3) (t4 := t4) (t4 := t1) (t4 := t2) (t4 := t2) (t4 := t2) (t4 := t2) (t5 := t2) (t4 := t2) (t5 := t2) (t5 := t2) (t6 := t2) (t5 := t2) (t6 := t2) (t6 := t2) (t6 := t2) (t7 := t3) (t7 := t2) (t7 := t2Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\nunfold height_pred at 2 3 3 in |- *.\napply height_pred_nil.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\ninduction n.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\n- constructor.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t l.\nelim t; auto with arith.\nintros t1 l2.\nunfold height_seq in H.\ninversion H.\napply (H t1 t2 l1 t2 l2 t1 t2 l2 t2 l1 t2 l1 t2 l2 t1 t2).\nauto with arith.\nQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\ninduction n.\nsimpl in |- *.\nintros.\napply n.\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n).\napply (H (S n)).\napply (H (S n)).\napply (H (S n).\napply (H (S n)).\napply (H (S n)).\napply (H (S n).\napply (H (S n).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n).\napply (H (S n).\napply H.\napply (H (S n).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (HQed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t.\ninduction n.\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n).\napply (H (S n)).\napply (H (S n)).\napply (H (S n)).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n).\napply (H (S n).\napply H.\napply (H (S n).\napply (H (S n).\napply (H (S n).\napply (H (S n)).\napply (H (S n).\napply (H (S n).Qed.",
                    "Theorem height_pred_ordered_cover : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ordered_cover l t.\nProof.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nintros n t; case t; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "CULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\n",
                "context_tokens": 533,
                "proof_start_offset": 2832,
                "proof_end_offset": 3143,
                "proof": "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln l n t H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l; elim n; simpl in |- *; auto.\nintros n0 H; elim n0; simpl in |- *; auto.\nintros n1 H; elim n1; simpl in |- *; auto.\nintros n2 H; elim n2; simpl in |- *; auto.\nintros n3 H; elim H; simpl in |- *; auto.\nintros n3 H; elim H; simpl in |- *; auto.\nintros n3 H; elim H; simpl in |- *; auto.\nintros n3 H; elim H; simpl in |- *; auto.\nintros n3 H; elim H; simpl in |- *; auto.\nintros n3 H; elim H; simpl in |- *; auto.\nintros n4 H; elim n4; simpl in |- *; auto.\nintros n4 H; elim n4; simpl in |- *; auto.\nintros n4 H; elim H; simpl in |- *; auto.\nintros n4 H; elim n5; simpl in |- *; auto.\nintros n4 H; elim n5; simpl in |- *; auto.\nintros n5 H; elim n6; simpl in |- *; auto.\nintros n4Qed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l; elim l; simpl in |- *; auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nintros; absurd (n < n); auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln l t; elim l; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; auto.\nintros n t; case t; simpl in |- *; autoQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l.\ncase l; auto.\nintros n t1 l2.\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t2 l).\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t2 l).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n t1 l2).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n t2 l2).\napply (length_pred_inv n tQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln l t; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l; elim n; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln l t; elim n.\nauto with arith.\nintros p t; elim n.\nauto with arith.\nintros p t; elim n.\nauto with arith.\nintros p t; elim n.\nauto with arith.\nintros p t; elim n.\nauto with arith.\nQed.",
                    "Theorem height_pred_not_nil1 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> ln <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/HeightPred.v",
                "context": "c., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: HeightPred.v                         \n                                                                     \n    Definition of the predicate that associates a height list        \n    with a cover                                                     \n                                                                     \n    Definition: height_pred                                          \n                                    Laurent.Thery@inria.fr (2003)    \n **********************************************************************)\n\nFrom Huffman Require Export OrderedCover.\nFrom Huffman Require Export WeightTree.\nRequire Import ArithRing.\nFrom Huffman Require Export Ordered.\nFrom Huffman Require Export Prod2List.\n \nSection HeightPred.\nVariable A : Type.\nVariable f : A -> nat.\nVariable eqA_dec : forall a b : A, {a = b} + {a <> b}.\n\n(* \n  A predicate that associates an initial height, a list of\n  height, a cover and a tree\n*)\nInductive height_pred : nat -> list nat -> list (btree A) -> btree A -> Prop :=\n  | height_pred_nil :\n      forall (n : nat) (t : btree A), height_pred n (n :: nil) (t :: nil) t\n  | height_pred_node :\n      forall (n : nat) (ln1 ln2 : list nat) (t1 t2 : btree A)\n        (l1 l2 : list (btree A)),\n      height_pred (S n) ln1 l1 t1 ->\n      height_pred (S n) ln2 l2 t2 ->\n      height_pred n (ln1 ++ ln2) (l1 ++ l2) (node t1 t2).\nHint Resolve height_pred_nil height_pred_node : core.\n\n(* The cover is an ordered cover *)\nTheorem height_pred_ordered_cover :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ordered_cover l t.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.\n\n(* The height list is never empty *)\nTheorem height_pred_not_nil1 :\n forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)),\n height_pred n ln l t -> ln <> nil.\nProof using.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case ln1; simpl in |- *; auto.\nintros; discriminate.\nQed.\n\n(* The cover list is never empty *) \n",
                "context_tokens": 594,
                "proof_start_offset": 3182,
                "proof_end_offset": 3491,
                "proof": "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nintros; discriminate.\nintros n0 ln1 ln2 t1 t2 l1 l2 H0; case l1; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t; elim t; simpl in |- *; auto.\nintros n0 t1 l2 H; case (le_lt_eq_dec n0 n1); auto.\nintros n3 l3 l4; case (le_lt_eq_dec n2 n2); auto.\nintros n4 l4; case (le_lt_eq_dec n2 n3); auto.\nintros n5 l5; case (le_lt_eq_dec n1 n3); auto.\nintros n5 l6; case (le_lt_eq_dec n2 n1); auto.\nintros n6 l7; case (le_lt_eq_dec n2 n3); auto.\nintros n6 l7; case (le_lt_eq_dec n1 n2); auto.\nintros n6 l7; case (le_lt_eq_dec n2 n3); auto.\nintros n7 l7; case (le_lt_eq_eq_dec n1 n2); auto.\nintros n6 l7; case (le_lt_eq_eq_dec n2 n3);Qed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t.\ninduction n.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln t l H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t l.\nelim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t H; elim H; simpl in |- *; auto.\nintros; discriminate.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t H; elim H; simpl in |- *; auto.\nQed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t; elim l; simpl in |- *; auto.\nintros n1 t1 l2.\ncase (lt_eq_dec n1 n2); intros; auto.\ncase (lt_eq_dec n1 n2); intros; auto.\ncase (lt_eq_dec n1 n2); intros; auto.\ncase (lt_eq_dec n2 n3); intros; auto.\ncase (lt_eq_dec n1 n3); intros; auto.\ncase (lt_eq_dec n2 n3); intros; auto.\ncase (lt_eq_dec n1 n3); intros; auto.\ncase (lt_eq_dec n2 n3); intros; auto.\ncase (lt_eq_dec n1 n3); intros; auto.\ncase (lt_eq_dec n2 n3); intros; auto.\ncase (lt_eq_dec n2 n3); intros; auto.\ncase (lt_eq_dec n1 n3); intros; auto.\ncase (lt_eq_dec n2 n3); intros; auto.\ncase (lt_eq_Qed.",
                    "Theorem height_pred_not_nil2 : forall (n : nat) (ln : list nat) (t : btree A) (l : list (btree A)), height_pred n ln l t -> l <> nil.\nProof.\nintros n ln l t H; elim H; simpl in |- *; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \n",
                "context_tokens": 244,
                "proof_start_offset": 1591,
                "proof_end_offset": 1678,
                "proof": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; intros H0 H1; elim H1; intros H2; elim H2;\n intros H3 H4; elim H4; intros H5; elim H5;\n intros H6 H7; elim H7; intros H8; elim H8;\n intros H9; elim H9; intros H10; elim H10;\n intros H10; elim H10; intros H10; elim H10; \n intros H11; elim H10; intros H11; elim H10; \n intros H12; elim H10; intros H11; elim H10; \n intros H12; elim H10; intros H11; elim H10; \n intros H12; elim H10; intros H11; elim H10; \n intros H12; elim H10; \n intros H12; elim H10; intros H11; elim H10; \n intros H12; elim H10; intros H12; elim H10; \n intros H13; elim H10; intros H11; elim H10; \n intros H13; elim H10; intros H12; elim H10; \n intros H13; elim H10; intros H13Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H1; cut (a -> ~ b).\n2: auto with *.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; auto with float.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H.\nelim H.\nintros H' H'0; elim H'0; intros H'1 H'2; elim H'2; intros H'3 H'4; clear H'2 H'4.\nelim H'0; intros H'4 H'5; clear H'0.\nelim H'0; intros H'6 H'7; clear H'0.\nelim H'0; intros H'7 H'8; clear H'0.\nelim H'0; intros H'8 H'9; clear H'0.\nelim H'0; intros H'10 H'10; clear H'0.\nelim H'0; intros H'10 H'11; clear H'0.\nelim H'0; intros H'10 H'10; clear H'0.\nelim H'0; intros H'11 H'10; clear H'0.\nelim H'0; intros H'10 H'11; clear H'0.\nelim H'0; intros H'10 H'11; clear H'0.\nelim H'0; intros H'10 H'10;Qed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H.\napply H; auto.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; auto with arith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H; elim H; auto with arith.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H.\ncut (a -> ~ b).\nintro H1; elim H1; intros H3; elim H3; clear H3.\nintros H4 H5.\ncut (b -> b).\nintro H5; elim H5; intros H6 H7.\napply H7; auto with sets.\ncut (b -> b); auto with sets.\ncut (b -> b); auto with sets.\ncut (b -> b); auto with sets.\ncut (b /\\ b); auto with sets.\ncut (b /\\ b); auto with sets.\nQed.",
                    "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nintros a b H H0.\nelim H0; intros H1 H2; elim H1; intros H3 H4; elim H4; clear H4; intros H4 H5.\nelim H1; intros H4 H5; elim H5; clear H5; intros H5.\nelim H2; intros H6; elim H6; intros H7.\nelim H7; intros H8 H10.\nelim H8; intros H10.\nelim H9; intros H10.\nelim H10; intros H10.\nelim H10; intros H10.\nelim H10; intros H11 H12.\nelim H10; intros H11 H12.\nelim H10; intros H12.\nelim H11; intros H12.\nelim H11; intros H13.\nelim H12; intros H13.\nelim H14; intros H14.\nelim H14; intros H14.\nelim H15; intros H14.\nelim H15; intros H15.\nelim H15; intros H15 H16.\nelim H16; intros H15 H16.\nelim H16; intros H17 H17Qed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 277,
                "proof_start_offset": 1681,
                "proof_end_offset": 1759,
                "proof": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/huffman/theories/sTactic.v",
                "context": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU Lesser General Public License for more details.                *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n(**********************************************************************\n    Proof of Huffman algorithm: sTactic.v                            \n                                                                     \n    Useful tactics                                                   \n                                                                     \n    Tactics: Contradict, CaseEq, ElimEq                              \n                                    Laurent.Thery@inria.fr (2003)    \n  **********************************************************************)\n \nTheorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n \nTheorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n \n",
                "context_tokens": 305,
                "proof_start_offset": 1762,
                "proof_end_offset": 1830,
                "proof": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed.",
                    "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nintuition.\nQed."
                ]
            }
        ],
        "PolTac": [
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\nTheorem Nlt_lt_rev: forall n  m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n\n",
                "context_tokens": 668,
                "proof_start_offset": 1675,
                "proof_end_offset": 2086,
                "proof": "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nProof.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1.\nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 < nat_of_P p1)%nat; auto with arith.\napply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_ge; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p H0; inversion H0.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H4; inversion H4.\nintros p H5; inversion H5.\nintros p H5; inversion H5.\nintros p H5; inversion H6.\nintros p H5; inversion H6.\nintros p H5; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H5; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H7; inversion H6.\nintros p H8; inversion H6.Qed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros n m; case n; case m; unfold N.ge; simpl; try (intros; discriminate); auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nlt_le_rev; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nle_ge; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nge_ge; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nge_ge: forall n m, (N.to_nat n >= N.to_nat m)%nat -> n >= m.\nintros; apply Nlt_gt; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rle_trans_r : forall x y z, (y = z) -> (x <= y) -> (x <= z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_l : forall x y z, (x = z) -> (x >= y) -> (z >= y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rge_trans_r : forall x y z, (y = z) -> (x >= y) -> (x >= z).\nintros x y z H; rewrite H; auto.\nQed.\n\nTheorem Rge_trans: forall x y z, (x >= z) -> (z >= y) -> (x >= y).\nintros x y z H1 H2; red; apply Rge_trans with z; auto.\nQed.\n\n(* For RGroundTac *)\n\n\n",
                "context_tokens": 746,
                "proof_start_offset": 32895,
                "proof_end_offset": 33883,
                "proof": "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nintros p; case p; auto.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zpos (xI p2)) at 2; replace (Zpos (xI p2)) with (2 * (Zpos p2) +1)%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1);ring.\nintros p2 Rec; pattern (Zpos (xO p2)) at 2; replace (Zpos (xO p2)) with (2 * (Zpos p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p1; elim p1; auto.\nintros p2 Rec; pattern (Zneg (xI p2)) at 2; replace (Zneg (xI p2)) with ((2 * (Zneg p2) + -1))%Z; auto with zarith.\nrewrite plus_IZR; rewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nintros p2 Rec; pattern (Zneg (xO p2)) at 2; replace (Zneg (xO p2)) with (2 * (Zneg p2))%Z; auto with zarith.\nrewrite mult_IZR; rewrite <- Rec.\nsimpl Z2R; simpl IZR; case p2; intros; simpl (P2R 1); ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; unfold Z2R; rewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case (Z_eq_dec p 0); intros H1;\n [ left; apply IZR_eq_0 | right; auto with real ].\ncase (Z_eq_dec p 0); intros H2;\n [ left; apply IZR_eq_0 | right; auto with real ].\ncase (IZR_eq_dec p 0); intros H3;\n [ left; apply IZR_eq_0 | right; auto with real ].\ncase (IZR_eq_dec p 0); intros H3;\n [ right; apply IZR_eq_0 | left; auto with real ].\ncase (IZR_eq_dec p 0); intros H4;\n [ right; apply IZR_eq_0 | right; auto with real ].\ncase (IZR_eq_dec p 0); intros H5;\n [ left; apply IZR_eq_0 | right; auto with real ].\ncase (IZR_eq_dec p 0); intros H6;\n [ left; apply IZR_eq_0 | right; auto with real ].\ncase (IZR_eq_dec p 0); intros H7;\n [ left; apply IZR_eq_0 | right; autoQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros p; case (IZR p); auto.\nintros pQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros; rewrite Z2R_IZR.\napply IZR_le; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros; unfold Z.succ.\nrewrite Z2R_IZR; auto.\nrewrite Z2R_IZR; auto.\nrewrite Z2R_IZR; auto.\nrewrite Z2R_IZR; auto.\nrewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case (Pos.eq_dec p 0); intros H1; auto.\ncase (Pos.eq_dec p 0); intros H2; auto.\ncase (Pos.eq_dec p 0); intros H3; auto.\ncase (Pos.eq_dec p 0); intros H4; auto.\ncase (Pos.eq_dec p 0); intros H4; auto.\ncase (Pos.eq_dec p 0); intros H5; auto.\ncase (Pos.eq_dec p 0); intros H6; auto.\ncase (Pos.eq_dec p 0); intros H6; auto.\ncase (Pos.eq_dec p 0); intros H7; auto.\ncase (Pos.eq_dec p 0); intros H7; auto.\ncase (Pos.eq_dec p 0); intros H7; auto.\ncase (Pos.eq_dec p 0); intros H7; auto.\ncase (Pos.eq_dec p 0); intros H8; auto.\ncase (Pos.eq_dec p 0); intros H8; auto.\ncase (Pos.eq_dec p 0); intros H8;Qed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros; unfold Z.le.\napply IZR_eq; apply IZR_eq; apply IZR_eq; apply IZR_eq; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nProof.\nunfold Z2R; unfold Z2R; unfold IZR; rewrite Z2R_IZR.\nrewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; rewrite Z2R_IZR; rewrite Z2R_IZR; auto.\nQed.",
                    "Theorem Z2R_correct: forall p, (Z2R p) = (IZR p).\nintros p; case (IZR_eq_dec p 0); intros H1; auto.\napply IZR_eq_dec.\nrewrite <- Z2R_IZR; apply IZR_eq_dec.\nrewrite <- Z2R_IZR; apply IZR_eq_dec.\napply IZR_eq_dec.\nrewrite <- Z2R_IZR; apply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\nrewrite <- Z2R_IZR; apply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_eq_dec.\napply IZR_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\n",
                "context_tokens": 6,
                "proof_start_offset": 24,
                "proof_end_offset": 107,
                "proof": "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\nrewrite <- (ar2_succ x y) at 2.\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2_succ y).\nrewrite <- (ar2Qed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros.\nrewrite <- (ar_bound_bound_gen_aux_aux_aux (fun x y => x + y) (fun x => y + x)).\napply (fun x y => x + y).\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros x y.\nrewrite <- (mult_1_l y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewriteQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros.\n rewrite <- (Rmult_comm _ x), (Rmult_comm _ y).\n apply Rmult_le_compat_r.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros. apply (lt_le_trans _ _ H).\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\nintros; apply (well_founded_induction_type (x + y)); intros.\nrewrite H1.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewrite <- H.\nsimpl.\nrewriteQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct (le_gt_dec x y); [left|right]; auto.\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros.\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n rewrite le_lteq.\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n rewrite le_lteq.\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n rewrite le_lteq.\n apply le_trans with (l:=l).\n rewrite le_lteq.\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans with (l:=l).\n apply le_trans withQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros. apply (f_equal (fun x y => x + y + x)).\nQed.",
                    "Theorem pols_test1: forall x y, x < y -> (x + x < y + x).\nProof.\n intros.\n rewrite <- (ar2_bound x) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n apply (pow_bound_bound y) with y.\n rewrite (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (ar2_bound y) at 1.\n rewrite <- (Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 46,
                "proof_start_offset": 109,
                "proof_end_offset": 188,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nco_equiv.\nrewrite <- (comp_comp_pow2 _ x y).\nrewrite <- (comp_comp_pow2 _ x y).\nrewrite <- (comp_comp_pow2 _ x y).\napply Rmult_le_compat_r.\nnow apply pow_pos.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nAbss.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply Rle_trans with (y + x).\napply Rle_lt_trans with (y + x).\napply Rle_lt_trans with (y + x).\napply Rmult_le_compat_r.\napply Rle_lt_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_r.\napply Rlt_le_trans with (y + x).\napply Rmult_le_compat_rQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ngeneralize (le_gt_cases x y); intro.\ncontradict H.\napply le_trans with (1 + y); auto.\nrewrite H; auto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nreps.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ngeneralize (lt_le_lt_eq_lt_trans _ _ H0).\nintro.\nrewrite (le_lt_le_eq_eq_trans _ _ H1).\nrewrite (le_lt_le_eq_trans _ _ H1).\nrewrite (le_lt_le_eq_lt_trans _ _ H2).\napply lt_le_trans with (1 + x - y).\napply le_n_S.\nrewrite <- (le_plus_r x y).\napply le_n_S.\nrewrite <- (le_plus_r y x).\napply le_n_S.\nrewrite <- (le_plus_r x y).\napply le_n_S.\nrewrite <- (le_plus_r x y).\napply le_n_S.\nrewrite <- (le_plus_r y x).\napply le_n_S.\nrewrite <- (le_plus_r x y).\napply le_n_S.\nrewrite <- (le_plus_r y x).\napply le_n_S.\nrewrite <- (le_plus_r x y).\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply RmultQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\npattern x at 1; replace y with (y + 0).\nring.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ncontradict H.\nrewrite H0.\nrewrite <- (le_n_O x).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply RmultQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nassert (H: forall x, (x + y <= x + y) -> (x + y < x + y)).\nintros.\nassert (H1: forall x, (x + y > x + y) -> (x + y < x + y)).\nintros.\nassert (H2: forall x, (x + y > x + y) -> (x + y < x + y).\nintros.\napply H1.\napply H2.\napply H1.\napply H2.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H1.\napply H2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 84,
                "proof_start_offset": 191,
                "proof_end_offset": 311,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nreps.\nomega.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rmult_le_compat_r with (1 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_l with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 := H).\napply Rmult_le_compat_r with (2 :=Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nlocal_op.\nrewrite <- (mult_comm x y).\nrewrite <- (mult_assoc y x).\nrewrite (mult_assoc y x).\nrewrite <- (mult_assoc y x).\nrewrite <- (mult_assoc x y).\nrewrite (mult_comm x y).\nrewrite <- (mult_assoc y x).\nrewrite <- (mult_assoc y x).\nrewrite <- (mult_assoc y x).\nrewrite <- (mult_assoc y x).\nrewrite <- (mult_assoc y x).\nrewrite (mult_assoc y x).\nrewrite <- (mult_assoc y x).\nrewrite (mult_assoc y x).\nrewrite (mult_comm x).\nrewrite <- (mult_assoc y x).\nrewrite (mult_assoc y x).\nrewrite (mult_assoc y x).\nrewrite (mult_comm x).\nrewrite (mult_assoc y x).\nrewrite (mult_assoc y x).\nrewrite (mult_comm y).\nrewrite (mult_assoc y x).\nrewrite (mult_comm x).\nrewrite (mult_assoc y x).\nrewrite (mult_comm y).\nrewrite (mult_comm y).Qed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply RmultQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ngeneralize (le_gt_cases x y).\ncase (le_gt_cases x y).\nintros.\nrewrite <- (mult_1_r x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y x).\nrewrite (mult_comm y x).\nrewrite (mult_comm y y).\nrewrite (mult_comm y y).\nrewrite (mult_comm x y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewrite (mult_comm x y).\nrewrite (mult_comm y).\nrewriteQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\n15.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_l; auto.\napply Rmult_le_compat_l; auto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nassert (H: (y + y) <= 2 * (y + x)).\napply H.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H.\napply H0.\napply H0.\napply H1.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply RmultQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite <- (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (mult_comm y).\nrewrite (mult_comm x).\nrewrite (mult_comm y).\nrewrite (multQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nassert (H: (x + y) <= 2 * y + (y * x + y) * y).\napply H.\napply H.\napply H.\napply H.\napply H.\napply H.\napply H0.\napply H1.\napply H1.\napply H.\napply H0.\napply H1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 145,
                "proof_start_offset": 314,
                "proof_end_offset": 436,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncos.\nomega.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\napply Rmult_le_compat_r; auto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nRewriteVar (x + z) (x + z) H0 H1.\nrewrite H1.\nrewrite H2.\nrewrite H3.\nring.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nAbss.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nspec H1.\nrewrite H1.\nring.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\n shrus.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nsqrts.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nspec H0.\nrewrite H.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 208,
                "proof_start_offset": 439,
                "proof_end_offset": 515,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nassert (H: (1 <= x + y) * 2 = 2 * 2 * 2).\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nassert (forall x y, (2 <= y -> x <= y) -> 2 * x <= 2 * y).\nintros.\napply H0.\napply H1.\napply H1.\napply H2.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H0.\napply H1.\napply H1.\napply H2.\napply H0.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncos.\nomega.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nsqrts.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nco_gt_0_compat.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nring.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nspec H x.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_Qed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nassert (H: (x + y < x * y + x * y + 2 * y) = 2 * (1 + y * x + 2 * y)).\nrewrite H.\nrewrite H.\nrewrite H0.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nrewrite H0.\nrewrite H1.\nrewrite H1.\nrewrite H1.\nring.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncos.\nomega.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nassert (H1: (2 <= y) * 2 <= 2 * 2).\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 244,
                "proof_start_offset": 517,
                "proof_end_offset": 613,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nassert (H: (0 <= y) * 2 <= 2 * 2). omega.\nassert (H: (x + y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (x * y) * 2 <= 2 * 2). omega.\nassert (H: (Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_spec x y H1 H2.\nrewrite H1.\napply Rplus_le_compat_l.\nrewrite <- H0.\napply Rplus_le_compat_r.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_gt_0_le_compat.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napplyQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncof_equal.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compatQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ndestruct (le_gt_dec x y) as [H | H].\nrewrite H.\nrewrite <- (proj1 H).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_gt_0_compat.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncof_equal.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compatQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncontradict H.\ncontradict H0.\ncontradict H1.\ncontradict H2.\ncontradict H3.\ncontradict H1.\ncontradict H3.\ncontradict H3.\napply le_trans with (2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 + 3 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 + 3 * 2 * 2 * 2 * 2 * 2 * 2 * 2 + 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 + 4 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 2 * 2 * 2 * 2Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncos.\nomega.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncof_equal.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\napply Rmult_le_compat_r; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Natex.v",
                "context": "Require Import PolTac.\n\nTheorem pols_test1: forall x y, x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 290,
                "proof_start_offset": 617,
                "proof_end_offset": 735,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H1: forall x y z, (x + z) < 2*y -> (x + y) < 2*y).\nintros.\nassert (H2: forall x y z, (x + z) >= 2*y -> (x + y) > 2*y).\nintros.\nassert (H3: forall x y z, (x + z) <= 2*y -> (x + y) > 2*y).\nintros.\nassert (H4: forall x y z, (x + y) < 2*y -> (x + y) > 2*y).\nintros.\nassert (H4: forall x y z, (x + y) > 2*y -> (x + y) > 2*y).\nintros.\nassert (H5: forall x, (x + y) > 2*y -> (x + y) > 2*y).\nintros.\nassert (H5: forall x y z, (x + y) > 2*y -> (x + y) > 2*y).\nintros.\nassert (H6: forall x y z, (x + y) >Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict HQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rmult_le_compat_r;\n[apply Rmult_le_compat_r; auto | omega].\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H: (2 * x + y * z) == (2 * x + y * z + x * z)).\napply (af_pow1_r _ _ H).\nassert (H: (2 * x + y * z) == (2 * x + y * z)).\napply (af_pow2_r _ _ H0).\nintros.\napply (mul_comm (2 * x + y * z)).\nrewrite (mult_comm x), (mult_comm y), (mult_comm x), (mult_comm y), (mult_comm x), (mult_comm y).\nintros.\napply (mul_comm (2 * x + y * z)).\nrewrite (mult_comm x), (mult_comm y), (mult_comm y), (mult_comm y), (mult_comm x).\nintros.\napply (mul_comm (2 * x + y * z)).\nrewrite (mult_comm x), (mult_comm y), (mult_comm x), (mult_comm y), (mult_comm y).\nintros.\napply (mult_comm (2 * x + y * z)).Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H1: (2*x + y) * x + (2*x + z) = 2*x + (2*x + z)).\nrewrite H1 in H1.\nrewrite H in H1.\nrewrite H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H2 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.\nsimpl in H1.\nrewrite <- H1 in H1.Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H: (x + y) < 2 * y + (y + z)).\napply H; auto.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H3: (2*x + y) <= 2*z).\napply H1.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_r.\napply mult_le_compat_l.Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H: (x + y - x) <= z + x * y) by omega.\nclear H H0.\ndestruct H.\nassert (H0: (y + x * y - x * y) = 2 * x + 2 * y + 2 * y) by omega.\nrevert H0.\ndestruct H.\nassert (H1: (y + x - 1) * y - x * y) by omega.\nclear H0.\nrevert y H1.\nrevert y H1.\ninduction x; intros.\nsimpl.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H2.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- H0.\nrewrite <- H1.\nrewrite <- H1.\nrewrite <- HQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rle_trans with (2*z).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napplyQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H: forall x, 0 <= x -> 2 * x + y < 2 * x + y).\nintros.\nassert (H: forall x, 2 * x + y * x <= 2 * x + y).\nintros.\nassert (H: forall x, 2 * x + y * x + 2 * x = 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\n",
                "context_tokens": 33,
                "proof_start_offset": 123,
                "proof_end_offset": 285,
                "proof": "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H.\n induction m.\n - (* m = 0 *)\n   simpl in H.\n   omega.\n - (* m = 0 *)\n   simpl in H.\n   omega.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nsimple induction n; intros.\nleft; apply le_refl.\nintro H0.\napply le_trans with m; auto.\napply le_trans with (p*m); auto.\napply le_trans with (p*m); auto.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros.\napply le_trans with (n - m).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (m - p).\napply le_lt_trans with (Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H.\n destruct (le_gt_cases m n) as [H|H].\n apply le_lt_trans with (n * m).\n apply le_lt_trans with (n * m).\n rewrite <- (mult_comm n p), (mult_comm m p).\n apply le_lt_trans with (n * m).\n apply le_le_trans with (n * m).\n rewrite (mult_comm n p), (mult_comm m p).\n apply le_n_S.\nQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H.\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (le_lt_cases n m).\nrewrite (leQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H. apply lt_le_trans with (n + m).\n apply le_lt_trans with (m + p).\n apply le_trans with (m + p).\n apply le_lt_trans with (n + p).\n apply le_lt_trans with (m + p).\n apply le_trans with (n + p).\n apply le_lt_trans with (n + p).\n apply le_trans with (n + p).\n apply le_trans with (n + p).\n apply le_trans with (m + p).\n apply le_n_n.\n apply le_trans with (n + p).\n apply le_n_n.\n apply le_trans with (n + p).\n apply le_n_n.\n apply le_trans with (n + p).\n apply le_n_Sn.\n apply le_n_n.\n apply le_trans with (n + p).\n apply le_n_Sn.\n apply le_trans with (n + p).\n apply le_n_Sn.\n apply le_n_n.\n apply le_n_n.Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p H.\nrewrite (mult_comm n m) in H.\nrewrite (mult_comm n m) in H.\nrewrite (mult_comm n m) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm n m) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm n m) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_comm m n) in H.\nrewrite (mult_commQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\nintros n m p.\napply le_lt_trans with (m - n); [|apply lt_le_trans];\n[apply le_lt_trans with (m - n);\n[apply le_lt_trans with (m - n);\n[apply le_lt_trans with (m - n);\n[apply le_trans with (m - n);\n[apply le_lt_trans with (m - n);[apply le_le_trans with (m - n);\n[apply le_lt_trans with (m - n);\n[apply le_trans with (m - n);[apply le_le_trans with (m - n);\n[apply le_le_trans with (m - n);[apply le_n_n_Sm|apply le_le_trans with (m - n);\n[apply le_le_trans with (m - n);[apply le_n_n_Sm|apply le_le_trans with (m - n);\n[apply le_lt_trans with (m - n);[apply le_n_n_Sm|apply le_le_trans with (m -Qed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H. apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n rewrite (plus_comm p m).\n apply le_lt_trans with (p*m).\n apply le_trans with (p*m).\n rewrite (plus_comm p m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n rewrite <- (plus_comm p m).\n apply le_lt_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans with (p*m).\n apply le_trans withQed.",
                    "Theorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nProof.\n intros n m p H1 H2.\n apply (lt_le_trans n m).\n apply lt_le_trans with (p * n); trivial.\n apply le_lt_trans with (p * m).\n apply le_lt_trans with (p * n).\n apply lt_le_trans with (p * n).\n apply le_lt_trans with (p * n).\n apply le_lt_trans with (p * n).\n apply le_lt_trans with (p * n).\n apply le_n_S.\n apply le_n_S.\n apply le_trans with (p * n).\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_trans with (p * n).\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_n_S.\n apply le_trans with (p * n).\n applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\n",
                "context_tokens": 98,
                "proof_start_offset": 287,
                "proof_end_offset": 396,
                "proof": "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nProof.\nintros n m p H; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm n); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm n); apply mult_ge_compat_l.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H1; repeat rewrite (mult_comm p); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\n",
                "context_tokens": 142,
                "proof_start_offset": 398,
                "proof_end_offset": 535,
                "proof": "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm n); apply mult_ge_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; apply (mult_ge_compat_l n m p); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; repeat rewrite (mult_comm p); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H; case (le_gt_dec n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_r; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H0; repeat rewrite (mult_comm n p); apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 201,
                "proof_start_offset": 537,
                "proof_end_offset": 655,
                "proof": "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; elim H; intros; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; apply (lt_O_lt_reg_l n m p); auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply (lt_not_le n m); auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; apply mult_le_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; apply le_n_n.\nQed.",
                    "Theorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p H; rewrite (mult_comm n p); apply mult_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 250,
                "proof_start_offset": 657,
                "proof_end_offset": 889,
                "proof": "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nProof.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; simpl in |- *; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; elim H; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\n",
                "context_tokens": 345,
                "proof_start_offset": 892,
                "proof_end_offset": 1010,
                "proof": "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nProof.\nintros n m p; case p; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nintros n0 H1; case (le_or_lt n0 m); auto with arith.\nintros n1 H2; case (le_or_lt n1 n1); auto with arith.\nintros n2 H3; case (le_or_lt n2 n2); auto with arith.\nintros n3 H3; case (le_or_lt n3 n3); auto with arith.\nintros n4 H5; case (le_or_lt n4 n4); auto with arith.\nintros n5 H5; case (le_or_lt n4 n5); auto with arith.\nintros n5 H6; case (le_or_lt n4 n5); auto with arith.\nintros n5 H6; case (le_or_lt n4 n5); auto with arith.\nintros n6 H7; case (le_or_lt n4 n5); auto with arith.\nintros n6 H7; case (le_or_lt n4 n6); auto with arith.\nintros n7 H7Qed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nintros p0; absurd (p * n > p0); auto with arith.\napply mult_lt_compat_l; auto.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nrewrite H1; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt m n); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p H; case (le_or_lt (n - m) (n - m)); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\n",
                "context_tokens": 394,
                "proof_start_offset": 1012,
                "proof_end_offset": 1197,
                "proof": "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nProof.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed.",
                    "Theorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p; case p; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\n",
                "context_tokens": 470,
                "proof_start_offset": 1199,
                "proof_end_offset": 1445,
                "proof": "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nProof.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (n * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith.\nintros m H H0; absurd (m * n > m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H2.\nabsurd (p * n < p * n); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H0; apply (lt_not_le _ _ H H0).\napply le_trans with (m * p).\napply le_lt_trans with (m * p).\napply le_trans with (m * p).\napply le_lt_trans with (m * p).\napply le_trans with (m * p).\napply le_trans with (m * p).\napply le_n_S; auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (n * n > p * m); auto with arith.\nQed.",
                    "Theorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 569,
                "proof_start_offset": 1447,
                "proof_end_offset": 1704,
                "proof": "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nProof.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith; intros H3; absurd (p * n < p * n); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith; intros H2.\ncut (n * p < n * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\ncut (p * n < p * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H0; case (le_or_lt n m); auto with arith; intros H1.\nrewrite (mult_comm n m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; case (le_or_lt n m); auto with arith; intros H3.\napply le_trans with (n * m); auto with arith.\nQed.",
                    "Theorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_trans with (p * n + m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 671,
                "proof_start_offset": 1706,
                "proof_end_offset": 1872,
                "proof": "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nProof.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; apply lt_le_weak; apply lt_le_weak; apply lt_le_weak; auto.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt 0 a); auto with arith; intros H1.\nabsurd (a * b <= a * b); auto with arith.\napply lt_not_le; apply lt_trans with (a * b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt 0 a); auto with arith; intros H1.\nabsurd (a * b < a * b); auto with arith.\napply lt_not_le; apply lt_O_Sn.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; elim H0; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt 0 b); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H0; case (le_or_lt a b); auto with arith; intros H1.\ncut (a * b < b * b). auto with arith.\nrewrite H0; auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H1 H2; case (le_or_lt 0 a); auto with arith.\nQed.",
                    "Theorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H H1; case (le_or_lt a b); auto with arith; intros H2.\nabsurd (a * b <= a * b); auto with arith.\napply le_trans with (n * 0 + 0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for Z *)\nRequire Import Arith.\nRequire Import List.\nRequire Export NatGroundTac.\n\n\nTheorem mult_lt_compat_l: forall n m p : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 1874,
                "proof_end_offset": 1996,
                "proof": "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nProof.\nintros a b H1 H2; red; apply lt_mult_0; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case b; simpl; auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros m H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros m H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); autoQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nintros n H1 H3; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H H0; case (le_or_lt 0 a); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H3; case (le_or_lt n m); auto with arith.\nintros n H1 H3; case (le_or_lt n m); auto with arith.\nintros n H1 H3; case (le_or_lt n m); auto with arith.\nintros n H1 H3; case (le_or_lt n m); auto with arith.\nintros n H1 H3; case (le_or_lt n m); auto with arith.\nintros n H1 H3; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.Qed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nintros n H1 H2; case (le_or_lt n m); auto with arith.\nQed.",
                    "Theorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b; case a; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " : nat, n < m -> 0 < p -> p * n < p * m.\nintros n m p H H1; repeat rewrite (mult_comm p); apply mult_lt_compat_r; auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\n",
                "context_tokens": 742,
                "proof_start_offset": 1999,
                "proof_end_offset": 2106,
                "proof": "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H0; case (le_or_lt a b); auto with arith.\nintros H2; absurd (0 < 0); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; elim H1; intros; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; case (le_or_lt 0 a); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; apply le_trans with (a * b).\napply lt_trans with (b * b).\napply lt_n_S.\napply lt_n_S.\napply lt_trans with (a * b).\napply lt_n_S.\napply lt_n_S.\napply lt_trans with (b * a).\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_trans with (b * a).\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_trans with (b * a).\napply lt_n_S.\napply lt_n_S.\napply lt_trans with (a * b).\napply le_n_S.\napply lt_n_S.\napply lt_n_S.\napply ltQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case a; simpl; auto with arith.\nintros n H1; Contradict H1; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b; case b; simpl in |- *; auto with arith.\nintros n H1; case (le_or_lt n m); auto with arith.\nintros n1 H2; case (le_or_lt n m); auto with arith.\nintros n2 H3; case (le_or_lt n m); auto with arith.\nintros n3 H3; case (le_or_lt n m); auto with arith.\nintros n3 H4; case (le_or_lt n m); auto with arith.\nintros n3 H5; case (le_or_lt n m); auto with arith.\nintros n3 H5; case (le_or_lt n m); auto with arith.\nintros n3 H5; case (le_or_lt n m); auto with arith.\nintros n4 H5; case (le_or_lt n m); auto with arith.\nintros n4 H5; case (le_or_lt n m); auto with arith.\nintros n4 H5; case (le_or_lt n m); auto with arith.\nintros n4 H6; case (leQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H1 H2; elim H1; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_l: forall a b, 0 < a * b -> 0 < a .\nintros a b H H0; case (le_or_lt a b); auto with arith.\nintros n H1; case (le_or_lt n m); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": " auto.\nQed.\n\nTheorem mult_ge_compat_l: forall n m p : nat, n >= m -> p * n >= p * m.\nintros n m p H; auto with arith.\nQed.\n\nTheorem mult_gt_compat_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2108,
                "proof_end_offset": 2250,
                "proof": "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; red in |- *; apply lt_mult_rev_0_l; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1; elim H1; elim H2; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; red; apply lt_mult_rev_0_l; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H1 H2; case (le_or_lt a b); auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H0; elim H; auto with arith.\nQed.",
                    "Theorem lt_mult_rev_0_r: forall a b, 0 < a * b -> 0 < b .\nintros a b H H1; replace b with (1 * b); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l: forall n m p : nat, n > m -> p > 0 -> p * n > p * m.\nintros n m p H H1; red; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2252,
                "proof_end_offset": 2358,
                "proof": "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nProof.\nintros a b; case a; simpl; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H1; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b H1 H2; rewrite <- (mult_comm a b); apply lt_mult_rev_0_l.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_l: forall a b, a * b > 0 -> a > 0.\nintros a b; case a; simpl; auto with arith.\nintros n H1 H2; Contradict H2; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "; auto.\nQed.\n\nTheorem mult_lt_compat_rev_l1: forall n m p : nat, p * n < p * m -> 0 < p.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 2360,
                "proof_end_offset": 2503,
                "proof": "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case b; simpl in |- *; auto with arith.\nQed.",
                    "Theorem gt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b; case a; simpl in |- *; auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "Qed.\n\nTheorem mult_lt_compat_rev_l2: forall n m p : nat, p * n < p * m -> n < m.\nintros n m p H; case (le_or_lt m n); auto with arith; intros H1.\nabsurd (p * n < p * m); auto with arith.\napply le_not_lt; apply mult_le_compat_l; auto.\nQed.\n\n\nTheorem mult_gt_compat_rev_l1: forall n m p : nat, p * n > p * m -> p > 0.\nintros n m p; case p; auto with arith.\nQed.\n\nTheorem mult_gt_compat_rev_l2: forall n m p : nat, p * n > p * m -> n > m.\nintros n m p H; case (le_or_lt n m); auto with arith; intros H1.\nabsurd (p * n > p * m); auto with arith.\nQed.\n\nTheorem mult_le_compat_rev_l: forall n m p : nat, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H H1; case (le_or_lt n m); auto with arith; intros H2; absurd (p * n <= p * m); auto with arith.\napply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem mult_ge_compat_rev_l: forall n m p : nat, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H H1; case (le_or_lt m n); auto with arith; intros H2; absurd (p * n >= p * m); auto with arith.\nunfold ge; apply lt_not_le; apply mult_lt_compat_l; auto.\nQed.\n\nTheorem lt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b; case a ; case b; simpl; auto with arith.\nintros n H1 H2; absurd (0 < 0); auto with arith.\nQed.\n\nTheorem gt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; red; apply  lt_mult_0; auto with arith.\nQed.\n\n\nTheorem lt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem lt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b; case a; simpl; auto with arith.\nQed.\n\nTheorem gt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b; case b; simpl; auto with arith.\nrewrite mult_0_r; auto with arith.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 2505,
                "proof_end_offset": 2590,
                "proof": "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n; case n; auto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; elim H; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; generalize (lt_0_eq_0_l n); case n; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (le_eq_0 n); auto with arith.\nintros n H1 H2; case (leQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nintros n H1; case n; simpl; auto with arith.\nintros n H1; case n; simpl; auto with arith.\nintros n0 H1; case n; simpl; auto with arith.\nintros n1 H1; case n; simpl; auto with arith.\nintros n0 H1; case n; simpl; auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; rewrite <- (plus_0_l n); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case (le_0_eq_0_l 0); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; rewrite <- (mult_0_r n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_r n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_l n).\nrewrite <- (mult_0_r nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; case n; simpl; auto with arith.\nintros n H; apply le_trans with (S n); auto with arith.\nQed.",
                    "Theorem le_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; elim H; auto with arith.\nintros n0 H1; apply le_trans with (S n0); auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_compat_l || apply mult_lt_compat_l ||\n              apply mult_ge_compat_l || apply mult_gt_compat_l ||\n              apply lt_mult_0 || apply gt_mult_0); auto with arith.\n\nLtac hyp_nsign_tac H :=\n  match type of H with\n   0 <= _ => clear H\n|?X1 <= 0 => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ <=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_le_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4783,
                "proof_end_offset": 5148,
                "proof": "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H0 H1 H2 H3;\n generalize (lt_plus_plus_r _ _ H1); clear H0; intros H3;\n generalize (lt_plus_plus_r _ _ H3); clear H3; intros H4;\n generalize (lt_plus_plus_r _ _ H3); clear H3; intros H4;\n generalize (lt_plus_plus_r _ _ H4); clear H4; intros H5;\n generalize (lt_plus_plus_r _ _ H5); clear H5; intros H6;\n generalize (lt_plus_plus_r _ _ H6); clear H5; intros H7;\n generalize (lt_plus_plus_r _ _ H6); clear H6; intros H8;\n generalize (lt_plus_plus_r _ _ H7); clear H6; intros H8;\n generalize (lt_plus_plus_r _ _ H7); clear H6; intros H8;\n generalize (lt_plus_plus_r _ _ H8); clear H6; intros H8;\n generalize (lt_plus_plus_rQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H_rec H1 H2;\n generalize (le_0_eq _ H_rec); clear H_rec; intros H1 H2;\n generalize (le_0_eq _ H2); clear H_rec; intros H2 H3;\n generalize (le_0_eq _ H3); clear H_rec; intros H3 H4;\n generalize (le_0_eq _ _ H4); clear H_rec; intros H4;\n generalize (le_0_eq _ _ H4); clear H_rec; intros H5;\n generalize (le_0_eq _ _ H4); clear H_rec; intros H5;\n generalize (le_0_eq _ _ H4); clear H_rec; intros H5;\n generalize (le_0_eq _ _ H5); clear H_rec; intros H5;\n generalize (le_0_eq _ _ H5); clear H_rec; intros H6;\n generalize (le_0_eq _ _ H6); clear H_rec; intros H6;\n generalize (le_0_eq _ _ H6); clear H_recQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc.\nelim Hc; clear Hc Hc; intros Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hd Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hd Hh Hh Hh Hh Hh.\nelim Hc; clear Hc; intros Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hh Hh.\nelim Hc; clear Hc; intros Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hd Hc Hc Hc Hc Hc Hh Hg Hh.\nelim Hc; clear Hc; intros Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc HcQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H_rec H_rec H_rec H_rec.\nrewrite H_rec.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec; auto.\nrewrite H_rec;Qed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H1 H2 H3 H4.\napply (mult_reg_l a b c d d e H1 H2 H4).\napply (mult_reg_l a b c d d e H1 H2 H4).\napply (mult_reg_l a b c d d e H1 H2 H3).\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\n intros a b c d e H1 H2 H3 H4.\ngeneralize H3; clear H3; intros H5.\nrewrite H5 in H5.\ngeneralize (le_0_eq _ _ H1 H2); clear H3; intros H5.\nrewrite H5 in H6.\ngeneralize (le_0_eq _ _ H2 H3); clear H3; intros H6.\nrewrite H6 in H6.\ngeneralize (le_0_eq _ _ H1 H2); clear H3; intros H6.\nrewrite H6 in H6.\ngeneralize (le_0_eq _ _ H1 H3); clear H3; intros H6.\nrewrite H6 in H6.\ngeneralize (le_0_eq _ _ H1 H2); clear H3; intros H6.\nrewrite H6 in H6.\ngeneralize (lt_le_trans _ _ _ H2 H3); clear H3; intros H6.\nrewrite H6 in H6.\ngeneralize (le_0_eq _ _ H2 H3); clear H3; intros H6.\nrewrite H6 in HQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hd Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hh Hh Hh Hh Hh).\nintros a b c d e Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hh Hg Hh.\nintros a b c d e Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hg Hc Hc Hc Hc Hg Hg Hh Hh.\nintros a b c c d e Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hh Hg Hh Hh.\nintros a b c b c d e Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc Hc HcQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\nintros a b c d e Hab Hcd.\ngeneralize (le_0_eq _ _ Hab); intro Hc; clear Hab.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hab.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hab.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hab.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hc Hc.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hc Hc.\ngeneralize (lt_mult_compat_r _ _ Hab); intro Hc; clear Hc Hc.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hc Hc.\ngeneralize (lt_mult_compat_l _ _ Hab); intro Hc; clear Hc Hc.\ngeneralize (lt_mult_compat_r _ _ Hab); intro Hc; clear Hc Hc.\ngeneralize (lt_mult_compat_r _ _ Hab); intro Hc; clear Hc Hc.\nQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H_c H_c H_c H_c H_c H_c H_c H_c.\ngeneralize (le_plus_distr_l a b c d H_c H_c H_c H_c H_c H_c).\ngeneralize (le_plus_distr_l a b c d H_c H_c H_c H_c H_c H_c).\ngeneralize (le_plus_distr_l a b c d H_c H_c H_c H_c).\ngeneralize (le_plus_distr_r a b c d H_c H_c H_c H_c H_c).\ngeneralize (le_plus_distr_r a b c d H_c H_c H_c H_c).\ngeneralize (le_plus_distr_r a b c d H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_c H_cQed.",
                    "Let hyp_test : forall a b c d e, 0 <= a -> 0 < a -> a * b <= a * c -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nProof.\ngeneralize a b c d e H0 H1 H2; clear a b c d e H1 H2.\ngeneralize a.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.\nrewrite e; clear e.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NatSignTac.v",
                "context": "_l _ _ _ H s1);\n                   clear H s1; intros H])\n|   0  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (lt_mult_rev_0_l _ _ H);\n                    generalize (lt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 < 0 => absurd (~ (X1 < 0)); auto with arith\n|?X1 * _  <?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_lt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_lt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n| ?X1 >= 0 => clear H\n| 0 >=?X1  => generalize (le_0_eq_0 _ H); clear H; intros H; subst X1\n| ?X1 * _ >=?X1 * _ => \n             let s1 := fresh \"NS\" in\n                   (assert (s1: 0 < X1); [nsign_tac; fail |\n                   generalize (mult_ge_compat_rev_l _ _ _ H s1);\n                   clear H s1; intros H])\n| ?X1 * _ > 0 => \n              let s1 := fresh \"NS\" in\n                   (generalize (gt_mult_rev_0_l _ _ H);\n                    generalize (gt_mult_rev_0_r _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n|  0 >?X1 => absurd (~ (0 > X1)); auto with arith\n|?X1 * _  >?X1 * _ => \n              let s1 := fresh \"NS\" in\n                   (generalize (mult_gt_compat_rev_l1 _ _ _ H);\n                    generalize (mult_gt_compat_rev_l2 _ _ _ H); clear H;\n                    intros H s1; hyp_nsign_tac s1; hyp_nsign_tac H)\n  |  _ => (let u := type of H in (clear H; assert (H: u); [auto with arith; fail | clear H]) || idtac)\n              \n   end.\n\n(* Test *)\nSection Test.\n\nLet hyp_test : forall a b c d e, \n  0 <= a -> 0 < a -> a * b <= a * c  -> b * a <= b * c -> d <= 0 -> e < 0 -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H should disappear *)\nhyp_nsign_tac H.\n(* a in H2 should disappear *)\nhyp_nsign_tac H2.\n(* H3 unchanged *)\ntry hyp_nsign_tac H3.\n(* d should disappear *)\nhyp_nsign_tac H4.\n(* Prove it *)\nhyp_nsign_tac H5.\nQed.\n\n\n",
                "context_tokens": 718,
                "proof_start_offset": 5151,
                "proof_end_offset": 5516,
                "proof": "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nProof.\nintros a b c d e H H1 H2 H3 H4 H5.\nhyp_nsign_tac H.\nhyp_nsign_tac H2.\ntry hyp_nsign_tac H3.\nhyp_nsign_tac H4.\nhyp_nsign_tac H5.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3 H4.\n(* H1 = H2 *)\ninjection H0; intro H2.\ninjection H3; intro H4.\ninjection H4; intro H5.\ninjection H4; intro H6.\ninjection H4; intro H7.\ninjection H4; intro H7.\ninjection H5; intro H7.\ninjection H7; intro H7.\ninjection H5; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H8.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H8.\ninjection H7; intro H8.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro H7.\ninjection H7; intro HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\n(* H1 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H3 H4 H5).\n(* H2 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H4 H5).\n(* H3*)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H3 H4 H5).\n(* H4 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H4 H5).\n(* H5 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H3 H5).\n(* H6 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H3 H6).\n(* H6 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H1 H2 H3 H4 H5).\n(* H6 *)\ngeneralize (hyp_nsign_tac a b c d e H1 H2 H3 H1 H3 H6).\n(* HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3.\n(* H1 *)\nhyp_nsign_tac H2.\n(* H2 can be needed *)\nhyp_nsign_tac H3.\n(* H2 can be needed *)\nhyp_nsign_tac H2.\n(* H3 can be needed *)\nhyp_nsign_tac H3.\n(* H3't be needed *)\nQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3 H4.\n(* H1 *)\ninjection H1; clear H1.\n(* H2 *)\ninjection H2; clear H2.\n(* H3 *)\ninjection H2; clear H2.\n(* H4 *)\ninjection H2; clear H2.\n(* H4 *)\ninjection H2; clear H2.\n(* H4 *)\ninjection H3; clear H3.\n(* H4 *)\ninjection H3; clear H3.\n(* H4 *)\ninjection H4; clear H4.\n(* H4 *)\ninjection H4; clear H4.\n(* H5 *)\ninjection H4; clear H4.\n(* H6 *)\ninjection H4; clear H4.\n(* H5 *)\ninjection H4; clear H4.\n(* H5 *)\ninjection H4; clear H4.\n(* H5 *)\ninjection H5; clear H5.\n(* H6 *)\ninjection H5; clear H5.\n(* H6 *)\ninjection H5; clear H5.\n(* H6 *)\ninjection H5; clear H5.\n(*Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4.\n(* H1 = One *)\nhyp_nsign_tac H2.\n(* H2 = One *)\nhyp_nsign_tac H2.\n(* H3 = One *)\nhyp_nsign_tac H3.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H4 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = One *)\ninjection H_rec.\n(* H3 = OneQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros.\napply hyp_rec_r_always_r with (a := a) (b := a) (c := b) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (d := d) (Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H1 H2 H3 H4 H5.\n(* H1 *)\ngeneralize a b c d e H1 H2 H3 H4 H5.\nrewrite e in H3.\ngeneralize a b c d e H1 H2 H3 H4 H5.\nrewrite e in H3.\ngeneralize b c d e H1 H3 H4 H5.\nrewrite e in H3.\ngeneralize b c d e H1 H3 H4 H5.\nrewrite e in H3.\ngeneralize a b c d e H1 H3 H4 H6.\nrewrite e in H3.\ngeneralize b c d e H1 H3 H4 H6.\nrewrite e in H3.\ngeneralize b c d e H2 H3 H4 H6.\nrewrite e in H3.\ngeneralize b c d e H3 H4 H6.\nrewrite e in H3.\ngeneralize b c d e H3 H4 H6.\nrewrite e in H3.\ngeneralize b c d e H3 H4 H6.\nrewrite e in H3.\ngeneralize b c d e H3 H4 HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3.\nrewrite H0 in H1.\ninjection H1; intro H3; rewrite H2 in H2; clear H3.\ninjection H1; intro H4; rewrite H4 in H2; clear H4.\ninjection H1; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H3; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite H4 in H2; clear H4.\ninjection H2; intro H2; rewrite HQed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H H0 H1 H2 H3 H4.\n(* H1 *)\nhyp_nsign_tac H1.\n(* H2 *)\nhyp_nsign_tac H2.\n(* H3factor*)\ninjection H_n3.\n(* H3factor*)\ninjection H_n3.\n(* H4factor *)\ninjection H_n3.\n(* H4factor *)\ninjection H_n3.\n(* H2*)\ninjection H_n3.\n(* H3factor *)\ninjection H_n3.\n(* H2 *)\ninjection H_n3.\n(* H4factor *)\ninjection H_n3.\n(* H2*)\ninjection H_n3.\n(* H2*)\ninjection H_n3.\n(* H2*)\ninjection H_n3.\n(* H2*)\ninjection H_n3.\n(* H2 *)\ninjection H_n3.\n(* H2*)\ninjection H_n3.\n(* H2 *)\ninjection H_n3.\n(* H2 *)\ninjection H_n3.\n(* H2*)\ninjection H_Qed.",
                    "Let hyp_test1 : forall a b c d e, a >= 0 -> a > 0 -> a * b > a * c -> b * a >= b * c -> 0 >= d -> 0 > e -> d = 0.\nintros a b c d e H1 H2 H3 H4.\nrewrite H4 in H4.\nrewrite H4 in H4.\ninjection H4; [ omega | assumption ].\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\n",
                "context_tokens": 329,
                "proof_start_offset": 839,
                "proof_end_offset": 971,
                "proof": "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nProof.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p H1; inversion H1. \nintros n1 H1; inversion H1.\nintros n1 H1; inversion H1.\nintros n2 H2; inversion H1.\nintros n2 H2; inversion H2.\nintros n3 H3; inversion H3.\nintros n3 H4; inversion H4.\nintros m1 n3 H4; inversion H4.\nintros n4 H5; inversion H5.\nintros m1 n4 H5; inversion H5.\nintros n4 H6; inversion H5.\nintros n4 H6; inversion H6.\nintros n4 H6; inversion H6.\nintros n4 H6; inversion H7.\nintros n4 H6; inversion H8.\nintros n4 H6; inversion H8.\nintros n4 H6; inversion H8.\nintros n4 H6; inversion H9.\nintros n4 H6; inversion H8.\nintros n4 H6; inversion H9.\nintros n4 H6; inversion H8Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p; elim p; intros p; elim p; intros p; elim p; intros p; elim p; intros p; elim p; intros p;\n apply nat_of_P_gt_Gt_compare_morphism; auto.\nintros p; elim p; intros p; elim p; intros p; elim p; intros p; elim p; intros p;\n apply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; simpl; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; auto with arith.\nintros p; elim p; autoQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; simpl; auto with arith.\nintros p q; case (le_or_lt p q); auto with arith.\nintros p; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q); auto with arith.\nintros p0; elim (le_or_lt p q);Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros m1 n1 H1; case H1; auto with arith.\nintros m2 n2 H2; case (le_or_lt n2 m1); auto with arith.\nintros n3 H3; case (le_or_lt n3 m2); auto with arith.\nintros n4 H5; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n1 H1; case (le_or_lt n1 n2); auto with arith.\nintros n4 H5; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n1 H1; case (le_or_lt n1 n2); auto with arith.\nintros n5 H6; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n1 H1; case (le_or_lt n1 n2); auto with arith.\nintros n5 H6; case H1Qed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m H; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros m1 n2 H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nintros n1 H1; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n2 H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n2 H2; case H2.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n3 H3; case H3.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n1 H2; case H3.\napply nat_of_P_gtQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nintros n1 H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros n2 H2; case (le_or_lt n2 m2); auto with arith.\nintros H3; case H3.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite nat_of_P_o_P_of_succ_morphism; auto with arith.\nQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; autoQed.",
                    "Theorem Nle_le_rev: forall n m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.\nintros p; elim p; simpl; auto with arith.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 386,
                "proof_start_offset": 973,
                "proof_end_offset": 1244,
                "proof": "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 n1); auto with arith.\nintros n2 H2; case (le_or_lt n2 m1); auto with arith.\nintros n3 H3; case (le_or_lt n2 n3); auto with arith.\nintros n4 H5; case (le_or_lt n2 n3); auto with arith.\nintros n5 H6; case (le_or_lt n2 n4); auto with arith.\nintros n5 H7; case (le_or_lt n3 n4); auto with arith.\nintros n5 H6; case (le_or_lt n2 n5); auto with arith.\nintros n6 H7; case (le_or_lt n2 n5); auto with arith.\nintros n6 H7; case (le_or_lt n2 n6); auto with arith.\nintros n7 H8; case (le_or_lt n2 n6); auto with arith.\nintros n7 H8;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n2 H1; case (le_or_lt m1 n2); auto with arith.\nintros H2; case H2; auto.\nintros n2 H2; case (le_or_lt m1 n2); auto with arith.\nintros m2 n2 H2; case H2; auto with arith.\nintros m2 n2 H2; case (le_or_lt m2 n2); auto with arith.\nintros m2 n3 H3; case (le_or_lt m2 n2); auto with arith.\nintros n3 n4 H5; case H6; auto.\nintros m2 n4 H5; case (le_or_lt m2 n4); auto with arith.\nintros m3 n4 H5; case H6; auto with arith.\nintros m4 n5 H6; case H7; auto with arith.\nintros m3 n4 H6; case (le_or_lt m1 n2);Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros p H1; inversion H1.\nintros p H2; inversion H2.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H4; inversion H4.\nintros p H5; inversion H5.\nintros p H5; inversion H5.\nintros p H5; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6. inversion H6.\nintros p H6; inversion H6.\nintros p H6 H7. inversion H7.\nintros p H7 H8.\ncase (le_or_lt 0 p); auto with arith.\nintros p7 H9; inversion H8.\nintros p7 H9.\ncase (le_or_lt 0 p); auto with arith.\nintros p7 H9; inversion H9.\nintros p8 H9.\ncase (le_or_lt 0 p); auto with arith.\nintros p8 H9Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind; simpl; auto with arith.\nintros p; elim p using Pind;Qed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply lt_irrefl; apply lt_O_Sn.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros p1 p2 H1; case (le_or_lt p1 p2); auto with arith.\nintros p2 H2; case (le_or_lt p2 p2); auto with arith.\nintros p3 H3; case (le_or_lt p1 p2); auto with arith.\nintros p4; case (le_or_lt p2 p2); auto with arith.\nintros p4; case (le_or_lt p1 p2); auto with arith.\nintros p5; case (le_or_lt p2 p3); auto with arith.\nintros p5; case (le_or_lt p2 p5); auto with arith.\nintros p5; case (le_or_lt p3 p5); auto with arith.\nintros p5; case (le_or_lt p1 p5); auto with arith.\nintros p5; case (le_or_lt p3 p6); auto with arith.\nintros p5; case (le_or_lt p2 p6); auto withQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros p; elim p using Pind; simpl.\nintros p; elim p using Pind; simpl.\nintros p; elim p using Pind; simpl.\nintros p q; elim p using Pind; simpl.\nintros p q; elim p using Pind; simpl.\nintros p q; elim q using Pind; simpl.\nintros p q; elim q using Pind; simpl.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintros p q; elim q; simpl; auto.\nintrosQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros; apply Nlt_le_rev; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 n2); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto with arith.\nintros n1 H2; case (le_or_lt n1 n2); auto with arith.\nintros H3; case (le_or_lt n1 n2); auto with arith.\nintros H3; case H1.\napply nat_of_P_gt_Gt_compare_morphism; auto with arith.\nQed.",
                    "Theorem Nlt_lt: forall n m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; unfold N.le; simpl; auto with arith.\nintros n1 H1; case (le_or_lt n1 m); auto with arith.\nintros n2 H2; case (le_or_lt n2 m1); auto with arith.\nintros m1 n2 H2; case (le_or_lt n2 m2); auto with arith.\nintros m1 n2 H2; case (le_or_lt n2 m1); auto with arith.\nintros m2 n2 H2; case (le_or_lt n2 m2); auto with arith.\nintros m2 n3 H2; case (le_or_lt n2 m1); auto with arith.\nintros n3 n3 H2; case (le_or_lt n2 m1); auto with arith.\nintros m3 n3 H2; case (le_or_lt n2 m2); auto with arith.\nintros m3 n4 H2; case (le_or_lt n2 m3); auto with arith.\nintros m3 n4 H2; case (le_or_lt nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\n",
                "context_tokens": 490,
                "proof_start_offset": 1246,
                "proof_end_offset": 1540,
                "proof": "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nProof.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1.\napply lt_le_trans with (m := n1); auto with arith.\nintros p H2; case H2.\napply lt_le_trans with (m := n1); auto with arith.\nintros p H3; case H3.\napply lt_le_trans with (m := n1); auto with arith.\nintros p H3; case H3.\napply lt_le_trans with (m := n2); auto with arith.\nintros p H3; case H3.\napply lt_le_trans with (m := n1); auto with arith.\nintros p H3; case H3.\napply lt_le_trans with (m := n1); auto with arith.\nintros p H3; case H3.\napply lt_le_trans with (m := n2); auto with arith.\nintros p H3; case H3.\napply lt_le_trans with (m := n1); auto with arith.\nintros p H3; case H3Qed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros p H1; inversion H1.\nintros p1 p2 H2; inversion H1.\nintros p2 H2; inversion H2.\nintros p2 H3; inversion H3.\nintros p3 p4; inversion H1.\nintros p4; inversion H1.\nintros p5; inversion H1.\nintros p6; inversion H2.\nintros p7; inversion H1.\nintros p7; inversion H1.\nintros p7; inversion H1.\nintros p8; inversion H1.\nintros p8; inversion H2.\nintros p9; inversion H1.\nintros p9; inversion H1.\nintros p10; inversion H2.\nintros p10; inversion H1.\nintros p12; inversion H1.\nintros p12; inversion H1.\nintros p13; inversion H1.\nintros p13; inversion H1.\nintros p12; inversion H1.\nintros p13; inversion H1.\nintros p13; inversion H1.\nintros p14; inversion H1.\nQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate).\nintros p H1; inversion H1.\nintros p H2; inversion H1.\nintros p H2; inversion H1.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintrosQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case m; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.lt; simpl; auto with arith.\nintros p; elim p; unfold N.lt; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros p; elim p; unfold N.le; simpl; auto with arith.\nintros pQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate).\nintros n1 H1; inversion H1.\nintros p1 H1; inversion H1.\nintros p2 H2; inversion H1.\nintros p2 H2; inversion H2.\nintros p2 H3; inversion H3.\nintros p3 H4; inversion H4.\nintros p4; inversion H4.\nintros p5; inversion H4.\nintros p5; inversion H5.\nintros p6; inversion H6.\nintros p7; inversion H7.\nintros p7; inversion H7.\nintros p7; inversion H7.\nintros p7; inversion H8.\nintros p7; inversion H8.\nintros p7; inversion H9.\nintros p8; inversion H9.\nintros p8; inversion H9.\nintros p9; inversion H10.\nintros p9; inversion H9.\nintros p10; inversion H10.\nintros p12; inversion H10.\nintros p12; inversion H11.\nintros p12; inversion H13.\nintros p13; inversion HQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H1; inversion H1.\nintros p H2; inversion H1.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H2; inversion H2.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H2.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros p H3; inversion H3.\nintros pQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; unfold N.lt; simpl; auto with arith.\nintros p H1; inversion H1.\nintros p H2; inversion H2.\nintros p H3; inversion H3.\nintros p H3; inversion H4.\nintros p H4; inversion H4.\nintros p H5; inversion H5.\nintros p H5; inversion H5.\nintros p H5; inversion H5.\nintros p H5; inversion H5.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6; inversion H6.\nintros p H6 H7; inversion H7.\nintros p H7; inversion H6.\nintros p H8; inversion H8.\nintros p H9; inversion H9.\nintros p H9; inversion H9.\nintros p H9; inversion H9.\nintros p H9; inversion H9.\nintros p0 H9; inversion H9.\nintros p0 H9; inversion H9.\nintros p H9; inversion H9.\nintros p H9; inversion H9.\nintros pQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; auto with arith.\nintros n1 H1; inversion H1.\nintros p1; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p2; inversion H1.\nintros p3; inversion H1.\nintros p3; inversion H1.\nintros p4; inversion H1.\nintros p4; inversion H1.\nintros p5; inversion H1.\nintros p6; inversion H1.\nintros p6; inversion H1.\nintros p6; inversion H1.\nintros p7; inversion H1.\nintros p8; inversion H1.\nintros p7; inversion H1.\nintros p7; inversion H1.\nintros p8; inversion H1.\nintros p8; inversion H1.\nintros p9; inversion H1.\nintros p9; inversion H1.\nintros p9; inversion H1.\nintros p9; inversion H1.\nintros p9; inversion H1.\nintros p9; inversion H1.\nintros p10; inversion HQed.",
                    "Theorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros; apply lt_irrefl with (N.to_nat n).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NAux.v",
                "context": "Require Export NArith.\nRequire Import ZArith.\n\nOpen Scope N_scope.\n\nTheorem Nle_le: forall n  m, (N.to_nat n <= N.to_nat m)%nat -> n <= m.\nintros n m; case n; case m; unfold N.le; simpl; try (intros; discriminate).\nintros p; elim p using Pind; simpl.\nintros H1; inversion H1. \nintros n1 _; rewrite nat_of_P_succ_morphism.\nintros H1; inversion H1.\nintros p1 p2 H1 H2; absurd (nat_of_P p2 > nat_of_P p1)%nat; auto with arith.\napply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.\n\nTheorem le_Nle: forall n m, N.of_nat n <= N.of_nat m -> (n <= m)%nat.\nintros n m; case n; case m; unfold N.le; simpl; auto with arith.\nintros n1 H1; case H1; auto.\nintros m1 n1 H1; case (le_or_lt n1 m1); auto with arith.\nintros H2; case H1.\napply nat_of_P_gt_Gt_compare_complement_morphism.\nrepeat rewrite  nat_of_P_o_P_of_succ_nat_eq_succ; auto with arith.\nQed.\n\nTheorem Nle_le_rev: forall n  m, n <= m -> (N.to_nat n <= N.to_nat m)%nat.\nintros; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_lt: forall n  m, (N.to_nat n < N.to_nat m)%nat -> n < m.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros H1; inversion H1.\nintros p H1; inversion H1.\nintros; apply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.\n\nTheorem lt_Nlt: forall n m, N.of_nat n < N.of_nat m -> (n < m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.\n\n",
                "context_tokens": 610,
                "proof_start_offset": 1542,
                "proof_end_offset": 1672,
                "proof": "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nProof.\nintros; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p H1; inversion H1.\nintros p H2.\nrewrite <- (Nat2N.id (S n1))); rewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S m1)).\nsimpl; apply nat_of_P_gt_Gt_compare_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S n1));\n rewrite <- (Nat2N.id (S n1)); simpl; auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros m1 n1 H1.\nrewrite <- (Nat2N.id (S n1)); rewrite <- (Nat2N.id (S n1)); auto with arith.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; auto with arith.\nintros m1 n2 H2; case (le_or_lt n1 m1); auto with arith.\nintros m2 n2 H2; case (le_or_lt n2 m2); auto with arith.\nintros m1 n2 H2; case (le_or_lt n2 m1); auto with arith.\nintros m2 n2 H2; case (le_or_lt n2 m2); auto with arith.\nintros m3 n2 H3; case (le_or_lt n2 m1); auto with arith.\nintros m3 n3 H4; case (le_or_lt n2 m2); auto with arith.\nintros m3 n4 H5; case (le_or_lt n2 m3); auto with arith.\nintros m3 n4 H5; case (le_or_lt n2 m3); auto with arith.\nintros m3 n4 H5; case (le_or_lt n2 m3); auto with arith.\nintros m4 n5 H6;Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 m1 n2; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 m2; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 m2; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n2 m1 n2; case m2; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 m2; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 m2; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n2 m2; case m2; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros m1 n2; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 H1; case H1.\napply nat_of_P_lt_Lt_compare_complement_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n1 m1; case m1; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros n2 H1.\nrewrite <- (Nat2N.id (S n1)); simpl; apply nat_of_P_lt_Lt_compare_morphism; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; auto with arith.\nintros m1 n2 H1.\nrewrite <- (Nat2N.id (S m1)); rewrite <- (Nat2N.id (S m1)); simpl; auto.\nQed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; case m; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p H1; inversion H1.\nintros p0 H2; inversion H1.\nintros p0 H2; inversion H1.\nintros p0 H3; inversion H3.\nintros p0 H3; inversion H4.\nintros p0 H4; inversion H5.\nintros p0 H5; inversion H6.\nintros p0 H5; inversion H6.\nintros p0 H6; inversion H6.\nintros p0 H6; inversion H6.\nintros p0 H7; inversion H6.\nintros p0 H5; inversion H6.\nintros p0 H6; inversion H6.\nintros p0 H7; inversion H6.\nintros p0 H7; inversion H7.\nintros p0 H7; inversion H7.\nintros p0 H7; inversion H7.\nintros p0 H7; inversion H7.\nintros p0 H8; inversion H7.\nintros p0 H8; inversion H8.\nintros p0 H9; inversion H9.Qed.",
                    "Theorem Nlt_lt_rev: forall n m, n < m -> (N.to_nat n < N.to_nat m)%nat.\nintros n m; case n; unfold N.lt; simpl; try (intros; discriminate); auto.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.lt; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.le; simpl; try (intros; discriminate); auto with arith.\nintros p; elim p; unfold N.lt; simpl; try (introsQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\n",
                "context_tokens": 20,
                "proof_start_offset": 66,
                "proof_end_offset": 153,
                "proof": "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n  intros.\n  destruct x; destruct y; simpl in *; omega.\n  apply (N.lt_irrefl (N.lt_irrefl (N.lt_irrefl x)).\n  rewrite (N.le_irrefl (N.lt_refl x)).\n  rewrite (N.le_antisym x y).\n  apply N.lt_trans with (N.lt x y).\n  apply N.lt_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.lt_trans with (N.lt x y).\n  apply N.lt_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (N.lt x y).\n  apply N.le_trans with (Qed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros. apply H.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n).\n rewrite <- (Pos.iter_succ n) at 1.\n apply Pos.iter_add.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct x; simpl in *; try discriminate; simpl in *.\n rewrite <- (mult_comm x y).\n apply Rmult_le_compat_r.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct x; simpl.\n destruct y; simpl; trivial.\n apply (lt_irrefl y).\n rewrite (lt_trans y x). apply le_trans with (y + x).\n apply le_trans with (y + x).\n rewrite <- (le_plus_r x y). apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n rewrite <- (le_plus_r x y). apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n rewrite (le_plus_r y x). apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\n apply le_trans with (y + x).\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n induction x; destruct y; simpl; intros.\n omega.\n destruct (le_gt_dec x y); [left|right]; auto.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y [H|H]; apply H.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct x; simpl; trivial.\n destruct y; simpl; trivial.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros x y.\n unfold pols.\n case_eq (leb x y); intros.\n rewrite H.\n rewrite H0.\n rewrite mult_comm.\n rewrite mult_comm.\n apply H.\nQed.",
                    "Theorem pols_test1: forall x y: N, x < y -> (x + x < y + x).\nProof.\n intros.\n destruct x; simpl in *.\n now rewrite <- (Pos.add_comm x).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 63,
                "proof_start_offset": 155,
                "proof_end_offset": 234,
                "proof": "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\ncos.\napply Rle_trans with (1 + y).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rlt_le_trans with (2 * y + x).\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rlt_le_trans with (1 + y).\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rlt_le_trans with (2 * y + x).\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rlt_le_trans with (2 * y + x).\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rlt_le_trans with (2 * y + x).\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rlt_leQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nups.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nRewriteVar (x + y) (y + y)).\napply H.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_r.\napply Rplus_le_compat_l.\napply Rplus_le_compatQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nups.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nam_bound x y.\napply le_lt_trans with (1:=y).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_l (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_lt_trans with (1:=y).\nrewrite <- (mult_1_r (1/2)).\napply le_le_trans with (1:=y).\nrewrite <- (Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nglb_spec.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_Qed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nAbss.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nreps.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nups.\nauto.\nQed.",
                    "Theorem pols_test2: forall x y, y < 0 -> (x + y < x).\nintros.\nlocal_eq (x + y) (x + y) H.\nrewrite H.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 101,
                "proof_start_offset": 237,
                "proof_end_offset": 357,
                "proof": "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply RmultQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nbasics.\nauto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ncos.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_lQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nrewrite Rmult_plus_distr_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply RmultQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nbasics.\nauto.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rmult_lt_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply RmultQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\n15.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\napply Rplus_le_compat_l.\nQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\ncontradict H.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_rQed.",
                    "Theorem pols_test4: forall x y, x * x < y * y -> ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\nbasic_spec.\nrewrite Z.add_comm.\nrewrite Z_div_plus.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.\nrewrite Z_div_mult.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \n",
                "context_tokens": 162,
                "proof_start_offset": 360,
                "proof_end_offset": 482,
                "proof": "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nProof.\nintros.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\npattern z at 2 3 ; replace z with (2 * z + 2 * z + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * y + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 *Qed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\n15.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ninduction u as [ | v IH u IH u IH]; simpl in *; auto.\nsimpl in IH.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimpl.\nrewrite IH.\nsimplQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nAbss.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nFFs.\nrewrite H.\nring.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\n ffs.\nauto.\nQed.",
                    "Theorem pols_test5: forall x y z, x + y * (y + z) = 2 * z -> 2 * x + y * (y + z) = (x + z) + z.\nintros.\nFFs.\napply (pow_correct x y z H1).\nrewrite (mult_comm y z), <- H1.\nrewrite (mult_comm z), <- H2.\nrewrite (mult_comm x), <- H1.\nrewrite (mult_comm x), <- H2.\nrewrite (mult_comm x), <- H1.\nrewrite <- H1.\nrewrite (mult_comm x), (mult_comm x), <- H2.\nrewrite (mult_comm x), <- H1.\nrewrite (mult_comm x), <- H2.\nrewrite (mult_comm x), <- H1.\nrewrite (mult_comm x), <- H1.\nrewrite <- H1.\nrewrite (mult_comm x), <- H2.\nrewrite (mult_comm x), <- H1.\nrewrite (mult_comm x), (mult_comm x), <- H1.\nrewrite (mult_comm x), (mult_comm x), <- H1.\nrewrite (mult_comm x), (mult_comm x), <- H1.\nrewrite (mult_comm x), (mult_comm x), <- H1.\nrewriteQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\n",
                "context_tokens": 225,
                "proof_start_offset": 485,
                "proof_end_offset": 561,
                "proof": "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply RmultQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nrewrite H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite <- H.\nrewrite H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewrite <- H.\nrewriteQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncos.\nomega.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\npattern y at 1; replace y with ((x + y) + (1 * x)) by ring.\nrewrite 2 2!plus_comm.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plus_assoc.\nrewrite 2!plusQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncos.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nassert (H: forall x y, y > 0 -> 2 * x > y * (x + y)).\nintros.\nassert (H: forall x y, y > 0 -> 2 * x > y * y).\nintros.\nassert (H: forall x y, y > 0 -> 2 * x > y * y).\nintros.\napply H0.\napply H.\napply H.\napply H.\napply H.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nomega.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\ncos.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\n parity_f1.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (1 <= y -> x <= x * y).\nintros.\nassert (forall x y, x + y = 2 * x + 2 * x + 2 * y).\nintros.\nrewrite H.\nrewrite H.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 261,
                "proof_start_offset": 563,
                "proof_end_offset": 659,
                "proof": "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nProof.\nintros.\nhyp_polf H0.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrepf.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nrepf.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_gt_0_le.\napply H.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nincr_lt (x * y) (y * x + y * y).\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_leQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nassert (H: (1 <= y /\\ x <= y /\\ x <= y /\\ x <= y)).\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H0.\napply H.\napply H.\napply H.\napply H0.\napply H0.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncof_equal.\napply Rle_trans with (1 + y * x).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_Qed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_gt_0_l in H1.\napply H.\nQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\ncof_equal.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compatQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_gt_0_compat.\nrewrite H.\nring_simplify_eq.\nrewrite <- (mult_1_l 2).\nring_simplify_eq.\nrewrite <- (mult_1_l 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_r 2).\nring_simplify_eq.\nrewrite <- (mult_1_l 2).\nring_simplify_eqQed.",
                    "Theorem polf_test2: forall x y, 0 < x -> x <= x * y -> 1 <= y.\nintros.\nco_gt_0_r.\napply Rle_trans with (2 * x * y * 2 * 2 * 2 + y * 2 * 2).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_rQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Nex.v",
                "context": "Require Import PolTac.\nRequire Import NAux.\n\nOpen Scope N_scope.\n\nTheorem pols_test1: forall x y: N,  x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n\nTheorem pols_test2: forall x y, y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test4:\n forall x y,\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\n\nTheorem polf_test1: forall x y, (1 <= y -> x  <= x  * y).\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, 0 < x -> x  <= x  * y -> 1 <= y.\nintros.\nhyp_polf H0.\nauto.\nQed.\n\n\n\n",
                "context_tokens": 307,
                "proof_start_offset": 663,
                "proof_end_offset": 781,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rle_trans with (2*y).\nrewrite <- H1.\nring.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\ndestruct H0.\nrewrite H0.\ntrivial.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (le_gt_cases x y H0).\nomega.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply RmultQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (le_gt_cases x y z).\nintros.\ncontradict H0.\napply le_lt_trans with (2*y).\napply le_trans with (2*z).\napply le_plus_r.\napply le_trans with (2*z).\napply le_minus_r.\napply le_minus_r.\napply le_trans with (2*z).\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply le_minus_r.\napply leQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (le_gt_cases x y).\ngeneralize (le_gt_cases x y).\nclear H0.\nintro.\nomega.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H := proj1 H).\nrewrite H in H0.\nclear H0.\nrevert x H0.\ninduction H0; intros.\nrewrite H0 in H0.\nomega.\nassert (H0 := proj1 H0).\nrewrite H in H0.\nclear H0.\nrevert y H0.\ninduction H0; intros.\nrewrite H0 in H1.\nomega.\nassert (H1 := proj2 H0).\nrewrite H in H0.\nclear H0.\nrewrite H in H0.\nclear H0.\nrevert x H0.\ninduction H0; intros.\nrewrite H0 in H0.\nomega.\nassert (H0 := proj2 H0).\nrewrite H in H0.\nclear H0.\nrewrite H0 in H0.\nclear H0.\ninduction H0; intros.\nrewrite H0 in H0.\nomega.\nassert (H1 := proj2 H0).\nrewrite H in H0.\nclear H0.\nrewrite H0 in H0.\nclear H0.\ninduction H0; intros.\nrewrite H0 inQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ngeneralize (lt_gt_cases x y).\nomega.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*y -> x * z < 2*y).\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*z -> x * y < 2*y).\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*z -> x * y < 2*z).\nintros.\nassert (H': forall x y z, z < 2*y -> x * y < 2*z).\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*z).\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*z).\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*z).\nintros.\nassert (H: forall x y z, z < 2*y -> x * y < 2*z).\nintros.\nassert (H: forall x y z, z < 2Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nset (l := 2 * y) in *.\nset (l' := 2 * y) in *.\nset (l' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nset (l'' := 2 * y) in *.\nsetQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 223,
                "proof_start_offset": 611,
                "proof_end_offset": 812,
                "proof": "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nProof.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_le_incl; repeat rewrite N2Nat.inj_mul.\napply Plus.mult_le_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le_compat_l; apply lt_O_n.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_le_compat_l; apply le_stepl; repeat rewrite N2Nat.inj_mul.\napply (lt_O_n_n (m * p) (m * p) (n * p)).\napply le_trans with (m * p); auto.\napply le_trans with (m * p); auto.\napply le_trans with (m * p); auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nlt_le_incl; repeat rewrite N2Nat.inj_mul.\napply div2_ge_compat_l; apply lt_O_Sn_m.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply Pos.mul_le_reg_r with (m := p).\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_r; apply lt_O_n.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Plus.mult_le_compat_l; apply le_O_n.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Pos.le_lt_le_compat_l; apply le_n_Sm; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_le_compat_l; apply le_Pmult_pos_lt; auto.\nQed.",
                    "Theorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_r; apply lt_O_le; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 303,
                "proof_start_offset": 814,
                "proof_end_offset": 1025,
                "proof": "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nProof.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nle_lt_trans with (m * p).\napply mult_lt_compat_l; apply lt_O_n.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply lt_O_n.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le_trans with (m * p); auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le_trans with (p * n + p * n).\nrewrite <- (mul_comm (n * p)).\napply mult_le_compat_l; apply le_O_n.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le_trans with (m * p).\napply mult_le_compat_l; apply le_stepl; repeat rewrite N2Nat.inj_mul.\napply le_O_n; auto.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_r; apply le_O_Sn.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nlt_le_incl; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_O_n.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply lt_O_n.\nQed.",
                    "Theorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Nge_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_O_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 389,
                "proof_start_offset": 1027,
                "proof_end_offset": 1270,
                "proof": "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_O_n; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le_trans with (n * p).\napply lt_le_trans with (n * p).\napply lt_le_trans with (m * p).\napply le_0_n.\napply le_n_Sn.\napply le_n_Sn.\napply le_n_Sn.\napply le_S_n.\napply le_trans with (m * p).\napply le_n_Sn.\napply le_S_n.\napply le_S_n.\napply le_trans with (m * p).\napply le_n_Sn.\napply le_n_Sn.\napply le_S_n.\napply le_S_n.\napply le_n_Sn.\napply le_S_n.\napply le_n_Sn.\napply le_S_n.\napply le_S_n.\napply le_n_Sn.\napply le_S_n.\napply le_S_n.\napply le_n_Sn.\napply le_S_n.\napply le_n_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_lt_trans with (p * n <= p * m).\napply mult_le_compat_l; apply le_Pmult_pos_le; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le_trans with (p * m); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_INR; apply lt_O_Sn.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le_trans with (m * p); auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_Pmult_nat_pos.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le_trans with (p * n + p).\napply (fun p m => mult_le_compat_l n m p H1).\nQed.",
                    "Theorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1 H2; apply Nlt_le_compat_l; apply lt_O_n.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "(* Ugly tacty to resolve sign condition for N *)\nRequire Import NatSignTac.\nRequire Import NAux.\nRequire Import NArith.\nRequire Import List.\nRequire Export NGroundTac.\n\nOpen Scope N_scope.\n\nTheorem Nmult_lt_compat_l: forall n m p, n < m -> 0 < p -> p * n < p * m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_l: forall n m p, n <= m -> p * n <= p * m.\nintros n m p H1; apply Nle_le; repeat rewrite N2Nat.inj_mul.\napply Mult.mult_le_compat_l; apply le_Nle; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_l: forall n m p, n >= m -> p * n >= p * m.\nintros n m p H1; apply Nge_ge; repeat rewrite N2Nat.inj_mul.\napply mult_ge_compat_l; apply ge_Nge; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_gt_compat_l: forall n m p, n > m -> p > 0 -> p * n > p * m.\nintros n m p H1 H2; apply Ngt_gt; repeat rewrite N2Nat.inj_mul.\napply mult_gt_compat_l; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_lt_compat_rev_l1: forall n m p, p * n < p * m -> 0 < p.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l1 with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 493,
                "proof_start_offset": 1272,
                "proof_end_offset": 1502,
                "proof": "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nProof.\nintros n m p H1; apply Nlt_lt; apply mult_lt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply lt_O_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le_incl; apply lt_le_incl.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply lt_O_gt; apply lt_O_gt; apply lt_O_gt; apply lt_O_gt; apply lt_O_gt;\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt; apply mult_le_compat_l; apply lt_O_le; repeat rewrite N2Nat.inj_mul.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le; apply le_0_n.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul; apply le_O_gt; repeat rewrite N2Nat.id; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nle_lt; repeat rewrite N2Nat.inj_mul.\napply mult_lt_compat_l; apply lt_O_nat; auto.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_le_reg_l with (nat_of_N n) (nat_of_N m).\nrepeat rewrite <- N2Nat.inj_mul; apply lt_O_nat_of_N.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt; repeat rewrite N2Nat.inj_mul.\napply mult_le_compat_l; apply le_O_nat.\nQed.",
                    "Theorem Nmult_lt_compat_rev_l2: forall n m p, p * n < p * m -> n < m.\nintros n m p H1 H2; apply Nlt_lt; apply Pos.lt_le_incl; repeat rewrite N2Nat.id; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " p * n > p * m -> n > m.\nintros n m p H1; apply Ngt_gt; apply mult_gt_compat_rev_l2 with (nat_of_N p).\nrepeat rewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_le_compat_rev_l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 3553,
                "proof_end_offset": 3760,
                "proof": "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nProof.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a).\nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Ngt_le; rewrite N2Nat.inj_mul; apply lt_mult_rev_l. \nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H; apply Ngt_le_incl; apply lt_mult_rev_0_r.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_le_incl; apply lt_mult_rev_0_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_gt; apply lt_mult_rev_0_r. \nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Ngt_gt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_0_r.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Ngt_gt; apply lt_mult_rev_0_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1; apply Nlt_le_trans with (n * b).\nrewrite <- N2Nat.inj_mul; apply lt_mult_rev_l; apply lt_mult_rev_l.\nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Ngt_le; apply lt_mult_rev_0_r. \nQed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Nlt_le_trans with (n * b).\nrewrite <- (mult_comm (a * b) (b * b)).\nrewrite (plus_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a * b) (b * b)).\nrewrite (mult_comm (a *Qed.",
                    "Theorem Ngt_mult_rev_0_r: forall a b, a * b > 0 -> b > 0 .\nintros a b H1 H2; apply Nle_lt; rewrite N2Nat.inj_mul; apply lt_mult_rev_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": "l: forall n m p, p * n <= p * m -> 0 < p -> n <= m.\nintros n m p H1 H2; apply Nle_le; apply mult_le_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply le_Nle; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3762,
                "proof_end_offset": 3929,
                "proof": "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nlt_0_lt; apply lt_le_incl; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nlt_0_le; apply le_0_n.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nle_0_eq; apply lt_le_0_n. Qed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nle_0_eq_0; apply lt_0_le; apply lt_0_le; apply lt_0_le; auto.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1 H2; apply Nle_0_eq_0; apply le_0_1.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nle_0_eq_0; apply eq_0_sym.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; rewrite <- (N2Nat.inj_mul n (N.of_nat n)).\napply Nlt_0_eq_0.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nlt_0_lt; apply le_0_n.\nQed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H; apply Nle_0_eq_0; auto. Qed.",
                    "Theorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n; apply Nlt_0_lt; apply lt_0_0_lt; apply lt_0_1.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/NSignTac.v",
                "context": " rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nmult_ge_compat_rev_l: forall n m p, p * n >= p * m -> 0 < p -> n >= m.\nintros n m p H1 H2; apply Nge_ge; apply mult_ge_compat_rev_l with (nat_of_N p). \nrepeat rewrite <- N2Nat.inj_mul; apply ge_Nge; repeat rewrite N2Nat.id; auto.\napply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_0: forall a b, 0 < a -> 0 < b -> 0 < a * b.\nintros a b H1 H2; apply Nlt_lt; rewrite N2Nat.inj_mul; apply lt_mult_0; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_0: forall a b, a > 0 -> b > 0 -> a * b > 0.\nintros a b H1 H2; apply Ngt_gt; rewrite N2Nat.inj_mul; apply gt_mult_0; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_l: forall a b, 0 < a * b ->  0 < a.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nlt_mult_rev_0_r: forall a b, 0 < a * b ->  0 < b.\nintros a b H1; apply Nlt_lt; apply lt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply lt_Nlt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_l: forall a b, a * b > 0 ->  a > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_l with (nat_of_N b). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Ngt_mult_rev_0_r: forall a b, a * b > 0  ->  b > 0.\nintros a b H1; apply Ngt_gt; apply gt_mult_rev_0_r with (nat_of_N a). \nrewrite <- N2Nat.inj_mul; apply gt_Ngt; repeat rewrite N2Nat.id; auto.\nQed.\n\nTheorem Nle_0_eq_0: forall n, n <= 0 -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\napply le_Nle; rewrite N2Nat.id; auto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3931,
                "proof_end_offset": 4128,
                "proof": "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nProof.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq_0 (nat_of_N n)); auto.\nchange (0 >= nat_of_N n)%nat.\napply ge_Nge; rewrite N2Nat.id; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0_eq_0; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H; rewrite <- (N2Nat.id n).\nrewrite (le_0_eq (nat_of_N n)); auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n; rewrite <- (N2Nat.id n).\nrewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (N.of_nat n)).\nrewrite (N2Nat.id (Qed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n; rewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewriteQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0_eq_0; apply lt_le_incl; auto.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0_le; apply lt_le_incl.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).\nrewrite (N2Nat.id n).Qed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; rewrite <- (N2Nat.id n).\nrewrite <- (N2Nat.id n).\napply le_Sn_0.\nQed.",
                    "Theorem Nge_0_eq_0: forall n, 0 >= n -> n = 0.\nintros n H1; apply Nge_0_eq_0; apply Nge_0_le; apply lt_le_incl.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " simplify x * y? x * z where? is < > <= >= *)\n\nTheorem Rmult_le_compat_l:\n  forall n m p : R, (m <= n)%R -> (0 <= p)%R -> (p * m <= p * n)%R.\nauto with real.\nQed.\n\nTheorem Rmult_le_neg_compat_l:\n  forall n m p : R, (m <= n)%R -> (p <= 0)%R -> (p * n <= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30052,
                "proof_end_offset": 30304,
                "proof": "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; replace (n * m)%R with ((-p * m))%R; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H0; replace (p * m)%R with ((p * m) * m)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((m * p)%R); auto with real.\nreplace (m * n)%R with ((m * p)%R); auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (m * n)%R with (m * n)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with (p * n)%R; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1 H2; replace (p * n)%R with ((p * m + p) * m)%R; auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (n * m)%R with ((n * m + p) * m)%R; auto with real.\nreplace (n * m)%R with ((n * m + p) * m)%R; auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * m)%R); auto with real; try ring.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((p * m + p))%R; auto with real.\nrewrite <- Rmult_assoc.\nrewrite <- (Rmult_plus_distr_l_reverse n m p); auto with real.\nQed.",
                    "Theorem Rmult_le_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H1 H2; replace (p * n)%R with ((m * n)%R); auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_lt: forall n m, (m < n -> -n < -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l:\n  forall n m p : R, (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30306,
                "proof_end_offset": 30566,
                "proof": "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m <= p)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p := p); auto.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p := p); auto.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p := p); auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\napply Rle_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m <= n)%R; auto with real.\napply Rle_not_lt; apply Rmult_lt_reg_l with (p * n); auto with real.\napply Rle_not_lt; apply Rmult_lt_reg_l with (p * n); auto with real.\napply Rle_not_lt; apply Rmult_lt_reg_l with (p * n); auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\nrewrite <- (Rmult_1_l (n - m)).\nrewrite <- (Rmult_1_l (n - m)).\nrewrite Rmult_assoc; apply Rmult_le_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m <= p)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (p := p); auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\napply Rlt_not_le; apply Rlt_not_le; auto.\napply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_lt_trans with (m := p); auto with real.\napply Rle_trans with (m := p); auto with real.\napply Rlt_trans with (m := p); auto with real.\nQed.",
                    "Theorem Rmult_le_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_reg_l with (m := n); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": ", (m < n)%R -> (p < 0)%R -> (p * n < p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\nTheorem Ropp_ge: forall n m, (m >= n -> -n >= -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 30568,
                "proof_end_offset": 30827,
                "proof": "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\nrewrite <- (Rmult_comm (n * m)%R); auto.\nrewrite <- (Rmult_assoc (n * n)%R); auto.\napply Rmult_le_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\napply Rle_lt_trans with (m := n).\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_lt_trans with (m := (n - p)%R); auto.\napply Rle_lt_trans with (m := (n - p)%R); auto.\napply Rle_lt_trans with (m := (n - p)%R); auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_le; apply Rlt_trans with (m := p); auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m < n)%R; auto with real.\napply Rle_lt_trans with (m + n)%R; auto with real.\napply Rlt_trans with (m + n)%R; auto with real.\napply Rlt_trans with (m + n)%R; auto with real.\napply Rle_lt_trans with (m + n)%R; auto with real.\napply Rle_trans with (m + n)%R; auto with real.\nQed.",
                    "Theorem Rmult_lt_compat_l_rev: forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (n <= p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\nTheorem Rmult_ge_compat_l:\n  forall n m p : R, (m >= n)%R -> (p >= 0)%R -> (p * m >= p * n)%R.\nintros n m p H H1; apply Rle_ge; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l:\n  forall n m p : R, (m >= n)%R -> (0 >= p)%R -> (p * n >= p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 30829,
                "proof_end_offset": 31096,
                "proof": "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nProof.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt m n); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\napply Rlt_not_le; apply Rlt_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (m < n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\nrewrite (Rmult_comm (m - n)%R); auto with real.\napply Rmult_lt_reg_l with (m - n)%R; auto with real.\nQed.",
                    "Theorem Rmult_lt_neg_compat_l_rev: forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "intros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real;try ring.\nQed.\n\nTheorem Ropp_gt: forall n m, (m > n -> -n > -m)%R.\nauto with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31098,
                "proof_end_offset": 31286,
                "proof": "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H0; case (Rle_or_lt n m); auto; intros H3.\nabsurd (n * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (n * m < p * n)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1 H2; case (Rle_or_lt n m); auto; intros H3.\nabsurd (n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_pos_compat; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_le_compat_l_rev; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rle_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rle_not_le; apply Rmult_lt_pos_compat; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " with real.\nQed.\n\nTheorem Rmult_gt_compat_l:\n  forall n m p : R, (n > m)%R -> (p > 0)%R -> (p * n > p * m)%R.\nunfold Rgt; auto with real.\nQed.\n\n\nTheorem Rmult_gt_neg_compat_l:\n  forall n m p : R, (m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31288,
                "proof_end_offset": 31484,
                "proof": "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nProof.\nintros n m p H H1; apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rle_trans with (m * n <= p * m)%R; auto with real.\nrewrite Rmult_comm; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rlt_le; apply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_le; apply Rmult_lt_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (n > 0)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rle_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m >= n)%R; auto with real.\napply Rle_trans with (m + n)%R; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_ge_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (le_or_lt n m); auto; intros H2.\nabsurd (p * n >= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto.\nQed.",
                    "Theorem Rmult_ge_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\napply Rle_trans with (m := p); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "m > n)%R -> (0 > p)%R -> (p * n > p * m)%R.\nintros n m p H1 H2; replace (p * n)%R with (-(-p * n))%R; auto with real; try ring.\nreplace (p * m)%R with (-(-p * m))%R; auto with real; try ring.\nQed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 724,
                "proof_start_offset": 31486,
                "proof_end_offset": 31663,
                "proof": "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_reg_l with (m := n); auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\napply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\ncut (p * n < p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_le_pos_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n > p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rle_trans with (m * n <= p * m)%R; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rmult_le_compat_l; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\napply Rle_trans with (m - n)%R; auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H1; case (le_or_lt n m); auto; intros H2.\nabsurd (n >= m)%R; auto with real.\napply Rmult_le_reg_l with (n := m); auto with real.\napply Rmult_le_reg_l with (n := m); auto with real.\nQed.",
                    "Theorem Rmult_gt_compat_l_rev: forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (n >= 0)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_pos_compat_l; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "Qed.\n\n(* Theorem to simplify a hyp x * y? x * z where? is < > <= >= *)\n\n\nTheorem Rmult_le_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n <= p * m)%R -> (n <= m)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\n",
                "context_tokens": 722,
                "proof_start_offset": 31665,
                "proof_end_offset": 31850,
                "proof": "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nProof.\nintros n m p H H1; red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; elim H1; auto; intros; apply H2; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (m <= n)%R; auto with real.\napply Rle_not_lt; apply Rmult_gt_pos_compat_l; auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1; apply Rmult_le_compat_l_rev; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; rewrite <- Rmult_assoc; apply Rmult_lt_pos_compat_l_rev; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1; rewrite <- (mult_comm n m); apply Rmult_gt_compat_l_rev.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1; rewrite <- (Ropp_involutive n).\nrewrite <- (Ropp_involutive m).\napply Ropp_involutive.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_reg_l with (p * n)%R; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; red; apply Rmult_ge_pos; auto with real.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (m < n)%R; auto with real.\nrewrite <- (Ropp_involutive m); auto.\napply Ropp_le_contravar; apply Ropp_le_contravar; apply Ropp_le_contravar; auto.\napply Ropp_le_contravar; apply Ropp_le_contravar; apply Ropp_le_contravar; auto.\nQed.",
                    "Theorem Rmult_gt_neg_compat_l_rev: forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H1; red; apply Rmult_le_reg_l with (p := p); auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\n",
                "context_tokens": 736,
                "proof_start_offset": 31871,
                "proof_end_offset": 31978,
                "proof": "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1; case (Rle_or_lt x y); auto; intros H2.\nabsurd (y < z)%R; auto with real.\napply Rle_trans with (z * z)%R; auto with real.\napply Rle_trans with (z * z)%R; auto with real.\napply Rlt_le; apply Rlt_trans with (z * z)%R; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H1; apply Rle_trans with (z * x)%R; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; case (Rle_or_lt x z); auto; intros H2.\nabsurd (x < z); auto with real.\nrewrite <- H2; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case (Rle_or_lt x y); auto; intros H3.\napply Rlt_le; auto.\napply Rle_trans with (r2 := x); auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; case (Rle_or_lt 0 x); auto; intros H3.\napply Rle_trans with (z * x); auto with real.\napply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; rewrite H; apply Rle_antisym; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0 H1; pattern z at 1; rewrite <- H1;\n apply eq_R0_R1; apply eq_R0_R1; auto.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; rewrite H1; rewrite H2; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H H0; case (Rle_or_lt y z); auto; intros H2.\napply Rlt_trans with (x * z).\napply Rmult_lt_reg_l with (y + z).\nrewrite Rmult_assoc; apply Rmult_lt_compat_l; auto with real.\nQed.",
                    "Theorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H1 H2; rewrite H1; rewrite H2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " Rmult_lt_compat_l; auto.\nQed.\n\nTheorem Rmult_le_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 31979,
                "proof_end_offset": 32086,
                "proof": "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H1; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H H1; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " <= p * m)%R -> (m <= n)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n <= p * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32087,
                "proof_end_offset": 32194,
                "proof": "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " * m)%R; auto with real.\napply Rlt_not_le; apply Rmult_lt_neg_compat_l; auto.\nQed.\n\nTheorem Rmult_lt_compat_l_rev:\n  forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32195,
                "proof_end_offset": 32302,
                "proof": "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " forall n m p : R, (0 < p)%R -> (p * n < p * m)%R -> (n < m)%R.\nintros n m p H H1; case (Rle_or_lt m n); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_compat_l; auto with real.\nQed.\n\nTheorem Rmult_lt_neg_compat_l_rev:\n  forall n m p : R, (p < 0)%R -> (p * n < p * m)%R -> (m < n)%R.\nintros n m p H H1; case (Rle_or_lt n m); auto; intros H2.\nabsurd (p * n < p * m)%R; auto with real.\napply Rle_not_lt; apply Rmult_le_neg_compat_l; auto with real.\nQed.\n\nTheorem Rmult_ge_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n >= p * m)%R -> (n >= m)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_ge_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n >= p * m)%R -> (m >= n)%R.\nintros n m p H H1;\n apply Rle_ge; apply Rmult_le_neg_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_compat_l_rev:\n  forall n m p : R, (p > 0)%R -> (p * n > p * m)%R -> (n > m)%R.\nintros n m p H H1;\n red; apply Rmult_lt_compat_l_rev with p; auto with real.\nQed.\n\nTheorem Rmult_gt_neg_compat_l_rev:\n  forall n m p : R, (0 > p)%R -> (p * n > p * m)%R -> (m > n)%R.\nintros n m p H H1;\n red; apply Rmult_lt_neg_compat_l_rev with p; auto with real.\nQed.\n\n(* For replace *)\n\nTheorem eq_Rlt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rlt_trans_r : forall x y z, (y = z) -> (x < y) -> (x < z).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_l : forall x y z, (x = z) -> (x > y) -> (z > y).\nintros x y z H; rewrite H; auto.\nQed.\nTheorem eq_Rgt_trans_r : forall x y z, (y = z) -> (x > y) -> (x > z).\nintros x y z H; rewrite H; auto.\nQed.\n",
                "context_tokens": 736,
                "proof_start_offset": 32303,
                "proof_end_offset": 32412,
                "proof": "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed.",
                    "Theorem eq_Rle_trans_l : forall x y z, (x = z) -> (x <= y) -> (z <= y).\nintros x y z H; rewrite H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " a Z *)\nLtac RCst t :=\n  match t with\n   | R0 => constr:(Z0)\n   | R1 => constr:(Zpos xH)\n   | Rplus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4809,
                "proof_end_offset": 4938,
                "proof": "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nProof.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := mult); auto.\nQed.",
                    "Theorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 =>  eval vm_compute in (Zplus e3  e4)\n              end\n      end\n   | Rminus?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4940,
                "proof_end_offset": 5073,
                "proof": "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nProof.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_reg_l with n; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_reg_l with n; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply f_equal2 with (f := plus); auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_reg_l with n; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l with n; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p; case n; simpl; auto.\nQed.",
                    "Theorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros; apply plus_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": "e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 5075,
                "proof_end_offset": 5184,
                "proof": "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nProof.\nintros a b c H H1; case H; subst; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H1; case H.\napply plus_reg_l with (n + m); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H; case H.\napply plus_reg_l with (n + m); auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H; case H.\napply plus_reg_l with a; auto.\nQed.",
                    "Theorem plus_neg_reg_l: forall a b c, a + b <> a + c -> b <> c.\nintros a b c H H0; case H.\napply plus_reg_l with a; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " eval vm_compute in (Zminus e3  e4)\n              end\n      end\n   | Rmult?e1?e2 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => match (RCst e2) with\n                 false => constr:(false)\n              | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 5186,
                "proof_end_offset": 5320,
                "proof": "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nProof.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; case H; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; case H; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; case H.\napply plus_reg_l with (p := S p); auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; case H; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros; apply plus_le_compat_l; auto.\nQed.",
                    "Theorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; pattern n, p; apply plus_le_compat_l; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/PolAux.v",
                "context": " | ?e4 => eval vm_compute in (Zmult e3  e4)\n              end\n      end\n   | Ropp?e1 =>\n       match (RCst e1) with\n        false => constr:(false)\n      |?e3 => eval vm_compute in (Z.opp e3)\n      end\n   | IZR?e1 =>\n       match (ZCst e1) with\n        false => constr:(false)\n      |?e3 => e3\n      end\n\n   | _ => constr:(false)\n end.\n\n\n(* Remove the Z.abs_nat of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs term :=\n  match term with\n   context id [(Z.abs_nat?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_nat X) in\n         let y := context id [x] in\n           clean_zabs y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Remove the Z.abs_N of a number, unfortunately stops at\n   the first Z.abs_nat x where x is not a number *)\n\nLtac clean_zabs_N term :=\n  match term with\n   context id [(Z.abs_N?X)] =>\n     match is_ZCst X with\n       true =>\n         let x := eval vm_compute in (Z.abs_N X) in\n         let y := context id [x] in\n           clean_zabs_N y\n     | false => term\n     end\n    | _ => term\n  end.\n\n(* Equality test for Ltac *)\n\nLtac eqterm t1 t2 :=\n  match constr:((t1,t2)) with (?X,?X) => true | _ => false end.\n\n(* For replace *)\n\nTheorem trans_equal_r : forall (A: Set) (x y z:A), y = z -> x = y -> x = z.\nintros; apply trans_equal with y; auto.\nQed.\n\n(* Theorems for nat *)\n\nOpen Scope nat_scope.\n\nTheorem plus_eq_compat_l: forall a b c, b = c -> a + b = a + c.\nintros; apply f_equal2 with (f := plus); auto.\nQed.\n\nTheorem plus_neg_compat_l: forall a b c, b <> c -> a + b <> a + c.\nintros a b c H H1; case H.\napply plus_reg_l with a; auto.\nQed.\n\nTheorem plus_ge_compat_l: forall n m p : nat, n >= m -> p + n >= p + m.\nintros n m p H; unfold ge; apply plus_le_compat_l; auto.\nQed.\n\nTheorem plus_neg_reg_l: forall a b c,  a + b <> a + c -> b <> c.\nintros a b c H H1; case H; subst; auto.\nQed.\n\nTheorem plus_ge_reg_l: forall n m p : nat, p + n >= p + m -> n >= m.\nintros n m p H; unfold ge; apply plus_le_reg_l with p; auto.\nQed.\n\n(* For replace *)\n",
                "context_tokens": 736,
                "proof_start_offset": 5340,
                "proof_end_offset": 5446,
                "proof": "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nProof.\nintros x y z H; rewrite H; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; case (z?= x); case (z?= x); case (z?= y); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (x + z).\napply le_trans with (y + z).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + x).\napply le_trans with (z + xQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (y + x).\napply le_lt_trans with (z + y).\napply le_plus_r.\napply le_plus_r.\napply le_plus_l.\napply le_plus_l.\napply le_plus_r.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (z + x); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with x; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (z + x).\napply eq_lt_trans with (z + x).\napply eq_lt_trans with (z + x).\napply eq_lt_trans with (z + x).\napply eq_lt_trans with (z + x).\napply eq_lt_trans with (z + x).\napply lt_le_trans with (z + x).\napply lt_trans with (z + x).\napply lt_le_trans with (z + x).\napply lt_le_trans with (z + x).\napply le_S_n.\napply le_S_n.\napply lt_trans with (z + x).\napply le_n_S.\napply le_n_S.\napply le_S_n.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros x y z H; case H; auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; rewrite eq_lt_trans with (x + z); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (z - x); auto.\nQed.",
                    "Theorem eq_lt_trans_l : forall x y z, (x = z) -> (x < y) -> (z < y).\nintros; apply eq_lt_trans with (z + x); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 485,
                "proof_start_offset": 1028,
                "proof_end_offset": 1154,
                "proof": "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nlc_disj (a + c) (a + c) (a + c) (b + c + d).\nreps.\nauto.\nreps.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nrep_div2 a b c d H1 H2.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H1 H2.\nrep_spec a bQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nLRHex.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolr (a + c) P.R 1%Z.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nrep_tac.\nring.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nrep_spec a b c d H1 H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d H2.\nrep_spec a b c d HQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\ncombr (a + c + d) (a + b + c - d).\nAbss.\nauto.\nAbss.\nauto.\nAbss.\nQed.",
                    "Goal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\nrepr (a + b) (b + c) (c + d).\nspec H0.\nring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 552,
                "proof_start_offset": 1156,
                "proof_end_offset": 1273,
                "proof": "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nProof.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * c + c - d).\nlocalvars (a * b + c - d).\nlocalvars (a * c + d - d).\nlocalvars (a * b + c - d).\nlocalvars (a * b + c + d - d).\nlocalvars (a * c + d - d).\nlocalvars (a * b + c + d - d).\nlocalvars (a * c + d + d - d).\nlocalvars (a * b + c + d - d).\nlocalvars (a * b + c + d - d).\nlocalvars (a * b + c + d + d - d).\nlocalvars (a * b + c + dQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\ncodm a b c d H1 H2.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\ncoosed.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nIsoleVar a.\nIsoleVar a.\nIsoleVar b.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar b.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar b.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar b.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nIsoleVar a.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nAut_| (0 < d) P.R 1%Z.\npols.\nauto.\ntyps.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nco wlist((a+c) * (b+c) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + b) * (d + c) * (d + c) * (d + b) * (d + b) * (d + b) * (d + b) * (d + c) * (d + b) * (d + b) * (d + c) * (d + c) * (d + b) * (d + b) * (d + c) * (d + b) * (d + b) * (d + c) * (d + c) * (d + c) * (d + c) * (d + c) * (d + c) * (d + c) * (d + c) * (d + c) * (d + cQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nrep lterm (a + b) P.R 1%Z.\npols.\nauto.\nrep wa (a + b + c * d + d * d + d * d + d * d + d * d + d * d + d * d + d * d + 1 * d + 1 + 1 * d * d + 1 * d * d + 1 * d + 1 * d + 1 * d + 1 * d * d + 1 * d + 1 * d * d + 1 * d * d + 1 * d + 1 * d + 1 * d + 1 * d * d + 1 * d * d + 1 * d + 1 * d + 1 * d * d + 1 * d + 1 * d * d + 1 * d + 1 * d * d + 1 * d + 1 * d + 1 * d * d + 1 * d + 1 * d + 1 * d * d + 1 * d + 1 * d * d + 1 * d + 1 * d + 1 * d + 1 * d * d + 1 * d + 1 * d + 1 * d * d + 1 * d + 1 * d + 1 * dQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nrefr (a + c) P.R 1%Z.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolurd (a + c) P.R 1%Z.\nrep3 c.\nomega.\nQed.",
                    "Goal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\nAbsromega (0 < d) P.R 1%Z.\npols.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 611,
                "proof_start_offset": 1275,
                "proof_end_offset": 1401,
                "proof": "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nProof.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolr (a + b) c d H1 H2.\nrep_div_div a b c d H2.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div b c c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div a b c d H3.\nrep_div_div_ b c d H3.\nrep_div_div a b c d H3.\nrep_div_Qed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolkl (a + c) P.R 1%Z.\npols.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nrep_gt_0_l.\napply Z.lt_le_trans with (2*2).\napply Z.lt_le_trans with (2*2).\napply Z.lt_le_trans with (2*2).\napply Z.lt_le_trans with (2*2).\napply Z.lt_le_trans with (2*2).\napply Z.le_max_l.\napply Z.le_max_r.\napply Z.le_max_l.\napply Z.le_max_l.\napply Z.le_max_l.\napply Z.le_max_r.\napply Z.le_max_r.\napply Z.le_max_l.\napply Z.le_max_r.\napply Z.le_max_r.\napply Z.le_max_l.\napply Z.le_max_l.\napply Z.le_max_r.\napply Z.le_max_r.\napply Z.le_max_r.\napply Z.le_max_l.\napply Z.le_max_rQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nlc_and (a + b + c > 0).\nring.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\ncor (a + c > d).\ncor (a + c + d).\ncor (a + b + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + d).\ncor (a + c + c + d).\ncor (a + c + c + d).\ncor (a + c + c + d).\ncor (a + c + c + d).\ncor (a + c + c + d).\ncor (a + c + c + d).\ncor (a + c + d).\ncor (a + c + dQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nsqrturd a b c d H1 H2.\nreps.\nauto.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\namand (a + b + c + d) (a + b + c + d).\n2: omega.\n2: omega.\n2: omega.\n2: omega.\n2: omega.\n2: omega.\n2: omega.\n2: omega.\n3: omega.\n3: omega.\n4: omega.\n4: omega.\n2: omega.\n4: omega.\n2: omega.\n3: omega.\n2: omega.\n3: omega.\n3: omega.\n3: omega.\n4: omega.\n3: omega.\n4: omega.\n3: omega.\n4: omega.\n3: omega.\n4: omega.\n4: omega.\n4: omega.\n5: omega.\n4: omega.\n5: omega.\n4: omega.\n4: omega.\n5: omega.\n5: omega.\n3: omega.\n4: omega.\n5: omega.\n5: omega.\n5: omega.\n6: omega.\n6: omega.\n7: omega.\n7: omega.\n7: omega.\n7Qed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nam (a + b - c - d).\nsqrt(a + c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrt(a + b - c - d).\nsqrtQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\nints_spec.\nring.\nQed.",
                    "Goal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\ncor (a + c < d).\ntyps.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Require Import PolTac.\nRequire Import ZArith.\n\n(* Test for Z *)\nOpen Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\n",
                "context_tokens": 699,
                "proof_start_offset": 1463,
                "proof_end_offset": 1579,
                "proof": "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nProof.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nlocal_eq a b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq c c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq c c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq c c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c d H.\nlocal_eq b c c H.\nlocal_eq b c c H.\nlocal_eq b c c H.Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nlocal_div_div_div a b c d.\nassert (a + b + c + a + b + c + b + c + b + c + d).\n(a + b + c + b + c + c + b + c + d).\n(a + b + c + c + b + c + c + d).\n(a + b + c + c + c + b + c + c + d).\n(a + c + c + b + c + c + b + c + c + c + d).\n(a + b + c + c + b + c + c + b + c + d).\n(a + b + c + c + c + b + c + c + c + c + c + b + d).\n(a + b + c + c + c + b + c + c + c + c + c + b).\n(a + b + c + c + b + c + c + c + c + c + c + c + d).\n(a + b + c + c + c + b + c + c + c + c + c + c + b + cQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nlocal_eq a b c d H1 H2.\nlocal_eq b c d H3.\nlocal_eq b c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq b c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_eq c d H3.\nlocal_Qed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\ninjection H; intro H0.\ninjection H0; intro H1.\ninjection H1; intro H2.\ninjection H2; intro H3.\ninjection H3; intro H4.\ninjection H3; intro H4.\ninjection H3; intro H4.\ninjection H4; intro H5.\ninjection H3; intro H4.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjection H3; intro H5.\ninjectionQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nIsoleVar a.\nunify c.\nunify c.\ncompute.\nintuition.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nlocal_eq a b c d H1 H2.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\ninjection H.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nintros.\ninjection H0.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nDecompExAnd H1.\nrevert a b c d H1 H2.\nIsoleVar a.\nIsoleVar a.\nIsoleVar b.\npattern c at 2; rewrite H1.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nlocal_div2.\nring.\nQed.",
                    "Goal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\nlocal_c a b c d H.\nlocal_c a b c d H0.\nlocal_c b c d H0.\nlocal_c a b c d H.\nlocal_c a b c d H.\nlocal_c b c d H0.\nlocal_c a b c d H0.\nlocal_c b c d H.\nlocal_c a b c d H.\nlocal_c a b c d H.\nlocal_c a b c d H.\nlocal_c a b c d H0.\nlocal_c a b c d H.\nlocal_c a b c d H.\nlocal_c a b c d H0.\nlocal_c a b c d H.\nlocal_c a b c d H0.\nlocal_c a b c d H0.\nlocal_c a b c d H0.\nlocal_c a b c d H0.\nlocal_c a b c d H.\nlocal_c a b c d H0.\nlocal_c a b c d H0.\nlocal_c a b c d H0.\nlocal_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/ReplaceTest.v",
                "context": "Open Scope  Z_scope.\n\nLtac cg g := match goal with |- g => idtac end.\n\n\nGoal forall a b c d, a + c = d -> b + d = c + d -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto. \nauto.\nQed.\n\nGoal forall a b c d, d = 0 -> a + b + c = c + 0 -> a + b + c = c + d.\nintros a b c d H1 H2.\npolr H1.\nrewrite H1; auto.\nauto.\nQed.\n\nGoal forall a b c d, a + c <= d -> b <= c -> a + b + c <= c + d.\nintros a b c d H1 H2.\npolr H1.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d,  a + b  <= 0 -> 0 <= d -> a + b + c <= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c >= d -> b >= c -> a + b + c >= c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b >= 0 -> 0 >= d -> a + b + c >= c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n\nGoal forall a b c d, a + c < d -> b <= c -> a + b + c < c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + b <= 0 -> 0 < d -> a + b + c < c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, a + c > d -> c <= b -> a + b + c > c + d.\nintros.\npolr (a + c < d).\npols.\nauto.\npols.\nauto.\nQed.\n\nGoal forall a b c d, 0 <= a + b -> 0 > d -> a + b + c > c + d.\nintros.\npolrx (0 < d) P.R P.R 1%Z.\npols.\nauto.\npols.\nauto.\nQed.\n\n(* Test for N *)\nRequire Import NAux.\nOpen Scope  N_scope.\n\nGoal forall a b c d, a + c = d -> b = c -> a + b + c = c + d.\nintros.\npolr (a + c = d).\npols.\nauto.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 1581,
                "proof_end_offset": 1693,
                "proof": "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nProof.\nintros.\npolr (d = 0).\npols.\nauto.\npols.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nAbss.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nAbsr (a + c = d).\nnus.\nauto.\nreps.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\n sKidididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididididQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\ncor (a + b) (b + c) (c + d) (d + d) H1.\nring.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nlocal2 (a + c) (b + c) (c + d).\nnus.\nauto.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\ncomb_c a b c d H1 H2.\nco_and H H2.\nco_and H3.\nco_and H4.\nco_and H4.\nco_and H4.\nco_and H4.\nco_and H4.\nco_and H4.\nco_and H5.\nco_and H4.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nco_and H5.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nlocal (a + b) (c + c = d).\nlocal (a + c) (b + c) (d + c) (d + c) (d + c) (d + c) (d + d).\nlocal (a + b) (c + c) (d + c) (d + d) (d + c) (d + d) (d + c) (d + d).\nlocal (a + b) (c + c) (d + c) (d + c) (d + c) (d + d) (d + c) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d +Qed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nlocal (a + b - a = d).\nlocal (a + b - a = d).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).\nlocal (a + b - a = b).Qed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nlc_tac.\nrewrite <- (opp_involutive b).\nring.\nQed.",
                    "Goal forall a b c d, 0 = d -> a + b = 0 -> a + b + c = c + d.\nintros.\nAbsr (a + c) (b + c) (c + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d) (d + d)Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\n",
                "context_tokens": 293,
                "proof_start_offset": 635,
                "proof_end_offset": 724,
                "proof": "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nProof.\nintros.\npolf.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nreps.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npattern x at 1 ; replace x with (1 + 2) by ring.\nreplace x with (1 + 2) by ring.\nreplace x with (1 + 2) by ring.\nreplace x with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (2 + 2) by ring.\nreplace y with (2 + 2) by ring.\nreplace y with (2 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (2 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2) by ring.\nreplace y with (1 + 2Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\npols.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nAbss.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\ncos.\nauto.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\n15 H0.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_Qed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nshiftrs.\nomega.\nQed.",
                    "Theorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x <= x * y)%R.\nintros.\nreps.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 336,
                "proof_start_offset": 726,
                "proof_end_offset": 820,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ntyps.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncos.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_lQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nassert (H: (0 <= y) * (x - y) = 2 * x + 2 * x + 2 * y).\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nring.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncontradict Hy.\napply Rmult_eq_compat_l with (2 := H).\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\npads.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_rQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nco_to_R_nat.\nrewrite <- (mult_1_r (2 * x)).\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nAbss.\nauto.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nring_simplify.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\ncos.\nomega.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%R.\nintros.\nco_gt_0_1.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Rex.v",
                "context": "Require Import Reals.\nRequire Import PolTac.\n\nOpen Scope R_scope.\n \nTheorem pols_test1: forall (x y : R), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : R), 0 < y ->  (x  < x + y).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : R), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with real.\nQed.\n\nTheorem pols_test4:\n forall (x y : R),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall (x y z : R),\n x * (z + 2) < y * (2 * x + 1)->  (x * ((z + y) + 2) < y * (3 * x + 1)).\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <=  x  * y)%R.\nintros.\npolf.\nQed.\n\nTheorem polf_test2: forall x y, (0 < x -> x  <= x  * y -> 1 <= y)%R.\nintros.\nhyp_polf H0.\nQed.\n\n",
                "context_tokens": 382,
                "proof_start_offset": 822,
                "proof_end_offset": 950,
                "proof": "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nProof.\nintros x y z H.\npolr H.\npols.\nauto.\npols.\nauto with real.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H.\ndestruct H.\nsubst z.\nomega.\nintro.\ndestruct H.\nsubst z.\nomega.\nintro.\ndestruct H.\nsubst z.\nomega.\nintro.\ndestruct H.\nsubst z.\nomega.\nintro.\ndestruct H.\nsubst z.\nomega.\nintro.\ndestruct H.\nsubst z.\nomega.\nintro.\ndestruct H.\nsubst z.\nomega.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\ncontradict H.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.\ncontradict H0.Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nassert (H3: (1 <= x + z) + 2 * x + 2 * x + 2 * y + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 3 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 3 * x + 2 * x + 3 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * x + 2 * xQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct H.\napply H1.\napply H2.\napply H0.\napply H0.\napply H1.\napply H.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H1.\napply H2.\napply H2.\napply H1.\napply H2.\nQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nL_s.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_r.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_l.\napply Rmult_eq_compat_Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\nclear H.\nunfold limit1 in H0.\ndestruct H0.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_rQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\napply Rle_trans with (1:= H0).\napply Rle_trans with (1:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (1:= H2).\napply Rle_trans with (2:= H1).\napply Rle_trans with (1:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (1:= H1).\napply Rle_trans with (1:= H2).\napply Rle_trans with (2:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (1:= H1).\napply Rle_trans with (2:= H1).\napply Rle_trans with (1:= H2).\napply Rle_trans with (2:= H1).\napply Rle_trans with (1:= H1).\napply Rle_trans with (1:= H1).\napply Rle_trans with (1:=Qed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ncontradict H.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_lQed.",
                    "Theorem polr_test1: forall x y z, (x + z) < y -> x + y + z < 2*y.\nintros.\ndestruct z.\napply Rle_trans with (2*x+y).\napply Rle_trans with (2*x+y).\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply RmultQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": " (-0)%R; auto with real.\nQed.\n\nTheorem Rlt_sign_neg_pos: forall x y, (x < 0 -> 0 < y  -> x * y < 0)%R.\nintros x y H1 H2; apply Rlt_pos_neg; replace (- (x * y))%R with (-x * y)%R; auto with real; try ring.\napply Rmult_lt_0_compat; auto with real.\nQed.\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\n",
                "context_tokens": 733,
                "proof_start_offset": 3923,
                "proof_end_offset": 4160,
                "proof": "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rlt_not_eq; apply Rlt_not_eq; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; generalize (lt_not_le_cases x y H0); intros H1.\napply Rlt_le_trans with (x * y); auto with real.\napply Rlt_le_trans with (x * y); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_not_eq; apply Rlt_not_eq; apply Rlt_not_eq; auto.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; apply Rlt_not_eq; apply Rlt_not_eq; apply Rlt_not_eq; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rle_not_lt; apply Rlt_not_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; case (Rle_or_lt (x * y) 0); intros H1; auto.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H; case (Rle_dec x y); auto.\nintros H'; generalize (Rlt_not_le _ _ H'); auto with real.\nintros H'; generalize (Rle_not_lt _ _ H'); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros; red; apply Rlt_zero_pos; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto with real.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": ".\n\n\n\nTheorem Rge_sign_neg_neg: forall x y, (0 >= x -> 0 >= y  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rge_sign_pos_pos: forall x y, (x >= 0 -> y >= 0  -> x * y >= 0)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4162,
                "proof_end_offset": 4401,
                "proof": "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 x); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_trans with (x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rlt_trans with (y * x)%R; auto with real.\napply Rle_trans with (y * x)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_trans with (y * x)%R; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= y * x)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y * x)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x = 0); auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rle_lt_trans with (r2 * y); auto with real.\napply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rle_ge; apply Rlt_not_le; apply Rlt_neg_pos; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "sign_pos_pos; auto with real.\nQed.\n\nTheorem Rge_neg_pos: forall x, (0 >= -x -> x >= 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\napply Rle_ge;apply Ropp_le_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rge_sign_neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4403,
                "proof_end_offset": 4640,
                "proof": "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_le; apply Rlt_trans with x; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_zero_pos.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y * x)%R; auto with real.\napply Rle_trans with (1 := H3); auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_le; auto with real.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 < y * x)%R; auto with real.\napply Rle_lt_trans with (y * x); auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y = x * y)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_le; auto.\nQed.",
                    "Theorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y = 0%R); auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_pos; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/RSignTac.v",
                "context": "neg_pos: forall x y: R, (0 >= x -> y >= 0  -> 0>= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rge_sign_pos_neg: forall x y, (x >= 0 -> 0 >= y  -> 0 >= x * y)%R.\nintros; apply Rle_ge; apply Rle_sign_pos_neg; auto with real.\nQed.\n\n\nTheorem Rgt_sign_neg_neg: forall x y, (0 > x -> 0 > y  -> x * y > 0)%R.\nintros; red;  apply Rlt_sign_neg_neg; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_pos: forall x y, (x > 0 -> y > 0  -> x * y > 0)%R.\nintros; red; apply Rlt_sign_pos_pos; auto with real.\nQed.\n\nTheorem Rgt_neg_pos: forall x, (0 > -x -> x > 0)%R.\nintros x H; rewrite <- (Ropp_involutive 0);  rewrite <- (Ropp_involutive x); auto with real.\nred;apply Ropp_lt_contravar; auto with real.\nrewrite Ropp_0; auto with real.\nQed.\n\nTheorem Rgt_sign_neg_pos: forall x y, (0 > x -> y > 0  -> 0> x * y)%R.\nintros; red; apply Rlt_sign_neg_pos; auto with real.\nQed.\n\nTheorem Rgt_sign_pos_neg: forall x y, (x > 0 -> 0 > y  -> 0 > x * y)%R.\nintros; red; apply Rlt_sign_pos_neg; auto with real.\nQed.\n\n(* Theorems to simplify the hyp 0? x * y and x * y? 0 where? is < > <= >= *)\n\nTheorem Rle_sign_pos_pos_rev: forall x y: R, (0 < x -> 0 <= x * y -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_neg; auto.\nQed.\n\nTheorem Rle_sign_neg_neg_rev: forall x y: R, (x < 0 -> 0 <= x * y ->  y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y  0); auto with real.\nintros H3; absurd (0 <= x * y)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_pos; auto.\nQed.\n\nTheorem Rle_sign_pos_neg_rev: forall x y: R, (0 < x -> x * y <= 0 -> y <= 0)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_pos_pos; auto.\nQed.\n\n",
                "context_tokens": 733,
                "proof_start_offset": 4642,
                "proof_end_offset": 4880,
                "proof": "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nProof.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le;apply Rlt_sign_neg_neg; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_le; apply Rlt_trans with (x * y)%R; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\napply Rle_trans with (y * y * x * y); auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_neg; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y <= 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y = x); auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_not_le; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; apply Rlt_zero_pos; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y * x <= 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_not_le; auto with real.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\napply Rlt_not_le; apply Rlt_zero_pos_neg; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt y 0); auto with real.\nintros H3; absurd (x * y < 0)%R; auto with real.\napply Rle_not_le; apply Rlt_not_le; apply Rlt_le; apply Rlt_trans with y; auto.\nQed.",
                    "Theorem Rle_sign_neg_pos_rev: forall x y: R, (x < 0 -> x * y <= 0 -> 0 <= y)%R.\nintros x y H1 H2; case (Rle_or_lt 0 y); auto with real.\nintros H3; absurd (y < 0)%R; auto with real.\napply Rle_not_lt; apply Rlt_le; apply Rlt_le; apply Rlt_trans with y; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/PolTac/Zex.v",
                "context": "Require Import ZArith.\nRequire Import PolTac.\n\nOpen Scope Z_scope.\n\nTheorem pols_test1: forall (x y : Z), x < y ->  (x + x < y + x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test2: forall (x y : Z), y < 0 ->  (x + y < x).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test3: forall (x y : Z), 0 < y * y ->  ((x + y) * (x - y) < x * x).\nintros.\npols.\nauto with zarith.\nQed.\n \nTheorem pols_test4:\n forall (x y : Z),\n x * x  < y * y ->  ((x + y) * (x + y) < 2 * (x * y + y * y)).\nintros.\npols.\nauto.\nQed.\n \nTheorem pols_test5:\n forall x y z, x + y * (y + z) = 2 * z ->  2 * x + y * (y + z) = (x + z) + z.\nintros.\npols.\nauto.\nQed.\n\nTheorem polf_test1: forall x y, (0 <= x -> 1 <= y -> x  <= x  * y)%Z.\nintros.\npolf.\nQed.\n\n",
                "context_tokens": 326,
                "proof_start_offset": 711,
                "proof_end_offset": 805,
                "proof": "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nProof.\nintros.\nhyp_polf H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply Rle_trans with (2 * x - x).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply RmultQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nring.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nassert (H : (y + x < y + x) / 2 = 2 * x + 2 * x + 2 * y).\nrewrite H.\nrewrite H.\nrewrite H.\nrewrite H0.\nring.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nco_elim H0; intros.\napply H0.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_rQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\ncos.\napply Rle_trans with (2*y).\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_r.\napply Rmult_le_compat_l.\napply Rmult_le_compat_r.\napply Rmult_le_compat_Qed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\ncof_equal.\napply Z.mul_lt_mono_pos.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nassert (H: (x + y) * 2 <= 2 * y * 2) by omega.\napply H.\nintros.\napply H.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nassert (H: (x + y) * y * (x + y) <= 2 * x * y)%Z.\napply H.\nintros.\nomega.\nQed.",
                    "Theorem polf_test2: forall x y, (0 < x -> x <= x * y -> 1 <= y)%Z.\nintros.\nomega.\nQed."
                ]
            }
        ],
        "angles": [
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \n",
                "context_tokens": 447,
                "proof_start_offset": 1407,
                "proof_end_offset": 1868,
                "proof": "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nProof.\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v)))); auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Rmult in |- *; intros.\napply paired_diff_r with (plus zero zero); auto.\napply construct_zero_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Qlt, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal, orthogonal.\nintros u v; elim (multfactoraire u); auto.\napply orthogonal_opp; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Qmult in |- *; intros.\napply Rmult_integralaire_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Qmult in |- *; intros.\napply Qgt_pos.\napply Rmult_integral_r; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Qmult in |- *; intros.\napply (mult_integral (opp (opp u)) (opp (opp (opp v))); auto.\napply (mult_integral (opp (opp (opp v))); auto.\napply (mult_integral (opp (opp (opp v))); auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Rmult in |- *; intros.\napply Rmult_integralaire_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Qle in |- *; intros.\napply Qgt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_r.\napply Qlt_mult_l.\napply Qlt_mult_l.\napply Qlt_mult_r.\napply Qlt_mult_l.Qed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Rmult in |- *; intros.\napply Rmult_integralaire_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold Qmult in |- *; intros.\napply Rmult_integralaire_sym; auto.\nQed.",
                    "Lemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply paired_sym.\napply Rmult_integralc with (mult a zero) (add a zero); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \n",
                "context_tokens": 582,
                "proof_start_offset": 1900,
                "proof_end_offset": 2307,
                "proof": "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nProof.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (mult_diff (mult_diff a (a::w))) (a::w)); auto.\napply (mult_diff (mult_diff a (a::w))); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply H with (add (mult (mult (mult (mult a u)) (mult (mult (mult a u))) (mult (mult (mult (mult a u))) (mult (mult (mult (mult (mult a u)))).\napply H; auto.\napply H0; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (mult_integral_r (a::v) (b::w)); auto.\napply (mult_integral_r (a::v) (b::w)); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply H0.\napply H1.\napply H1.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napplymerge_sym.\napply orthogonal_mult; auto.\napply orthogonal_mult; auto.\napply orthogonal_mult; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold Qmult in |- *; intros.\napply (mult_integralaire_sym u v (opp v)); auto.\napply (mult_integralaire_sym u v (opp v)); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply construct_sym; auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply inclusion_trans with (plus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v) (add w w)); auto.\napply inclusion_trans with (minus (cons u v)Qed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply inclusion_trans with (minus (cons u v) (cons v w)); auto.\napply inclusion_trans with (minus (cons u v) (cons u v)); auto.\napply inclusion_trans with (minus (cons u v) (cons v w)); auto.\napply inclusion_trans with (minus (cons u v) (cons v w)); auto.\nQed.",
                    "Lemma orthogonal_colineaire : forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold orthogonal in |- *; intros.\napply (mult_integraluire (head v) (cons v w) (cons v w)); auto.\napply\n (mult_integraluire (head v) (cons u v)); auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/angles/point_napoleon.v",
                "context": "Set Implicit Arguments.\nUnset Strict Implicit.\nRequire Export point_cocyclicite.\n \nLemma colineaire_sym : forall u v : V, colineaire u v -> colineaire v u.\nunfold colineaire in |- *; intros.\napply regulier with (a := double (cons u v)) (c := double (cons u v)); auto.\napply transitive with (double (plus (cons u v) (cons v u))); auto.\napply transitive with (double zero); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.\nHint Resolve colineaire_sym.\n \nLemma colineaire_modulo_pi :\n forall u v u' v' : V,\n colineaire u u' ->\n colineaire v v' -> R (double (cons u' v')) (double (cons u v)).\nunfold colineaire in |- *; intros.\napply\n transitive with (double (plus (cons u' u) (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with (plus (double (cons u' u)) (double (plus (cons u v) (cons v v'))));\n auto.\napply\n transitive\n  with\n    (plus (double (cons u' u))\n       (plus (double (cons u v)) (double (cons v v')))); \n auto.\napply compatible; auto.\napply\n transitive with (plus zero (plus (double (cons u v)) (double (cons v v'))));\n auto.\napply compatible; auto.\ncut (colineaire u' u); intros; auto.\napply transitive with (plus (double (cons u v)) (double (cons v v'))); auto.\napply transitive with (plus (double (cons u v)) zero); auto.\napply compatible; auto.\napply transitive with (plus zero (double (cons u v))); auto.\nQed.\nHint Resolve colineaire_modulo_pi.\n \nLemma orthogonal_opp : forall u v : V, orthogonal u v -> orthogonal u (opp v).\nunfold orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v (opp v)))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v (opp v))));\n auto.\napply transitive with (plus pi (double pi)); auto.\napply compatible; auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\nHint Resolve orthogonal_opp.\n \nLemma orthogonal_colineaire :\n forall u v w : V, orthogonal u v -> colineaire v w -> orthogonal u w.\nunfold colineaire, orthogonal in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus pi zero); auto.\napply compatible; auto.\napply transitive with (plus zero pi); auto.\nQed.\n \n",
                "context_tokens": 701,
                "proof_start_offset": 2310,
                "proof_end_offset": 2663,
                "proof": "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nProof.\nunfold colineaire in |- *; intros.\napply transitive with (double (plus (cons u v) (cons v w))); auto.\napply transitive with (plus (double (cons u v)) (double (cons v w))); auto.\napply transitive with (plus zero zero); auto.\napply compatible; auto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply parallel with (mult (cons u v) (cons v w)); auto.\napply parallel with (mult (cons u v) (cons v w)); auto.\napply parallel with (mult (cons u v) (cons v w)); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire in |- *; intros.\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (a := (a - a)).\napply Hyp with (Qed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply construct_mult_l with (head v); auto.\napply paraire_par_pi with (lambda u); auto.\napply paraire_par_pi with (lambda u); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply paraire_par_pi with (minus (cons u v) (cons v w)); auto.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply paraant.\napply parQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineack in |- *; intros.\napply parallel with (mult a (cons u v)); auto.\napply parallel with (mult a (cons u v)); auto.\napply paraant; auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineafsqrt in |- *; intros.\napply parallel with (mult a (cons u v)); auto.\napply Trans with (mult a (cons v w)); auto.\napply Trans with (mult a (cons v w)); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, Qlt in |- *.\nintros.\napply (mult_integral_r aire_transitive (plus a (swap v w))); auto.\napply (mult_integral_r aire_transitive (mult a (swap v w))); auto.\napply (mult_integral_r aire_transitive (mult a (swap v w))); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaove, orthogonal in |- *; intros.\napply Hrec; auto.\napply Cons with (mult a (cons v w)); auto.\napply Cons with (mult a (cons v w)); auto.\napply Cons with (mult a (cons v w)); auto.\napply Cons with (mult a (cons v w)); auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold col time, orthogonal in |- *; intros.\napplymerge_sym; auto.\napplymerge_sym; auto.\napplymerge_sym; auto.\napplymerge_sym; auto.\napplymerge_sym; auto.\nQed.",
                    "Lemma colineaire_transitive : forall u v w : V, colineaire u v -> colineaire v w -> colineaire u w.\nunfold colineaire, orthogonal in |- *; intros.\napply parallel with (add (cons u v) (cons v w)); auto.\napply paraire_par with (add a (cons v w)); auto.\napply paraire_par with (add a (cons v w)); auto.\napply paraire_par with (add a (cons v w)); auto.\nQed."
                ]
            }
        ],
        "coq-procrastination": [
            {
                "filepath": "./coq_projects/coq-procrastination/src/Procrastination.v",
                "context": " match goal with |-?G =>\n    match type of G with\n    | Prop => mk_begin_defer_helper_Prop ids H\n    | _ => mk_begin_defer_helper_Type ids H\n    end;\n    cut H; subst H; [| now prove_begin_defer_helper]\n  end.\n\n(* Tests *)\nGoal True.\n  mk_begin_defer_helper tt.\n  intro H; eapply H; clear H.\nAbort.\n\nGoal True.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\nGoal nat.\n  mk_begin_defer_helper (fun a b c : unit => tt).\n  intro H; eapply H; clear H.\nAbort.\n\n(* [end defer] helpers.\n\n   [end defer] is called on the second subgoal produced by [begin defer], of the\n   form [exists a.. z, group a.. z], where [group a.. z] has been\n   instantiated by [defer] into something of the form [P1 /\\ P2 /\\... /\\ Pn /\\\n  ?P], where P1.. Pn are the propositions that have been deferred, and [?P] is\n   the \"accumulator\" evar.\n\n   The role of [end defer] is to close the goal, instantiating [?P] with [True],\n   and removing it from the goal.\n\n   This is done by first applying a lemma of the form:\n\n   ```\n   forall A.. Z (G1 G2 : A ->.. -> Z -> Prop),\n   (forall a.. z, G1 a.. z -> G2 a.. z) ->\n   (exists a.. z, G1 a.. z) ->\n   exists a.. z, G2 a.. z\n   ```\n\n   After applying this lemma, [G2] is unified with the current goal (to clean),\n   and [G1] is introduced as an evar. An auxiliary tactic\n   ([cleanup_conj_goal_core], defined below) is called on the first subgoal, and\n   will discharge it, instantiating [G1] with the cleaned-up goal (i.e [P1 /\\ P2\n   /\\... /\\ Pn]).\n\n   The helpers below help generating and proving this lemma, for any number of\n   variables [a].. [z].\n*)\n\n(* Tactic that proves the lemma above for any arity. *)\nLtac prove_end_defer_helper :=\n  introsType;\n  let P1 := fresh in\n  let P2 := fresh in\n  let H1 := fresh in\n  let H2 := fresh in\n  intros P1 P2 H1 H2;\n  unfold Marker.end_defer in *;\n  repeat (let x := fresh \"x\" in destruct H2 as (x & H2); exists x);\n  apply H1; auto.\n\n(* Tests. *)\nGoal forall A (P1 P2 : A -> Prop),\n  (forall a, P1 a -> P2 a) ->\n  (exists a, P1 a) ->\n  Marker.end_defer (exists a, P2 a).\nProof. prove_end_defer_helper. Qed.\n\n",
                "context_tokens": 707,
                "proof_start_offset": 14539,
                "proof_end_offset": 14719,
                "proof": "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof.\nprove_end_defer_helper.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_tac_morph_goal_core. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. use_tac_ros_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_compute_simpl_rreper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_simpl. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_tauto. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_tac_theory. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_end_defer_helper. Qed.",
                    "Goal forall A B (P1 P2 : A -> B -> Prop), (forall a b, P1 a b -> P2 a b) -> (exists a b, P1 a b) -> Marker.end_defer (exists a b, P2 a b).\nProof. prove_simpl_all_helper. Qed."
                ]
            }
        ],
        "tree-automata": [
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nRequire Import EqNat.\nRequire Export Max.\n\nLemma nat_sum : forall n : nat, n = 0 \\/ (exists m : nat, n = S m).\nProof.\n\tsimple induction n. left. reflexivity. intros. right.\n\tsplit with n0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3102,
                "proof_end_offset": 3223,
                "proof": "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\nintros.\nelim (max_le_Sr_0 n m).\nintros.\nexact H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\tintros. elim H. intros. simpl in |- *. exact (le_n_S (S n0)).\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_S n0 m).\n\tintros.\n\telim H. intros.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapplyQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. trivial.\n\tintro.\n\tapply le_n_S.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_trans with (m := n0 + m).\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_Sn 0).\n\tintros. elim H. intros. simpl in |- *. exact (le_n_O (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_S (max (S n0) (S n1))).\n\tintros. elim H0. intros.\n\telim (H n1). intros.\n\telim H2. intros.\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (H m1).\n\tapply (HQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. trivial.\n\tintros. simpl in |- *. elim (le_n_O (S m)).\n\tintro.\n\tapply (le_n_S (max (S n0) n1)) with (max (S n0) (max n0 (S m))).\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_S.\n\tapply le_n_Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_S m).\n\tintro.\n\telim H. intros. simpl in |- *. split. exact (le_n_O (S n0)).\n\tintro.\n\telim H. intros.\n\tapply le_n_S.\n\tapply le_S_n.\n\tapply le_n_S.\n\tapply le_trans with (max (S n0) (S n0)).\n\tapply le_max_l.\n\tapply le_trans with (max (S n0) (S n0)).\n\tapply le_max_l.\n\tapply le_trans with (max (S n0) (S n0)).\n\tapply le_max_l.\n\tapply le_max_l.\n\tapply le_trans with (max (S n0) (S n0)).\n\tapply le_max_l.\n\tapply le_max_l.\n\tapply le_trans with (max (S n0) (S n0)).\n\tapply le_max_l.\n\tapply le_max_Qed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_Sn 0).\n\tintros. elim H. intros. split. apply le_n_S. assumption.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n; intros.\n\trewrite (plus_comm n m).\n\tapply plus_le_compat; apply le_n_S; assumption.\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_n_Sn 0).\nQed.",
                    "Lemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tsimple induction n.\n\tintros.\n\telim (le_n_O m).\n\tintros.\n\telim (le_n_O m).\n\tintros.\n\telim (le_Sn_O m).\n\tintros.\n\telim (le_n_S (max (S n0) (S n1)) (min (S n0) (S n1))).\n\tintros.\n\tapply le_n_S.\n\tintros.\n\telim (le_n_O m).\n\tintros.\n\tapply le_trans with (S (max n0 (S n1)) (min (S n0) (S n1))).\n\tintro.\n\tapply le_trans with (S (max (S n0) (S n1)) (min (S n0) (S n1))).\n\tapply le_max_l.\n\tapply le_trans with (S (max n0 (S n1)) (max (S n0) (S n1))).\n\tapply le_max_l.\n\tapply le_trans with (S (max n0 (S n1))Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "0. reflexivity.\nQed.\n\nLemma le_n_n : forall n : nat, n <= n.\nProof.\n        simple induction n. trivial.\n        intros. exact (le_n_S n0 n0 H).\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3253,
                "proof_end_offset": 3397,
                "proof": "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *.\ntrivial.\nintros.\nsimpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n.\n simpl in |- *. reflexivity.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. split. exact (plus_O_r 0).\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. reflexivity.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. reflexivity.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\tapply plus_n_O.\n\tapply plus_O_r.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_n_O.\n\tapply plus_nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tintro.\n\trewrite plus_n_O.\n\tapply plus_n_O.\nQed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite plus_comm.\n\trewrite (plus_comm n1 (plus_comm m1)) (plus_comm m1).\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_l.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_r.\n\tapply plus_O_Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. split. exact (plus_n_O 0).\n\tintro.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_O.\n\trewrite <- plus_n_Qed.",
                    "Lemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\nQed.\n\nLemma le_l_or_r : forall n m : nat, n <= m \\/ m <= n.\nProof.\n        intros. cut (n <= m \\/ m < n). intros. elim H.\n        intros. left. assumption.\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 3399,
                "proof_end_offset": 3543,
                "proof": "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\nsimple induction n.\nsimpl in |- *; trivial.\nintros; simpl in |- *.\nrewrite H.\ntrivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n        intros. right. exact (lt_le_weak m n H0).\n        exact (le_or_lt n m).\nQed.\n\nLemma plus_n_O : forall n : nat, n + 0 = n.\n Proof.\n       simple induction n. trivial.\n       intros. simpl in |- *. rewrite H. trivial.\n Qed.\n \n Lemma S_plus_l : forall n m : nat, S (n + m) = S n + m.\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3545,
                "proof_end_offset": 3788,
                "proof": "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\nsimple induction n.\nsimpl in |- *.\nintro.\ncut (m + 0 = m).\nintros.\nrewrite H.\nexact (le_O_n m).\nexact (plus_O_r m).\nsimpl in |- *.\nintros.\nexact (le_plus_r m (m + n0 * m)).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *; auto with arith.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *.\n\trewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": "\n Proof.\n       simpl in |- *. trivial.\n Qed.\n \n Lemma S_plus_r : forall n m : nat, S (n + m) = n + S m.\n Proof.\n       intros. rewrite (plus_comm n (S m)). rewrite (plus_comm n m).\n       simpl in |- *. trivial.\n Qed.\n\n\n(* lemmes concernant max *)\n\nLemma max_le_Sr_0 :\n forall n m : nat, max n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3790,
                "proof_end_offset": 4019,
                "proof": "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\nintros.\ncut (n * m = m * n).\ncut (n * S m = S m * n).\nintros.\nrewrite H.\nrewrite H0.\nexact (le_mult_lS m n).\nexact (mult_comm n (S m)).\nexact (mult_comm n m).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite H. exact (le_n_O_n m).\n\tsimpl in |- *. intros.\n\trewrite H. exact (le_plus_r m n0).\n\tintros.\n\telim (le_plus_r_S m n0).\n\tintros.\n\tapply le_plus_r_S.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (n = m). intro.\n\trewrite H. exact (le_n_S m).\n\texact (le_plus_r m (S n0) (S n0)).\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.\n\tapply le_plus_r.\n\tintro.Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. simpl in |- *.\n\trewrite plus_n_O; trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\tapply le_plus_r.\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm n m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_comm m).\n\trewrite (plus_Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros. simpl in |- *. intros.\n\trewrite H. exact (le_S_n n m).\n\trewrite <- (plus_n_O (S m)).\n\trewrite <- (plus_n_O (S m)).\n\trewrite <- (plus_n_O (S m)).\n\trewrite <- (plus_n_O (S m)).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm m).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm m).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm m).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm m).\n\trewrite <- (plus_n_Sm (S m)).\n\trewrite <- (plus_n_Sm (S m)).Qed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite H.\n exact (le_plus_r n m).\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m = 0). intro.\n\trewrite H. exact (le_n_O m).\n\tintro.\n\tapply H.\n\ttrivial.\nQed.",
                    "Lemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tsimple induction n. simpl in |- *. intros. cut (m + 0 = m). intro.\n\trewrite H. trivial.\n\trewrite H0. trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " n m <= max n (S m) /\\ max (S n) m <= max (S n) (S m).\nProof.\n\tsimple induction n; simple induction m. simpl in |- *. split. exact (le_n_Sn 0).\n\texact (le_n_n 1).\n\tintros. split. elim H. intros. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\telim H. intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\n",
                "context_tokens": 743,
                "proof_start_offset": 4021,
                "proof_end_offset": 4242,
                "proof": "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\nintros.\ncut (m <= n \\/ n < m).\nintro.\nelim H0; intros.\nleft.\nexact (le_antisym n m H H1).\nright.\nexact (lt_le_S n m H1).\nexact (le_or_lt m n).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tsimple induction n. simpl in |- *. split. exact (le_S_n m).\n\tintro. cut (n = m). intros.\n\trewrite H. exact (le_plus_r m n).\n\tintro. cut (m = n). intros.\n\trewrite H0. exact (le_plus_r m n).\n\tintro. cut (n = n). intro.\n\trewrite H2. exact (le_plus_r m n).\n\tintro.\n\telim (H (S n) (le_plus_r m n)).\n\tintro.\n\telim (H (S n) (le_plus_r m n)).\n\tintro.\n\telim (H (S n) (le_plus_r m n)).\n\tintro.\n\telim (H (S n) (le_plus_r m n)).\n\tintro.\n\telim (H (S n) (le_plus_r m n)).\n\tintro.\n\telim (H (S n) (le_plus_r m n)).\n\tintro.\n\tabsurd (n = n). intros.\n\trewriteQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plusQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\tapply le_n_S.\n\texact (le_plus_r n m).\n\tintro.\n\telim H. intros.\n\tabsurd (m = n).\n\tintro.\n\trewrite H1 in H0.\n\telim (le_S_n (S m) n).\n\tintro.\n\telim H1. intros.\n\tapply le_n_S.\n\texact (le_S_n (S m) n).\n\tintro.\n\telim (le_S_n (S m) n).\n\tintro.\n\telim (le_n_S (S m) n).\n\tintro.\n\trewrite H2 in H0.\n\telim (le_S_n (S m) n).\n\tintro.\n\telim (le_S_n (S m) n).\n\tintro.\n\telim (le_n_S (S m) n).\n\tintro.\n\telim (le_n_S (S m) n).\n\tintro.\n\telim (le_n_S (Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\n\tapply le_plus_l.\n\texact (le_plus_r m n).\n\tintro.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\texact (le_plus_r m n).\n\tintro.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\nelim (lt_or_eq n m).\n\tintro.\n\trewrite H0 in H.\n\tintro.\n\trewrite H0 in H.\n\telim (le_or_eq n m).\n\tintro.\n\trewrite H0 in H.\n\telim (le_or_eq m n).\n\tintro.\n\trewrite H0 in H.\n\telim (le_or_eq (S n) (S m)).\n\tintro.\n\trewrite H0 in H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H0 in H.\n\tintro.\n\trewrite H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H in H.\n\tintro.\n\trewrite H in H.\n\trewrite H in H.\n\tintro.\n\trewrite H in H.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros.\nelim (le_or_lt n m).\n\tintro.\n\tapply le_plus_r; trivial.\n\tintro; absurd (n = m). intro.\n\telim (le_or_lt n m).\n\tintro.\n\tapply le_plus_r; trivial.\n\tintro.\n\tapply le_plus_r; trivial.\n\tintro.\n\tapply le_plus_r; trivial.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tsimple induction n. simpl in |- *. intros. cut (m = n). intros.\n\trewrite H. exact (le_plus_l m n).\n\tintro.\n\trewrite H. exact (le_plus_r n m).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r n m).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r n m).\n\tintro.\n\trewrite H. exact (le_plus_r m n).\n\tintro.\n\trewrite H. exact (le_plus_r n m).\n\tintro.\n\trewrite H.Qed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\trewrite H. trivial.\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros n m H.\n\trewrite H. exact (le_S_l m).\nQed.",
                    "Lemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tsimple induction n. simpl in |- *. intros.\n\tapply le_n_Sn.\n\tapply le_n_Sn.\n\tapply le_S.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.Qed."
                ]
            },
            {
                "filepath": "./coq_projects/tree-automata/bases.v",
                "context": " intros. simpl in |- *. exact (le_n_Sn (S n0)).\n\tsplit. simpl in |- *. cut (max n0 0 = n0). intros. rewrite H0. trivial.\n\trewrite max_l; auto with arith.\n \tsimpl in |- *. exact (le_n_n (S (S n0))).\n\tintros. elim H0. intros. split. simpl in |- *. elim (H n1). intros.\n\texact (le_n_S (max n0 n1) (max n0 (S n1)) H3).\n\tcut (max (S (S n0)) (S n1) = S (max (S n0) n1)).\n\tcut (max (S (S n0)) (S (S n1)) = S (max (S n0) (S n1))).\n\tintros. rewrite H3. rewrite H4. elim (H (S n1)).\n\tintros. elim (H n1). intros.\n\texact (le_n_S (max (S n0) n1) (max (S n0) (S n1)) H8).\n\tsimpl in |- *. trivial.\n\tsimpl in |- *. trivial.\nQed.\n\nLemma max_le_Sr : forall n m : nat, max n m <= max n (S m).\nProof.\n\tintros. elim (max_le_Sr_0 n m). intros. exact H.\nQed.\n\n(* lemmes arithm\u00e9tiques *)\n\nLemma plus_O_r : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma plus_O_l : forall n : nat, n + 0 = n.\nProof.\n\tsimple induction n. simpl in |- *; trivial.\n\tintros; simpl in |- *. rewrite H. trivial.\nQed.\n\nLemma le_mult_lS : forall n m : nat, n * m <= S n * m.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (m + 0 = m). intros.\n\trewrite H. exact (le_O_n m).\n\texact (plus_O_r m).\n\tsimpl in |- *. intros. exact (le_plus_r m (m + n0 * m)).\nQed.\n\nLemma le_mult_rS : forall n m : nat, n * m <= n * S m.\nProof.\n\tintros. cut (n * m = m * n). cut (n * S m = S m * n).\n\tintros. rewrite H. rewrite H0. exact (le_mult_lS m n).\n\texact (mult_comm n (S m)).\n\texact (mult_comm n m).\nQed.\n\nLemma le_disj : forall n m : nat, n <= m -> n = m \\/ S n <= m.\nProof.\n\tintros. cut (m <= n \\/ n < m). intro. elim H0; intros.\n\tleft. exact (le_antisym n m H H1).\n\tright. exact (lt_le_S n m H1).\n\texact (le_or_lt m n).\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4244,
                "proof_end_offset": 5286,
                "proof": "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\nintro.\nsimple induction m.\nintros.\ncut (n = 0).\nintro.\nrewrite H0; trivial.\nsymmetry in |- *.\nexact (le_n_O_eq n H).\ninduction n as [| n Hrecn].\nintros.\nsimpl in |- *.\nexact (le_O_n (p + n * p)).\nintros.\nsimpl in |- *.\ncut (n = n0 \\/ S n <= n0).\nintro.\ncut (n * p <= n0 * p).\nintro.\nelim H1; intros.\ncut (p <= p).\nintros.\nexact (plus_le_compat p p (n * p) (n0 * p) H4 H2).\nexact (le_n_n p).\ncut (n * p <= S n * p).\ncut (S n * p <= n0 * p).\nintros.\napply (le_trans (p + n * p) (p + S n * p) (p + n0 * p)).\nexact (plus_le_compat p p (n * p) (S n * p) (le_n_n p) H5).\nexact (plus_le_compat p p (S n * p) (n0 * p) (le_n_n p) H4).\nexact (H p H3).\nexact (le_mult_lS n p).\nelim H1; intros.\nrewrite H2.\nexact (le_n_n (n0 * p)).\ncut (n * p <= S n * p).\nintro.\ncut (S n * p <= n0 * p).\nintro.\nexact (le_trans (n * p) (S n * p) (n0 * p) H3 H4).\nexact (H p H2).\nexact (le_mult_lS n p).\ncut (n <= n0).\nintro.\nexact (le_disj n n0 H1).\nexact (le_S_n n n0 H0).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_trans with (m := p).\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapplyQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\tapply le_trans with (n * p).\n\tapply le_n_S.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapplyQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (m <= n * p). intro. elim H0; intros.\n\tleft. exact (le_trans m n H H1).\n\tright. exact (le_plus_l n m H1).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tsimple induction n. simpl in |- *. trivial.\n\tintros. simpl in |- *. cut (n = m). intro.\n\trewrite H. trivial.\n\trewrite H0. trivial.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros. cut (n * p <= m). intro. elim H0; intros.\n\tleft. exact (le_S_r m n H1).\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\tright.\n\tintro.\n\tright.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tleft.\n\tright.\n\tintro.\n\tleft.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tleft.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tleft.\n\tintro.\n\tright.\n\tintro.\n\tright.\n\tintro.\n\tleft.\n\tintro.\n\tright.\n\tintro.\n\tleft.\n\tintro.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\n\telim (le_or_lt n m).\n\tintros.\n\tapply le_plus_l.\n\tapply le_plus_l.\n\tapply le_plus_l.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_rQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tsimple induction n. simpl in |- *. intro. cut (n = m). intro.\n\trewrite H. exact (le_plus_r n m).\n\texact (plus_O_r m n H H0).\n\ttrivial.\nQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros n m p; elim (le_or_lt p m).\n\tintro. elim (lt_n_S m).\n\tintros. elim (le_or_eq (S n) m).\n\tintros.\n\tleft. exact (le_plus_l m n).\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_r.\n\tapply le_plus_rQed.",
                    "Lemma le_mult_l : forall n m p : nat, n <= m -> n * p <= m * p.\nProof.\n\tintros.\nelim (le_or_lt n m).\n\tintro.\n\tright. exact (le_S_r n m H1).\n\tright. exact (lt_le_S n m H1).\n\tright. exact (le_S_r m n H H1).\n\tintro.\n\tright. exact (le_S_r m n H H1).\nQed."
                ]
            }
        ],
        "coquelicot": [
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "\n  exact Hl.\nQed.\n\nLemma linear_cont (l : U -> V) (x : U) :\n  is_linear l -> continuous l x.\nProof.\n  intros Hl.\n  apply filterlim_locally_ball_norm => eps.\n  apply locally_le_locally_norm.\n  case: (linear_norm _ Hl) => M Hn.\n  assert (0 < eps / M).\n    apply Rdiv_lt_0_compat.\n    apply cond_pos.\n    apply Hn.\n  exists (mkposreal _ H) => y Hy.\n  rewrite /ball_norm /minus -linear_opp // -linear_plus //.\n  eapply Rle_lt_trans.\n  by apply Hn.\n  evar_last.\n  apply Rmult_lt_compat_l with (2 := Hy).\n  apply Hn.\n  simpl.\n  field.\n  apply Rgt_not_eq, Hn.\nQed.\n\nLemma is_linear_ext (l1 l2 : U -> V) :\n  (forall x, l1 x = l2 x) -> is_linear l1 -> is_linear l2.\nProof.\n  intros Hl Hl1.\n  split.\n  intros ; rewrite -!Hl ; apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\n  case: Hl1 => _ _ [M Hl1].\n  exists M ; split.\n  by apply Hl1.\n  intros ; rewrite -!Hl ; apply Hl1.\nQed.\n\n(** zero in a linear function *)\nLemma is_linear_zero : is_linear (fun _ => zero).\nProof.\n  repeat split.\n  - move => _ _ ; by rewrite plus_zero_l.\n  - move => k _ ; by rewrite scal_zero_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\n",
                "context_tokens": 753,
                "proof_start_offset": 3935,
                "proof_end_offset": 4211,
                "proof": "Lemma is_linear_opp : is_linear (@opp V).\nProof.\nrepeat split.\nmove => x y.\nnow apply opp_plus.\nmove => k x.\napply sym_eq.\napply: scal_opp_r.\nexists 1 ; split.\nexact Rlt_0_1.\nmove => x ; rewrite norm_opp Rmult_1_l.\nby apply Rle_refl.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x.\n  destruct (linear_opp_l x) as [M1 HM2].\n  exists (1 * M1).\n  apply (is_linear_opp _ _ _ _ _ _ _ _ _ Hl1).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  move=> x.\n  destruct (is_linear_opp _ Hl) as [M1 HM2].\n  rewrite M1, N2.\n  apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  split.\n  - move => x.\n    exact (proj1 (proj2 (proj2 (proj1 (proj2 (proj2 (proj1_sig x)))).\n    exact (proj1 (proj2 (proj2 (proj2_sig x)))).\n  - exact (proj1 (proj2 (proj2 (proj2 (proj2 (proj2_sig x)))).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x.\n  rewrite <- (is_linear_opp _ _ x).\n  now apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  apply is_linear_opp.\n  exact Rlt_0_1.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  now destruct 1.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n  - destruct 1.\n    - exists 1 ; split.\n      exact (conj (proj1_sig _ _)).\n    - exists 1 ; split.\n      exact (conj (proj1_sig _ _)).\n    - exists 1 ; split.\n      exact (conj (proj1_sig _ _)).\n  - exists 1 ; split.\n      exact (conj (proj1_sig _ _)).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  apply is_linear_opp.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  exact (is_linear_opp).\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  destruct (is_linear_opp V) as [N1 N2].\n  destruct N1 ; destruct N2 ; destruct N2 ; destruct N3.\n  destruct N1 ; destruct N2 ; destruct N3.\n  reflexivity.\nQed.",
                    "Lemma is_linear_opp : is_linear (@opp V).\nProof.\n  intros x.\n  destruct (is_linear_opp _ x) as [X|X].\n  - exists 0.\n    exact Rlt_0_1.\n  - apply is_linear_opp.\n  - apply is_linear_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": " - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l norm_zero.\n    apply norm_ge_0.\nQed.\n\nEnd LinearFct.\n\nLemma is_linear_comp {K : AbsRing} {U V W : NormedModule K}\n  (l1 : U -> V) (l2 : V -> W) :\n  is_linear l1 -> is_linear l2 -> is_linear (fun x => l2 (l1 x)).\nProof.\n  intros Hl1 Hl2.\n  split.\n  - move => x y.\n    by rewrite!linear_plus.\n  - move => k x.\n    by rewrite!linear_scal.\n  - destruct (linear_norm _ Hl1) as [M1 Hn1].\n    destruct (linear_norm _ Hl2) as [M2 Hn2].\n    exists (M2 * M1) ; split.\n    now apply Rmult_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\n",
                "context_tokens": 740,
                "proof_start_offset": 5017,
                "proof_end_offset": 5487,
                "proof": "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_r.\nmove => u v /= ; apply sym_eq, @scal_assoc.\nexists (norm x + 1) ; split.\napply Rplus_le_lt_0_compat.\napply norm_ge_0.\nexact Rlt_0_1.\nmove => k /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\nnow rewrite Rmult_comm ; apply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  destruct x as [k1 k2].\n  exists k1.\n  intros x.\n  destruct (H k) as (k1,Hk).\n  exists k2.\n  intros k1 k2.\n  rewrite Hk.\n  replace k1 with (k1 + k2) by ring.\n  now apply (f_equal (fun k => scal k x)).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  rewrite /is_linear_scal => k _.\n  rewrite /is_linear_scal => k _.\n  rewrite /is_linear_add.\n  rewrite /is_linear_add /=.\n  rewrite /is_linear_add => k _.\n  by rewrite!big_map /=!big_map /=!big_map.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  apply (is_linear_scal_r _ x).\n  exact (is_linear_scal_l _ x).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  exact (is_linear_scal_l x).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  apply is_linear_opp.\n  - exact is_linear_opp.\n  - exact is_linear_opp.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k.\n  destruct (fn k) as (fn, Hf) eqn: Hf.\n  exists (fun k => (fn k x)).\n  apply (is_linear_scal_l x).\n  apply (is_linear_scal_r x).\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  now intros x.\n  rewrite -[x]un_sum; trivial.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intros k.\n  apply (is_linear_opp (fun k : K => scal k x)).\n  - apply is_linear_opp.\n  - intros k.\n    apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_opp (fun k : K => scal k x)).\n    - apply (is_linear_oppQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  intro k.\n  destruct (is_linear_opp k) as [H|H].\n  - now apply opp_plus.\n  - intros k x.\n    apply scal_opp_r.\n  - now apply opp_inv.\nQed.",
                    "Lemma is_linear_scal_l (x : V) : is_linear (fun k : K => scal k x).\nProof.\n  rewrite /is_linear_add /is_linear.\n  apply/is_linear_opp.\n  exact/is_linear_opp.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coquelicot/theories/Derive.v",
                "context": "_lt_0_compat.\n    move => x.\n    eapply Rle_trans.\n    by apply Hn2.\n    rewrite Rmult_assoc.\n    apply Rmult_le_compat_l.\n    now apply Rlt_le.\n    apply Hn1.\nQed.\n\nSection Op_LinearFct.\n\nContext {K : AbsRing} {V : NormedModule K}.\n\n(** id is a linear function *)\nLemma is_linear_id : is_linear (fun (x : V) => x).\nProof.\n  repeat split.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** opp is a linear function *)\nLemma is_linear_opp : is_linear (@opp V).\nProof.\n  repeat split.\n  - move => x y.\n    now apply opp_plus.\n  - move => k x.\n    apply sym_eq.\n    apply: scal_opp_r.\n  - exists 1 ; split.\n    exact Rlt_0_1.\n    move => x ; rewrite norm_opp Rmult_1_l.\n    by apply Rle_refl.\nQed.\n\n(** plus is a linear function *)\nLemma is_linear_plus : is_linear (fun x : V * V => plus (fst x) (snd x)).\nProof.\n  repeat split.\n  - move => x y.\n    rewrite -!plus_assoc ; apply f_equal.\n    rewrite plus_comm -!plus_assoc.\n    by apply f_equal, @plus_comm.\n  - move => k x.\n    now rewrite scal_distr_l.\n  - exists 2 ; split.\n    exact Rlt_0_2.\n    move => x /= ; eapply Rle_trans.\n    by apply @norm_triangle.\n    rewrite Rmult_plus_distr_r Rmult_1_l ; apply Rplus_le_compat.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> Rabs_pos_eq by apply norm_ge_0.\n    by apply Rmax_l.\n    apply Rle_trans with (2 := proj1 (sqrt_plus_sqr _ _)).\n    rewrite -> (Rabs_pos_eq (norm (snd x))) by apply norm_ge_0.\n    by apply Rmax_r.\nQed.\n\n(** [fun k => scal k x] is a linear function *)\nLemma is_linear_scal_l (x : V) :\n  is_linear (fun k : K => scal k x).\nProof.\n  split.\n  - move => u v ; by apply @scal_distr_r.\n  - move => u v /= ; apply sym_eq, @scal_assoc.\n  - exists (norm x + 1) ; split.\n    apply Rplus_le_lt_0_compat.\n    apply norm_ge_0.\n    exact Rlt_0_1.\n    move => k /=.\n    rewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\n    apply Rplus_le_compat.\n    now rewrite Rmult_comm ; apply norm_scal.\n    apply norm_ge_0.\nQed.\n\n(** [fun x => scal k x] is a linear function if [mult] is commutative *)\n",
                "context_tokens": 724,
                "proof_start_offset": 5562,
                "proof_end_offset": 6076,
                "proof": "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\nsplit.\nmove => u v ; by apply @scal_distr_l.\nmove => u v /= ; apply sym_eq ; rewrite !@scal_assoc.\nby rewrite H.\nexists (abs k + 1) ; split.\napply Rplus_le_lt_0_compat.\napply abs_ge_0.\nexact Rlt_0_1.\nmove => x /=.\nrewrite Rmult_plus_distr_r Rmult_1_l -(Rplus_0_r (norm (scal k x))).\napply Rplus_le_compat.\napply norm_scal.\napply norm_ge_0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k.\n  apply (is_linear_mult _ _ k).\n  intros x; apply scal_mult_distr_r.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k x.\n  apply (is_linear_scal_r k x).\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k Hk.\n  assert (Hx := symmetric_integral_sym k k).\n  assert (Hx' := symmetric_integral_sym k k).\n  assert (Hy' := symmetric_integral_sym k k).\n  assert (H' := symmetric_integral_sym k k).\n  rewrite Hx, Hx, Hy.\n  apply Hx.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k Hk.\n  rewrite <- (is_linear_mult k).\n  rewrite <- (is_linear_mult k).\n  rewrite <- (is_linear_mult k).\n  rewrite <- (is_linear_mult k).\n  rewrite <- (is_linear_mult k).\n  apply sum_is_linear.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  induction k as [k IH].\n  - intros k m IH.\n    destruct (IH (k + m)) as (k',Hk').\n    + rewrite (IH k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k').\n  - intros k k' Hk.\n    destruct (IH (k + m)) as (k',Hk').\n    + rewrite (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k'), (IH' k').\n    apply IH. intros k' Hk'. rewriteQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k Hk Hk.\n  destruct k as [n|n] k Hk.\n  - rewrite (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (S n)) at 2.\n    rewrite <- (hom_sum k (SQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k.\n  rewrite <-!is_linear_mult,!is_linear_mult.\n  rewrite!is_linear_mult.\n  rewrite <-!is_linear_mult.\n  rewrite <-!is_linear_mult.\n  rewrite <-!is_linear_mult.\n  rewrite!is_linear_mult.\n  destruct k as [n IH]; rewrite!IH,!IH,!IH.\n  apply f_equal2.\n  rewrite <- IH, <-!IH,!IH.\n  rewrite <-!IH,!IH,!IH.\n  rewrite <- IH,!IH,!IH,!IH.\n  rewrite <-!IH,!IH,!IH,!IH,!IH.\n  rewrite <-!IH,!IH,!IH.\n  rewrite <-!IH,!IH,!IH,!IH,!IH.\n  rewrite!IH,!IH,!IH,!IH.\n  rewrite <- IH,!IH,!IH,!IH,!IH,!IH.\n  rewrite <-!IH,!IH,!IH,!IH,!IH,!IH.\n  rewrite!IH,!IH,!IH,!IH,!IH,Qed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k Hk.\n  destruct k as [k Hk].\n  - now apply Hk.\n  - apply k_eq.\n    apply k_eq.\n    + apply k_eq.\n    + apply k_eq.\n    + apply k_eq.\n  - apply k_eq.\n  - apply k_eq.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k.\n  apply is_linear_mult.\n  - intros k x.\n    rewrite <- (fun k => proj1_sig k).\n    now apply eq_sym.\n  - intros k x.\n    rewrite <- (fun k => proj1_sig k).\n    rewrite <- (fun k => proj1_sig k).\n    now apply eq_sym.\nQed.",
                    "Lemma is_linear_scal_r (k : K) : (forall n m : K, mult n m = mult m n) -> is_linear (fun x : V => scal k x).\nProof.\n  intros k k.\n  apply (@is_linear_scal_r _ _ k _ _ k _ _ _ k _ k).\nQed."
                ]
            }
        ],
        "fermat4": [
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "\nLemma prop2 : forall m n : Z, rel_prime m n -> rel_prime (m * m) (n * n).\nProof.\n  intros; apply rel_prime_mult; apply rel_prime_sym; apply rel_prime_mult;\n    apply rel_prime_sym; assumption.\nQed.\n\nLemma is_sqr_compat : forall k a : Z,\n  k <> 0 -> is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 20559,
                "proof_end_offset": 20779,
                "proof": "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); rewrite H in H0; clear H; rewrite Zmult_assoc in H0; apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H0; clear H0; intros; auto with zarith.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H0; rewrite <- (Z_div_mod a b c H H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod a b c H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b c H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b c H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b c H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b c H0); apply Z.div_mod.\n  rewrite <- (Z_mod_eq c b H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b c H0); apply Z.div_mod.\n  rewrite <- (Z_mod_eq c b H0); apply Z.div_mod.\n  rewrite <- (Z_mod_eq c b H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b c H0); apply Z.div_mod.\n  rewrite <- (Z_div_mod b cQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  simple induction 1; auto.\n  simple induction 1; auto.\n  intros; elim H1; clear H1; intros; elim H1; clear H1; intros;\n    generalize (Z_le_trans _ _ _ H3); intro;\n      generalize (Z_le_trans _ _ _ H1); intro;\n        generalize (Z_le_trans _ _ _ H4); intro;\n          generalize (Z_le_trans _ _ _ H2); intro;\n          generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n            generalize (Z_le_trans _ _ _ H4); intro;\n              generalize (Z_le_trans _ _ _ H4); intro;\n                generalize (Z_le_transQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; elim H0; clear H0; intros; auto with zarith.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros; generalize (gcd_eq a b); rewrite <- gcd_eq; intuition.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H0; apply rel_prime_mult; apply rel_prime_sym;\n    apply rel_prime_mult; apply rel_prime_sym; assumption.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H0; apply rel_prime_mult; apply rel_prime_mult; auto.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H; rewrite H; rewrite H; auto.\nQed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H0; apply divide_trans with (c := (c * a)).\n  apply divide_trans with (c := (c * a)).\n  apply divide_trans with (c := (c * a)).\n  apply divide_trans with (c := (c * a)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (c := (c * b)).\n  apply divide_trans with (Qed.",
                    "Lemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c H H0; elim H0; clear H0; intros;\n    generalize (divide_0_l a b); intro H0; rewrite H1 in H0;\n      elim (Z_le_gt_dec 0 c); intro;\n        [ rewrite H0 in H0; rewrite H0 in H0; elim (Z_le_gt_dec 0 c);\n          intro;\n            [ rewrite H0 in H1; rewrite Zplus_0_r in H1; rewrite <- H0 in H1;\n                rewrite (Z_eq_dec x0 (Z.succ c)) in H0;\n                rewrite (Z_eq_dec x0 (Z.succ c)) in H0;\n                  rewrite (Z_eq_dec x0 (Z.succ c)) in H0;\n                  rewrite (Z_eq_dec x0 (Z.succ c)) in H0;\n                  rewrite (Z_eq_dec x0 (Z.succ c)) in H0;\n                    rewrite (Z_eq_dec x0 (Z.succ c)) in H0;\n                    rewrite (Z_eq_dec x0 (Z.succ c)) in H0Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " is_sqr ((k * k) * a) -> is_sqr a.\nProof.\n  intros; elim H0; clear H0; intros; do 2 (elim H1; clear H1; intros);\n    elim (rel_prime_dec x k); intro;\n      [ generalize (prop2 _ _ a0); clear a0; intro; rewrite H1 in H3;\n        elim (relp_mult2 _ _ H3); intro;\n          [ rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 20781,
                "proof_end_offset": 21011,
                "proof": "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\nintros a b c (q,H) (q0,H0); cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0; exists (q0 - q); rewrite H0; ring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H1); rewrite H1 in H0; clear H1.\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * b).\n  apply divide_trans with (a * bQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H0) (q0,H1);\n    rewrite H0 in H0; clear H0; rewrite Zmult_assoc in H0;\n    apply (Z_le_ge_0_compat _ _ H1); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H0); rewrite H0 in H0; clear H0;\n    repeat rewrite Zmult_assoc; apply Zmult_ge_0_compat; assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H0) (q1,H1); rewrite H1 in H0; clear H1.\n  apply divide_sum_1; auto.\n  apply divide_sum_2; auto.\n  apply divide_sum_3; auto.\n  apply divide_sum_3; auto.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H1) (q0,H2);\n    rewrite H0 in H1; clear H1; rewrite Zmult_assoc in H2;\n    apply (Zmult_eq_reg_r (a - b) (c - b));\n      apply Zmult_le_compat_l; auto with zarith.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H0); rewrite H0 in H0; clear H0.\n  destruct (Z_le_gt_cases c 0) as [H1|H1]; auto.\n  destruct (Z_le_gt_cases c 0) as [H2|H2]; auto.\n  destruct (Z_le_gt_cases c 0) as [H3|H3]; auto.\n  destruct (Z_le_gt_cases c 0) as [H4|H4]; auto.\n  destruct (Z_le_gt_cases c 0) as [H4|H4]; auto.\n  destruct (Z_le_gt_cases c 0) as [H4|H4]; auto.\n  destruct (Z_le_gt_cases c 0) as [H4|H4]; auto.\n  destruct (Z_le_gt_cases c 0) as [H5|H5]; auto.\n  destruct (Z_le_gt_cases c 0) as [H4|H5]; auto.\n  destruct (Z_le_gt_cases c 0) as [H4|H5]; auto.Qed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H1) (q0,H2);\n    rewrite H0 in H0; clear H1; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); apply Zmult_le_compat_l; auto.\n  apply (Zabs_mult_l (a * q0) (b * q0)); auto.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H0) (q1,H1) (q2,H2);\n    rewrite H0 in H0; clear H0; rewrite Zmult_comm in H1;\n    apply (Zplus_comm a b c (q0 * q0)); assumption.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c H H0.\n  rewrite H0 in H0; clear H H0.\n  rewrite H0 in H0; clear H0.\n  destruct (Z_le_gt_dec a b); [ | left; auto with zarith ].\n  destruct (Z_le_gt_dec b c); [ | right; auto with zarith ].\n  apply (Z.le_ge_cases a b); auto with zarith.\nQed.",
                    "Lemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q0,H1); rewrite H1 in H0; clear H1;\n    rewrite Zmult_comm in H0; clear H1; rewrite Zmult_assoc in H0;\n      apply (Z_le_gt_0_lt_0_compat_l (a - b));\n      omega.\n  rewrite H0 in H0; clear H0; rewrite Zmult_comm in H0;\n    apply (Z_le_gt_0_lt_0_compat_l (a - b));\n      omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " rewrite H4 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            unfold is_sqr; intuition; exists x; intuition\n          | elimtype False; generalize (sqr_pos k); intro; rewrite H4 in H5;\n            auto with zarith ]\n      | elim (not_rel_prime1 _ _ b); clear b; intros; elim H3; clear H3;\n        intros; elim H4; clear H4; intros; elim (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 21013,
                "proof_end_offset": 21297,
                "proof": "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\nintros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a)) in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro; apply Zdivide_intro with (q := q); assumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q0,H0);\n    rewrite H0 in H0; clear H0; intro; rewrite H0 in H0;\n    elim (mult_reg_l b c 0 0); auto with zarith.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q0,H0);\n    cut (c = q0 * a); auto with zarith; clear H0; intro; rewrite H0 in H0;\n      rewrite H0 in H0; discriminate H0.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0.\n  apply divide_trans with (c * a + b * c); auto with zarith; clear H0;\n    replace (b * c * a) with (c * a + b * c); auto with zarith; clear H0; intro;\n      rewrite H0 in H1; rewrite Zmult_assoc in H1; rewrite <- H1; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0 H1; rewrite H; clear H H0.\n  destruct (Z.eq_dec c 0); [ left | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ left | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ left | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ left | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ left | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.\n  destruct (Z.eq_dec c 0); [ right | right ]; trivial.Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0; rewrite H0 in H0; clear H0; rewrite H0 in H0;\n    apply (Zmult_eq_0_compat_l (b * a - b) (c * b)); auto with zarith.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q0,H0) (q1,H1);\n    replace (c * a + b * c) with (c * a + b * c); auto with zarith;\n    replace (c * a + b * c) with (c * a + b * c); auto with zarith;\n    replace (c * a + b * c) with (c * a + b * c); auto with zarith; ring.\nQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q0,H1) (q0,H2);\n    assert (c = q0 * a); auto with zarith; clear H2; intro; rewrite H1 in H2;\n      rewrite H2 in H1; rewrite H2 in H2; rewrite H3 in H2;\n      elim (Z_le_gt_cases a b); intro;\n        [ rewrite H0 in H1; rewrite H1 in H1; rewrite H2 in H1; rewrite H2 in H1;\n        auto with zarith ]\n      | elim (not_rel_prime _ _ H1); intro;\n          [ rewrite H0 in H1; rewrite H1 in H1; rewrite H2 in H1;\n            elim (Z_le_gt_cases a b); intro;\n            [ rewrite H0 in H1; rewrite H1 in H1; rewrite H1 in H1;\n              auto with zarith ] ]\n      | elim (not_rel_prime _ _ H1); intro;\n          [ rewrite H0 in H1; rewrite H1 in H1; rewrite H2 in H1;\n            elim (Z_le_gt_cases a b);Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0.\n  assert (H0 : (c * a | b * a) * b = c * b); auto with zarith; clear H0; intro;\n    rewrite H0 in H1; rewrite Zmult_comm in H1; rewrite Zmult_1_l in H1;\n      rewrite (Zplus_comm a b) in H0; rewrite H0 in H1; rewrite Zmult_1_l in H1;\n        rewrite (Zplus_comm b c) in H0; rewrite H0 in H0;\n          rewrite (Zplus_comm b c) in H0;\n            rewrite (Zplus_comm b c) in H0;\n            rewrite (Zplus_comm b c) in H0;\n            rewrite (Zplus_comm b c) in H0;\n              rewrite (Zplus_comm b c) in H0;\n                rewrite (Zplus_comm b c) in H0;\n                rewrite (Zplus_comm b c) in H0;\n                rewrite (Zplus_comm b c) in H0;\n                  rewrite (Zplus_comm b c) in H0;\n                    rewrite (Zplus_comm b c) in H0;\n                    rewrite (Zplus_commQed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H H0; cut (c = q0 * a); auto with zarith; clear H0; intro; rewrite H0 in H0;\n    elim (Z_eq_dec a 0); intro;\n      [ rewrite H0 in H0; rewrite Zmult_1_r in H0; rewrite <- H0 in H0;\n        rewrite <- H0 in H0; rewrite <- H0 in H0;\n          rewrite <- H0 in H0; rewrite <- H0 in H0; rewrite <- H0 in H0;\n          rewrite <- H0 in H0; rewrite <- H0 in H0;\n            rewrite <- H0 in H0; rewrite <- H0 in H0;\n            rewrite <- H0 in H0; rewrite <- H0 in H0;\n              rewrite <- H0 in H0; rewrite <- H0 in H0;\n              rewrite <- H0 in H0; rewrite <- H0 in H0;\n              rewrite <- H0 in H0; rewrite <- H0 in H0;\n              rewrite <- H0 in H0; rewrite <- H0 in H0;\n                rewrite <- H0 in H0; rewrite <- H0 in H0;Qed.",
                    "Lemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c (q0,H0);\n    generalize (divide_0_l a b c (q0 * a));\n      rewrite H; clear H0; intro; rewrite H0 in H0;\n      generalize (mult_0_l a b c (q0 * a));\n        rewrite H0; clear H0; intro;\n        generalize (mult_0_l a b c (q0 * a));\n          rewrite H0; clear H0; intro;\n          generalize (mult_0_l b c (q0 * a)) (mult_comm a b c (q0 * a));\n            rewrite H0; clear H0; intro;\n            generalize (mult_0_l b c (q0 * a));\n            rewrite H0; clear H0; intro;\n              generalize (mult_0_l a (q0 * a));\n                rewrite H0; clear H0; intro;\n                generalize (mult_0_l a b c (q0 * a));\n                rewrite H0; clear H0; intro;\n                generalize (mult_0_l a b c (q0 * a));\n                  rewrite H0; clear H0; intro;\n                  generalizeQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": " (gcd_rel_prime _ _ _ H3);\n        clear H3; intros; do 2 (elim H3; clear H3; intros); elim H6; clear H6;\n        intros; rewrite H3 in H1; rewrite H6 in H1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\n",
                "context_tokens": 747,
                "proof_start_offset": 21299,
                "proof_end_offset": 21412,
                "proof": "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\nintros; elim H; clear H; intros; auto with zarith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz; case (z?= 0); auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz.\n  destruct z as [|z|z]; [destruct z as [|z|z]; [exists (z * z); rewrite Hz | rewrite Hz ];\n  rewrite H; rewrite H0; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; replace z with 0 by auto with zarith.\n  replace z with 0 by auto with zarith.\n  rewrite H0; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z; rewrite (z_eq_sym z); auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz; exists (z * z); repeat rewrite Hz; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz.\n  replace (z * z) with (z * z + (z * z)).\n  rewrite (z_c (z * z)); auto with zarith.\n  rewrite (z_c (z * z)); auto with zarith.\n  rewrite (z_c (z * z)); auto with zarith.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz; generalize (z Hz); generalize (z Hz); generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (z Hz).\n  intros Hz; generalize (z Hz); clear (Qed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz; exists (z * z); rewrite Hz; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz.\n  generalize (Z_div_mod_eq z z Hz); intros (q0, Hz).\n  generalize (Z_div_mod_eq z z Hz); intros (q1, Hz1).\n  generalize (Z_div_mod_eq z z Hz); intros (q2, Hz2).\n  destruct (Z_div_mod_eq z z Hz1) as (q3, Hz3).\n  generalize (Z_div_mod_eq z z Hz2); intros (q3, Hz4).\n  generalize (Z_div_mod_eq z z Hz2); intros (q4, Hz4).\n  destruct (Z_div_mod_eq z z Hz2) as (q4, Hz4).\n  generalize (Z_div_mod_eq z z Hz3); intros (q5, Hz5).\n  destruct (Z_div_mod_eq z z Hz4) as (q6, Hz6).\n  destruct (Z_div_mod_eq z z Hz4) as (q6, Hz9).\n  exists (q6 * q6); rewrite Hz6; ring.\nQed.",
                    "Lemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros z Hz.\n  replace (z * z) with (z * z * z + 0); [|ring]; auto with zarith.\n  rewrite H0; ring.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fermat4/ArithCompl.v",
                "context": "1; elim (Z_eq_dec x0 0);\n        intro; try (elimtype False; rewrite a0 in H6; simpl in H6; auto);\n        replace (x0 * x1 * (x0 * x1)) with (x0 * x0 * (x1 * x1)) in H1;\n        try ring; replace (x0 * x2 * (x0 * x2) * a) with\n        (x0 * x0 * (x2 * x2 * a)) in H1; try ring; generalize (sqr_spos _ b);\n        clear b; intro; cut ((x1 * x1) = x2 * x2 * a);\n        try (apply Zcompare_Eq_eq;\n        rewrite (Zmult_compare_compat_l (x1 * x1) (x2 * x2 * a) (x0 * x0) H8);\n        elim (Zcompare_Eq_iff_eq (x0 * x0 * (x1 * x1))\n        (x0 * x0 * (x2 * x2 * a))); auto); clear H1; intro;\n        generalize (prop2 _ _ H7); clear H7; intro; rewrite H1 in H7;\n        elim (relp_mult2 _ _ H7); intro;\n          [ rewrite H9 in H1; rewrite Zmult_1_l in H1; rewrite <- H1;\n            elim (Z_le_dec 0 x1); intro;\n              [ unfold is_sqr; intuition; exists x1; intuition\n              | split; [ apply Zge_le; apply sqr_pos | exists (-x1);\n                intuition; ring ] ]\n          | elimtype False; generalize (sqr_pos x2); intro; rewrite H9 in H10;\n            auto with zarith ] ].\nQed.\n\nLemma divide_trans : forall a b c : Z, (a | b) -> (b | c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    rewrite H in H0; clear H; rewrite Zmult_assoc in H0;\n    apply (Zdivide_intro a c (q0 * q)); assumption.\nQed.\n\nLemma divide_sum : forall a b c : Z, (a | b) -> (a | b + c) -> (a | c).\nProof.\n  intros a b c (q,H) (q0,H0);\n    cut (c = q0 * a - b); auto with zarith; clear H0; intro; rewrite H in H0;\n    exists (q0 - q); rewrite H0; ring.\nQed.\n\nLemma divide_mult_l : forall a b c : Z, c <> 0 -> (c * a | c * b) -> (a | b).\nProof.\n  intros a b c H (q,H0); replace (q * (c * a)) with (c * (q * a))\n    in H0; try ring; generalize (Zmult_eq_reg_l _ _ _ H0 H); clear H0; intro;\n    apply Zdivide_intro with (q := q); assumption.\nQed.\n\nLemma divide_0 : forall z : Z, (0 | z) -> z = 0.\nProof.\n  intros; elim H; clear H; intros; auto with zarith.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 21414,
                "proof_end_offset": 21759,
                "proof": "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\nintros; cut (2 <> 0); auto with zarith; intro; generalize (Zdivide_bounds _ _ H2 H3); clear H2; simpl; generalize H; generalize H0; generalize H1; elim z; simpl; intros; progress (auto with zarith) || (elimtype False; auto with zarith).\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz Hxy; exists (z * x); rewrite Hz; rewrite Hz; ring.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz H H0.\n  assert (z <> 0).\n  apply (divide_0_l _ _ H0).\n  apply divide_trans with (q * z + (z * (z * a))).\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  apply divide_mult_l.\n  rewrite (mult_comm z).\n  rewrite (mult_comm (z * a)).\n  apply (mul_1_r (z * a)).\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz H1 H2.\n  apply divide_mult_l with (q := 1); assumption.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz Hz Hz.\n  case (z?= Z.le_gt_cases z 0); intro Hnz.\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [Hnz|Hnz].\n  apply (Z.lt_gt_cases z 0); auto with zarith.\n  destruct Hnz as [HnQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz Hz Hz.\n  destruct (z?= z).\n  rewrite (mult_comm (z + z)); rewrite (mult_comm (z + z)); rewrite (mult_comm (z + z)); ring.\n  apply (mult_cancel_l (z * x * z)); auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 H2; elim H1; clear H1; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H H0; rewrite (mul_comm z); apply divide_mult_l.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 H2; generalize (Zmult_eq_reg_l _ _ H2); clear H1; intro.\n  apply Zdivide_intro with (q := z); assumption.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z Hz Hz Hz; elim Hz; clear Hz; intros; auto with zarith.\nQed.",
                    "Lemma divide_2 : forall z : Z, 0 <= z -> z <> 0 -> z <> 1 -> (z | 2) -> z = 2.\nProof.\n  intros z H1 H2.\n  assert (z = (z * x)); auto with zarith.\n  rewrite H1 in H2; rewrite H2 in H2; auto.\n  replace (z * x) with (z * x) in H1; auto with zarith.\n  apply Z_div_mult_l with (q * x); auto with zarith.\n  apply Z_div_mult_l with (q * x); auto with zarith.\nQed."
                ]
            }
        ],
        "demos": [
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": ") \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n\n(*-- Intuition: Tactics for simplifications of buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 3939,
                "proof_end_offset": 3991,
                "proof": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.",
                    "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " buts, based on LJT calcul.\n     Ref      : Cesar Munoz, Rapport de stage de DEA 1993. --*)\n\nTheorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 3993,
                "proof_end_offset": 4051,
                "proof": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.",
                    "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 4053,
                "proof_end_offset": 4125,
                "proof": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.",
                    "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " P 0.\nintuition.\nQed.\n\n(*  A private club has the following rules :\n *\n * . rule 1 : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4127,
                "proof_end_offset": 4190,
                "proof": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.",
                    "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo_tauto.v",
                "context": " : Every non-scottish member wears red socks\n * . rule 2 : Every member wears a kilt or doesn't wear red socks\n * . rule 3 : The married members don't go out on sunday\n * . rule 4 : A member goes out on sunday if and only if he is scottish\n * . rule 5 : Every member who wears a kilt is scottish and married\n * . rule 6 : Every scottish member wears a kilt\n *\n *  Actually, no one can be accepted!\n *)\n\nSection club.\n\nVariable Scottish RedSocks WearKilt Married GoOutSunday : Prop.\n\nHypothesis rule1 : ~ Scottish -> RedSocks.\nHypothesis rule2 : WearKilt \\/ ~ RedSocks.\nHypothesis rule3 : Married -> ~ GoOutSunday.\nHypothesis rule4 : GoOutSunday <-> Scottish.\nHypothesis rule5 : WearKilt -> Scottish /\\ Married.\nHypothesis rule6 : Scottish -> WearKilt.\n\nLemma NoMember : False.\ntauto.\nQed.\n\nEnd club.\n\nTheorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n\nTheorem tauto1 : A -> A.\ntauto.\nQed.\n\nTheorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n\nTheorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n\nTheorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n\nTheorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n\nTheorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n\nTheorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n\nTheorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n\nTheorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n\nTheorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n\nTheorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n\nTheorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n\nTheorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n\nTheorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n\nTheorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 4192,
                "proof_end_offset": 4255,
                "proof": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\nProof.\ntauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.",
                    "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\n",
                "context_tokens": 329,
                "proof_start_offset": 2541,
                "proof_end_offset": 2641,
                "proof": "Goal forall n : nat, n = Plus n 0.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.",
                "end_command": "Save Plus_n_O.",
                "generated_proofs": [
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nintros.\nreflexivity.\nintros.\nreflexivity.\nintros.\nreflexivity.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\ncase n.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.\nelim H.\nsimple induction n.\nintros.Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (mult_n_O 0).\nelim (mult_n_O 0).\nelim (mult_n_O 0).\nelim (mult_n_O 0).\nelim (mult_n_O 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_O (S n) 0).\nelim (mult_n_Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (eq_nat_dec n 0); auto.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\napply O.\napply S_n.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nsimple induction n.\nsimple induction n.\nsimple induction n.\nsimpl in |- *.\nauto with arith.\nintros m H.\nelim (H m).\nintros.\nelim H.\nintros.\nelim (H m).\nintros.\nelim (H m).\nintros.\nelim (H m).\nintros.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H8.\nintrosSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros n.\nelim (eq_n_O n).\nelim (eq_n_O n).\nintros.\nelim H1.\nelim H1.\nintros.\nelim H1.\nintros.\nelim H2.\nintros.\nelim H3.\nintros.\nelim H4.\nintros.\nelim H5.\nintros.\nelim H5.\nintros.\nelim H6.\nintros.\nelim H6.\nintros.\nelim H7.\nintros.\nelim H7.\nintros.\nelim H8.\nintros.\nelim H8.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H9.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.\nelim H9.\nintros.\nelim H10.\nintros.\nelim H10.\nintros.Save Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros; elim n.\napply S_n.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\napply O.\nSave Plus_n_O.",
                    "Goal forall n : nat, n = Plus n 0.\nintros.\nelim (le_n_O n).\nelim (lt_O_n n).\nelim (eq_n_O n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_n_O n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_n_S n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (eq_S_n n).\nelim (Save Plus_n_O."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                                          *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\n",
                "context_tokens": 340,
                "proof_start_offset": 2666,
                "proof_end_offset": 2781,
                "proof": "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nProof.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                "end_command": "Save Plus_S.",
                "generated_proofs": [
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.",
                    "Goal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_S."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "  *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\n",
                "context_tokens": 371,
                "proof_start_offset": 2804,
                "proof_end_offset": 2949,
                "proof": "Goal forall n m : nat, Plus n m = Plus m n.\nProof.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.",
                "end_command": "Save Plus_com.",
                "generated_proofs": [
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_com.",
                    "Goal forall n m : nat, Plus n m = Plus m n.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_com."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "etails.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\n",
                "context_tokens": 385,
                "proof_start_offset": 2976,
                "proof_end_offset": 3104,
                "proof": "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                "end_command": "Save Plus_simpl.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simple induction m; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simple induction m; simpl in |- *; auto with arith.\nSave Plus_simpl.",
                    "Goal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_simpl."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": " a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\n",
                "context_tokens": 412,
                "proof_start_offset": 3106,
                "proof_end_offset": 3237,
                "proof": "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nProof.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.",
                "end_command": "Save Plus_assoc.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nintros n m p H H0; elim (plus_n_O n m); auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction m; simpl in |- *; auto with arith.\nSave Plus_assoc.",
                    "Goal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with arith.\nSave Plus_assoc."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "in St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\n(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(*                 The Calculus of Inductive Constructions                  *)\n(*                                                                          *)\n(*                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\n",
                "context_tokens": 429,
                "proof_start_offset": 3264,
                "proof_end_offset": 3360,
                "proof": "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nProof.\nauto with core.\nSave assoc_Plus.",
                "end_command": "Save assoc_Plus.",
                "generated_proofs": [
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction m; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction m; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction m; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus.",
                    "Goal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nsimple induction n; simpl in |- *; auto with arith.\nSave assoc_Plus."
                ]
            },
            {
                "filepath": "./coq_projects/demos/Demo.v",
                "context": "                                Projet Coq                                *)\n(*                                                                          *)\n(*                     INRIA                        ENS-CNRS                *)\n(*              Rocquencourt                        Lyon                    *)\n(*                                                                          *)\n(*                                Coq V5.10                                 *)\n(*                              Nov 25th 1994                               *)\n(*                                                                          *)\n(****************************************************************************)\n(*                                  Demo.v                                  *)\n(****************************************************************************)\n\n(* A short demo of coq *)\n\nFixpoint Plus (n : nat) : nat -> nat :=\n  fun m : nat => match n with\n                 | O => m\n                 | S p => S (Plus p m)\n                 end.\n\n(**********************************************)\n(***      A few elementary properties       ***)\n(**********************************************)\n\nGoal forall n : nat, n = Plus n 0.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_n_O.\nHint Resolve Plus_n_O.\n\nGoal forall m n : nat, S (Plus m n) = Plus m (S n).\nsimple induction m; simpl in |- *; auto with core.\nSave Plus_S.\nHint Resolve Plus_S.\n\nGoal forall n m : nat, Plus n m = Plus m n.\nsimple induction m; simpl in |- *; auto with core.\nsimple induction 1; auto with core.\nSave Plus_com.\nHint Immediate Plus_com.\n\nGoal forall n m p : nat, Plus n m = Plus n p -> m = p :>nat.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_simpl.\n\nGoal forall n m p : nat, Plus n (Plus m p) = Plus (Plus n m) p.\nsimple induction n; simpl in |- *; auto with core.\nSave Plus_assoc.\nHint Resolve Plus_assoc.\n\nGoal forall n m p : nat, Plus (Plus n m) p = Plus n (Plus m p).\nauto with core.\nSave assoc_Plus.\n\n\n(************************************)\n(***         Trees                ***)\n(************************************)\n\nInductive tree : Set :=\n  | tip : tree\n  | node : tree -> tree -> tree.  \n\nFixpoint size (t : tree) : nat :=\n  match t return nat with\n  | tip => 1\n  | node u v => Plus (size u) (size v)\n  end.\n\n",
                "context_tokens": 487,
                "proof_start_offset": 3676,
                "proof_end_offset": 3802,
                "proof": "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nProof.\nsimpl in |- *; auto with core.\nSave size_assoc.",
                "end_command": "Save size_assoc.",
                "generated_proofs": [
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\npattern (size v) at 2 3 in |- *.\nelim (le_lt_eq_dec n (S n)); intros.\nabsurd (S (S n) = S (S n)).\nelim (le_lt_eq_dec n (S n)); intros.\nabsurd (S n = S (S n)).\nelim (le_lt_eq_dec n (S n)); intros.\nabsurd (S n = S (S n)).\nelim (le_lt_eq_eq_dec n (S n)); intro.\nabsurd (S n = S (S n)).\nelim (le_lt_eq_eq_dec n (S n)); intros.\nabsurd (S n = S (S n)).\nelim (le_lt_eq_eq_dec n (S n)); intros.\nabsurd (S n = S (S n)).\nelim (le_lt_eq_eq_dec n (S n)); intros.\nabsurd (S n = S n).\nelim (le_lt_eq_eq_dec n (S n)); intros.\nabsurd (S n = S (S n)).\nelim (le_ltSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros.\npattern t at 2 in |- *.\npattern t at 2 in |- *.\npattern (max 0 v) at 2 in |- *.\npattern (max 0 v) at 2 in |- *.\npattern (max 0 v) at 2 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 2 in |- *.\npattern (max 0 v) at 2 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 2 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (min 0 v) at 2 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (max 0 v) at 1 in |- *.\npattern (min 0 v) at 1Save size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim u; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nintros; elim (le_or_lt (node (node t u) v)); auto with arith.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with bool.\nSave size_assoc.",
                    "Goal forall t u v : tree, size (node t (node u v)) = size (node (node t u) v).\nsimple induction t; simpl in |- *; auto with arith.\nSave size_assoc."
                ]
            }
        ],
        "coqoban": [
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "R l3' b'))\n      end\n  | _ => b\n  end.\n\nFixpoint stepwest (b : Board) : Board :=\n  match b with\n  | K r b' => K (rowstepwest r) b'\n  | R r b' => R r (stepwest b')\n  | Nothing => Nothing\n  end.\n\n\n(* This one's obvious: *)\nDefinition dostep (r : Direction) (b : Board) : Board :=\n  match r with\n  | No => stepnorth b\n  | Ea => stepeast b\n  | So => stepsouth b\n  | We => stepwest b\n  end.\n\n\n\n(* The game of Sokoban now boils down to: given a board, prove it's solvable.\n   If it's ready (see above: no loose boxes) then it's solvable (constructor OK)\n   and it is also solvable if it's solvable after one step (constructor STEP) *)\nInductive solvable : Board -> Prop :=\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 763,
                "proof_start_offset": 9802,
                "proof_end_offset": 10183,
                "proof": "Goal solvable b.\nProof.\nunfold b in |- *.\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\napply STEP with Ea.\nsimpl in |- *.\nn.\nn.\ne.\ns.\ns.\nSave solution'_b.",
                "end_command": "Save solution'_b.",
                "generated_proofs": [
                    "Goal solvable b.\nunfold b in |- *.\nsplit.\napply H.\napply H0.\nSave solution'_b.",
                    "Goal solvable b.\ndestruct b.\n(* The following lemma, the same state is not false if it's not true,\n   it is not true if it's not true or false *)\nAdmitted.\nSave solution'_b.",
                    "Goal solvable b.\nunfold b in |- *; simpl in |- *; intuition.\nSave solution'_b.",
                    "Goal solvable b.\nProof.\nunfold b.\nFail apply necR_refl.\nSave solution'_b.",
                    "Goal solvable b.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b in |- *.\nunfold b inSave solution'_b.",
                    "Goal solvable b.\nunfold b; apply (H b c); trivial.\nSave solution'_b.",
                    "Goal solvable b.\nintro.\nchange\n  ((fun x : nat => (fun y : nat => x = y /\\ y = x))\n  && (fun x : nat => (fun y : nat => x = y /\\ y = x))\n  && (fun x : nat => (fun y : nat => x = y /\\ y = x))).\nintro.\nchange\n  ((fun x : nat => (fun y : nat => x = y /\\ y = x)))\n  && (fun x : nat => (fun y : nat => x = y /\\ y = x))).\nintro.\nchange\n  ((fun x : nat => (fun y : nat => x = y /\\ y = x))\n  && (fun x : nat => (fun y : nat => x = y /\\ y = x))).\nintro.\nchange\n  ((fun x : nat => (fun y : nat => x = y /\\ y = x /\\ y = x)))\n  || (fun x : nat => (fun y : nat => x = y /\\ y = x))\n  || (fun x : nat => (fun y : nat => x = y /\\ y = x))).\nintro.\nchange\n  ((fun x : nat => (fun y :Save solution'_b.",
                    "Goal solvable b.\nAdmitted.\n\n(* The next case of the identity function (b,c) *)\n\nGoal exists b : bool, b = true /\\ ~ b = true.\nAdmitted.\nSave solution'_b.",
                    "Goal solvable b.\ntry (apply (Build_Predicate (A:=B) (B:=B) (B:=B) (B:=B) (B:=B)).\n\n(* Now, the same is the same value of the same value of the same value *)\n(*   not the same value of the same value *)\n(*   not the same value of the same value *)\n(*   not the same value *)\n(*   not in the same value *)\n(*   not in the same value *)\n(*   not in the same value *)\n(*     not in the same value *)\n(*   not in the same value *)\n(*  not in the same value *)\n(*   not in the same value *)\n(*     not in the same value *)\n(*   not in the same value *)\n(*  not in the same value *)\n(*  not in the same value *)\n(*   not in the same value *)\n(*     not in the same value *)\n(*   not in the same value *)\n(*   not in the same value *)\n(*   not in the same value *)\n(*     not in the same value *)\n(*   not in the same value *)\n(*   not in the same value *)Save solution'_b.",
                    "Goal solvable b.\nintros.\nunfold b, b in |- *; apply (H b).\nSave solution'_b."
                ]
            },
            {
                "filepath": "./coq_projects/coqoban/Coqoban_engine.v",
                "context": "\n  | OK : forall b : Board, ready b -> solvable b\n  | STEP :\n      forall (b : Board) (d : Direction), solvable (dostep d b) -> solvable b.\n\n\n(* Four tactics to play the game easier: *)\nLtac n :=\n  apply STEP with No; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac e :=\n  apply STEP with Ea; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac s :=\n  apply STEP with So; simpl in |- *; try (apply OK; simpl in |- *; tauto).\nLtac w :=\n  apply STEP with We; simpl in |- *; try (apply OK; simpl in |- *; tauto).\n\n(* Notations *)\nNotation \"'_' a\" := (C Empty a) (at level 0, right associativity).\nNotation \"#  a\" := (C Wall a) (at level 0, right associativity).\nNotation \"+ a\" := (C Keeper a) (at level 0, right associativity).\nNotation \"'X' a\" := (C Box a) (at level 0, right associativity).\nNotation \"'O' a\" := (C Dest a) (at level 0, right associativity).\nNotation \"*  a\" := (C Full a) (at level 0, right associativity).\nNotation \"'o'  a\" := (C KeepOD a) (at level 0, right associativity).\nNotation \"<|\" := Nil (at level 0).\n\nNotation \"|> a b\" := (R a b)\n  (format \"'[v' |>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"+> a b\" := (K a b)\n  (format \"'[v' +>  a '/' b ']'\", at level 0, a, b at level 0).\nNotation \"|><|\" := Nothing (format \"|><| '//'\", at level 0).\n\n(* A silly example *)\n\nDefinition b :=\n  |> # # # # # # # <|\n  |> # _ _ _ _ _ # <|\n  +> #\n     _ +\n       X _ _ # <| (* Note: the row containing the keeper (+) must be indicated *)\n  |> #\n     _ _ _ _ _ # <| (*       by +> instead of |>  (constructor K instead of R)  *)\n  |> # _ _ _ _ O # <|\n  |> # # # # # # # <|\n  |><|\n .\n\nGoal solvable b.\nunfold b in |- *.\n(* Stepping east, the hard way *)\napply STEP with Ea.\nunfold dostep in |- *.\nunfold stepeast in |- *.\nunfold rowstepeast in |- *.\nunfold move in |- *.\n(* Another step east, still hard *)\napply STEP with Ea.\nsimpl in |- *.\n(* Or using simply the tactics: *)\nn.\n(* We can tell Coq to go north even if there's a wall *)\nn.\ne.\ns.\ns.\nSave solution'_b.\nPrint solution'_b. (* Look at the start of this term! *)\n\nDefinition microban_1 :=\n  |> # # # # <|\n  |> # _ O # <|\n  |> # _ _ # # # <|\n  +> # *  + _ _ # <|\n  |> # _ _ X _ # <|\n  |> # _ _ # # # <|\n  |> # # # # <|\n  |><|\n .\n\n",
                "context_tokens": 758,
                "proof_start_offset": 10408,
                "proof_end_offset": 10585,
                "proof": "Goal solvable microban_1.\nProof.\nunfold microban_1 in |- *.\ns.\nw.\nn.\ne.\ne.\ne.\ns.\nw.\nn.\nw.\nw.\ns.\ns.\ne.\nn.\nw.\nn.\ne.\nn.\nn.\nw.\ns.\ne.\ns.\ns.\ne.\ne.\nn.\nw.\ns.\nw.\nn.\nn.\nSave microban_1_solution.",
                "end_command": "Save microban_1_solution.",
                "generated_proofs": [
                    "Goal solvable microban_1.\nunfold micGutsTactic_1, no_cond, no_cond, no_cond, no_cond_', no_cond_', no_cond_', no_cond_', no_cond_', and is_cond_', no_cond_', not_cond_', not_cond_', no_cond_', not_cond_', not_cond_', not_cond_', not_cond_', no_cond_', not_cond_', not_cond_', not_cond_', no_cond_', not_cond_', no_cond_', not_cond_', not_cond_', not_cond_', not_cond_', not_ghost_ghost_ref.\n\n(* The following two lemmas about the lemma *)\nLtac is_cond_not_in_SEP :=\n  match goal with\n  | H: ~?P |- _ => is_cond_not_in_SEP\n  | H: ~?P |- _ => is_cond_not_in_SEP\n  | H: ~?P |- _ => is_cond_not_in_SEP\n  | H: ~?P |- _ => is_cond_not_inSave microban_1_solution.",
                    "Goal solvable microban_1.\napply (Build_quotient (M:=M) (M:=M) (M:=M) (M':=M)); try assumption.\nintros x y.\nsimpl in |- *.\nintros x y.\nsimpl in |- *.\nintros x y.\nsimpl in |- *.\nintros x y.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.\nintros x y z.\nsimpl in |- *.Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsan_1, michombusan_2, micdayan_2, mic sparsityan_3, mic ********************)\nintros.\napply same_side_1.\napply same_side_2.\napply same_side_3.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_side_4.\napply same_Save microban_1_solution.",
                    "Goal solvable microban_1.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_scalar_bound.\napply full_is_Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsInfix_1.\napply(nicensionan_2).\napply(nicensionan_3).\napply(nickrun (_ : mic \u226b\u2013> (mod mic ELSE (mod mic ELSE (mod mic THEN (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod mic \u2192 mic);;mic')))).\nintros.\n(* Apply the end of G is just not in the case of G, it is not *)\n(*   (not mic ELSE (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod micTests (mod mic ELSE (mod mic ELSE (mod mic)))))). *)\n(* We need to prove the lemma in G, but not be in the case of G, but it is *)\n(*   (not mic ELSE (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod mic THEN (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod miccte (mod mic ELSE (mod mic ELSE (mod mic ELSE (mod mic \u2227 (Save microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsInfix_1_2.\nunfold micerveInfix_2_3_3_4_5.\nunfold mic***********)\n\nSection Art.\n\nVariable A : Ens.\n\nLet step1 : has_n_elements n_elements.\napply has_n_elements.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_n_elements in |- *.\nunfold has_elements inSave microban_1_solution.",
                    "Goal solvable microban_1.\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_b b).\napply(is_a_reg_a_reg_a b).\napply(is_a_reg_a_reg_a b).\napply(is_a_reg_a_reg_a b).\napply(is_a_reg_a_regSave microban_1_solution.",
                    "Goal solvable microban_1.\nsplit.\nunfold micautmE_1 in |- *.\napply (Build_Map (D:=E)); unfold micgetThreadan_1 in |- *.\napply (Build_Map (D:=E)); unfold micerveInfix_1 in |- *.\napply (Build_Map (D:=E)); unfold micGutsInfix_1 in |- *.\nintros.\n(* Case *)\n\napply (Build_Map (D:=E)); unfold micGutsInfix_2 in |- *.\nintros.\napply (Build_Map (D:=E)); unfold micGuts in |- *.\napply (Build_Map (D:=E)); unfold micGutsInfix_3 in |- *.\nintros.\napply (Build_Map (D:=E)); unfold micerve in |- *.\napply (Build_Map (D:=E)); unfold micGutsInfix_3 in |- *.\nintros.\napply (Build_Map (D:=E)); unfold mic >>\"\n(Build_Map (D:=E)); unfold micGutsInfix_3 in |- *.\nintros.\napply (Build_Map (D:=E)); unfold micGutsInfix_3 in |- *.\nintros.\napplySave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGuts's_1, micEalignof's_2, mic sparsity's_3, and hence we have to do this *)\napply no_empty_micclassic.\n(* the same is in the same time *)\napply no_empty_micclassic.\n(* The proof is the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as *)\n(*  (e.g., the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as *)\n(*  (e.g., the same as the same as the same as the same as the same as the same as the same as the same as the same as *)\n(*  (e.g., the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as the same as *)\n(*  (e.g., the same as the same as the same as the same as the same as the same as theSave microban_1_solution.",
                    "Goal solvable microban_1.\nunfold micGutsan_1, micGutsan_1.\nunfold micHistoryAntiChainan_1, miclatestThreadan_2, micmkPoolan_2.\nunfold micGutsan_1, mic SuchThatCorrectan_2.\nunfold micmkPoolsP_1, micEalignofan_2, micmkPoolan_3.\nunfold micGutsan_3, micGutsInfix_3, micdependenceInfix_4, mic ridal_defs.\n\n(* The problem is a theorem: *)\n\nDefinition micefinite :=\n  ~ # # # <dep\n  O\n  \\/ ~ (exists P : nat -> Prop, (exists P : nat -> Prop, (P /\\ P)).\n\nDefinition micefinite :=\n  ~ # # # # <|\n  O\n  \\/ ~ (exists P : nat -> Prop, (exists P : nat -> Prop, (P /\\ P))).\n\nDefinition micefinite :=\n  ~ # # # # <|\n  /\\ ~ (exists P : nat -> Prop, (exists P : nat -> Prop, (P /\\ Q)).\n\n(* We show that the following definition of the axiom of the proof of theSave microban_1_solution."
                ]
            }
        ],
        "goedel": [
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": "\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 9996,
                "proof_end_offset": 10123,
                "proof": "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\napply (fetoreCorrect _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nintros.\nreflexivity.\nQed.",
                    "Lemma codeOrCorrect : forall a b : Formula, codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10202,
                "proof_end_offset": 10332,
                "proof": "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeAndCorrect : forall a b : Formula, codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/code.v",
                "context": " A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R0|\n      f]\n | destruct q\n    as\n     [A|\n      Axm1 Axm2 A B p p0|\n      Axm A v n p|\n      A B|\n      A B C|\n      A B|\n      A v t|\n      A v n|\n      A B v|\n      |\n      |\n      |\n      R|\n      f0] ];\n (simpl in H;\n   try\n    match goal with\n    | h:(cPair?X1?X2 = cPair?X3?X4) |- _ =>\n        elimtype False; cut (X1 = X3);\n         [ discriminate | eapply cPairInj1; apply h ]\n    end); try reflexivity.\nreplace A0 with A.\nreflexivity.\napply codeFormulaInj.\neapply cPairInj2.\napply H.\nreplace Axm0 with Axm1.\nreplace Axm3 with Axm2.\nreflexivity.\neapply Hrecp0 with A0 p2.\ndo 3 eapply cPairInj2.\napply H.\neapply Hrecp1 with (fol.impH L A0 B0) p.\neapply cPairInj2.\neapply cPairInj1.\neapply cPairInj2.\napply H.\neapply Hrecp with A0 p0.\ndo 3 eapply cPairInj2.\napply H.\nQed.\n\nDefinition codeImp (a b : nat) := cPair 1 (cPair a b).\n\nLemma codeImpCorrect :\n forall a b : Formula,\n codeImp (codeFormula a) (codeFormula b) = codeFormula (impH a b).\nProof.\nauto.\nQed.\n\nDefinition codeNot (a : nat) := cPair 2 a.\n\nLemma codeNotCorrect :\n forall a : Formula, codeNot (codeFormula a) = codeFormula (notH a).\nProof.\nauto.\nQed.\n\nDefinition codeForall (n a : nat) := cPair 3 (cPair n a).\n\nLemma codeForallCorrect :\n forall (n : nat) (a : Formula),\n codeForall n (codeFormula a) = codeFormula (forallH n a).\nProof.\nauto.\nQed.\n\nDefinition codeOr (a b : nat) := codeImp (codeNot a) b.\n\nLemma codeOrCorrect :\n forall a b : Formula,\n codeOr (codeFormula a) (codeFormula b) = codeFormula (orH a b).\nProof.\nauto.\nQed.\n\nDefinition codeAnd (a b : nat) := codeNot (codeOr (codeNot a) (codeNot b)).\n\nLemma codeAndCorrect :\n forall a b : Formula,\n codeAnd (codeFormula a) (codeFormula b) = codeFormula (andH a b).\nProof.\nauto.\nQed.\n\nDefinition codeIff (a b : nat) := codeAnd (codeImp a b) (codeImp b a).\n\n",
                "context_tokens": 735,
                "proof_start_offset": 10406,
                "proof_end_offset": 10536,
                "proof": "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed.",
                    "Lemma codeIffCorrect : forall a b : Formula, codeIff (codeFormula a) (codeFormula b) = codeFormula (iffH a b).\nProof.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "\napply cPairPi2IsPR.\napply pi2_2IsPR.\napply eqIsPR.\napply pi3_3IsPR.\napply pi1_3IsPR.\napply switchIsPR.\napply switchIsPR.\napply\n filter1100IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\n",
                "context_tokens": 753,
                "proof_start_offset": 12173,
                "proof_end_offset": 12326,
                "proof": "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\napply is_LanPR.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold isPR, reg_nf, isTrans, reg_nf, isTrans, and)).\nsplit.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_Wamim.\napply is_WQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nsplit.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+\n apply (proj2 (H0 (H1 (H2 (H3 (H3 (H4 (H4 (H5 (H4 (H5 (H5 (H6 H7))))) H2)).\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+ intros.\n+\n apply (proj2 (H0 (H3 (H4 (H5 (H7 (H6 (H7 (H7 (H8 H7))))) H2)).\n+ intros.\n+ intros.\n + intros.\n+ intros.\n + intros.\n+\n+ intros.\n+ intros.\n+\n apply (proj2 (H0 (H3 (H4 (H5 (H7 (H7 (H7 (H7 (H8 (H7 (H7 (H7 (H8 (H7 (H7 (H7 (H7 (Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply (Build_C_Sum (fun t => t)\n    (fun t recs : nat =>\n        (t - S (cPair (cPair (cPair (t - S (cPair (t - S (cPair (t - S (cPair (t - S (cPair (t - S (cPair (t - S (c)))))) recs))\n        (cPair (cPair (cPair (cPair (t - S (cPair (t - S (cPair (t - S (cPair (t - S (cArrow (t - S))))) recs)))\n        (cPair (cPair (cPair (t - S (cPair (t - S (cArrow (t - S (cPair (t - S (cPair (t - S (c))))) recs))).\napply is_L_G2.\napply is_L_G2.\napply H.\napply cPairtyArr2IsPR.\napply pair2IsPR.\napply pair2IsPR.\napply pair2IsPR.\napply pair3IsPR.\napply pair3IsPR.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nunfold isPR.\napply trans2_3IsPR.\napply trans2_4IsPR.\napply trans2_4IsPR.\napply trans2_5IsPR.\napply trans2_4IsPR.\napply trans2_5IsPR.\napply trans2_5IsPR.\napply trans2_5IsPR.\napply trans2_5IsPR.\napply trans2_5IsPR.\napply trans2_5IsPR.\napply trans2_2DIsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_5IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans_2DIsPR.\napply trans2_6IsPR.\napply trans2_6IsPR.\napply trans2_6IsQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nsplit; unfold isPR2, isInv2, isInv2, is_EXT4.\nsplit; unfold isPR2, isTrans in |- *.\nsplit; unfold isPR2, isTrans in |- *.\nsplit; unfold isTrans in |- *.\nintros.\napply H1.\nQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply (Build_atom (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t => t) (fun t =>Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\napply (Build_field (fun t : nat => t) (fun t : nat => t) (fun t : nat => t).\napply (Build_field (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t :Qed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply is_Wam.\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_Wam).\napply (Build_WQed.",
                    "Lemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\napply (Build_F (fun t => t) (fun t : nat => t)).\napply (Build_F (fun t => t) (fun t : nat => t)).\napply (Build_F (fun t => t) (fun t : nat => t)).\napply (Build_F (fun t => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : nat => t)).\napply (Build_F (fun t : nat => t) (fun t : natQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/codeSubTerm.v",
                "context": "IsPR\n  with\n    (g := fun t recs : nat =>\n          switchPR t\n            (S\n               (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                  (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)))) 0).\napply\n compose2_3IsPR\n  with\n    (f1 := fun t recs : nat => t)\n    (f2 := fun t recs : nat =>\n           S\n             (cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n                (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))))\n    (f3 := fun t recs : nat => 0).\napply pi1_2IsPR.\napply\n compose2_1IsPR\n  with\n    (f := fun t recs : nat =>\n          cPair (cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n            (cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs))).\nassert\n (forall g : nat -> nat,\n  isPR 1 g ->\n  isPR 2 (fun t recs : nat => g (codeNth (t - S (g (pred t))) recs))).\nintros.\napply\n compose2_1IsPR\n  with (f := fun t recs : nat => codeNth (t - S (g (pred t))) recs).\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat => t - S (g (pred t)))\n    (g := fun t recs : nat => recs).\napply filter10IsPR with (g := fun t : nat => t - S (g (pred t))).\napply\n compose1_2IsPR\n  with (f := fun t : nat => t) (f' := fun t : nat => S (g (pred t))).\napply idIsPR.\napply compose1_1IsPR with (f := fun t : nat => g (pred t)).\napply compose1_1IsPR.\napply predIsPR.\nauto.\napply succIsPR.\napply minusIsPR.\napply pi2_2IsPR.\napply codeNthIsPR.\nauto.\napply\n compose2_2IsPR\n  with\n    (f := fun t recs : nat =>\n          cPairPi1 (codeNth (t - S (cPairPi1 (pred t))) recs))\n    (g := fun t recs : nat =>\n          cPairPi2 (codeNth (t - S (cPairPi2 (pred t))) recs)).\napply H.\napply cPairPi1IsPR.\napply H.\napply cPairPi2IsPR.\napply cPairIsPR.\napply succIsPR.\nexists (composeFunc 2 0 (PRnil _) zeroFunc).\nsimpl in |- *.\nauto.\napply switchIsPR.\napply cPairIsPR.\nQed.\n\nLemma codeSubTermIsPR : isPR 3 codeSubTerm.\nProof.\nunfold codeSubTerm in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi1IsPR.\nQed.\n\n",
                "context_tokens": 751,
                "proof_start_offset": 12328,
                "proof_end_offset": 12484,
                "proof": "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubTerms in |- *.\napply compose3_1IsPR.\napply codeSubTermTermsIsPR.\napply cPairPi2IsPR.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub256sIsPR.\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_field (fun t => t) t).\napply (Build_fieldQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub TermsOfPR.\napply (Build_subtype (fun t : nat => t) (fun t : nat => t)).\napply (Build_subtype (fun t : nat => t)).\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => t)).\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nintros.\napply H0.\napply (Build_subtype (fun t : nat => t)).\nred in |- *.\nsplit.\napply (Build_subtype (fun t : nat => tQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold code Subfraction in |- *.\napply comp1_3IsPR.\napply (pair3 (Var 0)).\napply (pair3 (Var 0)).\napply (pair3 (Var 0)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napply (pair4 (Var 1)).\napplyQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeToarF in |- *.\napply (Build_Map (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat =>Qed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub256sIsPR in |- *.\napply cPairPi2IsPR.\napply cPairCP2IsPR.\nQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubequ in |- *.\napply comp3_2IsPR.\napply (Build_field (Build_field (Build_field (Build_field (Build_field (Build_field (Build_field (S (S (cseq t)))) (cseq (t - S (cseq t)))).\napply (Build_field (Build_field (Build_field (S (cseq t)))) (cseq (t - S (cseq t)))).\napply (Build_field (Build_field (S (cseq t)))) (cseq (t - S (cseq t)))).\napply (Build_field (Build_field (S (cseq t))) (cseq (t - S (cseq t)))).\napply (Build_field (Build_field (S (cseq t))) (cseq (t - S (cseq t)))).\napply (Build_field (Build_field (S (cseq t)))).\napply (Build_field (Build_field (S (cseq t)))) (cseq (t - S (cseq t)))).\napply (Build_field (Build_field (S (cseq t))) (cQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSubSEM in |- *.\napply (Build_field (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => tQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub TermsOfSub TermsOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodyOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodysOf sembodyOf sembodysOf sembodysOf sembodyOfsembodysOf sembodysOf sembodysOf sembodyOf sembodysOfsemACdo sembodysOf sembodyOf sembodysOf sembodyOf sembodysOf sembodysOf sembodyOfsemACSEsemACSEsemACimEqOfsemACTQed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub TermsOfPR.\napply (Build_induction (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat => t) (fun t : nat =>Qed.",
                    "Lemma codeSubTermsIsPR : isPR 3 codeSubTerms.\nProof.\nunfold codeSub TermsIsPR.\napply (Build_ Ens (fun t => t) (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => t)\n    (fun t : nat => tQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\n",
                "context_tokens": 75,
                "proof_start_offset": 226,
                "proof_end_offset": 385,
                "proof": "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction n.\n  simpl.\n  destruct a; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct b; simpl.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destruct b; simpl.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destruct (Pos.eq_dec b b0); simpl; auto.\n  destructDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nexact (Fiximpl_eq _ _ (Fiximpl_eq _ _ (Fixon_eq _ _ (Fixon_eq _ _ _ (Fixon_eq _ _ _ (Fixon_eq _ _ _ b)))))).\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : brs) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nDefinition extProd (n : nat) (a b : nat) : Prop. Admitted.\n\nLemma extProd_equiv : forall (n : nat) (a b : nat), a = b -> a = b.\nProof.\n  intros n a b H; apply extProd_equiv.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct a; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  destruct a.\n  - exact (eq_nat_dec n 0).\n  - exact (eq_nat_dec n 0).\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  destruct a.\n  auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nProof.\n  induction n.\n  (* + *)\n  simpl.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  simpl.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  subst.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  omega.\n  (* + *)\n  simpl.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  omega.\n  (* + *)\n  simpl.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  omega.\n  (* + *)\n  simpl.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  omega.\n  (* + *)\n  simpl.\n  destruct (eq_nat_dec n 0).\n  (* + *)\n  omega.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\nrefine (match n with\n                 | O => True\n                 | S n' => True\n                   end).\napply (match n with\n                 | O => True\n                 | S n' => True\n                   | S n' => True\n                   end).\napply (match n with\n                   | O => True\n                 | S n' => True\n                   | S n' => True\n                 end).\napply (match n with\n                 | O => True\n                   | S n' => True\n                   | S n' => True\n                 end).\napply (match n with\n                   | O => True\n                 | S n' => True\n                   | S n' => True\n                   | S n' => True\n                   end).\napply (match n with\n                   | O => True\n                 | S n' => True\n                   | S n' => True\n                   end).\napply (match n with\n                   | O => True\n                   | S n' => True\n                   | S n' => True\n                   | S n' => True\n                   end).\napply (match n with\n                   | O => True\n                   | S n' => True\n                   | S n' => True\n                   end).\napply (match n with\n                   | O => True\n                   | S n' => True\n                   | S n' => TrueDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop.\n  destruct a; simpl in *; auto.\nDefined.",
                    "Definition extEqual (n : nat) (a b : naryFunc n) : Prop. Admitted.\n\nFixpoint arith_eq (n m : nat) : Prop. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> m <= n. Admitted.\n\nDefinition neq_equiv : forall n m : nat, neq m n -> n <= m. Admitted.\n\nDefinition neq_equiv : forall n m :Defined."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\n",
                "context_tokens": 134,
                "proof_start_offset": 387,
                "proof_end_offset": 569,
                "proof": "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n.\nexact (a = b).\nexact (eq_nat_dec n).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\n  intros.\n  destruct n; auto.\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\ninduction n.\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\ndestruct n; simpl in *.\ndestruct a; simpl in *.\ndestruct a; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n; simpl in *.\ndestruct n;Qed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/extEqualNat.v",
                "context": "Require Import Arith.\n\nFixpoint naryFunc (n : nat) : Set :=\n  match n with\n  | O => nat\n  | S n => nat -> naryFunc n\n  end.\n\nFixpoint naryRel (n : nat) : Set :=\n  match n with\n  | O => bool\n  | S n => nat -> naryRel n\n  end.\n\nDefinition extEqual (n : nat) (a b : naryFunc n) : Prop.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (forall c : nat, Hrecn (a c) (b c)).\nDefined.\n\nLemma extEqualRefl : forall (n : nat) (a : naryFunc n), extEqual n a a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply Hrecn.\nQed.\n\n",
                "context_tokens": 197,
                "proof_start_offset": 571,
                "proof_end_offset": 810,
                "proof": "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nsymmetry in |- *.\napply H.\nsimpl in |- *.\nintros.\napply Hrecn.\nsimpl in H.\napply H.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nexact (a = b).\nexact (a = b).\nexact (a = b).\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nsimpl in |- *.\nreflexivity.\nsimpl in |- *.\nintro.\napply IHn.\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n as [| n Hrecn].\nexact (a = b).\nexact (a = b).\nQed.",
                    "Lemma extEqualSym : forall (n : nat) (a b : naryFunc n), extEqual n a b -> extEqual n b a.\nProof.\nintros.\ninduction n.\nexact (a = b).\nexact (a = b).\nexact (a = b).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " unfold not in |- *; intros; elim b0.\ninversion H.\nreflexivity.\ninduction (b r r0).\nassert\n (forall (f g : Relations L) (p : f = g) (ts : Terms (arity L (inl _ f)))\n    (ss : Terms (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 8985,
                "proof_end_offset": 9141,
                "proof": "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth.\nintros A B.\nsplit.\nintros; apply le_max.\napply le_max.\napply le_max.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A; simpl; intros.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.\nconstructor; auto.Qed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\ninduction A; induction B; simpl; intros; auto.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth.\nintros A B.\ninduction B.\nsimpl.\napply lt_n_O.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\napply le_n_S.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *; unfold lt_depth in |- *; simpl in |- *;\n intros.\ninversion H.\ndestruct x0.\ninversion H0.\ninversion H0.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply le_S_n.\nsimpl in |- *.\nsplit.\nintros.\napply leQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth in |- *.\nsplit.\napply le_n_S.\napply le_n_S.\napply le_n_S.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth.\ninduction A.\nintros; simpl in |- *; auto.\nintros.\ninversion H.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply le_S_n.\napply leQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth.\napply le_n_S.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth.\nintros A B.\napply le_n_O.\napply le_n_S.\nQed.",
                    "Lemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold le_depth in |- *; intros.\nelim H; clear H; intros.\ninversion H; clear H; auto.\ninversion H; clear H; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": "s (arity L (inl _ g)))\n    (q : arity L (inl _ f) = arity L (inl _ g)),\n  eq_rec _ (fun x => Terms x) ts _ q = ss <-> atomic f ts = atomic g ss).\nintros f g p.\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\n",
                "context_tokens": 746,
                "proof_start_offset": 9143,
                "proof_end_offset": 9299,
                "proof": "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_r.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ".\neapply\n eq_ind\n        with\n        (x := g)\n       (P := \n         fun a =>\n         forall (ts : Terms (arity L (inl _ a)))\n           (ss : Terms (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\n",
                "context_tokens": 749,
                "proof_start_offset": 9301,
                "proof_end_offset": 9401,
                "proof": "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_n_O.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_n_O.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_O.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " (arity L (inl _ g)))\n           (q : arity L (inl _ a) = arity L (inl _ g)),\n         eq_rec _ (fun x => Terms x) ts _ q = ss <->\n         atomic a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 9403,
                "proof_end_offset": 9523,
                "proof": "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (max (depth A) (pos v)).\napply max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold le_depth in |- *.\nsimpl in |- *.\nintros.\napply le_max_l.\nQed.",
                    "Lemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_trans with (le_max_r (S v) (S v)).\napply le_max_r.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": " a ts = atomic g ss).\nintros ts ss q.\nelim q using K_dec_set.\napply eq_nat_dec.\nsimpl in |- *.\nsplit.\nintros.\nrewrite H.\nreflexivity.\nintros.\ninversion H.\neapply\n inj_right_pair2\n                 with\n                 (P := \n                   fun f : Relations L =>\n                   Terms (arity L (inl (Functions L) f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 9525,
                "proof_end_offset": 9687,
                "proof": "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nintros A B C.\nelim C.\nintros.\nrewrite <- (lt_n_O x).\napply le_trans with (m := x).\napply le_n_S.\napply le_max_l.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C H H0 H1.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros A B C H H0 H1 H2.\nelim H1; clear H1; intros H3 H4.\ninversion H4.\napply le_S_n_Sm.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply lt_n_Sm.\napply le_trans with (max (depth A) (BuildH A B)).\napply le_max_l.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (bs A).\napply le_n_S.\napply le_n_S.\napply le_max_r.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed.",
                    "Lemma eqDepth : forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold le_depth in |- *.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/goedel/fol.v",
                "context": ") f))).\nassumption.\nassumption.\nauto.\nassert (arity L (inl (Functions L) r) = arity L (inl (Functions L) r0)).\nrewrite a0.\nreflexivity.\ninduction\n (terms_dec _\n    (eq_rec (arity L (inl (Functions L) r)) (fun x : nat => Terms x) t\n       (arity L (inl (Functions L) r0)) H0) t0).\nleft.\ninduction (H _ _ a0 t t0 H0).\nauto.\nright.\ninduction (H _ _ a0 t t0 H0).\ntauto.\nright.\nunfold not in |- *; intros.\ninversion H.\nauto.\ninduction (H f1).\ninduction (H0 f2).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H3; auto.\nright; unfold not in |- *; intros.\ninversion H3; auto.\ninduction (H f0).\nleft.\nrewrite a0.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\ninduction (eq_nat_dec n n0).\ninduction (H f0).\nleft.\nrewrite a0.\nrewrite a1.\nreflexivity.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nright; unfold not in |- *; intros.\ninversion H1; auto.\nQed.\n\nEnd Formula_Decideability.\n\nSection Formula_Depth_Induction.\n\nFixpoint depth (A : Formula) : nat :=\n  match A with\n  | equal _ _ => 0\n  | atomic _ _ => 0\n  | impH A B => S (max (depth A) (depth B))\n  | notH A => S (depth A)\n  | forallH _ A => S (depth A)\n  end.\n\nDefinition lt_depth (A B : Formula) : Prop := depth A < depth B.\n\nLemma depthImp1 : forall A B : Formula, lt_depth A (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_l.\nQed.\n\nLemma depthImp2 : forall A B : Formula, lt_depth B (impH A B).\nProof.\nunfold lt_depth in |- *.\nsimpl in |- *.\nintros.\napply le_lt_n_Sm.\napply le_max_r.\nQed.\n\nLemma depthNot : forall A : Formula, lt_depth A (notH A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma depthForall : forall (A : Formula) (v : nat), lt_depth A (forallH v A).\nProof.\nunfold lt_depth in |- *.\nauto.\nQed.\n\nLemma eqDepth :\n forall A B C : Formula, depth B = depth A -> lt_depth B C -> lt_depth A C.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H.\nassumption.\nQed.\n\n",
                "context_tokens": 706,
                "proof_start_offset": 9689,
                "proof_end_offset": 10147,
                "proof": "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros P H n.\ninduction n as [| n Hrecn].\nintros.\napply H.\nintros.\nunfold lt_depth in H1.\nrewrite <- (le_n_O_eq _ H0) in H1.\nelim (lt_n_O _ H1).\nintros.\napply H.\nintros.\napply Hrecn.\napply lt_n_Sm_le.\napply lt_le_trans with (depth b).\napply H1.\napply H0.\nDefined.",
                "end_command": "Defined.",
                "generated_proofs": [
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (pred (Rlength (or_introl (or_introl (or_introl (or_introl (or_intror (or_introl (or_introl (or_introl (or_introl (or_introl (or_intror (or_intror (or_introl (or_intror (or_intror (or_intror (or_intror (or_introl (or_intror (or_introl (or_introl (or_intror (or_intror (or_intror (or_intror (or_intror (or_intror (or_intror (or_iff_or_intror (or_intror (or_intror (or_iff_intror (or_intror (or_iff (or_intror (or_intror (or_intror (or_intror (or_iff (or_intror (or_iff_intror (or_introl (or_iff_or_intror (or_intror (or_iff_intror (or_iff_iff (or_iff (or_introl (or_iff_intror (or_iff_and_introrDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (m := n).\napply le_max_r.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold le_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply lt_n_O.\napply lt_n_S.\napply lt_n_S.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_O.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\napply lt_n_S.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply le_trans with (S (max (depth A) (depth B))).\napply le_max_r.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite H0.\nassumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nintros.\ndestruct n.\nsimpl in |- *.\nintros.\napply le_n_O.\napply lt_n_O.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\nrewrite <- H0.\nassumption.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_Sm.\napply lt_n_Sm.\napply lt_n_O.\nDefined.",
                    "Definition Formula_depth_rec_rec : forall P : Formula -> Set, (forall a : Formula, (forall b : Formula, lt_depth b a -> P b) -> P a) -> forall (n : nat) (b : Formula), depth b <= n -> P b.\nProof.\nunfold lt_depth in |- *.\nintros.\napply le_lt_n_O.\napply lt_n_Sm.\napply le_max_r.\nDefined."
                ]
            }
        ],
        "zorns-lemma": [
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " Import Eqdep.\napply inj_pair2 in H2.\ndestruct H2.\napply H3.\nQed.\n\nLemma ord_le_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta <= gamma -> alpha <= gamma.\nProof.\ninduction alpha.\ninduction beta.\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4386,
                "proof_end_offset": 4594,
                "proof": "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ln beta).\napply ord_le_trans with (ln beta).\napply ln2_beta.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply le_lt_trans with (fun i => le_rec i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth iQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_lt_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_trans (lt_le_trans (lt_le_trans (lt_le_trans (lt_trans (lt_le_trans (lt_le_trans (lt_trans (lt_le_transQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply le_lt_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ord_le_trans with (fun i => le_i (S i)).\napply ordQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_sup (o i)).\napply H.\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans with (le_sup (o i)).\napply le_trans withQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans _ _ _ _))).\napply le_lt_trans with (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_trans (eta_le_trans (eta_le_trans (eta_le_trans (eta_trans (eta_le_trans (eta_trans (eta_le_trans (eta_trans (eta_le_trans (eta_trans (eta_le_trans (eta_trans (eta_trans (eta_eq_trans (eta_le_trans (eta_trans (eta_trans (eta_le_trans (eta_trans (eta_transQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply le_lt_trans with alpha; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with alpha; trivial.\nQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (le_lt_trans _ _ _ H0).\napply le_lt_trans with (leQed.",
                    "Lemma ord_le_lt_trans: forall alpha beta gamma:Ordinal, alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ln (u - a)).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\napply ord_le_trans with (u - a).\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": ".\ninduction gamma.\nintros.\napply ord_le_respects_succ.\napply IHalpha with beta.\napply ord_le_respects_succ_converse; trivial.\napply ord_le_respects_succ_converse; trivial.\nintros.\napply ord_le_S_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 4596,
                "proof_end_offset": 4786,
                "proof": "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial; apply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_g_weak_le _ _ (lt_h_weak_le _ _ _ H)).\nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_sup (mk beta beta (fun i => i+i)) (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (mk beta (fun i => i+i)).\napply ord_le_trans with (Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _ i).\napply ord_le_trans with (fun i => ord_le_trans _ _Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_lt_trans _ _ (lt_le_trans _ _ (lt_le_trans _ _ _ _ _)).\napply le_le_trans with (le_lt_trans _ _ (lt_le_trans _ _ _ _)).\napply le_le_trans with (le_lt_trans _ _ (lt_le_trans _ _ _ _)).\napply le_le_trans with (le_lt_trans _ _ (le_le_trans _ _ _ _ _)).\napply le_le_trans with (le_le_trans _ _ _ (le_le_trans _ _ _ _ _)).\napply le_le_trans with (le_lt_trans _ _ _ (le_le_trans _ _ _ _)).\napply le_le_trans with (le_le_trans _ _ _ (le_le_trans _ _ _ _)).\napply le_le_trans with (le_le_trans _ _ _ (le_le_trans _ _ _ (le_le_trans _ _ _ _ _)).\napply le_le_trans with (le_le_trans _ _ _Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (le_sup (o i)).\napply ord_le_trans with (leQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_S (o i)).\napply ord_le_trans with (le_S (o i)).\napply ord_le_trans with (lt_le_trans _ _ (le_S_sup (lt_le_trans _ _ _ _)))).\napply le_lt_trans with (le_S_n _ _ (le_S_n _ _ _)).\napply le_lt_trans with (le_S_n _ _ (le_S_n _ _ _ _ _)).\napply le_lt_trans with (le_S_n _ _ _ (le_S_n _ _ _ _ _)).\napply le_lt_trans with (le_S_n _ _ _ _ (le_S_n _ _ _ _)).\napply le_lt_trans with (le_S_n _ _ _ _ (le_S_n _ _ _ _)).\napply le_lt_trans with (le_S_n _ _ _ (le_S_n _ _ _ _)).\napply le_lt_trans with (le_S_n _ _ (le_S_nQed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (le_k_limit (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i => k_limit i (fun i =>Qed.",
                    "Lemma ord_lt_trans: forall alpha beta gamma:Ordinal, alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x => x).\napply ord_le_trans with (fun x =>Qed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_sup_converse in H1.\ndestruct H1 as [i].\napply ord_le_S_sup with i.\napply H; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 740,
                "proof_start_offset": 4788,
                "proof_end_offset": 4941,
                "proof": "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (le_sup (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _ => S (fun _Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (fun x => x=0).\napply ord_le_trans with (funQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_lt_trans with (ordS (o i)); trivial.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_lt_trans with (ordS (o i)).\napply ord_le_trans with (max (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (nth i (i + i)))))...\napply le_max_l.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (fun n => n <= rho \\/ n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_trans with (fun n => n <= rho).\napply ord_le_Qed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (fun i => ord_lt_trans _ (lt_n_S _ (lt_n_S _ _ (lt_n_S _ _ _ _ (lt_n_S _ _ _ _ (lt_n_S _ _ _ _ (lt_n_S _ _ _ _ _ (lt_n_S _ _ _ _ _ (lt_n_S _ _ _ _ _ _ _)));\n auto.\nQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (fun x:R => x).\napply ord_le_trans with (funQed.",
                    "Lemma ord_lt_respects_succ: forall alpha beta:Ordinal, alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": " _ _ H1).\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [i].\napply H with i; trivial.\nintros.\npose proof (ord_sup_minimal_converse _ _ _ H0).\nconstructor.\nintro.\napply H with beta; trivial.\nQed.\n\nLemma ord_le_sup: forall (I:Type) (alpha:I->Ordinal) (i:I),\n  alpha i <= ord_sup alpha.\nProof.\nassert (forall beta:Ordinal, beta <= beta /\\\n  forall (I:Type) (alpha:I->Ordinal) (i:I),\n  beta <= alpha i -> beta <= ord_sup alpha).\ninduction beta.\ndestruct IHbeta.\nsplit.\napply ord_le_respects_succ; trivial.\nintros.\napply ord_le_S_sup with i.\ntrivial.\nsplit.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H1 with i; trivial.\nintros J alpha j?.\napply ord_sup_minimal.\nintro.\ndestruct (H i).\napply H2 with j.\napply ord_le_trans with (ord_sup o).\napply H2 with i; trivial.\ntrivial.\n\nintros.\ndestruct (H (alpha i)).\napply H1 with i; trivial.\nQed.\n\nLemma ord_le_refl: forall alpha:Ordinal, alpha <= alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\napply ord_le_sup.\nQed.\n\nLemma ord_le_S: forall alpha:Ordinal, alpha <= ordS alpha.\nProof.\ninduction alpha.\napply ord_le_respects_succ; trivial.\napply ord_sup_minimal.\nintro.\napply ord_le_trans with (ordS (o i)).\napply H.\napply ord_le_respects_succ.\napply ord_le_sup.\nQed.\n\nLemma ord_lt_le: forall alpha beta:Ordinal,\n  alpha < beta -> alpha <= beta.\nProof.\nintros.\napply ord_le_trans with (ordS alpha); trivial.\napply ord_le_S.\nQed.\n\nLemma ord_lt_le_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta <= gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.\n\nLemma ord_le_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha <= beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_le_trans with (ordS beta); trivial.\napply ord_le_respects_succ; trivial.\nQed.\n\nLemma ord_lt_trans: forall alpha beta gamma:Ordinal,\n  alpha < beta -> beta < gamma -> alpha < gamma.\nProof.\nintros.\napply ord_lt_le_trans with beta; trivial;\n apply ord_lt_le; trivial.\nQed.\n\nLemma ord_lt_respects_succ: forall alpha beta:Ordinal,\n  alpha < beta -> ordS alpha < ordS beta.\nProof.\nintros.\napply ord_le_respects_succ; trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4943,
                "proof_end_offset": 7301,
                "proof": "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\ninduction alpha.\ninduction beta.\ndestruct (IHalpha beta) as [|[|]].\nleft; apply ord_lt_respects_succ; trivial.\nright; left.\nsplit.\napply ord_le_respects_succ; apply H.\napply ord_le_respects_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply pred_le_lt_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (fun x => x = id).\napply ord_le_trans with (funQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (fun x => match x with | left _ => true | right _ => false end).\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with beta; trivial.\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (fun x => match x with | Lt => Lt | _ => Lt end).\napply ord_le_trans with (fun x => match x with | Lt => Lt | _ => Lt end).\nQed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (fun x => proj1_sig (proj1_sig (proj1_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2_sig (proj2sig (proj2sig (proj2_sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj1_sig (proj2sig (proj2sig (proj2sig (proj2sig (proj1_sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj1_sig (proj2sig (proj2sig (proj2sig (proj1_sig (proj2sig (proj2 sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2sig (proj2Qed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (ordS (u + u)).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).\napply ord_le_trans with (u + u).Qed.",
                    "Lemma ord_total_order: forall alpha beta:Ordinal, alpha < beta \\/ alpha == beta \\/ alpha > beta.\nProof.\nintros.\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordS (o i)).\napply ord_le_trans with (ordQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Ordinals.v",
                "context": "_succ; apply H.\nright; right.\napply ord_lt_respects_succ; trivial.\n\ndestruct (classic (exists i:I, ordS alpha < o i)).\ndestruct H0 as [i].\nleft.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ndestruct (classic (exists i:I, ordS alpha == o i)).\ndestruct H1 as [i].\nright; left.\nsplit.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\napply ord_sup_minimal.\nintro.\ndestruct (H i0) as [|[|]].\ncontradiction H0; exists i0; trivial.\napply H2.\napply ord_lt_le; trivial.\nassert (forall i:I, ordS alpha > o i).\nintros.\ndestruct (H i) as [|[|]].\ncontradiction H0; exists i; trivial.\ncontradiction H1; exists i; trivial.\ntrivial.\nright; right.\napply ord_le_lt_trans with alpha.\napply ord_sup_minimal.\nintro.\napply ord_le_respects_succ_converse.\napply H2.\napply ord_le_refl.\n\ninduction beta.\ncase (classic (exists i:I, o i > ordS beta)); intro.\ndestruct H0 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i == ordS beta)); intro.\nright; left.\ndestruct H1 as [i].\nsplit.\napply ord_sup_minimal.\nintro j.\ndestruct (H j (ordS beta)) as [|[|]].\napply ord_lt_le; trivial.\napply H2.\ncontradiction H0; exists j; trivial.\napply ord_le_trans with (o i).\napply H1.\napply ord_le_sup.\nleft.\napply ord_le_respects_succ.\napply ord_sup_minimal.\nintro.\ndestruct (H i (ordS beta)) as [|[|]].\napply ord_le_respects_succ_converse; trivial.\ncontradiction H1; exists i; trivial.\ncontradiction H0; exists i; trivial.\n\ncase (classic (exists j:I0, ord_sup o < o0 j)); intro.\nleft.\ndestruct H1 as [j].\napply ord_lt_le_trans with (o0 j); trivial.\napply ord_le_sup.\ncase (classic (exists i:I, o i > ord_sup o0)); intro.\ndestruct H2 as [i].\nright; right.\napply ord_lt_le_trans with (o i); trivial.\napply ord_le_sup.\n\nright; left.\nsplit.\napply ord_sup_minimal; intro.\ndestruct (H i (ord_sup o0)) as [|[|]].\napply ord_lt_le; trivial.\napply H3.\ncontradiction H2; exists i; trivial.\napply ord_sup_minimal; intro j.\ndestruct (H0 j) as [|[|]].\ncontradiction H1; exists j; trivial.\napply H3.\napply ord_lt_le; trivial.\nQed.\n\n",
                "context_tokens": 752,
                "proof_start_offset": 7303,
                "proof_end_offset": 7689,
                "proof": "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nred; intro alpha.\ninduction alpha.\nconstructor.\nintros beta ?.\napply ord_le_respects_succ_converse in H.\nconstructor; intros gamma ?.\ndestruct IHalpha.\napply H1.\napply ord_lt_le_trans with beta; trivial.\nconstructor; intros alpha ?.\napply ord_le_S_sup_converse in H0.\ndestruct H0 as [j].\ndestruct (H j).\napply H1; trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\nsplit; intros.\ndestruct (H (max_case (le_gt_dec n (S n)) (le_lt_dec n (S n))).\ndestruct H0 as [[H0|H0]].\nright; left.\napply ord_le_trans with (S n); trivial.\nright; right.\napply ord_le_lt_trans with (S n); trivial.\nright; right.\napply ord_le_lt_trans with (S n); trivial.\nright; right.\napply ord_le_lt_trans with (S n); trivial.\nright; right.\napply ord_le_trans with (S n); trivial.\nright; left.\napply ord_le_trans with (S n); trivial.\nright; right.\napply ord_le_trans with (S n); trivial.\nright; right.\napply ord_le_trans with (S n); trivial.\nright; right.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ndestruct ord_lt_dec as [n1 n2].\ndestruct (le_lt_dec n1 n2).\nleft; apply ord_lt_eq_lt_trans with (o n1); trivial.\nright; left.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; right.\napply ord_le_lt_trans with (o n2); trivial.\nright; right.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; right.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; right.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; right.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; right.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; right.\napply ord_lt_eq_lt_trans with (o n2); trivial.\nright; left.\napply ord_lt_eq_lt_Qed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply well_founded_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\napply wf_induction; intros; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply wf_lt_preserves_wf.\napply wf_lt_lex_lt_trans.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply wf_ind.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_ind.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\napply wf_intro.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply wf_wf_ind; apply wf_wf_ind; apply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_ind;\napply wf_wf_indQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ngeneralize (well_founded_induction (fun x => x = x)); intro.\ndestruct (H i) as [[i?]?].\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintro.\ncase (H i).\nintroQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ndestruct ord_wf.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_induction; intros.\napply well_founded_inductionQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\ngeneralize (lt_wf_ind _ H).\ncase (classic (exists i:I, ordS beta = None)).\nexists 1; intros.\nexists (S i); exists (S i); exists (S i).\nintros.\ndestruct H0 as [i].\nexists i; exists i; trivial.\nQed.",
                    "Lemma ordinals_well_founded: well_founded ord_lt.\nProof.\napply well_founded_induction; simpl; intros.\ndestruct (H i) as [[i?]?]].\ndestruct (H i) as [[i?]?]].\ndestruct (H i) as [[i?]?]].\nexists i; exists i; exists i; exists j; split; trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\n",
                "context_tokens": 226,
                "proof_start_offset": 778,
                "proof_end_offset": 1010,
                "proof": "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included in |- *.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\ndestruct H.\ncontradiction H.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold In.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set.\nunfold Same_set in |- *.\nintros.\napply H0.\napply H1.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set, Included.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold In.\nintuition.\nQed.",
                    "Lemma empty_family_intersection: FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nintros x y H.\nelim (classic (In (FKLIST x) y)); intro H0.\nelim (classic (In (FreelistEffect y) y)); intro H1.\nclear H1.\nrewrite H1.\nauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\n",
                "context_tokens": 305,
                "proof_start_offset": 1059,
                "proof_end_offset": 1278,
                "proof": "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H.\napply Extensionality_Ensembles.\nunfold Same_set in H.\nunfold Included in H.\ntauto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nintros F G H.\napply Extensionality_Ensembles.\nunfold Same_set.\nintros x y H0.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\nunfold In in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\nunfold In in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, In in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\nunfold In in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\napply Extensionality_Ensembles.\nunfold Same_set, Im, Included in |- *.\nsplit.\napply Extensionality_Ensembles.Qed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H; red; simpl; intros.\nred; simpl.\nunfold Union in H0.\nelim (H0 x); intros.\nleft; assumption.\nright; assumption.\nright; assumption.\nright; assumption.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H0.\nunfold Same_set in |- *.\nsplit.\napply Union_union_intro with (union F) (union F) (union F)); auto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H.\nelim H.\nintros x H'; elim H'.\nintros x H'; elim H'.\nintros x0 H'; elim H'0.\nintros x1 H'; elim H'0.\nintros x2 H'3 x4 H'5 H'6.\napply H'2; auto.\napply H'2; auto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H; red; intro H0.\napply H0.\napply H0.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Same_set.\nunfold Included.\nintuition.\nunfold Same_set.\nintros x0 H1 H2.\napply H1.\napply H2.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set.\nunfold Included in |- *.\nintros x H0.\nelim H0; intros.\nclear H0 H1.\ngeneralize (H x0 H1).\nintro.\napply H1; auto.\nQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply Extensionality_Ensembles.\nunfold Same_set in |- *.\nintros.\napply ExtensionalityQed.",
                    "Lemma subfamily_union: forall F G:Family T, Included F G -> Included (FamilyUnion F) (FamilyUnion G).\nProof.\nintros F G H.\nunfold Same_set in |- *.\nsplit.\nunfold Included in |- *.\nintuition.\nintros x H0.\ngeneralize (H x); clear H.\nintro H1; generalize (H x); clear H0.\nintro H2; generalize (H2 x); clear H2.\nrewrite H2; auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/zorns-lemma/Families.v",
                "context": "Require Export Ensembles.\nRequire Import EnsemblesImplicit.\n\nSet Implicit Arguments.\n\nSection Families.\n\nVariable T:Type.\nDefinition Family := Ensemble (Ensemble T).\nVariable F:Family.\n\nInductive FamilyUnion: Ensemble T :=\n  | family_union_intro: forall (S:Ensemble T) (x:T),\n    In F S -> In S x -> In FamilyUnion x.\n\nInductive FamilyIntersection: Ensemble T :=\n  | family_intersection_intro: forall x:T,\n    (forall S:Ensemble T, In F S -> In S x) ->\n    In FamilyIntersection x.\n\nEnd Families.\n\nSection FamilyFacts.\n\nVariable T:Type.\n\nLemma empty_family_union: FamilyUnion (@Empty_set (Ensemble T)) =\n                          Empty_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\ndestruct H.\ncontradiction H.\n\ncontradiction H.\nQed.\n\nLemma empty_family_intersection:\n  FamilyIntersection (@Empty_set (Ensemble T)) = Full_set.\nProof.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included.\nintuition.\nconstructor.\nconstructor.\nintros.\ncontradiction H0.\nQed.\n\n(* unions and intersections of subfamilies *)\n\nLemma subfamily_union: forall F G:Family T, Included F G ->\n  Included (FamilyUnion F) (FamilyUnion G).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply family_union_intro with S.\napply H.\nassumption.\nassumption.\nQed.\n\n",
                "context_tokens": 374,
                "proof_start_offset": 1280,
                "proof_end_offset": 1506,
                "proof": "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\nconstructor.\ndestruct H0.\nintros.\napply H0.\napply H.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply included_trans with (empty_vide_union F).\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros F G H.\napply subfamily_union.\napply H.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply Union_union_intro with (F:=(F)); auto.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Union F); auto.\nunfold Same_set.\napply included_trans with (Qed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply Same_set.\nunfold Included in |- *.\nsplit; auto.\nintros.\napply Same_set.\nunfold In in |- *.\nsplit; auto.\nintros.\napply H0.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply Union_union_intro with (Union_union F G).\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply subgroup_union_intro with (x:=x) (x:=x) (x0:=x0) (x:=x1) (x:=x1) (x2:=x2).\napply Union_union_intro with (x0:=x) (x0:=x1) (x2:=x2).\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply intersection_union_intro with (empty_family_union F) (empty_family_union F).\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nunfold Included.\nintros.\ndestruct H0.\napply part_domain.\napply H.\nassumption.\nQed.",
                    "Lemma subfamily_intersection: forall F G:Family T, Included F G -> Included (FamilyIntersection G) (FamilyIntersection F).\nProof.\nintros F G H.\napply Extensionality_Ensembles.\nunfold Same_set.\nunfold Included in H0.\nsplit.\napply Intersection_add.\napply Intersection_add.\napply Union_add.\napply Union_add.\napply Intersection_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply Union_add.\napply UnionQed."
                ]
            }
        ],
        "coqrel": [
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "inter_refl : typeclass_instances.\n\nLemma rel_inter_corefl_l {A} (R1 R2: rel A A):\n  Coreflexive R1 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\n",
                "context_tokens": 719,
                "proof_start_offset": 6671,
                "proof_end_offset": 6793,
                "proof": "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_relim {A B} (R1 R2: rel A B) x y: RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "l : typeclass_instances.\n\nLemma rel_inter_corefl_r {A} (R1 R2: rel A A):\n  Coreflexive R2 ->\n  Coreflexive (R1 /\\ R2).\nProof.\n  firstorder.\nQed.\n\nHint Extern 1 (Coreflexive (_ /\\ _)) =>\n  eapply rel_inter_corefl_r : typeclass_instances.\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 6891,
                "proof_end_offset": 7009,
                "proof": "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B): Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "\n\nLemma rel_inter_trans {A} (R1 R2: rel A A):\n  Transitive R1 ->\n  Transitive R2 ->\n  Transitive (R1 /\\ R2).\nProof.\n  intros H1 H2 x y z [Hxy1 Hxy2] [Hyz1 Hyz2].\n  split; etransitivity; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\n",
                "context_tokens": 741,
                "proof_start_offset": 7147,
                "proof_end_offset": 7239,
                "proof": "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_subrel {A B} (R: rel A B): Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "; eassumption.\nQed.\n\nHint Extern 2 (Transitive (_ /\\ _)) =>\n  eapply rel_inter_trans : typeclass_instances.\n\nLemma rel_inter_sym {A} (R1 R2: rel A A):\n  Symmetric R1 ->\n  Symmetric R2 ->\n  Symmetric (R1 /\\ R2).\nProof.\n  intros H1 H2 x y [Hxy1 Hxy2].\n  split; symmetry; assumption.\nQed.\n\nHint Extern 2 (Symmetric (_ /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 7326,
                "proof_end_offset": 7416,
                "proof": "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_bot_relim {A B} (x: A) (y: B) P: RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " /\\ _)) =>\n  eapply rel_inter_sym : typeclass_instances.\n\nGlobal Instance rel_inter_flip_sym {A} (R: rel A A):\n  Symmetric (R /\\ flip R).\nProof.\n  intros x y [Hxy Hyx].\n  split; assumption.\nQed.\n\n(** On a related note, a symmetric subrelation of [R] is also a\n  subrelation of its inverse. *)\n\nLemma subrel_sym_flip {A} (R R': relation A):\n  Symmetric R ->\n  RStep (subrel R R') (subrel R (flip R')).\nProof.\n  intros HR H x y Hxy.\n  symmetry in Hxy.\n  firstorder.\nQed.\n\nHint Extern 60 (RStep _ (subrel _ (flip _))) =>\n  eapply subrel_sym_flip : typeclass_instances.\n\n(** ** Implication *)\n\nDefinition rel_impl {A B} (R1 R2: rel A B): rel A B :=\n  fun x y => R1 x y -> R2 x y.\n\nGlobal Instance rel_impl_subrel {A B}:\n  Monotonic (@rel_impl A B) (subrel --> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_impl_subrel_params:\n  Params (@rel_impl) 4.\n\nLemma rel_impl_rintro {A B} (R1 R2: rel A B) x y:\n  RIntro (R1 x y -> R2 x y) (rel_impl R1 R2) x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ (rel_impl _ _) _ _) =>\n  eapply rel_impl_rintro : typeclass_instances.\n\nLemma rel_impl_relim {A B} (R1 R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 7595,
                "proof_end_offset": 7683,
                "proof": "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\nfirstorder.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_top_rintro {A B} (x: A) (y: B): RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " R2: rel A B) x y:\n  RElim (rel_impl R1 R2) x y (R1 x y) (R2 x y).\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim (rel_impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8747,
                "proof_end_offset": 8901,
                "proof": "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed.",
                    "Lemma rel_compose_id_left {A B} (R: rel A B): eqrel (rel_compose R eq) R.\nProof.\n  firstorder.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": "impl _ _) _ _ _ _) =>\n  eapply rel_impl_relim : typeclass_instances.\n\nLemma rel_impl_subrel_codomain {A B} (R1 R2: rel A B):\n  Related R2 (rel_impl R1 R2) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** The bottom and top relations *)\n\nDefinition rel_bot {A B}: rel A B :=\n  fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 737,
                "proof_start_offset": 8903,
                "proof_end_offset": 9058,
                "proof": "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  intros x y; firstorder.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_id_right {A B} (R: rel A B): eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/RelOperators.v",
                "context": " fun x y => False.\n\nNotation \"\u22a5\" := rel_bot : rel_scope.\n\nLemma rel_bot_subrel {A B} (R: rel A B):\n  Related \u22a5%rel R subrel.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (Related \u22a5%rel _ _) =>\n  eapply rel_bot_subrel : typeclass_instances.\n\nLemma rel_bot_relim {A B} (x: A) (y: B) P:\n  RElim \u22a5 x y True P.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RElim \u22a5 _ _ _ _) =>\n  eapply rel_bot_relim : typeclass_instances.\n\nDefinition rel_top {A B}: rel A B :=\n  fun x y => True.\n\nNotation \"\u22a4\" := rel_top : rel_scope.\n\nLemma rel_top_rintro {A B} (x: A) (y: B):\n  RIntro True \u22a4 x y.\nProof.\n  firstorder.\nQed.\n\nHint Extern 0 (RIntro _ \u22a4 _ _) =>\n  eapply rel_top_rintro : typeclass_instances.\n\nGlobal Instance rel_top_equiv {A}:\n  @Equivalence A \u22a4.\nProof.\n  repeat constructor.\nQed.\n\n(** ** Relation equivalence *)\n\nDefinition eqrel {A B}: rel (rel A B) (rel A B) :=\n  (subrel /\\ flip subrel)%rel.\n\nArguments eqrel {_ _} RA%rel RB%rel.\n\nGlobal Instance eqrel_equivalence A B:\n  Equivalence (@eqrel A B).\nProof.\n  unfold eqrel.\n  split; typeclasses eauto.\nQed.\n\nGlobal Instance eqrel_subrel A B:\n  Related (@eqrel A B) (@subrel A B) subrel.\nProof.\n  firstorder.\nQed.\n\n(** ** Relation composition *)\n\nDefinition rel_compose {A B C} (RAB: rel A B) (RBC: rel B C): rel A C :=\n  fun x z => exists y, RAB x y /\\ RBC y z.\n\nHint Unfold rel_compose.\n\nGlobal Instance rel_compose_subrel {A B C}:\n  Monotonic (@rel_compose A B C) (subrel ++> subrel ++> subrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_eqrel {A B C}:\n  Monotonic (@rel_compose A B C) (eqrel ==> eqrel ==> eqrel).\nProof.\n  firstorder.\nQed.\n\nGlobal Instance rel_compose_params:\n  Params (@rel_compose) 4.\n\nLemma rel_compose_id_left {A B} (R: rel A B):\n  eqrel (rel_compose R eq) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\nLemma rel_compose_id_right {A B} (R: rel A B):\n  eqrel (rel_compose eq R) R.\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.\n\n",
                "context_tokens": 698,
                "proof_start_offset": 9060,
                "proof_end_offset": 9315,
                "proof": "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\nunfold rel_compose.\nsplit; intros x y; firstorder; congruence.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed.",
                    "Lemma rel_compose_assoc {A B C D} (RAB: rel A B) (RBC: rel B C) (RCD: rel C D): eqrel (rel_compose (rel_compose RAB RBC) RCD) (rel_compose RAB (rel_compose RBC RCD)).\nProof.\n  unfold rel_compose.\n  split; intros x y; firstorder; congruence.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " sum_rel R R (inl a) (inl b).\nProof.\n  intros.\n  rewrite H.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n(** There is an issue with the following. *)\n\nGoal\n  forall A (a b: A) (R: rel A A) (f: A -> A) (p: A -> Prop),\n    Monotonic f (R ++> R) ->\n    Monotonic p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\n",
                "context_tokens": 685,
                "proof_start_offset": 2211,
                "proof_end_offset": 2462,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x + y)).\n  intros.\n  apply (f_equal (fun x => x +Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  apply (equiv_refl _ _ _ f).\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_equal.\n  apply functional_extensionality; intros.\n  f_Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros; destruct f; simpl in *; auto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  destruct H0.\n  + destruct H1.\n    + destruct H2.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + destruct H2.\n        + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n    + destruct H1.\n      + simpl in *.\n        unfold F in *.\n        rewrite H0 in *.\n        auto.\n  + destruct H1.\n    +Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros A B f g x y Hxy.\n  destruct (f x) as [[a' b'] [Ha'b'] [Ha'b'b'] [Hb'b'b'] [Hb'b'b'b'].\n  apply H in Ha'.\n  rewrite <- Ha'.\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  destruct H.\n  rewrite <- H0.\n  reflexivity.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  f_equal.\n  match goal with\n  | |- context [?P *?Q] =>\n    match goal with\n    | |- context [?P *?Q] =>\n      match goal with\n      | |- context [?Q *?R] =>\n        match goal with\n        | |- context [?Q *?R] =>\n            match goal with\n          | |- context [?Q *?R] =>\n              match goal with\n              | |- context [?R *?R] =>\n                match goal with\n                | |- context [?R *?R] =>\n                  match goal with\n                | |- context [?R *?R] =>\n                  match goal with\n                    | |- context [?R *?R] =>\n                    match goal with\n                  | |- context [?R *?R] =>\n                    match goal with\n                  | |- context [R?x] =>\n                  match goal with\n                  | |- context [?R?x] =>\n                    match goal with\n                    | |- context [?R?x] =>\n                    match goal with\n                    | |- context [?R?x] =>\n                    match goal with\n                    | |- context [R?x] =>\n                    match goal with\n                    | |- context [R?x] =>\n                    match goal with\n                    | |- context [R?Qed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B), RA x y -> (RA ++> RA + RB) f f -> RA (match f x with inl a => a | inr b => x end) (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  destruct H0 as [x [y [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [zz [z [z [z [z [z [z [zz [Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " p (R --> impl) ->\n    R a b ->\n    p (f b) ->\n    p (f a).\nProof.\n  intros A a b R f p Hf Hp Hab H.\n  Fail rewrite <- Hab in H.\nAbort.\n\n(** ** Monotonicity tactics *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 697,
                "proof_start_offset": 2464,
                "proof_end_offset": 2664,
                "proof": "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A), RA z z -> prod_rel RA RB x y -> RA (let (a, b) := x in z) (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " *)\n\n(** Basic sanity check. This has actually failed in the past due to\n  [context_candidate] being too liberal and selecting the [RB]\n  property instead of [RA], then going nowhere with that with no\n  backtracking implemented yet. *)\n\nGoal\n  forall A B (RA: rel A A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 729,
                "proof_start_offset": 2666,
                "proof_end_offset": 2819,
                "proof": "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  destruct b; auto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  destruct H.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H.\n  destruct H.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H0Qed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R: rel A A), Monotonic (fun (b: bool) x y => if b then x else y) (- ==> R ++> R ++> R).\nProof.\n  intros.\n  unfold re, sig in *.\n  apply (fun (b: bool) x y => if b then x else y).\n  apply (fun (b: bool) x y => if b then x else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b then y else x).\n  apply (fun (b: bool) x y => if b then y else y).\n  apply (fun (b: bool) x y => if b thenQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " A) (x y: A) (RB: rel B B) (z t: B),\n    RA x y ->\n    RB z t ->\n    RA x y.\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A (a b: A) (R: rel A A) (H: R a b),\n    let f (x y: A * A) := (@pair (A+A) (A+A) (inr (fst x)) (inl (snd y))) in\n    Monotonic f (R * \u22a4 ++> \u22a4 * R ++> (\u22a5 + R) * (R + \u22a5))%rel.\nProof.\n  intros; unfold f.\n  rauto.\nQed.\n\nGoal\n  forall {A1 A2 B1 B2} (R1 R1': rel A1 A2) (R2 R2': rel B1 B2),\n    subrel R1' R1 ->\n    subrel R2 R2' ->\n    subrel (R1 ++> R2) (R1' ++> R2').\nProof.\n  do 10 intro.\n  rauto.\nQed.\n\n(** Check that we can use relational hypotheses from the context as\n  well as [Monotonic]/[Related] instances. *)\n\nGoal\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\n",
                "context_tokens": 715,
                "proof_start_offset": 2821,
                "proof_end_offset": 2999,
                "proof": "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  unfold reflexive.\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (* <- *)\n  (*Qed.",
                    "Goal forall {A} (R : rel A A) (b : bool) (x y : A), b = b -> R x x -> R y y -> R (if b then x else y) (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  forall\n    {A B} (R: rel A A)\n    (op: A -> B) (Hop: (R ++> eq) op op)\n    (x y: A) (Hxy: R x y),\n    op x = op y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** Bug with relational parametricity: you can't [RElim] a relation\n  you don't know yet. *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\n",
                "context_tokens": 715,
                "proof_start_offset": 3599,
                "proof_end_offset": 3825,
                "proof": "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\nintros A R f C x y Hf Hxy.\nFail rauto.\npose proof @f_equal_relim.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B R f x y Ex.\n  pose proof (f x y ltac:(auto)).\n  (* TODO: should be solved here? *)\n  destruct (f x y) as [y [y [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [zQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B R R R f x y.\n  pose proof (R x y).\n  pose proof (R x y).\n  apply (R x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (R' x y).\n  apply (Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  rewrite H.\n  rewrite H0.\n  auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct H0.\n  + apply (rel_downward_eq_dep _ _ _ _ H H0).\n  + apply (rel_downward_eq_dep _ _ _ _ H H0).\n  + apply (rel_downward_eq_dep _ _ _ _ _ H0).\n  + apply (rel_downward_eq_dep _ _ _ _ _ H0).\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros A B R R f x y Ex.\n  pose proof I.\n  apply I.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct H0 as [H0 H1].\n  destruct H1 as [H2 H3].\n  destruct H2 as [H3 H4].\n  destruct H3 as [H5 H6].\n  destruct H6 as [H6 H7].\n  destruct H7 as [H8 H9].\n  destruct H10 as [H9 H10].\n  destruct H10 as [H10 H10].\n  destruct H10 as [H11 H12].\n  destruct H10 as [H11 H12].\n  destruct H11 as [H12 H12].\n  destruct H12 as [H13 H13].\n  destruct H13 as [H13 H14].\n  destruct H14 as [H14 H14].\n  destruct H15 as [H15 H15].\n  destruct H15 as [H15 H15].\n  destruct H15 as [H16 H15].\n  destruct H15 as [H16 H15].\n  destruct H15 as [H15 H15].\n  destruct H15 as [H15 H15].\n  destruct H15 as [H16 H15].\n  destruct H15 as [H16 H15].\n  destruct H15 as [H15Qed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct H0.\n  destruct H1 as [x1 [x2 [x3 [x4 [x5 [x6 [x7 [x8 [x9 [x10 [x11 [x12 [x13 [x13 [x14 [x14 [x14 [x14 [x15 x15]]]]]]]]]]]]]]]].\n  destruct H1 as [x1 [x2 [x3 [x4 [x5 [x6 [x7 [x8 [x9 [x10 [x11 [x12 [x13 [x14 [x14 [x14 [x14 [x15 x15]]]]]]]].\n  destruct H1 as [x2 [x3 [x4 [x5 [x6 [x7 [x8 [x9 [x10 [x12 [x13 [x13 [x14 [x14 [x15 x15]]]]]]]]]]]]]]]].\n  destruct H1 as [x3 [x4 [x5 [x6 [x7 [x8 [x9 [x10 [x12 [x13 [x14 [x14 [x14 [x15 [x15 [x15 [x15 x15]]]]]]]]]]]]]]]].\n  destruct HQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct H.\n  + (* does nothing, but [H] fails with [eq_rect] *)\n    auto.\n  + (* does nothing, but [H] fails with [H] fails with [H] *)\n    auto.\n  + (* after [H] fails with [H] fails with [H] *)\n    auto.\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  destruct (H x y) as [[H|H]|H].\n  + (* <- H *)\n    destruct (H y y) as [[H|H]|H].\n    + (* <- H *)\n      apply (H x y H).\n    + (* <- H *)\n      apply (H x y H).\nQed.",
                    "Goal forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y, Monotonic f (R ++> eq) -> R x y -> C (f x) -> C (f y).\nProof.\n  intros.\n  unfold R.\n  apply H.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ") (RB: rel B B) (m n: (A -> B) * B) (x y: A),\n    ((- ==> RB) * RB)%rel m n ->\n    RB (fst m x) (fst n x).\nProof.\n  intros A B RA RB m n x y Hmn.\n  try monotonicity.\n  try rauto.\nAbort.\n\n(** Pattern matching *)\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A) (f: A -> A + B),\n    RA x y ->\n    (RA ++> RA + RB) f f ->\n    RA (match f x with inl a => a | inr b => x end)\n       (match f y with inl a => a | inr b => y end).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\n",
                "context_tokens": 737,
                "proof_start_offset": 3953,
                "proof_end_offset": 4077,
                "proof": "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\nintros A R x y Hxy Hyy.\nmonotonicity.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R x y.\n  pose proof @f_equal_,-rec _ _ _ _ _ _ Hxy.\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] is not provable. *)\n  (* The [reflexivity] isQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Ex.\n  apply (fun x => x).\n  + intros x y Ex.\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun y => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun x => x).\n    apply (fun y => x).\n    apply (fun x =>Qed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R x y.\n  apply (rel_trans A R x y H).\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R x y.\n  pose proof @f_equal_irrel_left R R x y.\n  pose proof @f_equal_irrel_left R R x y.\n  pose proof @f_equal_irrel_left R R x y.\n  pose proof @f_equal_irrel_right R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x y.\n  pose proof @f_equal_compat R R x yQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros.\n  destruct H as [H|H].\n  + destruct H as [H|H].\n    + apply H.\n    + apply H.\n  + apply H.\n  + apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R x y.\n  apply (R x y).\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R x y.\n  apply (f_equal_commutes_iff R R x y).\n  apply (f_equal_commutes_iff R R x y).\n  apply (f_equal_commutes_iff R R x y).\n  apply (f_equal_commutes_iff R R x y).\n  apply (f_equal_commutes_iff R R x y).\n  apply (f_equal_commutes_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_implication_iff R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equal_disjunction_iff R R x y).\n  apply (f_equalQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R x y.\n  pose proof (eq_rect _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ H).\n  intros.\n  apply H0.\nQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R x y Ex.\n  apply (R x y).\n  apply (R x y).\n  apply (R x y).\n  apply (R x y).\n  apply (R x y).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y x).\n  apply (R y xQed.",
                    "Goal forall {A} (R: rel A A) (x y: A), R x y -> eq y y -> R x y.\nProof.\n  intros A R R R f C x y Hf Hxy.\n  apply Hxy.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " B} (RA: rel A A) (RB: rel B B) (x y: A * B) (z: A),\n    RA z z ->\n    prod_rel RA RB x y ->\n    RA (let (a, b) := x in z)\n       (let (a, b) := y in z).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R: rel A A),\n    Monotonic\n      (fun (b: bool) x y => if b then x else y)\n      (- ==> R ++> R ++> R).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\n",
                "context_tokens": 730,
                "proof_start_offset": 4556,
                "proof_end_offset": 4698,
                "proof": "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\nintros A R f Hf.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f f H0.\n  apply H0.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f (g x).\n  pose proof @g_equal_irrel _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H0 x y Hxy Hyz.\n  destruct Hxy as [y [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [zz [zQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f H.\n  apply (f_equal_ bilin (R:=R)).\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f g H.\n  apply H.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf Hxy.\n  apply eq_trans with (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R ==> eq) (R) (R ==> eq) (R) (R ==> eq) (R ==> eq) (R ==> eq) (R) (R ==> eq) (R) (R ==> eq) (R ==> eq) (R) (R ==> eq) (R ==> eq) (R ==> eq) (R) (R ==> eq) (R) (R ==> eq) (R ==> eq) (R ==> eq) (R), (R) (R ==> eq) (R ==> eq) (R) (R ==> eq) (R ==> eqQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f F T U V R' S f.\n  rewrite <- (fun x => f x).\n  apply F.\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f F H x y Hxy Hz.\n  pose proof (@f_equal_respondence (R:=R) _ _ _ H x y Hxy Hz).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_crelation (R:=R) _ _ _ H x y Hxy Hz).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_ Qcabs (R:=R) _ _ _ H x Hxy Hy).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_crelation (R:=R) _ _ _ H x Hxy Hy).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_OZ (R:=R) _ _ _ _ H x Hxy Hy).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_light (R:=R) _ _ _ _ H x Hxy Hy).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_ HappPred (R:=R) _ _ _ _ H x Hxy Hy).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_ases (R:=R) _ _ _ _ H x Hxy Hy).\n  rewrite Hxy in Hxy.\n  pose proof (@f_equal_entails (Qed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f R H.\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\n  pose proof (@f_equal_crelation R f R f H).\nQed.",
                    "Goal forall {A} (R: rel A A) (f : A -> A), Monotonic f (R ++> R) -> (flip R ++> flip R) f f.\nProof.\n  intros A R f g H.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R : rel A A) (b : bool) (x y : A),\n    b = b ->\n    R x x ->\n    R y y ->\n    R (if b then x else y)\n      (if b then x else y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** [rel_curry] *)\n\nGoal\n  forall {A B C} R R' S (f: A -> B -> B -> C) (x1 y1: A) (x2 y2: B),\n    Monotonic f (rel_curry (R ++> R' ++> S)) ->\n    S (f x1 x2 x2) (f y1 y2 y2).\nProof.\n  intros A B C R R' S f x1 y1 x2 y2 Hf.\n  monotonicity.\nAbort.\n\n(** If we can deduce some terms are equal, we should be able to\n  rewrite them under any context. However right now this can only be\n  done by declaring the [f_equal_relim] hint.\n\n  Maybe a good solution for this might even go further: abstract the\n  common context and use [eq_rect] if it's possible to prove equality\n  between the variant parts. *)\n\nGoal\n  forall {A} (R: rel A A) (f: A -> A) (C: A -> Prop) x y,\n    Monotonic f (R ++> eq) ->\n    R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\n",
                "context_tokens": 719,
                "proof_start_offset": 4997,
                "proof_end_offset": 5177,
                "proof": "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\nintros A R R' f Hf HR.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  destruct (R' f Hf).\n  - intros [f' Hf']. apply Hf'.\n  - intros [f' Hf']. apply Hf'.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  destruct (R' f Hf) as (x,H).\n  apply H.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  destruct Hf as [H | H].\n  + rewrite <- (f_equal_under_ok _ _ _ H).\n    rewrite <- (f_equal_under_ok _ _ _ H).\n    rewrite <- (f_equal_under_ok _ _ _ H).\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n    rewrite <- f_equal_under_ok.\n   Qed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  apply L.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  destruct Hf as [H1 H2].\n  apply f_equal_crelation.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  destruct (R f Hf) as (x,H).\n  apply H.\nQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equal (R:=flip R)).\n  rewrite (f_equalQed.",
                    "Goal forall {A} (R R': rel A A) (f: A -> A), Monotonic f (R ++> R) -> Related R' (flip R) subrel -> (R' ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  apply (R f Hf).\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R x y ->\n    C (f x) ->\n    C (f y).\nProof.\n  intros A R f C x y Hf Hxy.\n  Fail rauto.\n  pose proof @f_equal_relim.\n  rauto.\nQed.\n\n(** *** Hypotheses from the context *)\n\n(* This used to fail because [Hyy] would\n  shadow [Hxy] (the hypothesis we want). *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\n",
                "context_tokens": 710,
                "proof_start_offset": 5968,
                "proof_end_offset": 6181,
                "proof": "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\nintros A B C R f a1 a2 b c Hf Ha.\nmonotonicity; rauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H H0 H1.\n  apply H0 with (R':=R').\n  assumption.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  apply (H (R':=R)).\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C D R f g.\n  (* FILL IN HERE *) Admitted.\n(** [] *)\n\n(** **** Exercise: 4 stars, optional (impl_rel)  *)\n(** We'll define a property that all the following definition is\n    not equivalent to the first one of [R] and [R] as the\n    second argument of the first one of [R]. *)\n\n(** The [impl_rel_impl_rel] is the same as the\n    first one of the second definition of [R] as follows.  We also use the\n    second definition of [impl_rel_impl_rel]. *)\n\nTheorem trans_rel_impl_rel_impl_rel_impl_rel_proper_rel_proper_rel_proper_rel_proper_rel_proper_rel_proper_rel_proper_rel_proper_rel_proper_proper_rel_proper_rel_proper_proper_rel_proper_rel_proper_proper_rel_proper_proper_rel_proper_proper_rel_proper_proper_rel_proper_proper_rel_proper_proper_rel_proper_proper_rel_proper_proper_rel_proper_Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  apply H.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  apply H.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f g a1 a2 b c.\n  destruct c as [R [R [R [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R' [R'Qed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  destruct H as [R [R [R' R'']]] eqn:R' R'' H.\n  + (* b = c -> c -> c -> d -> d -> d *)\n    destruct H as [R' [R' [R' R'']]] eqn:R' R'' H.\n    rewrite H0 in H.\n    auto.\n  + (* b = c -> d -> d -> d -> d -> d *)\n    destruct H as [R' [R' [R' R'']]]] eqn:R' R'' H.\n    rewrite H0 in H.\n    auto.\n  + (* b = c -> d -> d *)\n    destruct H as [R [R [R' [R' [R'' [R'' R'']]]]]].\n    rewrite H0 in H.\n    auto.\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  apply (R Eq).\n  apply (R Eq).\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H H0 H1 H2 H3.\n  apply (H3 a1 b c H H0 H1 H2 H3).\nQed.",
                    "Goal forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c, Monotonic f (R ++> subrel) -> R a1 a2 -> impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c H.\n  apply H with a2 b2; assumption.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " forall {A} (R: rel A A) (x y: A),\n    R x y -> eq y y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  monotonicity.\nQed.\n\n(* This still fail with Coq 8.5, but Coq 8.6 is able to backtrack and\n  try hypothesis from the context beyond the first one it finds. *)\n\nGoal\n  forall {A} (R: rel A A) (x y: A),\n    R x y -> eq x y -> R x y.\nProof.\n  intros A R x y Hxy Hyy.\n  try monotonicity.\nAbort.\n\n(** This used to fail because the flipped hypothesis would not be\n  identified as a candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\n",
                "context_tokens": 708,
                "proof_start_offset": 6183,
                "proof_end_offset": 6385,
                "proof": "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 R1 R2 R HR12 x y.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C R1 R2 f a1 a2 b c Hf Ha.\n  pose proof I.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C R1 R2 f a1 a2 b c.\n  transitivity (R1 ==> R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  apply (R2 ==> R2).\n  apply (R2 ==> R1).\n  applyQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C R1 R2 x y.\n  apply H.\n  apply H.\n  apply H.\n  apply H0.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 R2 x y.\n  pose proof I.\n  eapply equiv_trans.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R2:=R1); auto.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R1:=R2); auto.\n  + apply equiv_trans with (R1:=R2); auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R2 f a1 a2 b c Hf Ha.\n  pose proof I.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C R1 R2 R3.\n  apply (R2 ==> rel A1); apply H.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C R1 R2 f a1 a2 b c Hf.\n  transitivity (R1 ==> R2) (R2 ==> R2) (R1 ==> R2)).\n  apply symmetry_rel.\n  apply symmetry_rel.\n  apply symmetry_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  apply f_rel.\n  applyQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C2 R1 R2 f a1 a2 b c.\n  pose proof R1 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R1 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R1 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R2 as Hf.\n  pose proof R1 as Hf.\n  pose proof R2Qed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C R1 R2.\n  apply (R1 A2 A3 A4); auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C2 R1 R2 f x y.\n  pose proof (R1 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R1 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R1 x y).\n  pose proof (R2 x y).\n  pose proof (R1 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x y).\n  pose proof (R2 x yQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " candidate. This is important because the constraints\n  generated by the setoid rewriting system often have this form. *)\n\nGoal\n  forall {A} (R: rel A A) (f : A -> A),\n    Monotonic f (R ++> R) ->\n    (flip R ++> flip R) f f.\nProof.\n  intros A R f Hf.\n  rauto.\nQed.\n\n(** Then *this* used to fail because the [flip] was hidden until after\n  we exploit the [subrel] property. This is important in particular\n  when using the equivalences for a given partial order, as in [eqrel]\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\n",
                "context_tokens": 720,
                "proof_start_offset": 6615,
                "proof_end_offset": 6735,
                "proof": "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy.\n  destruct (eq_dec x1 y1); [left|right]; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy.\n  rewrite <- Heq.\n  apply eq_sym.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy1 Hy2.\n  transitivity (x1, y1); [assumption|assumption].\n  transitivity (y1, y2); [assumption|assumption].\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy1 Hy2.\n  rewrite <- Heq, Heq, Heq, Heq, Heq, Heq, Heq.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy1 Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.\n  apply f_equal.Qed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy1 Hy2.\n  destruct (eq_dec x1 x2).\n  - subst.\n    rewrite <- Hy1, Hy2.\n    rewrite <- Hy1, Hy2.\n    auto.\n  - subst.\n    rewrite <- Hy1, Hy2.\n    auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2.\n  rewrite <- (f_equal (fun x => x1) (fun x => x2) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x1) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x1) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x1) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2)) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2) (fun x => x2)).\n  rewrite <- (f_equal (fun x => x2) (fun x => x2))).\n  rewriteQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 y3.\n  destruct (eq_dec x1 y1); destruct (eq_dec y2 y3); [left|right]; auto.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B C x1 x2 y1 y2 Hy1 Hy2.\n  apply prop_ext.\n  (* We prove that [x1 = y1] and [y1 = y2] are\n    equal when [x2 = y1], we could use [y1 = y2] and [y2 = y3]. *)\n  subst. rewrite <- Heq. rewrite <- Heq. rewrite <- Heq. reflexivity.\nQed.",
                    "Goal forall A B (x1 x2 : A) (y1 y2 : B), x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros A B x1 x2 y1 y2 Hy1 Hy2.\n  rewrite <- Hx1, <- Hy2.\n  rewrite <- Hy1, Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy2, <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, <- Hy2.\n  rewrite <- Hy1, Hy2.\n  rewrite <- Hy1, Hy2.\n  rewrite <- Hy1, Hy1, Hy2.\n  rewrite <- Hy1, Hy2.\n  rewrite <- Hy1, Hy2, Hy1.\n  rewrite <- Hy1, Hy2.\n  rewrite <- Hy1, Hy2.\n  rewrite <- Hy1, Hy1, Hy2.\n  rewrite <- Hy2, Hy2.\n  rewrite Hy1, Hy2.\n  rewrite <- Hy1, Hy2.\n  rewrite Hy1, Hy1, Hy2.\n  rewrite Hy1, Hy2.\n  rewrite Hy1, Hy2.\n  rewrite <- Hy1, Hy1, Hy2.\n  rewrite Hy1, Hy2Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n  vs. [subrel], where we want to be able to use equivalences in both\n  directions. *)\n\nGoal\n  forall {A} (R R': rel A A) (f: A -> A),\n    Monotonic f (R ++> R) ->\n    Related R' (flip R) subrel ->\n    (R' ++> flip R) f f.\nProof.\n  intros A R R' f Hf HR.\n  rauto.\nQed.\n\n(** As an example where proper handling of [flip] is important,\n  this is a goal generated by [setoid_rewrite] when we try to rewrite\n  using [eqrel] under [option_le]. Here, both [R1] and [R2] have to be\n  instantiated as [flip eq] (so that the associated hypotheses can be\n  used to solve goals of the form [yi = xi]), and similarly we need to\n  use the super-relation [flip subrel] of [eqrel]. *)\n\nGoal\n  forall A, exists R1 R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\n",
                "context_tokens": 694,
                "proof_start_offset": 6885,
                "proof_end_offset": 7143,
                "proof": "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\nintros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\nrewrite HR12.\nassumption.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 H1 H2.\n  rewrite H1 in H1.\n  rewrite H2 in H0.\n  apply H1; auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 C2 C1 R1 R2 [R1 R2] [R2 R3] [R3 R4] [R4] [R5] [R5] [R5] [R6] [R7] [R8] [R8] [R9] [R10] [R10] [R10] [R10] [R12] [R13] [R13] [R13] [R14] [R14] [R15] [R14] [R15] [R15] [R15] [R15] [R15] [R14] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15] [R15Qed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros.\n  destruct H.\n  destruct H.\n  subst.\n  rewrite <- H1, <- H2.\n  rewrite <- H0, <- H1.\n  rewrite <- H1.\n  rewrite <- H2, <- H2.\n  auto.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 C2 D1 D2 D3.\n  split; intros.\n  + apply (R1 A2 B1 B2 C1 D1 D2 C2 D3).\n    apply (R2 A3 B1 C1 D1 D3 D3 D4 D4 D5 D5 D6 D7 D8 D9).\n    apply (R2 A3 B1 C1 D1 D1 D2 D3 D4 D5 D6 D7 D8 D9).\n    apply (R3 A4 B1 C1 D1 D2 D3 D4 D5 D6 D8 D9).\n    apply (R3 A4 B1 C2 D1 D1 D2 D3 D4 D5 D6 D8 D9).\n    apply (R3 A4 B1 C1 D1 D2 D3 D4 D5 D6 D8 D9).\n    apply (R4 A5 B1 D1 D1 D2 D3 D4 D5 D6 D8 D9).\n    apply (R1 A2 A3 A4 B2 D1 D2 D3 D4 DQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 C2 C3 C4.\n  split; intros.\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H0.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\n  apply H0.\n  apply H1.\n  apply H1.\nQed.",
                    "Goal forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2), subrel R1 R2 -> forall x y, (R2 ++> R) x y -> (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 C2 C3 C4 R1 R2' Hf.\n  auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\n",
                "context_tokens": 738,
                "proof_start_offset": 8058,
                "proof_end_offset": 8174,
                "proof": "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\nintros.\nrstep.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoal forall `(PER) (x y z t : A), R x y -> R z y -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\nGoalQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\n(** *** Review and transitive and transitive closure *)\n\nGoal\n  forall `(PER) (x y z : A) (z t : A),\n    R x y ->\n    R z t ->\n    forall x y z t : A, R x y -> R z t -> t x z -> t z.\nProof.\n  intros.\n  rstep.\nAbort.\n\n(** ** Review and transitive closure *)\n\n(** The [setoid] tactic [T] is a useful for [T] *)\n\nGoal forall `(P : T -> Prop),\n    (forall x : T, P x -> P x) -> forall x : T, P x.\nProof.\n  intros.\n  apply (H x).\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\n(** *** Reasoning the [exists] relation *)\n\nGoal forall {A} (R S T: rel A),\n    Equivalence S ->\n    Equivalence S ->\n    Equivalence S ->\n    Equivalence S.\nProof.\n  intros.\n  destruct H as [H|H].\n  apply H0.\nQed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nAbort.\n\n(** ** The [simpl] tactic to [simpl] and [simpl] and [simpl]\n    and [simpl] and [simpl]. *)\n\n(** [simpl_eq_eq] is a shorthand for instance of the equality\n    [simpl_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq] and\n    [simpl] tactics to [simpl_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_eq_Qed.",
                    "Goal forall `(PER) (x y z t : A), R x y -> R z y -> R z t -> R t x.\nProof.\n  intros.\n  rstep.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ": rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\nGoal\n  forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\n",
                "context_tokens": 712,
                "proof_start_offset": 8703,
                "proof_end_offset": 8872,
                "proof": "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  induction l1.\n  + simpl.\n    reflexivity.\n  + simpl.\n    rewrite (IHl1 l2).\n    reflexivity.\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  let H := type of H in\n  let H' := type of H in\n  match type of H with\n  |?X =?Y => constr:(X Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Y => constr:(Y Y)\n  |?Y =?Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  let H1 := fresh \"H\" in\n  assert (H1 := H1).\n  pose proof (H1 x y H1).\n  pose proof (H2 x y H2).\n  pose proof (H1 x y H2).\n  pose proof (H1 x y H1).\n  pose proof (H2 x y H2).\n  pose proof (H3 x y H1).\n  pose proof (H3 x y H2).\n  pose proof (H4 x y H1).\n  pose proof (H4 x y H2).\n  pose proof (H4 x y H3).\n  pose proof (H4 x y H3).\n  pose proof (H5 x y H1).\n  pose proof (H5 x y H3).\n  pose proof (H5 x y H1).\n  pose proof (H5 x y H1).\n  pose proof (H5 x y H4).\n  pose proof (H5 x y H3).\n  pose proof (H5 x y H1).\n  pose proof (H5 x y H5).\n  pose proof (H6 x y H1).\n  pose proof (H6 x y H1).Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply (list_rel_trans _ _ _ _ _ _ _ _ _ H0 H1).\n  intros.\n  apply (list_rel_trans _ _ _ _ _ _ _ _ _ _ H1 H2).\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l1 l2 x y).\n  clearbody R'.\n  pose proof (Forall2_rel R' R' l2 x y y).\n  clearbody R'.\n  poseQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  assert (forall a b, R a b -> R' b b -> R' b b).\n  { induction l1; simpl; intros.\n    - apply H.\n    - apply H.\n  }\n  intros.\n  assert (forall a b, R a b -> R' b b).\n  { induction l2; simpl; intros.\n    - apply H.\n    - apply H.\n    - apply H.\n    - apply IHl1.\n }\n  intros.\n  assert (forall a b, R a b -> R' b b).\n  { induction l1; simpl; intros.\n    - apply H.\n    - apply IHl1.\n }\n  intros.\n  assert (forall a b, R' a b -> R' b b).\n  { induction l2; simpl; intros.\n    - apply H.\n    - apply IHl2.\n }\n  intros.\n  specialize (IHl1 a b H0).\n  destruct IHl1 as [y [y [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [z [zQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  let H1 := match goal with H1 :?R' |- _ =>\n    let H2 := fresh \"H\" in\n    assert (H3 : R' = R0) as H3 by (inv H1; inv H2); clear H3\n    end.\n  match goal with H : _ = _ |- _ =>\n    pose proof (H x y H1); clear H\n  end.\n  match goal with H : _ = _ |- _ =>\n    pose proof (H x y H1); clear H\n  end.\nAbort.\n\n(** ** Reasoning an inductive definition of a list of a list of type [list_rel] *)\n\n(** [list_rel] is well-founded. *)\n\nGoal forall A B C (R1: A -> B -> Prop) (R2: forall x y, R2 x y -> R2 x y),\n  forall x y, R1 x y -> R2 y x -> list_rel R1 (x :: y).\nProof.\n  intros.\n  Fail let H1 := match goal with H1 :?R2 |- _ =>\n    pose proof (H1 x y H1); clear HQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  apply (list_rel_rel_rel_rel_rel_left _ R' R' H).\nQed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  refine (let H3 := (list_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_rel_Qed.",
                    "Goal forall A B (R R': rel A B) l1 l2 x y, subrel R R' -> list_rel R l1 l2 -> R' x y -> list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  Fail simpl.\n  (* [list_subrel] on [list_subrel]. Please report. *)\n  (* [list_sub_rel] is used to solve it. *)\n  (* [list_sub_rel] is used to solve it. *)\n  (* [list_sub_rel] is used to solve it. *)\n  (* [list_sub_rel] is used to solve it. *)\n  (* [list_sub_rel] is used to solve it. *)\n  (* [list_sub_rel] is used to solve this. *)\n  (* [list_sub_rel] is used to solve it. *)\n  (* [list_sub_rel_rel] is used to solve it. *)\n  (* [list_rel_rel] is used to solve this. *)\n  (* [list_rel_rel] is used to solve it. *)\n  (* [list_rel_rel_rel] is used to solve this. *)\n  (* [list_rel_rel_rel] is used to solve this. *)\n  (* [list_rel_rel_rel] is used to solve this. *)\n  (* [list_rel_rel_rel]Qed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B)\n         (opA: A -> A -> A) (opB: B -> B -> B)\n         (RA: rel A A) (RB: rel B B)\n         (HopA: Monotonic opA (RA ++> RA ++> RA))\n         (HopB: Monotonic opB (RB ++> RB ++> RB))\n         (Hxa: RA xa1 xa2)\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\n",
                "context_tokens": 728,
                "proof_start_offset": 8967,
                "proof_end_offset": 9084,
                "proof": "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  pose proof (Forall_rel_compat R R' R' R' x y H0).\n  pose proof (Forall_rel_compat R R' R' R' R' x y H0).\n  pose proof (Forall_rel_compat R R' R' R' x y H0).\n  pose proof (Forall_rel_compat R R' R' R' R' x y H0).\n  pose proof (Forall_rel_compat R R' R' R' R' R' R' R' R' R' R' R' R' R R' R' R' R' R' R R' R' R' R' R' R R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' R' RQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  rewrite H0.\n  assumption.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply functional_extensionality; intros; destruct H0 as [R1 H1]; subst; auto.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct H as [H|H].\n  - (* [Forall] is a morphism from [R x y] to [R] *)\n    destruct H as [H|H].\n    + (* [Forall] is a morphism from [R] *)\n      destruct H as [H'|H'].\n      + (* [Forall] is a morphism from [R x y] *)\n        destruct H as [H'|H'].\n        + (* [Forall] is a morphism from [R] *)\n          simpl.\n          rewrite H''.\n          rewrite H''.\n          rewrite H''.\n          (* [Forall] is a morphism from [R x y] *)\n          rewrite H''.\n          rewrite H''.\n          rewrite H''.\n          rewrite H''.\n          (* [Forall] is a morphism from [R x y] *)\n          rewrite H''.\n          (* [Forall] is a morphism from [R x y] *)\n          rewrite H''.\n          rewrite H''.\n          rewrite H''.\n          (* [Forall] is a morphism from [R x y] *)\n          rewrite H''.\n          (* [Forall] is an equality of [R x y] *)\n          rewrite H''.\n          (* [Forall] is a morphism from [R x y] *)\n          rewrite H''.\n         Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n Qed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  destruct H.\n  + destruct H0.\n    + destruct H0.\n      + destruct H0.\n      + destruct H0.\n        + reflexivity.\n      + destruct H.\n        + destruct H0.\n        + reflexivity.\n      + destruct H0.\n        + reflexivity.\n      + destruct H0.\n        + destruct H0.\n        + reflexivity.\n      + destruct H0.\n        + destruct H0.\n        + reflexivity.\n      + destruct H0.\n        + reflexivity.\n  + destruct H0.\n    + destruct H0.\n      + destruct H0.\n      + destruct H0.\n        + destruct H0.\n        + reflexivity.\n      + destruct H0.\n        + reflexivity.\n      + destruct H0.\n        + destruct H0.\n        + reflexivity.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply H0.\n  apply H.\nQed.",
                    "Goal forall A B (f: A -> B) (R: rel B B) x y, R (f x) (f y) -> (R @@ f) x y.\nProof.\n  intros.\n  apply (RUndo (fun a => match a with\n      | left H => a\n      | right H => a\n      end).\n  intros.\n  destruct a.\n  (* The [exists] fails if the [exists] fails if [P], [exists] fails if [P], [exists] fails if [P], [exists] fails if [P], [exists] fails if [P], [exists] fails if [P], [exists] fails if [P], [exists] fails if [P], [exists] fails if [P] fails if [P], [exists] fails if [P], [exists] fails if [P] fails if [P], [exists] fails if [P] fails if [P] holds if [P] holds if [P] fails if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holds if [P] holdsQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": "\n         (Hxb: RB xb1 xb2)\n         (Hya: RA ya1 ya2)\n         (Hyb: RB yb1 yb2),\n    (RA * RB)%rel\n      (opA xa1 ya1, opB xb1 yb1)\n      (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\n",
                "context_tokens": 709,
                "proof_start_offset": 9180,
                "proof_end_offset": 9343,
                "proof": "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n  intros.\n  apply functional_extensionality.\n Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  destruct H0 as [R1 R2].\n  destruct H1 as [R2 R3].\n  destruct H2 as [R3 R4].\n  destruct H3 as [R5 R6].\n  apply H5.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite <- H.\n  rewrite <- H0.\n  rewrite <- H0.\n  reflexivity.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  apply functional_extensionality; intros.\n  applyQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  destruct H0.\n  rewrite H0.\n  apply H1.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rewrite H.\n  reflexivity.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  apply functional_rel_merge.\nQed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  destruct H.\n  destruct H0.\n  destruct H0.\n  destruct H0.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H2.\n  destruct H1.\n  destruct H1.\n  destruct H2.\n  destruct H0.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H2.\n  destruct H1.\n  destruct H0.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n Qed.",
                    "Lemma rel_pull_2: forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y, Monotonic g (\u22a4 ==> R @@ f) -> (R @@ f) (g x) (g y).\nProof.\n  intros.\n  unfold rel_restrict.\n  apply rel_prod_2.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": ", opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 * R1' ++> R) x y ->\n      (R1 * R1' ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n(** ** The [rgraph] tactic *)\n\nGoal\n  forall {A} (R S T: rel A A),\n    subrel R S ->\n    subrel S R ->\n    subrel S T ->\n    subrel R T.\nProof.\n  intros.\n  rstep.\nQed.\n\nGoal\n  forall `(PER) (x y z t : A),\n    R x y ->\n    R z y ->\n    R z t ->\n    R t x.\nProof.\n  intros.\n  rstep.\nQed.\n\n(** ** The [transport] tactic *)\n\nGoal\n  forall W acc A B C (R1: W -> rel A A) (R2: W -> rel B B) (R3: W -> rel C C) f g a b x w,\n    Monotonic f (rforall w, R1 w ++> R2 w) ->\n    Monotonic g (rforall w, R2 w ++> option_rel (rel_incr acc R3 w)) ->\n    R1 w a b ->\n    g (f a) = Some x ->\n    exists y, rel_incr acc R3 w x y.\nProof.\n  intros.\n  transport H2.\n  eexists.\n  rauto.\nQed.\n\n(** ** Tests for specific relators *)\n\n(** *** [list_rel] *)\n\n(** [list_subrel] use to not work because of a missing [Params] declaration. *)\n\nGoal\n  forall A B (R R': rel A B) l1 l2 x y,\n    subrel R R' ->\n    list_rel R l1 l2 ->\n    R' x y ->\n    list_rel R' (x :: l1) (y :: l2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_pull] *)\n\n(** The [RIntro] instance for [rel_pull] used to be less general. *)\n\nGoal\n  forall A B (f: A -> B) (R: rel B B) x y,\n    R (f x) (f y) ->\n    (R @@ f) x y.\nProof.\n  intros.\n  rauto.\nQed.\n\n(** We don't want the introduction rule for [rel_pull] to shadow\n  relational properties. *)\n\nLemma rel_pull_2:\n  forall A B (f: A -> B) (R: rel B B) (g: A -> A) x y,\n    Monotonic g (\u22a4 ==> R @@ f) ->\n    (R @@ f) (g x) (g y).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** *** [rel_all] *)\n\n",
                "context_tokens": 732,
                "proof_start_offset": 9367,
                "proof_end_offset": 9486,
                "proof": "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_lex.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_reflect_2.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  apply rel_dec.\n  applyQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  unfold equiv.\n  apply rel_sym.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply rel_impl_rel_induction.\n  intros.\n  destruct H.\n  apply H0.\n  apply H1.\n  apply H.\n  apply H2.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct H.\n  apply rel_merge_2; auto.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct H.\n  left.\n  destruct H.\n  left.\n  destruct H0.\n  right.\n  destruct H0.\n  left.\n  destruct H0.\n  destruct H1.\n  left.\n  destruct H1.\n  right.\n  destruct H0.\n  right.\n  destruct H0.\n  left.\n  destruct H1.\n  destruct H2.\n  right.\n  destruct H0.\n  destruct H1.\n  left.\n  destruct H1.\n  right.\n  destruct H0.\n  destruct H1.\n  right.\n  destruct H1.\n  destruct H1.\n  right.\n  destruct H0.\n  right.\n  destruct H0.\n  destruct H1.\n  right.\n  destruct H1.\n  destruct H1.\n  left.\n  destruct H1.\n  right.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  left.\n  destruct H1.\n  destruct H1.\n  right.\n  destruct H1.\n  destruct H1.\n  destruct H1.\n  right.\n  destruct H1.\n  destruct H1.\n  right.\n  destruct H0.\n  destruct H1.\n  destruct H0.\n  right.\n Qed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  destruct H as [x?].\n  rewrite <- (H x).\n  apply rel_swap.\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_trans (R:=R) (R:=R) (R:=R)).\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  apply (rel_compat_l_a (x:=x)).\nQed.",
                    "Lemma rel_all_1: forall {A} (x: A), (rforall a, req a) x x -> forall a, req a x x.\nProof.\n  intros.\n  induction H.\n  simpl.\n  eapply rel_unique.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\n  eapply rel_swap.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/coqrel/LogicalRelationsTests.v",
                "context": " R2: relation (option A),\n    (eqrel ==> R1 ==> R2 ==> flip impl)%signature option_le option_le.\nProof.\n  intros A. eexists. eexists.\n  rauto.\nQed.\n\n(** *** [impl] vs. [subrel] *)\n\n(** This checks that a relational property written in terms of\n  [subrel] can be used to solve a goal stated in terms of [impl].\n  This is made possible by [subrel_impl_relim]. *)\n\nGoal\n  forall A B C (R: rel A A) (f: A -> rel B C) a1 a2 b c,\n    Monotonic f (R ++> subrel) ->\n    R a1 a2 ->\n    impl (f a1 b c) (f a2 b c).\nProof.\n  intros A B C R f a1 a2 b c Hf Ha.\n  monotonicity; rauto.\nQed.\n\nGoal\n  forall A1 A2 B1 B2 (R1 R2: rel A1 A2) (R: rel B1 B2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 R1 R2 R HR12 x y.\n  rauto.\nQed.\n\n(** *** Generic rules *)\n\n(** The [coreflexivity] of [rel_prod] and [eq] makes it possible for\n  [pair_rel] to behave in the same way as [f_equal] below, since they\n  allow us to deduce that [eq * eq] is a [subrel] of [eq]. *)\n\nGoal\n  forall A B (x1 x2 : A) (y1 y2 : B),\n    x1 = x2 -> y1 = y2 -> (x1, y1) = (x2, y2).\nProof.\n  intros.\n  rauto.\nQed.\n\n(** ** Using [foo_subrel] instances *)\n\n(** Still broken because of the interaction between [subrel] and\n  [- ==> - ==> impl] (or lack thereof) *)\n\nGoal\n  forall A1 A2 B1 B2 C1 C2 (R1 R2: rel A1 A2) (R1': rel B1 B2) (R: rel C1 C2),\n    subrel R1 R2 ->\n    forall x y,\n      (R2 ++> R) x y ->\n      (R1 ++> R) x y.\nProof.\n  intros A1 A2 B1 B2 C1 C2 R1 R2 R1' R HR12 x y H.\n  rewrite HR12.\n  assumption.\nQed.\n\n",
                "context_tokens": 600,
                "proof_start_offset": 7145,
                "proof_end_offset": 7615,
                "proof": "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\nintros.\nrauto.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C.\n  destruct (eq_dec _ _ H).\n  + subst.\n    rewrite <- HopA, <- HopA, <- HopA, <- HopA, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <- HopB, <-Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B C D f A B f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C f B C.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B.\n  destruct (A B) as (a,a').\n  destruct (A B) as (a',a').\n  destruct (A B) as (a',a').\n  destruct (A B) as (a',a').\n  destruct (A B) as (a'',a').\n  simpl in *.\n  auto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B (x1, x2) (y1, y2) (y1, y2) (y1, y3) (y1, y3) (y2, y4) (z1, y5) (z2, z4) (z3, z4) (z4, z5) (z4, z5) (z5, z6) (z7, z7) (z8, z8) (z8, z9) (z9, z10, z11, z12, z13), (z8, z9) (z9, z10, z12, z13), (z8, z9) (z9, z10, z11, z13), (z8, z9) (z9, z10, z12), (z9, z15) (z10, z11, z13), (z8, z9) (z10, z15) (z11, z12), (z11, z13), (z12, z13) (z14, z15) (z15, z15).\nProof. intros AQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B.\n  destruct X as [X Y].\n  rewrite <- (R1 A2 B1 B2 C1 B1 C2 D1 D2 R1' R2' R1' R2' R2' R3 R4 R5 R5 R1' R2' R4 R5 R5 R1' R2' R4 R5 R5 R5 R6 R7 R8 R8 R9 R10.\n  intros.\n  unfold Basics.compose.\n  apply (R2 (R1:=R1) (R2:=R2) (R3:=R3) (R4:=R4) (R5:=R5) (R6:=R7) (R8:=R8) (R8:=R9) (R9:=R9) (R10:=R10) (R11:=R12) (R13:=R14) (R14:=R14) (R14) (R14:=R14) (R15) (R14:=R15) (R14) (R14:=R14) (R14:=R14) (R14) (R14:=R14)Qed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros.\n  rauto.\nQed.",
                    "Goal forall A B (xa1 xa2 ya1 ya2 : A) (xb1 xb2 yb1 yb2 : B) (opA: A -> A -> A) (opB: B -> B -> B) (RA: rel A A) (RB: rel B B) (HopA: Monotonic opA (RA ++> RA ++> RA)) (HopB: Monotonic opB (RB ++> RB ++> RB)) (Hxa: RA xa1 xa2) (Hxb: RB xb1 xb2) (Hya: RA ya1 ya2) (Hyb: RB yb1 yb2), (RA * RB)%rel (opA xa1 ya1, opB xb1 yb1) (opA xa2 ya2, opB xb2 yb2).\nProof.\n  intros A B x1 x2 b c d h.\n  apply (R1 (x1, b1) (x2, b2) (x3, b3) (x4, b5) (x5, b6)).\n  rewrite <- HQ12.\n  assumption.\nQed."
                ]
            }
        ],
        "fundamental-arithmetics": [
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\n",
                "context_tokens": 280,
                "proof_start_offset": 1048,
                "proof_end_offset": 1150,
                "proof": "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\nintros.\nred.\nexists n.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  simpl in |- *.  intros.  elim (H (S n)).\n  intros.  elim H0.  intros.  elim H1.  intros.  elim H2.  intros.\n  exists (S n).  split.  assumption.  split.  assumption.\n  simpl in |- *.  intros.  elim H2.  intros.  elim H3.  intros.  elim H4.\n  intros.  elim H5.  intros.  elim H5.  intros.\n  exists (S n).  split.  assumption.  split.  assumption.  split.\n  assumption.  intro.  elim H5.  intros.  elim H6.  intros.  elim H7.\n  intros.  elim H7.  intros.  elim H7.  intros.  elim H7.  intros.  elim H8.\n  intros.  elim H8.  intros.  elim H9.  intros.  elim H9.\n  intros.  elim H9.  intros.  elim H10.  intros.\n  exists (S n).  split.  assumption.  split. Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n simple induction n.\n simpl in |- *.\n intros.\n simpl in |- *.\n intros.\n elim H.\n intros.\n simpl in |- *.\n intros.\n elim H.\n intros.\n simpl in |- *.\n intros.\n apply H.\n intros.\n exists x.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n cut (exists q : nat, (exists q : nat, q = (q * q)).\n intro.\n exists (S p).\n apply le_n.\n apply le_O_n.\n apply le_O_n.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n intro.\n case (le_or_lt 0 n).\n intro.\n case (le_or_lt 0 n).\n intro.\n left.\n left.\n assumption.\n intro.\n right.\n assumption.\n intro.\n right.\n assumption.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\n intro.\n cut (0 < n)%Z.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intros n; elim (succ_pred_le_dec n 1); intros.\n left; apply le_n_O.\n right; apply le_n_S.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q * q).\n intro.\n cut (exists q:nat, n = q *Qed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n  simple induction n.\n  simpl in |- *.\n  intros.  elim (le_O_O _ H).\n  intros.  elim H1.\n  intros.  elim H2.\n  intros.  split with (S x).  simpl in |- *.  intros.\n  assumption.  simpl in |- *.  intros.  elim H2.\n  intros.  split with (S x).  simpl in |- *.  intros.\n  assumption.  simpl in |- *.  intros.  elim H3.\n  intros.  split with (S x).  simpl in |- *.  intros.\n  assumption.  simpl in |- *.  intros.  elim H4.\n  intros.  split with (S x).  simpl in |- *.  intros.\n  assumption.  simpl in |- *.  intros.  elim H4.\n  intros.  split with (S x).  simpl in |- *.  intros.\n  assumption.  simpl in |- *.  intros.  elim H4.  intros.  split with x.\n  simpl in |- *.  intros.  elim H4.  intros.  split with x.  simpl in |- *.  intros.\n  assumption.  simpl inQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro n; elim n; simpl in |- *; auto with arith.\nQed.",
                    "Lemma one_min_div : forall (n:nat),(divides n 1).\nProof.\n intro.\n induction  n as [| n Hrecn].\n simpl in |- *.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\n",
                "context_tokens": 327,
                "proof_start_offset": 1196,
                "proof_end_offset": 1299,
                "proof": "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\nintros.\nred.\nexists O.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  apply (fun n:nat => plus_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => plus_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => mult_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => plus_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat => plus_comm n 1 (pred (S n))).\n  intros.\n  apply (fun n:nat =>Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  simple induction n.\n  intros.\n  simpl in |- *.\n  apply not_O_O_n.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intro.\n  unfold modulo, modulo in |- *.\n  exists O.\n  rewrite S_O.\n  apply le_n_S.\n  apply le_O_n.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  unfold modulo in H.\n  apply le_n_S.\n  unfold modulo in |- *.\n  rewrite (plus_comm (n * 1)).\n  rewrite (plus_comm (n * 1)).\n  rewrite <- (plus_comm (n * 1)).\n  rewrite <- (plus_assoc n (n * 1)).\n  rewrite (plus_comm (n * 1)).\n  rewrite <- (plus_assoc n (n * 1)).\n  rewrite (plus_comm n 1).\n  rewrite <- (plus_assoc n 1).\n  rewrite (plus_comm (n * 1)).\n  rewrite <- (plus_assoc n 1).\n  rewrite (plus_assoc n 1).\n  rewrite <- (plus_assoc (n * 1)).\n  rewrite (plus_comm n 1).\n  rewrite (plus_comm (n * 1)).\n  rewrite <- (plus_assoc n 1).\n  rewrite (plus_comm (n * 1)).\n  rewrite <- (plus_assoc n 1).\n  rewrite (plus_comm (n * 1)).\n  rewrite <- (plus_assoc n 1).\n  rewrite <- (plus_assoc n 1).\n  rewrite (plus_assoc n 1).\n  rewrite (plus_comm n 1).\n Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  unfold opp, modulo, opp, opp.\n  intros.\n  absurd (exists q:nat, n = S q).\n  intro.\n  exists (S q).\n  apply (fun m n p:nat => S m < p /\\ (n < p /\\ (n < p /\\ (m * p) = S n)).\n  apply (fun m n p:nat => S m < p /\\ (n < p /\\ (n < p /\\ (n < p /\\ m) = S n)).\n  apply (fun m n p:nat => S m < p /\\ (n < p /\\ (n < p /\\ m) = S n)).\n  apply (fun m n p:nat => S m < p /\\ (n <= p /\\ (n < p /\\ (m * p) = S n)).\n  apply (fun m n p:nat => S m < p /\\ (n < p /\\ (n < p /\\ m) = S n)).\n  apply (fun m n p:nat => S m < p /\\ (n < p /\\ (n < p /\\ m) = S n)).\n  apply (fun m n p:nat => S m < p /\\ (n < p /\\ (Qed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\n  intro.\n  unfold modulo at 1.\n  apply (fun p n m:nat => p <= m * p)%nat.\n  rewrite (minus_n_O p).\n  rewrite <- (minus_n_O p).\n  rewrite <- (plus_n_O p).\n  apply le_n_S.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nintro.\nelim (le_gt_dec (S n) (S n)).\n intros.\n apply H.\n assumption.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  elim H.\n  intros.\n  apply succ_pred with (n:=n) (m:=n) (n:=m) (n:=n) (q:=q).\n  unfold plus in |- *.\n  apply le_n_S.\n  apply le_n_S.\n  apply le_O_n.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intro.\n  unfold modulo in |- *.\n  apply plus_n_O.\nQed.",
                    "Lemma zero_max_div : forall (n:nat),(divides O n).\nProof.\n  intros.\n  apply one_min_inf.\n  apply one_min_inf.\n  apply one_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  apply two_min_inf.\n  applyQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\n",
                "context_tokens": 373,
                "proof_start_offset": 1350,
                "proof_end_offset": 1453,
                "proof": "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\nintros.\nred.\nexists 1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intro.\n  unfold modulo in |- *.\n  exists O.\n  apply le_n.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  apply (fun p n m:nat =>\n      exists m : nat,\n        m = n /\\ n = m /\\ n = m /\\ n = m /\\ n = m /\\ n = m).\n  intro.\n  elim (dec_or_lt n m).\n  intros.\n  elim H1.\n  intro.\n  right.\n  apply (H m n).\n  intro.\n  left.\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n intros.\n unfold modulo in |- *.\n apply le_O_n.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  red in H.\n  apply H.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  unfold modulo in |- *.\n  intros.\n  elim (le_lt_or_eq _ _ H).\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intro.\n  unfold modulo in |- *.\n  elim (le_or_lt 0 (S (S (S n))) 0).\n  intros.\n  apply H0.\n  assumption.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n apply mod_refl.\nQed.",
                    "Lemma divides_refl : forall (a:nat),(divides a a).\nProof.\n  intros.\n  elim (le_or_lt 0 a H).\n  intros.\n  elim (le_le_or_eq 0 a H).\n  intros.\n  apply H.\n  apply H0.\n  apply H.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\n",
                "context_tokens": 417,
                "proof_start_offset": 1505,
                "proof_end_offset": 1745,
                "proof": "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nexists (q' * q).\nrewrite H1.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists (b*c).\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  unfold Divides, modulo, modulo.\n  intros.\n  elim (Zle_lt_or_eq (Zabs_nat a) (Zabs_nat b)).\n  intros.\n  apply H.\n  intros.\n  apply H1.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n intros.\n apply (H (b*c) (c*c) (c*c)).\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply (gcd_sym (a*c) (b*c)).\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply H.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  red; intros.\n  elim H; auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red.\n  exists 0.\n  auto with arith.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  red in |- *.\n  exists 1.\n  apply le_refl.\nQed.",
                    "Lemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\nProof.\n  intros.\n  apply H.\n  apply div_le_compat_l.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/division.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Import missing.\nRequire Import Wf_nat.\n\n(** b | a if there is q such that a = b * q*)\nDefinition divides (a b:nat) := exists q:nat,a = (b*q).\n\n(** 1 divides every natural number *)\nLemma one_min_div : forall (n:nat),(divides n 1).\n  intros.\n  red.\n  exists n.\n  auto with arith.\nQed.\n\n(** 0 is divides by every natural number *)\nLemma zero_max_div : forall (n:nat),(divides O n).\n  intros.\n  red.\n  exists O.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is reflexive *)\nLemma divides_refl : forall (a:nat),(divides a a).\n  intros.\n  red.\n  exists 1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is transitive *)\nLemma divides_trans : forall (a b c:nat),(divides a b)->(divides b c)->(divides a c).\n  unfold divides.\n  intros.\n  elim H;intro q;intro.\n  elim H0;intro q';intro.\n  rewrite H2 in H1.\n  exists (q' * q).\n  rewrite H1.\n  auto with arith.\nQed.\n\n(** the relation of divisibility is antisymmetric *)\n",
                "context_tokens": 508,
                "proof_start_offset": 1800,
                "proof_end_offset": 2305,
                "proof": "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\nunfold divides.\nintros.\nelim H;intro q;intro.\nelim H0;intro q';intro.\nrewrite H2 in H1.\nassert ((a = 0) \\/ (q' * q)=1).\napply mult_lemma4.\nreplace (a*(q'*q)) with (a*q'*q);try (auto with arith).\ncase H3;intro.\nrewrite H4 in H2;simpl in H2;rewrite H2;trivial.\nelim (mult_lemma5 q' q H4);intros.\nrewrite H5 in H2;rewrite mult_comm in H2;simpl in H2;rewrite plus_comm in H2;simpl in H2;symmetry;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  apply (H _ H1).\n  exists (q * q).\n  rewrite H2.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; rewrite H0 in H.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; elim H0; intro.\n  rewrite H2 in H1.\n  elim (H1 q); intro.\n  rewrite H3 in H1.\n  auto.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; elim H0; intro.\n  rewrite H1 in H0.\n  elim (H1 q); auto.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  apply (H1 (b*q)).\n  apply H0.\n  apply H1.\n  apply H2.\n  apply H2.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  unfold Divides.\n  intros.\n  elim H; intro q; elim H0; intro.\n  rewrite H1 in H0.\n  elim (H0 q); intro.\n  rewrite H1 in H0.\n  rewrite H0 in H0.\n  rewrite <- H0 in H0.\n  auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  elim H1; intro.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  rewrite H1 in H1.\n  assumption.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; intro.\n  elim H; intro.\n  left; auto with arith.\n  right; auto with arith.\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro q; elim H0; intros.\n  elim H; intro q'; intro.\n  apply H; apply (H0 q').\n  apply (H1 q').\n  apply (H1 q').\n  apply (H1 q').\n  apply (H2 q').\n  apply (H1 q').\n  apply (H2 q').\n  apply (H1 q').\n  apply (H1 q').\n  apply (H2 q').\nQed.",
                    "Lemma divides_antisym : forall (a b:nat),(divides a b)->(divides b a)->a=b.\nProof.\n  intros.\n  elim H; intro.\n  elim H0; intro.\n  elim H1; intro.\n  rewrite H2 in H1.\n  absurd (p * a = p * b).\n  auto with arith.\n  apply H.\n  apply H1.\n  apply H0.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "try omega.\n  assert (1 <= n);try omega.\n  assert (m > 1);try omega.\n  generalize (IHm H4);omega.\nQed.\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3621,
                "proof_end_offset": 3705,
                "proof": "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nProof.\nintros.\nring.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\nintros x y z t; simpl; auto. Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction x;intros;rewrite plus_comm;simpl.\nrewrite plus_comm.\napply mult_assoc.\napply mult_lemma3.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;simpl;intros;auto.\n  rewrite plus_comm;simpl.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm x y z).\n  rewrite mult_comm.\n  rewrite (mult_comm y z).\n  rewrite (mult_comm x y z).\n  rewrite mult_comm.\n  rewrite (mult_comm z y).\n  rewrite (mult_comm z y).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm z y).\n  rewrite mult_comm.\n  rewrite (mult_comm x y z).\n  rewrite (mult_comm y z).\n  rewrite (mult_comm z y).\n  rewrite (mult_comm z y).\n  rewrite (mult_comm z y).\n  rewrite mult_comm.\n  rewrite (mult_comm z y).\n  rewrite (mult_comm z y).\n  rewrite (mult_comm y z).\n  rewrite (mult_comm zQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction t;intros;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;auto.\n  rewrite plus_comm;simpl;rewrite mult_comm;simpl;rewrite mult_comm;simpl;auto.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  rewrite mult_comm;simpl.\n  rewrite <- mult_assoc.\n  apply mult_lemma5;auto.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\ninduction x;simpl;intros;auto with arith.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction x;intros;rewrite mult_comm;simpl.\n  rewrite mult_comm;simpl.\n  rewrite <- mult_assoc;simpl.\n  rewrite mult_assoc.\n  rewrite <- mult_assoc.\n  rewrite <- (mult_comm x y z).\n  rewrite (mult_comm x z).\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm x y z).\n  rewrite (mult_comm x y z).\n  rewrite (mult_comm x z).\n  rewrite (mult_comm x z).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm x z).\n  rewrite mult_comm.\n  rewrite (mult_comm y z).\n  rewrite (mult_comm x z).\n  rewrite (mult_comm (S x) z).\n  rewrite mult_assoc.\n  rewrite (mult_comm x z).\n  rewrite (mult_comm (S x) z).\n  rewrite (mult_comm (S x) z).\n  rewrite mult_assoc.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite (mult_Qed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  induction t;intros;rewrite plus_comm;simpl.\n  rewrite plus_comm.\n  apply mult_lemma1.\n  rewrite plus_comm.\n  apply mult_lemma1.\n  rewrite mult_comm.\n  apply mult_lemma1.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction t;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite <- plus_assoc.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma1.\n  apply plus_minus_lemma2.\n  apply plus_minus_lemma2.\nQed.",
                    "Lemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  induction t.\n  simpl.\n  trivial.\n  simpl.\n  replace (x*y-z) with (x*z+z); try omega.\n  simpl.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite mult_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite (mult_comm (x*y)).\n  rewrite (mult_comm (x*y)).\n  rewrite mult_comm.\n  rewrite (mult_comm (x*y)).\n  rewrite mult_Qed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n\nLemma mult_lemma4 : forall (n m:nat),n=n*m -> n=O \\/ m=1.\n  intros n m.\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3707,
                "proof_end_offset": 3783,
                "proof": "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\ninduction a.\nsimpl.\nauto with arith.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\nrewrite <- (mult_comm a b); rewrite <- (mult_comm a b).\nrewrite mult_comm.\nring.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nProof.\ninduction a.\nsimpl.\nauto with arith.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\ninduction a.\nsimpl.\ntrivial.\nsimpl.\napply le_trans with (S x + S y).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm (S a) (S b)).\nrewrite mult_comm.\nrewrite (mult_comm (S a) (S b)).\nrewrite mult_comm.\nrewrite mult_comm.\nrewrite (mult_comm (S b) (S b)).\nrewrite mult_comm.\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite mult_comm.\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite mult_assoc.\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (S b)).\nrewrite (mult_comm (Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\nintros.\ninduction a.\nsimpl.\nauto with arith.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite mult_comm.\nrewrite plus_comm.\nrewrite plus_comm.\nrewrite mult_comm.\nrewrite plus_comm.\nrewrite (mult_comm (a+S b)).\nrewrite plus_comm.\nrewrite plus_assoc.\nrewrite (mult_comm (a+S b)).\nrewrite mult_comm.\nrewrite (mult_comm (a+S b)).\nrewrite (mult_comm (b+S b)).\nrewrite (mult_comm (b+S b)).\nrewrite (mult_comm (a+S b)).\nrewrite (mult_comm (b+S b)).\nrewrite (mult_comm (b+S b)).\nrewrite (mult_comm (a+S b)).\nrewrite (mult_comm (a+S b)).\nrewrite (mult_comm (b+S b)).\nrewrite (mult_comm (a+S b)).\nrewrite (mult_comm (a+S b)).\nrewrite (mult_comm (b+S b)).\nrewrite (mult_comm (b+S b)).\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  rewrite mult_comm.\n  apply plus_minus_lemma1.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  simpl.\n  intros.\n  destruct (plus_minus_lemma1 _ _ H) as (y,(H,H)).\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm b a) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm b a) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm b a) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.\n  rewrite (plus_comm a y) in H.Qed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  rewrite (mult_comm a).\n  simpl.\n  rewrite (mult_comm a).\n  simpl.\n  rewrite mult_comm.\n  rewrite <- mult_assoc.\n  rewrite plus_comm.\n  apply mult_lemma1.\nQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  induction a;simpl;intros;auto with arith.\n  destruct b.\n  rewrite mult_comm.\n  rewrite plus_comm.\n  simpl.\n  rewrite <- minus_n_O.\n  simpl.\n  rewrite plus_comm.\n  rewrite mult_comm.\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S a)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (S b)).\n  rewrite (mult_comm (SQed.",
                    "Lemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  apply (mult_comm a b);trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": ".\n  case n.\n  left;trivial.\n  intros.\n  right.\n  destruct m.\n  rewrite mult_comm in H.\n  discriminate.\n  destruct m;trivial.\n  assert ((S n0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 744,
                "proof_start_offset": 3785,
                "proof_end_offset": 3863,
                "proof": "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  induction m.\n  simpl;intros.\n  omega.\n  simpl;intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "0)<(S n0)*(S (S m))).\n  apply mult_lemma3;intros;auto with arith.\n  rewrite <- H in H0.\n  elim (lt_irrefl (S n0) H0).\nQed.\n\nLemma mult_lemma5 : forall (n m:nat),((n * m) =1)->(n=1)/\\(m=1).\n  induction n;simpl;intros;try discriminate.\n  induction m.\n  rewrite mult_comm in H.\n  simpl in H;discriminate.\n  assert ((S n)<=((S n)*(S m))).\n  apply mult_lemma1;discriminate.\n  assert (((S n)*(S m))=((S m)+n*(S m))).\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\n",
                "context_tokens": 736,
                "proof_start_offset": 3865,
                "proof_end_offset": 4270,
                "proof": "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\nProof.\nintros.\ncase (le_lt_dec y z);intro.\nrewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\nassert (y=z+(y-z)).\nrewrite <- (le_plus_minus z y);try (auto with arith).\nreplace (x*y) with (x*(z+(y-z))).\nrewrite mult_plus_distr_l;rewrite minus_plus;trivial.\nrewrite <- H;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed.",
                    "Lemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "\n  reflexivity.\n  rewrite H1 in H0.\n  rewrite H in H0.\n  assert ((S n)=1).\n  omega.\n  split;trivial.\n  inversion H2.\n  rewrite H4 in H.\n  simpl in H.\n  omega.\nQed.\n\nLemma plus_minus_lemma1 : forall (y x:nat),(x+y-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\n",
                "context_tokens": 735,
                "proof_start_offset": 4272,
                "proof_end_offset": 4480,
                "proof": "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus y x);try (auto with arith).\nrewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_eq_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite (minus_lemma2 x z l);rewrite mult_comm;simpl;auto with arith.\n  rewrite <- H;rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;rewrite plus_comm;simpl;auto with arith.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_diag;auto with arith.\n  rewrite plus_comm;simpl;auto with arith.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma2 x y l);rewrite plus_minus;simpl;rewrite plus_minus;trivial.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_l.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma1 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;auto.\n  rewrite <- H;rewrite mult_plus_distr_l;rewrite mult_comm;simpl;rewrite minus_diag;auto.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite (plus_comm x y) in H;rewrite plus_comm in H.\n  discriminate H.\n  rewrite mult_plus_distr_r.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma1 y z l);rewrite mult_comm;simpl;rewrite plus_comm;trivial.\n  assert (y=z).\n  rewrite (plus_comm z y);rewrite (plus_comm z y);rewrite (plus_comm z y);rewrite (plus_comm z y);auto with arith.\n  rewrite <- H;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma1;trivial.\n  rewrite <- (mult_comm x y);rewrite mult_plus;trivial.\n  apply plus_le_compat_r.\n  apply plus_le_compat_r.\n  apply mult_le_compat_r.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma2 x z l);rewrite plus_minus;trivial.\n  rewrite <- plus_minus;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (plus_comm x z l);rewrite mult_plus;simpl.\n  rewrite plus_comm;simpl.\n  rewrite plus_comm;simpl.\n  rewrite mult_comm;simpl;trivial.\nQed.",
                    "Lemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (plus_minus_lemma2 y z l);rewrite mult_assoc;simpl;rewrite minus_lemma2;trivial.\n  rewrite mult_comm;simpl;auto.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "-y=x).\n  induction y;intros;rewrite plus_comm;simpl.\n  auto with arith.\n  rewrite plus_comm.\n  apply IHy.\nQed.\n\nLemma mult_minus_lemma1 : forall (a n:nat),a*n-n = (a-1)*n.\n  intros.\n  induction a.\n  simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\n",
                "context_tokens": 734,
                "proof_start_offset": 4482,
                "proof_end_offset": 4694,
                "proof": "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\nProof.\nintros.\nrewrite (le_plus_minus z y);trivial.\nrewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x y);intro.\n  rewrite (plus_comm z x (S y)).\n  rewrite mult_plus_distr_r;rewrite (plus_comm z x).\n  rewrite (plus_comm z x (S y)).\n  rewrite mult_plus_distr_r;rewrite (plus_comm z x).\n  rewrite (plus_comm z y (S y)).\n  rewrite mult_plus_distr_r;rewrite (plus_comm z x).\n  rewrite plus_assoc;rewrite plus_comm;rewrite plus_assoc;rewrite (plus_comm y z).\n  rewrite mult_plus;rewrite (plus_comm z x);rewrite (plus_comm z y);rewrite mult_plus;trivial.\n  rewrite (plus_comm y (S x));rewrite mult_plus;rewrite (plus_comm z x).\n  rewrite mult_plus;rewrite (plus_comm z x);rewrite mult_plus;trivial.\n  rewrite <- plus_assoc;rewrite (plus_comm z x).\n  rewrite mult_plus;rewrite mult_plus;trivial.\n  rewrite (plus_comm z x);rewrite mult_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_eq_dec x z);intro.\n  rewrite (minus_lemma1 y z l);rewrite mult_comm;simpl;rewrite plus_comm;simpl;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y z);rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;auto with arith.\n  Qed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus x y z);try (auto with arith).\n  rewrite mult_plus_distr_r;rewrite plus_comm;rewrite plus_comm;simpl;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite <- (plus_minus_lemma1 x y z).\n  rewrite plus_minus;rewrite mult_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite mult_plus_distr_l;rewrite mult_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma1 x z l);rewrite (minus_lemma1 x z l);rewrite plus_comm;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": " simpl.\n  trivial.\n  replace (S a*n) with (n+a*n);try (auto with arith).\n  rewrite plus_comm.\n  rewrite plus_minus_lemma1.\n  simpl.\n  rewrite <- minus_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\n",
                "context_tokens": 739,
                "proof_start_offset": 4696,
                "proof_end_offset": 4828,
                "proof": "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\nProof.\ninduction x;simpl;trivial.\nintros.\ncase y;simpl;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;rewrite plus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);try (auto with arith).\n  rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);simpl;rewrite plus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);try (auto with arith).\n  rewrite minus_plus;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  rewrite plus_comm;rewrite mult_comm;rewrite plus_comm;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  case (le_lt_dec x z);intro.\n  rewrite (minus_lemma2 z y l);rewrite mult_comm;simpl;rewrite plus_comm;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite plus_comm;rewrite plus_minus;rewrite minus_plus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus x y);try (auto with arith).\n  rewrite plus_comm;rewrite mult_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;rewrite plus_comm;auto with arith.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z x);try (auto with arith).\n  replace (x+(y-z)) with (x+(y-z)).\n  rewrite plus_minus_distr_l;rewrite plus_minus;trivial.\nQed.",
                    "Lemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  intros.\n  rewrite (le_plus_minus z y);rewrite mult_plus;rewrite minus_plus;trivial.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "_n_O;trivial.\nQed.\n\nLemma mult_lemma6 : forall (a b n:nat),(n <> O)->(n*a=n*b)->(a=b).\n  induction a.\n  intros;rewrite <- mult_n_O in H0; generalize (mult_lemma2 n b); intros Hl2; elim Hl2; intros; (auto || elim H ; auto).\n  intros b n H.\n  rewrite mult_comm;simpl;rewrite mult_comm;intro.\n  assert (n*a = n*b-n).\n  apply plus_minus;auto.\n  assert (a*n=(b-1)*n).\n  rewrite <- mult_minus_lemma1;rewrite mult_comm;rewrite (mult_comm b n);trivial.\n  assert (a=(b-1)).\n  apply (IHa (b-1) n);trivial.\n  rewrite mult_comm;rewrite (mult_comm n (b-1));trivial.\n  destruct b;simpl in H3.\n  rewrite H3 in H0;rewrite (mult_comm n 0) in H0;rewrite plus_comm in H0;simpl in H0;elim H;trivial.\n  rewrite <- minus_n_O in H3;auto.\nQed.\n\nLemma mult_lemma7 : forall (x y z t:nat),x*y*(z*t)=z*(x*y*t).\n  intros.\n  ring.\nQed.\n\nLemma minus_lemma1 : forall (a b:nat),(S a-S b)<S a.\n  intros.\n  omega.\nQed.\n\nLemma minus_lemma2 : forall (n m:nat),(n<=m)->(n-m=O).\n  intros.\n  omega.\nQed.\n\nLemma mult_minus_lemma2 : forall (x y z:nat),(x*(y-z))=(x*y-x*z).\n  intros.\n  case (le_lt_dec y z);intro.\n  rewrite (minus_lemma2 y z l);rewrite mult_comm;simpl;rewrite minus_lemma2;trivial;auto with arith.\n  assert (y=z+(y-z)).\n  rewrite <- (le_plus_minus z y);try (auto with arith).\n  replace (x*y) with (x*(z+(y-z))).\n  rewrite mult_plus_distr_l;rewrite minus_plus;trivial.\n  rewrite <- H;trivial.\nQed.\n\nLemma plus_minus_lemma2 : forall (x y z:nat),(y<=x)->(x-y+z)=(x+z-y).\n  intros.\n  rewrite (le_plus_minus y x);try (auto with arith).\n  rewrite minus_plus;rewrite <- plus_assoc;rewrite minus_plus;trivial.\nQed.\n\nLemma minus_minus_lemma1 : forall (x y z:nat),(z<=y)->(x-(y-z))=(x+z-y).\n  intros.\n  rewrite (le_plus_minus z y);trivial.\n  rewrite minus_plus;rewrite plus_comm;rewrite <- minus_plus_simpl_l_reverse;trivial.\nQed.\n\nLemma minus_minus_lemma2 : forall (x y z:nat),(x-y-z)=(x-(y+z)).\n  induction x;simpl;trivial.\n  intros.\n  case y;simpl;trivial.\nQed.\n\n",
                "context_tokens": 742,
                "proof_start_offset": 4830,
                "proof_end_offset": 4910,
                "proof": "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\nProof.\nintros.\nomega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed.",
                    "Lemma minus_lt_lemma1 : forall (b a:nat),(a<b)->(0<b-a).\n  intros.\n  omega.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\n",
                "context_tokens": 271,
                "proof_start_offset": 1084,
                "proof_end_offset": 1244,
                "proof": "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m;simpl;auto with arith.\nelim H0;trivial.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nintros.\nrewrite mult_comm.\napply plus_eq_compat_l.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m; elim (le_lt_eq_dec n m).\nrewrite (plus_comm n m); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  simple induction m.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\n  intros.\n  simpl.\n  reflexivity.\n  simpl.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  simple induction n; intros.\n  simpl in |- *.\n  reflexivity.\n  intros m IH.\n  simpl in |- *.\n  apply lt_n_O.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n intros.\n case (le_ge_dec n m).\n intro.\n apply H.\n apply le_n_S.\n assumption.\n intro.\n cut (n = m).\n intro.\n rewrite H0.\n apply H0.\n assumption.\n assumption.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n simple induction n.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\n simpl in |- *.\n reflexivity.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  simple induction n.\n  simpl; auto with arith.\n  intros n m IH.\n  simpl in |- *.\n  elim (mult_lemma1 m n); auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nsimple induction m.\nintros m IH.\nelim (le_gt_dec m 0); intros.\nelim (le_gt_dec m 0); intros.\nrewrite H1.\nrewrite mult_comm; auto with arith.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\nintros n m.\ndo 2 rewrite mult_comm.\nrewrite <- plus_n_O.\nrewrite mult_comm.\nring.\nQed.",
                    "Lemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\nProof.\n  simple induction n; simpl in |- *; intros.\n  apply plus_n_O.\n  apply le_n_O.\n  apply le_n_Sn.\n  apply le_S.\n  apply le_n_Sn.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\n",
                "context_tokens": 328,
                "proof_start_offset": 1246,
                "proof_end_offset": 1433,
                "proof": "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\nProof.\nintros.\ninduction n.\ntauto.\nsimpl in H.\nright.\nassert (m <= O);try omega.\nrewrite <- H.\nauto with arith.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  elim (le_lt_eq_eq_dec m n).\n  left.\n  apply le_n_S.\n  left.\n  rewrite H0.\n  rewrite H0.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction (S m).\n  simpl;auto with arith.\n  simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  rewrite mult_assoc.\n  apply mult_lemma1.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite plus_comm.\n  rewrite <- plus_n_O.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  rewrite mult_comm.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_assoc.\n  induction m;simpl;auto with arith.\nQed.",
                    "Lemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\nQed."
                ]
            },
            {
                "filepath": "./coq_projects/fundamental-arithmetics/missing.v",
                "context": "(* Copyright (C) 2005-2008 Sebastien Briais *)\n(* http://lamp.epfl.ch/~sbriais/ *)\n\n(* This library is free software; you can redistribute it and/or modify *)\n(* it under the terms of the GNU Lesser General Public License as *)\n(* published by the Free Software Foundation; either version 2.1 of the *)\n(* License, or (at your option) any later version. *)\n\n(* This library is distributed in the hope that it will be useful, but *)\n(* WITHOUT ANY WARRANTY; without even the implied warranty of *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *)\n(* Lesser General Public License for more details. *)\n\n(* You should have received a copy of the GNU Lesser General Public *)\n(* License along with this library; if not, write to the Free Software *)\n(* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA *)\n\nRequire Export Arith.\nRequire Export ArithRing.\nRequire Export Omega.\n\nUnset Standard Proposition Elimination Names.\n\n(** We first begin with some lemmas that relates *)\n(** +, * and - that are not in the standard library *)\nLemma mult_lemma1 : forall (n m:nat),(n <> O)->(m <> 0)->(n <= n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.\n\nLemma mult_lemma2 : forall (n m:nat),(n*m = O)->(n=O)\\/(m=O).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  assert (m <= O);try omega.\n  rewrite <- H.\n  auto with arith.\nQed.\n\n",
                "context_tokens": 400,
                "proof_start_offset": 1435,
                "proof_end_offset": 1719,
                "proof": "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\nProof.\nintros.\nrewrite mult_comm.\ninduction m.\ninversion H0.\nsimpl.\nassert (O < m*n);try omega.\ninversion H0;try omega.\nassert (1 <= n);try omega.\nassert (m > 1);try omega.\ngeneralize (IHm H4);omega.\nQed.",
                "end_command": "Qed.",
                "generated_proofs": [
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  right.\n  apply mult_lemma3.\n  apply mult_lemma3.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction m; simpl; auto with arith.\n  elim H0;intro.\n  rewrite <- H0.\n  rewrite <- (plus_n_O m).\n  rewrite plus_comm.\n  rewrite (plus_n_O m).\n  rewrite (plus_n_O m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm n m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).\n  rewrite (plus_comm m).Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  elim H.\n  left.\n  apply mult_lemma3; auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  elim H0;trivial.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  assumption.\n  simpl in H.\n  elim H.\n  intros.\n  simpl in H.\n  inversion H.\n  elim H0.\n  intros.\n  simpl in H0.\n  inversion H.\n  elim H0.\n  intros.\n  simpl in H0.\n  inversion H0.\n  elim H1.\n  intros.\n  simpl in H.\n  inversion H1.\n  elim H2.\n  intros.\n  simpl in H.\n  inversion H1.\n  elim H2.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H2.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H3.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H3.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H3.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H3.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H3.\n  intros.\n  simpl in H1.\n  inversion H1.\n  elim H3.\n  intros.\n  simpl in H1.\n  inversion H1.Qed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in H.\n  elim H.\n  intros.\n  elim (le_or_lt n m).\n  apply H.\n  apply le_n_S.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  rewrite mult_comm.\n  induction m;simpl;auto with arith.\n  elim H0;trivial.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  simpl in |- *; auto with arith.\n  elim H.\n  intros.\n  elim (le_gt_dec n m).\n  simpl in |- *; auto with arith.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  induction n.\n  tauto.\n  simpl in |- *.\n  rewrite H.\n  right.\n  reflexivity.\nQed.",
                    "Lemma mult_lemma3 : forall (n m:nat),(n <> O)->(m > 1)->(n < n*m).\n  intros.\n  elim H.\n  simpl in |- *; auto with arith.\nQed."
                ]
            }
        ]
    }
}